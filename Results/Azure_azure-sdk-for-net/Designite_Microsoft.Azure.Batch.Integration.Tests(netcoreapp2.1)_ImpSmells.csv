Implementation smell,Namespace,Class,File,Method,Description
Long Method,BatchClientIntegrationTests,IntegrationCloudPoolTestsWithSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_Bug1771277_1771278_RebootReimageComputeNode,The method has 101 lines of code.
Long Method,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug2329884_ComputeNodeRecentTasksAndComputeNodeError,The method has 116 lines of code.
Long Method,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug1770933_1770935_1771164_AddUserCRUDAndGetRDP,The method has 142 lines of code.
Long Method,BatchClientIntegrationTests,EndToEndIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\EndToEndIntegrationTests.cs,TestSampleWithFilesAndPool,The method has 103 lines of code.
Long Method,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestOMJobSpecAndRelease,The method has 138 lines of code.
Long Method,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,The method has 144 lines of code.
Long Method,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestNode_GetListDeleteFiles,The method has 155 lines of code.
Long Method,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1719609ODATADetailLevel,The method has 238 lines of code.
Long Method,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The method has 176 lines of code.
Long Method,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,TestDisplayNameMutability,The method has 134 lines of code.
Long Method,BatchClientIntegrationTests,IntegrationObjectModelFeatureTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1770942ExposeBatchRequestProperties,The method has 132 lines of code.
Long Method,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DisplayJobScheduleLong,The method has 155 lines of code.
Complex Method,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,Cyclomatic complexity of the method is 13
Complex Method,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DisplayJobScheduleLong,Cyclomatic complexity of the method is 12
Long Parameter List,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,AddTasksSimpleTestAsync,The method has 11 parameters. Parameters: batchCli' testName' taskCount' parallelOptions' resultHandlerFunc' storageCredentials' localFilesToStage' fileStagingArtifacts' timeout' useJobOperations' resourceFiles
Long Parameter List,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,AssertJobCorrectness,The method has 6 parameters. Parameters: jobOperations' jobId' boundJob' expectedPoolId' expectedPriority' expectedJobConstraints
Long Parameter List,BatchClientIntegrationTests,CloudJobScheduleIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,AssertJobScheduleCorrectness,The method has 8 parameters. Parameters: jobScheduleOperations' boundJobSchedule' expectedPoolId' expectedJobPriority' expectedJobManagerId' expectedJobManagerCommandLine' expectedRecurrenceInterval' expectedMetadata
Long Parameter List,BatchClientIntegrationTests.IntegrationTestUtilities,FileToStage,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\FileUploadUtilities.cs,CreateContainerWithPolicySASIfNotExistAsync,The method has 8 parameters. Parameters: account' key' blobUri' container' policy' start' end' permissions
Long Parameter List,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,HelloWorld,The method has 7 parameters. Parameters: batchCli' testOutputHelper' sharedPool' jobId' taskId' deleteJob' isLinux
Long Identifier,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchRetry,The length of the parameter numberOfTasksWhichHitClientError is 32.
Long Identifier,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchRetry,The length of the parameter numberOfTasksWhichWereForcedToRetry is 35.
Long Identifier,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchRequestFailure,The length of the parameter originalServiceRequestFunction is 30.
Long Identifier,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchWithFilesToStage,The length of the parameter expectedFinalFileStagingArtifactsCount is 38.
Long Identifier,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchWithFilesToStage,The length of the parameter expectedInitialFileStagingArtifactsCount is 40.
Long Identifier,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestPoolAutoscaleVerbs,The length of the parameter utcEarliestCanCallEnableASAgain is 31.
Long Identifier,BatchClientIntegrationTests,InboundEndpointIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\InboundEndpointIntegrationTests.cs,ValidateEquality,The length of the parameter expectedNetworkSecurityGroupRule is 32.
Long Identifier,BatchClientIntegrationTests,InboundEndpointIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\InboundEndpointIntegrationTests.cs,ValidateEquality,The length of the parameter actualNetworkSecurityGroupRule is 30.
Long Identifier,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,The length of the parameter victimComputeNodeRunningPrepAndRelease is 38.
Long Identifier,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,,The length of the parameter JobPrepRerunOnComputeNodeRebootAfterSuccess is 43.
Long Identifier,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestNode_GetListDeleteFiles,The length of the parameter filesByComputeNodeRecursiveOmitted is 34.
Long Identifier,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestNode_GetListDeleteFiles,The length of the parameter filesByComputeNodeRecursiveFalse is 32.
Long Identifier,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestNode_GetListDeleteFiles,The length of the parameter fileListFromComputeNodeOperations is 33.
Long Identifier,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestNode_GetListDeleteFiles,The length of the parameter computeNodeFileContentFromManager is 33.
Long Identifier,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestNode_GetListDeleteFiles,The length of the parameter computeNodeFileContentFromNode is 30.
Long Identifier,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the parameter resourceFileCountBeforeListModification is 39.
Long Identifier,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the parameter resourceFileCountAfterListModification is 38.
Long Identifier,BatchClientIntegrationTests,IntegrationObjectModelFeatureTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1770942ExposeBatchRequestProperties,The length of the parameter matchingPoolWithFullDetailLevel is 31.
Long Statement,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchRequestFailure,The length of the statement  "                using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()' addDefaultRetryPolicy: false)) " is 137.
Long Statement,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchRequestFailure,The length of the statement  "                        await this.AddTasksSimpleTestAsync(batchCli' testName' 397' parallelOptions' useJobOperations: useJobOperations).ConfigureAwait(false) " is 134.
Long Statement,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchWithFilesToStage,The length of the statement  "            ConcurrentBag<ConcurrentDictionary<Type' IFileStagingArtifact>> artifacts = new ConcurrentBag<ConcurrentDictionary<Type' IFileStagingArtifact>>(); " is 146.
Long Statement,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,AddTasksFailIfPoisonTaskTooLarge,The length of the statement  "                resourceFile = ResourceFile.FromUrl("https://mystorageaccount.blob.core.windows.net/files/resourceFile" + i' "resourceFile" + i); " is 129.
Long Statement,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,AddTasksFailIfPoisonTaskTooLarge,The length of the statement  "                        async () => await this.AddTasksSimpleTestAsync(batchCli' testName' 1' resourceFiles:resourceFiles).ConfigureAwait(false)).ConfigureAwait(false); " is 144.
Long Statement,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,AddTasksFailIfPoisonTaskTooLarge,The length of the statement  "                    Assert.Equal(((BatchException) innerException).RequestInformation.BatchError.Code' BatchErrorCodeStrings.RequestBodyTooLarge); " is 126.
Long Statement,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,AddTasksRequestEntityTooLarge_ReduceChunkSize,The length of the statement  "                resourceFile = ResourceFile.FromUrl("https://mystorageaccount.blob.core.windows.net/files/resourceFile" + i' "resourceFile" + i); " is 129.
Long Statement,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,AddTasksRequestEntityTooLarge_ReduceChunkSize,The length of the statement  "                using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()' addDefaultRetryPolicy: false)) " is 137.
Long Statement,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,AddTasksRequestEntityTooLarge_ReduceChunkSize,The length of the statement  "                    await AddTasksSimpleTestAsync(batchCli' testName' numTasks' parallelOptions' resourceFiles: resourceFiles).ConfigureAwait(false); " is 129.
Long Statement,BatchClientIntegrationTests,AuthenticationTest,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AuthenticationTest.cs,CanAuthenticateToServiceWithAADToken,The length of the statement  "            Func<Task<string>> tokenProvider = () => IntegrationTestCommon.GetAuthenticationTokenAsync("https://batch.core.windows.net/"); " is 126.
Long Statement,BatchClientIntegrationTests,AuthenticationTest,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AuthenticationTest.cs,CanAuthenticateToServiceWithAADToken,The length of the statement  "            using (var client = BatchClient.Open(new BatchTokenCredentials(TestCommon.Configuration.BatchAccountUrl' tokenProvider))) " is 121.
Long Statement,BatchClientIntegrationTests,AutoScaleIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AutoScaleIntegrationTests.cs,AutoScaleEvaluationIntervalTest,The length of the statement  "                    using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()' addDefaultRetryPolicy: false)) " is 137.
Long Statement,BatchClientIntegrationTests,AutoScaleIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AutoScaleIntegrationTests.cs,AutoScaleEvaluationIntervalTest,The length of the statement  "                            Assert.Equal(Microsoft.Azure.Batch.Common.BatchErrorCodeStrings.InvalidPropertyValue' batchException.RequestInformation.BatchError.Code); " is 137.
Long Statement,BatchClientIntegrationTests,AutoScaleIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AutoScaleIntegrationTests.cs,AutoScaleEvaluationIntervalTest,The length of the statement  "                                TestUtilities.AssertIsBatchExceptionAndHasCorrectAzureErrorCode(ex' Microsoft.Azure.Batch.Common.BatchErrorCodeStrings.AutoScaleTooManyRequestsToEnable' this.testOutputHelper); " is 176.
Long Statement,BatchClientIntegrationTests,BatchRequestIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\BatchRequestIntegrationTests.cs,BatchRequestWithShortClientSideTimeout,The length of the statement  "                    using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()' addDefaultRetryPolicy: false)) " is 135.
Long Statement,BatchClientIntegrationTests,BatchRequestIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\BatchRequestIntegrationTests.cs,BatchRequestWithShortClientSideTimeoutAndRetries,The length of the statement  "                    using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()' addDefaultRetryPolicy: false)) " is 135.
Long Statement,BatchClientIntegrationTests,BatchRequestIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\BatchRequestIntegrationTests.cs,BatchRequestWithShortClientSideTimeoutAndRetries,The length of the statement  "                            Func<CancellationToken' Task<AzureOperationResponse<Microsoft.Azure.Batch.Protocol.Models.CloudJob' Microsoft.Azure.Batch.Protocol.Models.JobGetHeaders>>> oldFunc = castRequest.ServiceRequestFunc; " is 196.
Long Statement,BatchClientIntegrationTests,BatchRequestIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\BatchRequestIntegrationTests.cs,BatchRequestWithShortUserCancellationToken,The length of the statement  "                    using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()' addDefaultRetryPolicy: false)) " is 135.
Long Statement,BatchClientIntegrationTests,BatchRequestIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\BatchRequestIntegrationTests.cs,BatchRequestWithShortUserCancellationToken,The length of the statement  "                            await client.JobOperations.GetJobAsync("Foo"' additionalBehaviors: customBehaviors).ConfigureAwait(false)).ConfigureAwait(false); " is 129.
Long Statement,BatchClientIntegrationTests,CertificateUnitTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CertificateUnitTests.cs,TestCreateCerFileFromRawData,The length of the statement  "            string filePath = IntegrationTestCommon.GetTemporaryCertificateFilePath(string.Format("{0}.cer"' CertificateFilePrefix)); " is 121.
Long Statement,BatchClientIntegrationTests,CertificateUnitTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CertificateUnitTests.cs,TestCreatePfxFileFromRawData,The length of the statement  "            string filePath = IntegrationTestCommon.GetTemporaryCertificateFilePath(string.Format("{0}.pfx"' CertificateFilePrefix)); " is 121.
Long Statement,BatchClientIntegrationTests,CertificateUnitTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CertificateUnitTests.cs,TestCreatePfxFileFromRawData,The length of the statement  "            CertificateBuilder.CreateSelfSignedInFile("Foo"' filePath' CertificateBuilder.Sha1Algorithm' CommonResources.CertificatePassword); " is 130.
Long Statement,BatchClientIntegrationTests,CertificateUnitTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CertificateUnitTests.cs,TestCreateSha256Cer,The length of the statement  "            string filePath = IntegrationTestCommon.GetTemporaryCertificateFilePath(string.Format("{0}.pfx"' CertificateFilePrefix)); " is 121.
Long Statement,BatchClientIntegrationTests,CertificateUnitTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CertificateUnitTests.cs,TestCreateSha256Pfx,The length of the statement  "            string filePath = IntegrationTestCommon.GetTemporaryCertificateFilePath(string.Format("{0}.pfx"' CertificateFilePrefix)); " is 121.
Long Statement,BatchClientIntegrationTests,CertificateUnitTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CertificateUnitTests.cs,TestCreateSha256Pfx,The length of the statement  "            CertificateBuilder.CreateSelfSignedInFile("Foo"' filePath' CertificateBuilder.Sha256Algorithm' password: CommonResources.CertificatePassword); " is 142.
Long Statement,BatchClientIntegrationTests,CertificateUnitTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CertificateUnitTests.cs,TestCertificateFromRawData,The length of the statement  "                    X509Certificate2 x509Certificate = password == null ? new X509Certificate2(certificateFileLocation) : new X509Certificate2(certificateFileLocation' password); " is 158.
Long Statement,BatchClientIntegrationTests,CloudCertificateIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudCertificateIntegrationTests.cs,TestCertificateVerbs,The length of the statement  "                    string cerFilePath = IntegrationTestCommon.GetTemporaryCertificateFilePath(string.Format("{0}.cer"' certificatePrefix)); " is 120.
Long Statement,BatchClientIntegrationTests,CloudCertificateIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudCertificateIntegrationTests.cs,TestCertificateVerbs,The length of the statement  "                    string pfxFilePath = IntegrationTestCommon.GetTemporaryCertificateFilePath(string.Format("{0}.pfx"' certificatePrefix)); " is 120.
Long Statement,BatchClientIntegrationTests,CloudCertificateIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudCertificateIntegrationTests.cs,TestCertificateVerbs,The length of the statement  "                            TestUtilities.DeleteCertMonitor(batchCli.CertificateOperations' this.testOutputHelper' certificate.ThumbprintAlgorithm' certificate.Thumbprint); " is 144.
Long Statement,BatchClientIntegrationTests,CloudCertificateIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudCertificateIntegrationTests.cs,TestPoolCertificateReferencesWithUpdate,The length of the statement  "                    string cerFilePath = IntegrationTestCommon.GetTemporaryCertificateFilePath(string.Format("{0}.cer"' certificatePrefix)); " is 120.
Long Statement,BatchClientIntegrationTests,CloudCertificateIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudCertificateIntegrationTests.cs,TestPoolCertificateReferencesWithUpdate,The length of the statement  "                    string pfxFilePath = IntegrationTestCommon.GetTemporaryCertificateFilePath(string.Format("{0}.pfx"' certificatePrefix)); " is 120.
Long Statement,BatchClientIntegrationTests,CloudCertificateIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudCertificateIntegrationTests.cs,TestPoolCertificateReferencesWithUpdate,The length of the statement  "                            TestUtilities.DeleteCertMonitor(batchCli.CertificateOperations' this.testOutputHelper' certificate.ThumbprintAlgorithm' certificate.Thumbprint); " is 144.
Long Statement,BatchClientIntegrationTests,CloudCertificateIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudCertificateIntegrationTests.cs,GenerateCertificates,The length of the statement  "            CertificateBuilder.CreateSelfSignedInFile("Foo"' pfxFilePath' CertificateBuilder.Sha1Algorithm' password: CommonResources.CertificatePassword); " is 143.
Long Statement,BatchClientIntegrationTests,CloudCertificateIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudCertificateIntegrationTests.cs,GenerateCertificates,The length of the statement  "            Certificate pfxCertificate = batchClient.CertificateOperations.CreateCertificate(pfxFilePath' CommonResources.CertificatePassword); " is 131.
Long Statement,BatchClientIntegrationTests,CloudCertificateIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudCertificateIntegrationTests.cs,TestCancelDeleteCertificateAsync,The length of the statement  "                    await batchCli.CertificateOperations.DeleteCertificateAsync(certToDelete.ThumbprintAlgorithm' certToDelete.Thumbprint).ConfigureAwait(false); " is 141.
Long Statement,BatchClientIntegrationTests,CloudCertificateIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudCertificateIntegrationTests.cs,TestCancelDeleteCertificateAsync,The length of the statement  "                    await batchCli.CertificateOperations.CancelDeleteCertificateAsync(certToDelete.ThumbprintAlgorithm' certToDelete.Thumbprint).ConfigureAwait(false); " is 147.
Long Statement,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Bug1665834TaskStateMonitor,The length of the statement  "                                        this.testOutputHelper.WriteLine("   poolstate: " + boundPool.State + "' currentdedicated: " + boundPool.CurrentDedicatedComputeNodes); " is 134.
Long Statement,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Bug1665834TaskStateMonitor,The length of the statement  "                                            this.testOutputHelper.WriteLine("           computeNode.Id: " + curComputeNode.Id + "' state: " + curComputeNode.State); " is 120.
Long Statement,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Bug1665834TaskStateMonitor,The length of the statement  "                            CloudTask unboundTask = new CloudTask(i.ToString() + "_a234567890a234567890a234567890a234567890a234567890a234567890"' "cmd /c ping 127.0.0.1 -n 4"); " is 148.
Long Statement,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Bug1665834TaskStateMonitor,The length of the statement  "                        Task whenAll = tsm.WhenAll(taskList' Microsoft.Azure.Batch.Common.TaskState.Completed' timeToWait' controlParams: odmc); " is 120.
Long Statement,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,TestBoundJobVerbs,The length of the statement  "                    string jobId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestBoundJobVerbs"; " is 123.
Long Statement,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Bug1433069TestBoundJobCommit,The length of the statement  "                    string jobId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestBoundJobCommit"; " is 124.
Long Statement,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Bug1433069TestBoundJobCommit,The length of the statement  "                            this.testOutputHelper.WriteLine("Bug1433069TestBoundJobCommit: sleeping for (refreshableJob.State != JobState.Disabled)"); " is 122.
Long Statement,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,TestJobCompletesWhenAllItsTasksComplete,The length of the statement  "                    string jobId = Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestJobCompletesWhenAllItsTasksComplete"; " is 123.
Long Statement,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,IfJobSetsOnTaskFailed_JobCompletesWhenAnyTaskFails,The length of the statement  "                    string jobId = Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-IfJobSetsOnTaskFailedJobCompletesWhenAnyTaskFail"; " is 132.
Long Statement,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,TestExitConditionsAreBeingRoundTrippedCorrectly,The length of the statement  "                    string jobId = Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestExitConditionsAreBeingRoundTrippedCorrectly"; " is 131.
Long Statement,BatchClientIntegrationTests,IntegrationCloudJobTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,JobPatch,The length of the statement  "            await SynchronizationContextHelper.RunTestAsync(() => MutateJobAsync(jobId' jobAction: job => job.CommitAsync())' TestTimeout); " is 127.
Long Statement,BatchClientIntegrationTests,IntegrationCloudJobTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,JobUpdate,The length of the statement  "            await SynchronizationContextHelper.RunTestAsync(() => MutateJobAsync(jobId' jobAction: job => job.CommitChangesAsync())' TestTimeout); " is 134.
Long Statement,BatchClientIntegrationTests,IntegrationCloudJobTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,TestJobUpdateWithAndWithoutPoolInfo,The length of the statement  "                        // Verify that we can update something besides PoolInformation without getting an error for not being in the Disabled state. " is 124.
Long Statement,BatchClientIntegrationTests,IntegrationCloudJobTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,TestJobUpdateWithAndWithoutPoolInfo,The length of the statement  "                        foreach (CloudPool pool in batchCli.PoolOperations.ListPools(new ODATADetailLevel(filterClause: string.Format("startswith(id''{0}')"' autoPoolPrefix)))) " is 152.
Long Statement,BatchClientIntegrationTests,IntegrationCloudJobTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,LongRunning_Bug1965363Wat7OSVersionFeaturesQuickJobWithAutoPool,The length of the statement  "                                    allComputeNodes.ForEach((icn) => { this.testOutputHelper.WriteLine("  computeNode.id: " + icn.Id + "' state: " + icn.State); }); " is 128.
Long Statement,BatchClientIntegrationTests,IntegrationCloudJobTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,SetUpdateJobConditionalHeader,The length of the statement  "                        Exception e = TestUtilities.AssertThrows<BatchException>(() => boundJob.Commit(additionalBehaviors: new[] { updateInterceptor })); " is 130.
Long Statement,BatchClientIntegrationTests,IntegrationCloudJobTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,SetUpdateJobConditionalHeader,The length of the statement  "                        TestUtilities.AssertIsBatchExceptionAndHasCorrectAzureErrorCode(e' BatchErrorCodeStrings.ConditionNotMet' this.testOutputHelper); " is 129.
Long Statement,BatchClientIntegrationTests,CloudJobScheduleIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,TestBoundJobScheduleCommit,The length of the statement  "                    string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestBoundJobScheduleCommit"; " is 140.
Long Statement,BatchClientIntegrationTests,CloudJobScheduleIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,TestBoundJobScheduleCommit,The length of the statement  "                        IList<MetadataItem> metadata = new List<MetadataItem> { new MetadataItem("key1"' "test1")' new MetadataItem("key2"' "test2") }; " is 127.
Long Statement,BatchClientIntegrationTests,CloudJobScheduleIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,TestBoundJobScheduleCommit,The length of the statement  "                        AssertJobScheduleCorrectness(batchCli.JobScheduleOperations' boundJobSchedule' this.poolFixture.PoolId' jobSchedulePriority' jobManagerId' jobManagerCommandLine' firstRecurrenceInterval' metadata); " is 197.
Long Statement,BatchClientIntegrationTests,CloudJobScheduleIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,TestBoundJobScheduleCommit,The length of the statement  "                        AssertJobScheduleCorrectness(batchCli.JobScheduleOperations' boundJobSchedule' this.poolFixture.PoolId' jobSchedulePriority' jobManagerId' jobManagerCommandLine' recurrenceInterval' metadata); " is 192.
Long Statement,BatchClientIntegrationTests,CloudJobScheduleIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,TestBoundJobScheduleCommit,The length of the statement  "                        AssertJobScheduleCorrectness(batchCli.JobScheduleOperations' boundJobSchedule' this.poolFixture.PoolId' newJobSchedulePriority' jobManagerId' jobManagerCommandLine' recurrenceInterval' metadata); " is 195.
Long Statement,BatchClientIntegrationTests,CloudJobScheduleIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,TestBoundJobScheduleCommit,The length of the statement  "                        AssertJobScheduleCorrectness(batchCli.JobScheduleOperations' boundJobSchedule' this.poolFixture.PoolId' newJobSchedulePriority' jobManagerId' newJobManagerCommandLine' recurrenceInterval' metadata); " is 198.
Long Statement,BatchClientIntegrationTests,CloudJobScheduleIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,AssertJobScheduleCorrectness,The length of the statement  "                Assert.Equal(1' boundJobSchedule.Metadata.Count(item => item.Name == metadataItem.Name && item.Value == metadataItem.Value)); " is 125.
Long Statement,BatchClientIntegrationTests,IntegrationCloudJobScheduleTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,SampleCreateJobScheduleAutoPool,The length of the statement  "                    string jsId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-CreateWiAutoPoolTest"; " is 125.
Long Statement,BatchClientIntegrationTests,IntegrationCloudJobScheduleTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,Bug1433008JobScheduleScheduleNewable,The length of the statement  "                    string jsId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-Bug1433008JobScheduleScheduleNewable"; " is 141.
Long Statement,BatchClientIntegrationTests,IntegrationCloudJobScheduleTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,TestListJobsByJobSchedule,The length of the statement  "                    string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestListJobsByJobSchedule"; " is 139.
Long Statement,BatchClientIntegrationTests,IntegrationCloudJobScheduleTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,TestListJobsByJobSchedule,The length of the statement  "                        CloudJobSchedule unboundJobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(jobScheduleId' schedule' jobSpecification); " is 130.
Long Statement,BatchClientIntegrationTests,IntegrationCloudJobScheduleTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,TestJobScheduleVerbs,The length of the statement  "                    string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestEnableDisableDeleteJobSchedule"; " is 148.
Long Statement,BatchClientIntegrationTests,IntegrationCloudJobScheduleTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,TestJobScheduleVerbs,The length of the statement  "                        CloudJobSchedule unboundJobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(jobScheduleId' schedule' jobSpecification); " is 130.
Long Statement,BatchClientIntegrationTests,IntegrationCloudJobScheduleTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,TestJobScheduleVerbs,The length of the statement  "                        Assert.True(boundJobSchedule.State == JobScheduleState.Completed || boundJobSchedule.State == JobScheduleState.Terminating); " is 124.
Long Statement,BatchClientIntegrationTests,IntegrationCloudJobScheduleTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,TestJobScheduleVerbs,The length of the statement  "                        BatchException be = TestUtilities.AssertThrowsEventuallyAsync<BatchException>(() => boundJobSchedule.RefreshAsync()' TimeSpan.FromSeconds(30)).Result; " is 150.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,Bug1505248SupportMultipleTasksPerComputeNodeOnPoolAndPoolUserSpec,The length of the statement  "                        CloudPool newPool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: 0); " is 168.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,Bug1505248SupportMultipleTasksPerComputeNodeOnPoolAndPoolUserSpec,The length of the statement  "                        //Debug.Assert(Microsoft.Azure.Batch.Common.ComputeNodeFillType.Spread == boundPUS.TaskSchedulingPolicy.ComputeNodeFillType); " is 125.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,Bug1587303StartTaskResourceFilesNotPushedToServer,The length of the statement  "                            CloudPool myPool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: 0); " is 167.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,Bug1587303StartTaskResourceFilesNotPushedToServer,The length of the statement  "                            CloudPool myPool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: 0); " is 167.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,Bug1433123PoolMissingResizeTimeout,The length of the statement  "                            CloudPool myPool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: 0); " is 167.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,Bug1432812SetAutoScaleMissingOnPoolPoolMgr,The length of the statement  "                            CloudPool unboundPool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)); " is 140.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,Bug1432819UpdateImplOnCloudPool,The length of the statement  "                        CloudPool unboundPool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: 0); " is 172.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestListPoolUsageMetrics,The length of the statement  "                    List<Microsoft.Azure.Batch.PoolUsageMetrics> clList = batchCli.PoolOperations.ListPoolUsageMetrics(additionalBehaviors: new[] { injectsTheFakeData }).ToList(); " is 159.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestListPoolUsageMetrics,The length of the statement  "                    List<PoolUsageMetrics> list = batchCli.PoolOperations.ListPoolUsageMetrics(DateTime.Now - TimeSpan.FromDays(1)).ToList(); " is 121.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestPoolObjectResizeStopResize,The length of the statement  "                        CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: targetDedicated); " is 179.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestPoolObjectResizeStopResize,The length of the statement  "                        Assert.True(boundPool.AllocationState == AllocationState.Steady || boundPool.AllocationState == AllocationState.Stopping); " is 122.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestPoolAutoscaleVerbs,The length of the statement  "                        CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicated); " is 150.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestServerRejectsNonExistantVNetWithCorrectError,The length of the statement  "                    string dummySubnetId = string.Format("/subscriptions/{0}/resourceGroups/{1}/providers/Microsoft.ClassicNetwork/virtualNetworks/vnet1/subnets/subnet1"' " is 150.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestServerRejectsNonExistantVNetWithCorrectError,The length of the statement  "                        BatchException exception = await TestUtilities.AssertThrowsAsync<BatchException>(async () => await pool.CommitAsync().ConfigureAwait(false)).ConfigureAwait(false); " is 163.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestServerRejectsNonExistantVNetWithCorrectError,The length of the statement  "                        Assert.Equal("Either the specified VNet does not exist' or the Batch service does not have access to it"' exception.RequestInformation.BatchError.Values.Single(value => value.Key == "Reason").Value); " is 199.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestPoolCreatedWithUserAccountsSucceeds,The length of the statement  "                        CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicated); " is 150.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestPoolCreatedWithUserAccountsSucceeds,The length of the statement  "                            new UserAccount("test4"' nodeUserPassword' linuxUserConfiguration: new LinuxUserConfiguration(sshPrivateKey: "AAAA=="))' " is 120.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestPoolCreatedWithUserAccountsSucceeds,The length of the statement  "                        var results = pool.UserAccounts.Zip(boundPool.UserAccounts' (expected' actual) => new { Submitted = expected' Returned = actual }); " is 131.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestPoolCreatedCustomImageExpectedError,The length of the statement  "                Func<Task<string>> tokenProvider = () => IntegrationTestCommon.GetAuthenticationTokenAsync("https://batch.core.windows.net/"); " is 126.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestPoolCreatedCustomImageExpectedError,The length of the statement  "                using (var client = BatchClient.Open(new BatchTokenCredentials(TestCommon.Configuration.BatchAccountUrl' tokenProvider))) " is 121.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestPoolCreatedCustomImageExpectedError,The length of the statement  "                                    $"/subscriptions/{TestCommon.Configuration.BatchSubscription}/resourceGroups/{TestCommon.Configuration.BatchAccountResourceGroup}/providers/Microsoft.Compute/images/FakeImage")' " is 177.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestPoolCreatedCustomImageExpectedError,The length of the statement  "                            "The user identity used for this operation does not have the required privelege Microsoft.Compute/images/read on the specified resource"' " is 137.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,PoolStateCount_IsReturnedFromServer,The length of the statement  "                    var filteredNodeCounts = batchCli.PoolOperations.ListPoolNodeCounts(new ODATADetailLevel(filterClause: $"poolId eq '{poolId}'")).ToList(); " is 138.
Long Statement,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,CreatePool_WithBlobFuseMountConfiguration,The length of the statement  "                        Assert.Equal(storageAccount.StorageAccount' pool.MountConfiguration.Single().AzureBlobFileSystemConfiguration.AccountName); " is 123.
Long Statement,BatchClientIntegrationTests,TestListPoolUsageMetricsFakesYieldInjector,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,NewFunc,The length of the statement  "                var response = new AzureOperationResponse<IPage<Protocol.Models.PoolUsageMetrics>' Protocol.Models.PoolListUsageMetricsHeaders>() " is 129.
Long Statement,BatchClientIntegrationTests,IntegrationCloudPoolLongRunningTests01,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_RemovePoolComputeNodesResizeTimeout_ResizeErrorsPopulated,The length of the statement  "                        CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: targetDedicated); " is 179.
Long Statement,BatchClientIntegrationTests,IntegrationCloudPoolLongRunningTests01,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_RemovePoolComputeNodesResizeTimeout_ResizeErrorsPopulated,The length of the statement  "                        batchCli.PoolOperations.RemoveFromPool(poolId' computeNodes' ComputeNodeDeallocationOption.TaskCompletion' resizeTimeout); " is 122.
Long Statement,BatchClientIntegrationTests,IntegrationCloudPoolLongRunningTests02,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_TestRemovePoolComputeNodes,The length of the statement  "                        CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: targetDedicated); " is 179.
Long Statement,BatchClientIntegrationTests,IntegrationCloudPoolLongRunningTests03,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_LowPriorityComputeNodeAllocated_IsDedicatedFalse,The length of the statement  "                        await TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).ConfigureAwait(false); " is 139.
Long Statement,BatchClientIntegrationTests,IntegrationCloudPoolTestsWithSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_Bug1771277_1771278_RebootReimageComputeNode,The length of the statement  "                        CloudJob workflowJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId }); " is 123.
Long Statement,BatchClientIntegrationTests,IntegrationCloudPoolTestsWithSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_Bug1771277_1771278_RebootReimageComputeNode,The length of the statement  "                        // Reboot the compute nodes from the pool with requeue option and ensure tasks goes to Active again and compute node state goes to rebooting " is 140.
Long Statement,BatchClientIntegrationTests,IntegrationCloudPoolTestsWithSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_Bug1771277_1771278_RebootReimageComputeNode,The length of the statement  "                        // Reimage a compute node from the pool with terminate option and ensure task goes to completed and compute node state goes to reimaging " is 136.
Long Statement,BatchClientIntegrationTests,IntegrationCloudPoolTestsWithSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_Bug1771277_1771278_RebootReimageComputeNode,The length of the statement  "                            Assert.False(DateTime.UtcNow > timeoutAfterThisTimeUtc' "Timed out waiting for compute nodes in pool to reach idle state"); " is 123.
Long Statement,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,CreatePool,The length of the statement  "            st.ResourceFiles = new List<ResourceFile> { ResourceFile.FromUrl("https://manoj123.blob.core.windows.net/mpi/MSMpiSetup.exe"' "MSMpiSetup.exe") };  // TODO: remove the dependency on magic blob.  bring this into project and use filestaging or something " is 251.
Long Statement,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,CreatePool,The length of the statement  "            TestUtilities.WaitForPoolToReachStateAsync(batchClient' poolToCreateId' AllocationState.Steady' computeNodeAllocationTimeout).Wait(); " is 133.
Long Statement,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,BasicMultiInstanceTasks,The length of the statement  "                            Assert.True(sw.Elapsed <= checkSubtasksStateTimeout' string.Format("The subtasks state is not set to Complete after {0} seconds"' checkSubtasksStateTimeout.TotalSeconds)); " is 171.
Long Statement,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,RealMpiTasks,The length of the statement  "                        CloudTask hwTask = new CloudTask(id: "mpi"' commandline: @"cmd /c ""%MSMPI_BIN%\mpiexec.exe"" -p 6050 -wdir %AZ_BATCH_TASK_SHARED_DIR%\ Sieve.exe 1000"); " is 153.
Long Statement,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,RealMpiTasks,The length of the statement  "                        hwTask.MultiInstanceSettings = new MultiInstanceSettings(@"cmd /c start cmd /c ""%MSMPI_BIN%\smpd.exe"" -d 3 -p 6050"' 3); " is 122.
Long Statement,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,RealMpiTasks,The length of the statement  "                        hwTask.MultiInstanceSettings.CommonResourceFiles.Add(ResourceFile.FromUrl("https://manoj123.blob.core.windows.net/mpi/Sieve.exe"' "Sieve.exe")); " is 144.
Long Statement,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,RealMpiTasks,The length of the statement  "                            Assert.True(sw.Elapsed <= checkSubtasksStateTimeout' string.Format("The subtasks state is not set to Complete after {0} seconds"' checkSubtasksStateTimeout.TotalSeconds)); " is 171.
Long Statement,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,Bug1432830TaskEnvSettings,The length of the statement  "                        CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId }); " is 122.
Long Statement,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,Bug1432973TaskAffinityInfoMissing,The length of the statement  "                        CloudJob createJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId }); " is 121.
Long Statement,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,Bug1447214TaskMissingExeInfoStatsAndConstraints,The length of the statement  "                        CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId }); " is 122.
Long Statement,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,Bug1447214TaskMissingExeInfoStatsAndConstraints,The length of the statement  "                        TaskConstraints ts = new TaskConstraints(maxWallClockTime: TimeSpan.FromHours(1)' retentionTime: TimeSpan.FromHours(1)' maxTaskRetryCount: 99); " is 143.
Long Statement,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,Bug1447214TaskMissingExeInfoStatsAndConstraints,The length of the statement  "                            this.testOutputHelper.WriteLine("    maxWallClockTime: " + (compTC.MaxWallClockTime.HasValue ? compTC.MaxWallClockTime.ToString() : "<null>")); " is 143.
Long Statement,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,Bug1447214TaskMissingExeInfoStatsAndConstraints,The length of the statement  "                            this.testOutputHelper.WriteLine("    retentionTime: " + (compTC.RetentionTime.HasValue ? compTC.RetentionTime.Value.ToString() : "<null>")); " is 140.
Long Statement,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,Bug1447214TaskMissingExeInfoStatsAndConstraints,The length of the statement  "                            this.testOutputHelper.WriteLine("    maxTaskRetryCount: " + (compTC.MaxTaskRetryCount.HasValue ? compTC.MaxTaskRetryCount.Value.ToString() : "<null>")); " is 152.
Long Statement,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,Bug1447214TaskMissingExeInfoStatsAndConstraints,The length of the statement  "                            this.testOutputHelper.WriteLine("    StartTime: " + (tei.StartTime.HasValue ? tei.StartTime.Value.ToString() : "<null>")); " is 122.
Long Statement,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,Bug1447214TaskMissingExeInfoStatsAndConstraints,The length of the statement  "                            this.testOutputHelper.WriteLine("    LastUpdateTime:   " + (tei.EndTime.HasValue ? tei.EndTime.Value.ToString() : "<null>")); " is 125.
Long Statement,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,Bug1447214TaskMissingExeInfoStatsAndConstraints,The length of the statement  "                            this.testOutputHelper.WriteLine("    ExitCode:  " + (tei.ExitCode.HasValue ? tei.ExitCode.Value.ToString() : "<null>")); " is 120.
Long Statement,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,Bug1535329JobOperationsMissingAddTaskMethods,The length of the statement  "                        CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId }); " is 122.
Long Statement,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,TestBoundTaskTerminateAndDelete,The length of the statement  "                    string jobId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestBoundTaskTerminateAndDelete"; " is 137.
Long Statement,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,DependencyActionIsRoundTripped,The length of the statement  "                        CloudJob cloudJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId }); " is 120.
Long Statement,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,DependencyActionIsRoundTripped,The length of the statement  "                        taskToAdd.ExitConditions = new ExitConditions { Default = new ExitOptions {JobAction = JobAction.Terminate' DependencyAction = DependencyAction.Satisfy} }; " is 155.
Long Statement,BatchClientIntegrationTests,IntegrationCloudTaskTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,SetTaskConditionalHeaders,The length of the statement  "                        Exception e = TestUtilities.AssertThrows<BatchException>(() => boundTask.Terminate(additionalBehaviors: new[] { interceptor })); " is 128.
Long Statement,BatchClientIntegrationTests,IntegrationCloudTaskTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,SetTaskConditionalHeaders,The length of the statement  "                        TestUtilities.AssertIsBatchExceptionAndHasCorrectAzureErrorCode(e' BatchErrorCodeStrings.ConditionNotMet' this.testOutputHelper); " is 129.
Long Statement,BatchClientIntegrationTests,IntegrationCloudTaskTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,AddTaskOnContainerPool_TaskIsExecuted,The length of the statement  "                    string jobId = Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-" + nameof(AddTaskOnContainerPool_TaskIsExecuted); " is 132.
Long Statement,BatchClientIntegrationTests,CloudTaskLinuxIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskLinuxIntegrationTests.cs,RunTaskAndUploadFiles_FilesAreSuccessfullyUploaded,The length of the statement  "                        CloudJob createJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId }); " is 121.
Long Statement,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug2302907_TestComputeNodeDoesInheritBehaviors,The length of the statement  "                using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()' addDefaultRetryPolicy: false)) " is 137.
Long Statement,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug2302907_TestComputeNodeDoesInheritBehaviors,The length of the statement  "                    Microsoft.Azure.Batch.Protocol.RequestInterceptor interceptor = new Microsoft.Azure.Batch.Protocol.RequestInterceptor(); " is 120.
Long Statement,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug2329884_ComputeNodeRecentTasksAndComputeNodeError,The length of the statement  "                        //Since the compute node name comes back as "Node:<computeNodeId>" we need to split on : to get the actual compute node name " is 124.
Long Statement,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug2329884_ComputeNodeRecentTasksAndComputeNodeError,The length of the statement  "                        //We use mocking to return a fake compute node object here to test Compute Node Error because we cannot force one easily " is 120.
Long Statement,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug1770933_1770935_1771164_AddUserCRUDAndGetRDP,The length of the statement  "                    List<string> names = new List<string>() { TestUtilities.GetMyName()' TestUtilities.GetMyName() + "1"' TestUtilities.GetMyName() + "2"' TestUtilities.GetMyName() + "3"' TestUtilities.GetMyName() + "4" }; " is 202.
Long Statement,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug2342986_StartTaskMissingOnComputeNode,The length of the statement  "                                EnvironmentSetting matchingEnvSetting = computeNode.StartTask.EnvironmentSettings.FirstOrDefault(envSetting => envSetting.Name == environmentSetting.Name); " is 155.
Long Statement,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug2342986_StartTaskMissingOnComputeNode,The length of the statement  "                                ResourceFile matchingResourceFile = computeNode.StartTask.ResourceFiles.FirstOrDefault(item => item.HttpUrl == resourceFile.HttpUrl); " is 133.
Long Statement,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug2342986_StartTaskMissingOnComputeNode,The length of the statement  "                        TestUtilities.AssertThrows<InvalidOperationException>(() => { computeNode.StartTask.UserIdentity = new UserIdentity("foo"); }); " is 127.
Long Statement,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug2342986_StartTaskMissingOnComputeNode,The length of the statement  "                        TestUtilities.AssertThrows<InvalidOperationException>(() => { computeNode.StartTask.EnvironmentSettings = new List<EnvironmentSetting>(); }); " is 141.
Long Statement,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug2342986_StartTaskMissingOnComputeNode,The length of the statement  "                            TestUtilities.AssertThrows<InvalidOperationException>(() => { computeNode.StartTask.EnvironmentSettings.Add(new EnvironmentSetting("test"' "test")); }); " is 152.
Long Statement,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug2342986_StartTaskMissingOnComputeNode,The length of the statement  "                        TestUtilities.AssertThrows<InvalidOperationException>(() => { computeNode.StartTask.ResourceFiles = new List<ResourceFile>(); }); " is 129.
Long Statement,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug2342986_StartTaskMissingOnComputeNode,The length of the statement  "                            TestUtilities.AssertThrows<InvalidOperationException>(() => { computeNode.StartTask.ResourceFiles.Add(ResourceFile.FromUrl("test"' "test")); }); " is 144.
Long Statement,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,OnlineOfflineTest,The length of the statement  "                                        condition: () => Task.FromResult(victim.SchedulingState.HasValue && (SchedulingState.Disabled == victim.SchedulingState))' " is 122.
Long Statement,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,OnlineOfflineTest,The length of the statement  "                                        condition: () => Task.FromResult(victim.SchedulingState.HasValue && (SchedulingState.Enabled == victim.SchedulingState))' " is 121.
Long Statement,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,OnlineOfflineTest,The length of the statement  "                                        condition: () => Task.FromResult(victim.SchedulingState.HasValue && (SchedulingState.Disabled == victim.SchedulingState))' " is 122.
Long Statement,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,OnlineOfflineTest,The length of the statement  "                                        condition: () => Task.FromResult(victim.SchedulingState.HasValue && (SchedulingState.Enabled == victim.SchedulingState))' " is 121.
Long Statement,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,OnlineOfflineTest,The length of the statement  "                                    TestUtilities.AssertIsBatchExceptionAndHasCorrectAzureErrorCode(ex' Microsoft.Azure.Batch.Common.BatchErrorCodeStrings.NodeAlreadyInTargetSchedulingState' this.testOutputHelper); " is 178.
Long Statement,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,OnlineOfflineTest,The length of the statement  "                                this.testOutputHelper.WriteLine(string.Format("OnlineOfflineTest: exception during exit trying to restore scheduling state: {0}"' ex.ToString())); " is 146.
Long Statement,BatchClientIntegrationTests,IntegrationComputeNodeLinuxTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,TestComputeNodeUserIaas,The length of the statement  "                                this.testOutputHelper.WriteLine("TestComputeNodeUserIAAS attempting to delete the following <nodeid'user>: <{0}'{1}>"' cn.Id' curCNUName); " is 138.
Long Statement,BatchClientIntegrationTests,EndToEndIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\EndToEndIntegrationTests.cs,TestSampleWithFilesAndPool,The length of the statement  "                        FileToStage wordsDotText = new FileToStage(Resources.LocalWordsDotText' storageCreds);                // use "default" mapping to base name of local file " is 153.
Long Statement,BatchClientIntegrationTests,EndToEndIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\EndToEndIntegrationTests.cs,TestSampleWithFilesAndPool,The length of the statement  "                        Assert.True(FoundFile("localwords.txt"' myCompletedTask.ListNodeFiles(recursive: true))' "mising file: localwords.txt"); " is 120.
Long Statement,BatchClientIntegrationTests,EndToEndIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\EndToEndIntegrationTests.cs,TestSampleWithFilesAndPool,The length of the statement  "                        TestUtilities.AssertThrows<ArgumentOutOfRangeException>(() => { new StagingStorageAccount(storageAccount: " "' storageAccountKey: "key"' blobEndpoint: "blob"); }); " is 163.
Long Statement,BatchClientIntegrationTests,EndToEndIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\EndToEndIntegrationTests.cs,TestSampleWithFilesAndPool,The length of the statement  "                        TestUtilities.AssertThrows<ArgumentOutOfRangeException>(() => { new StagingStorageAccount(storageAccount: "account"' storageAccountKey: " "' blobEndpoint: "blob"); }); " is 167.
Long Statement,BatchClientIntegrationTests,EndToEndIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\EndToEndIntegrationTests.cs,TestSampleWithFilesAndPool,The length of the statement  "                        TestUtilities.AssertThrows<ArgumentOutOfRangeException>(() => { new StagingStorageAccount(storageAccount: "account"' storageAccountKey: "key"' blobEndpoint: ""); }); " is 165.
Long Statement,BatchClientIntegrationTests,IntegrationEndToEndTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\EndToEndIntegrationTests.cs,Bug1965363_2384616_Wat7OSVersionFeatures,The length of the statement  "                            CloudPool noArgs = poolOperations.CreatePool("Bug1965363ButNoOSFamily-" + TestUtilities.GetMyName()' PoolFixture.VMSize' default(CloudServiceConfiguration)' targetDedicatedComputeNodes: 0); " is 189.
Long Statement,BatchClientIntegrationTests,IntegrationEndToEndTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\EndToEndIntegrationTests.cs,Bug1965363_2384616_Wat7OSVersionFeatures,The length of the statement  "                                CloudPool hasOSF = poolOperations.CreatePool(poolIdHOSF' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: 0); " is 162.
Long Statement,BatchClientIntegrationTests,IntegrationEndToEndTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\EndToEndIntegrationTests.cs,Bug1771070_1771072_JobAndPoolLifetimeStats,The length of the statement  "                    //Since we cannot really validate that the stats returned by the service are correct' the best we can do is make sure we get some " is 129.
Long Statement,BatchClientIntegrationTests,IntegrationEndToEndTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\EndToEndIntegrationTests.cs,Bug1771070_1771072_JobAndPoolLifetimeStats,The length of the statement  "                    this.testOutputHelper.WriteLine("PoolStatistics.ResourceStatistics.AvgMemory: {0}"' poolStatistics.ResourceStatistics.AverageMemoryGiB); " is 136.
Long Statement,BatchClientIntegrationTests,IntegrationEndToEndTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\EndToEndIntegrationTests.cs,Bug1771070_1771072_JobAndPoolLifetimeStats,The length of the statement  "                    this.testOutputHelper.WriteLine("PoolStatistics.UsageStatistics.DedicatedCoreTime: {0}"' poolStatistics.UsageStatistics.DedicatedCoreTime); " is 139.
Long Statement,BatchClientIntegrationTests,IntegrationEndToEndTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\EndToEndIntegrationTests.cs,ReadClientRequestIdAndRequestIdFromResponse,The length of the statement  "                        batchCli.PoolOperations.ListPools(additionalBehaviors: new[] { responseInterceptor} ).ToList(); //Force an enumeration to go to the server " is 138.
Long Statement,BatchClientIntegrationTests,IntegrationEndToEndTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\EndToEndIntegrationTests.cs,ReadClientRequestIdAndRequestIdFromException,The length of the statement  "                        await batchCli.JobOperations.GetJobAsync("this-job-doesnt-exist"' additionalBehaviors: new [] { clientRequestIdGenerator' setReturnClientRequestId })).Result; " is 158.
Long Statement,BatchClientIntegrationTests,InboundEndpointIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\InboundEndpointIntegrationTests.cs,WhenPoolCreatedWithInboundEndpoints_EndpointsAreReturnedByPoolAndComputeNodes,The length of the statement  "                        var expectedInboundNatPools = pool.NetworkConfiguration.EndpointConfiguration.InboundNatPools.OrderBy(inp => inp.Name).ToList(); " is 128.
Long Statement,BatchClientIntegrationTests,InboundEndpointIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\InboundEndpointIntegrationTests.cs,WhenPoolCreatedWithInboundEndpoints_EndpointsAreReturnedByPoolAndComputeNodes,The length of the statement  "                        var actualInboundNatPools = actualPool.NetworkConfiguration.EndpointConfiguration.InboundNatPools.OrderBy(inp => inp.Name).ToList(); " is 132.
Long Statement,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestOMJobSpecAndRelease,The length of the statement  "                    string jsId = "JobPrepAndRelease-" + /* "OM-static-c" */ "dynamic-" + CraftTimeString() + "-" + TestUtilities.GetMyName(); " is 122.
Long Statement,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestOMJobSpecAndRelease,The length of the statement  "                                this.testOutputHelper.WriteLine("TestOMJobSpecAndRelease: setting request timeout.  Request type: " + x.GetType().ToString() + "' ClientRequestID: " + x.Options.ClientRequestId); " is 178.
Long Statement,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,The length of the statement  "                List<JobPreparationAndReleaseTaskExecutionInformation> jobPrepStatusList = new List<JobPreparationAndReleaseTaskExecutionInformation>(); " is 136.
Long Statement,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,The length of the statement  "                    Assert.True(beforeJobPrepRuns < jptei.JobPreparationTaskExecutionInformation.StartTime + TimeSpan.FromSeconds(10));  // test that the start time is rational -- 10s of wiggle room " is 178.
Long Statement,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,The length of the statement  "                            this.testOutputHelper.WriteLine("    name:" + curTF.Path + "' size: " + ((curTF.IsDirectory.HasValue && curTF.IsDirectory.Value) ? "<dir>" : curTF.Properties.ContentLength.ToString())); " is 185.
Long Statement,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,The length of the statement  "                        ODATADetailLevel detailLevel = new ODATADetailLevel() { FilterClause = string.Format("nodeId eq '{0}'"' victimComputeNodeRunningPrepAndRelease.Id) }; " is 149.
Long Statement,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,The length of the statement  "                        jobPrepStatusList = batchCli.JobOperations.ListJobPreparationAndReleaseTaskStatus(jobId' detailLevel: detailLevel).ToList(); " is 124.
Long Statement,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,The length of the statement  "                    string stdOutFileSpec = Path.Combine("workitems"' boundJobSchedule.Id' "job-1"' boundJobSchedule.JobSpecification.JobPreparationTask.Id' Constants.StandardOutFileName); " is 168.
Long Statement,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,The length of the statement  "                    string stdErrFileSpec = Path.Combine("workitems"' boundJobSchedule.Id' "job-1"' boundJobSchedule.JobSpecification.JobPreparationTask.Id' Constants.StandardErrorFileName); " is 170.
Long Statement,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,The length of the statement  "                                                    ODATADetailLevel detailLevel = new ODATADetailLevel() { FilterClause = string.Format("nodeId eq '{0}'"' victimComputeNodeRunningPrepAndRelease.Id) }; " is 149.
Long Statement,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,The length of the statement  "                                                    jobPrepStatusList = batchCli.JobOperations.ListJobPreparationAndReleaseTaskStatus(jobId' detailLevel: detailLevel).ToList(); " is 124.
Long Statement,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,The length of the statement  "                    ODATADetailLevel detailLevel = new ODATADetailLevel() { FilterClause = string.Format("nodeId eq '{0}'"' victimComputeNodeRunningPrepAndRelease.Id) }; " is 149.
Long Statement,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,The length of the statement  "                    jobPrepStatusList = batchCli.JobOperations.ListJobPreparationAndReleaseTaskStatus(jobId' detailLevel: detailLevel).ToList(); " is 124.
Long Statement,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,UploadFilesMakeResFiles,The length of the statement  "            FileToStage wordsDotText = new FileToStage(Resources.LocalWordsDotText' stagingCreds);                // use "default" mapping to base name of local file " is 153.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug1480489NodeFileMissingIsDirectory,The length of the statement  "                        CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId }); " is 122.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug230385SupportDeleteNodeFileByTask,The length of the statement  "                        CloudTask directoryCreationTask1 = new CloudTask(directoryCreationTaskId1' string.Format("cmd /c mkdir {0} && echo test > {0}/testfile.txt"' directoryNameOne)); " is 160.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug230385SupportDeleteNodeFileByTask,The length of the statement  "                        CloudTask directoryCreationTask2 = new CloudTask(directoryCreationTaskId2' string.Format("cmd /c mkdir {0} && echo test > {0}/testfile.txt"' directoryNameTwo)); " is 160.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug230385SupportDeleteNodeFileByTask,The length of the statement  "                        TestUtilities.AssertThrows<BatchException>(() => batchCli.JobOperations.GetNodeFile(jobId' taskId' Constants.StandardOutFileName)); " is 131.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug230385SupportDeleteNodeFileByTask,The length of the statement  "                        NodeFile directory = batchCli.JobOperations.ListNodeFiles(jobId' directoryCreationTaskId1' recursive: true).First(item => item.Path.Contains(directoryNameOne)); " is 160.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug230385SupportDeleteNodeFileByTask,The length of the statement  "                        Assert.Null(batchCli.JobOperations.ListNodeFiles(jobId' directoryCreationTaskId1' recursive: true).FirstOrDefault(item => item.Path.Contains(directoryNameOne))); " is 161.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug230385SupportDeleteNodeFileByTask,The length of the statement  "                        TestUtilities.AssertThrows<BatchException>(() => batchCli.JobOperations.GetNodeFile(jobId' taskId' Constants.StandardErrorFileName)); " is 133.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug230385SupportDeleteNodeFileByTask,The length of the statement  "                        directory = batchCli.JobOperations.ListNodeFiles(jobId' directoryCreationTaskId2' recursive: true).First(item => item.Path.Contains(directoryNameTwo)); " is 151.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug230385SupportDeleteNodeFileByTask,The length of the statement  "                        TestUtilities.AssertThrows<BatchException>(() => batchCli.JobOperations.DeleteNodeFile(jobId' directoryCreationTaskId2' directory2PathOnNode' recursive: false)); " is 161.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug230385SupportDeleteNodeFileByTask,The length of the statement  "                        Assert.Null(batchCli.JobOperations.ListNodeFiles(jobId' directoryCreationTaskId2' recursive: true).FirstOrDefault(item => item.Path.Contains(directoryNameTwo))); " is 161.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestNode_GetListDeleteFiles,The length of the statement  "                        CloudTask directoryCreationTask1 = new CloudTask(directoryCreationTaskId1' string.Format("cmd /c mkdir {0} && echo test > {0}/testfile.txt"' directoryNameOne)); " is 160.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestNode_GetListDeleteFiles,The length of the statement  "                        CloudTask directoryCreationTask2 = new CloudTask(directoryCreationTaskId2' string.Format("cmd /c mkdir {0} && echo test > {0}/testfile.txt"' directoryNameTwo)); " is 160.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestNode_GetListDeleteFiles,The length of the statement  "                        //Since the compute node name comes back as "Node:<computeNodeId>" we need to split on : to get the actual compute node name " is 124.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestNode_GetListDeleteFiles,The length of the statement  "                        List<NodeFile> fileListFromComputeNodeOperations = batchCli.PoolOperations.ListNodeFiles(this.poolFixture.PoolId' computeNodeId' recursive: true).ToList(); " is 155.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestNode_GetListDeleteFiles,The length of the statement  "                        NodeFile computeNodeFileFromManager = batchCli.PoolOperations.GetNodeFile(this.poolFixture.PoolId' computeNodeId' filePathToGet); " is 129.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestNode_GetListDeleteFiles,The length of the statement  "                        var computeNodeFileContentDirect = batchCli.PoolOperations.CopyNodeFileContentToString(this.poolFixture.PoolId' computeNodeId' filePathToGet); " is 142.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestNode_GetListDeleteFiles,The length of the statement  "                        NodeFile directory = batchCli.PoolOperations.ListNodeFiles(this.poolFixture.PoolId' computeNodeId' recursive: true).First(item => item.Path.Contains(directoryNameOne)); " is 168.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestNode_GetListDeleteFiles,The length of the statement  "                        Assert.Null(batchCli.PoolOperations.ListNodeFiles(this.poolFixture.PoolId' computeNodeId' recursive: true).FirstOrDefault(item => item.Path.Contains(directoryNameOne))); " is 169.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestNode_GetListDeleteFiles,The length of the statement  "                        TestUtilities.AssertThrows<BatchException>(() => batchCli.JobOperations.GetNodeFile(jobId' taskId' Constants.StandardErrorFileName)); " is 133.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestNode_GetListDeleteFiles,The length of the statement  "                        directory = batchCli.PoolOperations.ListNodeFiles(this.poolFixture.PoolId' computeNodeId' recursive: true).First(item => item.Path.Contains(directoryNameTwo)); " is 159.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestNode_GetListDeleteFiles,The length of the statement  "                        TestUtilities.AssertThrows<BatchException>(() => batchCli.PoolOperations.DeleteNodeFile(this.poolFixture.PoolId' computeNodeId' directory.Path' recursive: false)); " is 163.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestNode_GetListDeleteFiles,The length of the statement  "                        Assert.Null(batchCli.PoolOperations.ListNodeFiles(this.poolFixture.PoolId' computeNodeId' recursive: true).FirstOrDefault(item => item.Path.Contains(directoryNameTwo))); " is 169.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug1480491NodeFileFileProperties,The length of the statement  "                        this.testOutputHelper.WriteLine("File {0} has content length: {1}"' Constants.StandardOutFileName' file.Properties.ContentLength); " is 130.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug1480491NodeFileFileProperties,The length of the statement  "                        this.testOutputHelper.WriteLine("File {0} has content type: {1}"' Constants.StandardOutFileName' file.Properties.ContentType); " is 126.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug1480491NodeFileFileProperties,The length of the statement  "                        this.testOutputHelper.WriteLine("File {0} has creation time: {1}"' Constants.StandardOutFileName' file.Properties.CreationTime); " is 128.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug1480491NodeFileFileProperties,The length of the statement  "                        this.testOutputHelper.WriteLine("File {0} has last modified time: {1}"' Constants.StandardOutFileName' file.Properties.LastModified); " is 133.
Long Statement,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug1480491NodeFileFileProperties,The length of the statement  "                        string filePathToGet = string.Format("workitems/{0}/{1}/{2}/{3}"' jobId' "job-1"' taskId' Constants.StandardOutFileName); " is 121.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug957878SkipTokenSupportMissing,The length of the statement  "                        CloudJob jobCreate = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId }); " is 121.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug957878SkipTokenSupportMissing,The length of the statement  "                            new Microsoft.Azure.Batch.Protocol.RequestReplacementInterceptor(box0.Bug957878RequestReplacementInterceptorOpContextFactory)})) " is 128.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1719609ODATADetailLevel,The length of the statement  "                            IEnumerable<CloudJob> ienumAllProps = batchCli.JobOperations.ListJobs(detailLevel: new ODATADetailLevel(){ FilterClause = filterString }); " is 138.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1719609ODATADetailLevel,The length of the statement  "                            IEnumerable<CloudJob> iEnumFewerProps = batchCli.JobOperations.ListJobs(detailLevel: new ODATADetailLevel() { SelectClause = "id'state"' FilterClause = filterString }); " is 168.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1719609ODATADetailLevel,The length of the statement  "                            lowDetailLevel = batchCli.JobOperations.GetJob(lowDetailLevel.Id);  // cant refresh 2 times or more because that pesky bug on refresh " is 133.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1719609ODATADetailLevel,The length of the statement  "                            IEnumerable<CloudTask> ienumOdd = boundJob.ListTasks(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(id' 'Odd')"' SelectClause = "id'state" }); " is 160.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1719609ODATADetailLevel,The length of the statement  "                            IEnumerable<CloudTask> ienumEven = boundJob.ListTasks(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(id' 'Even')"' SelectClause = "id'state" }); " is 162.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1719609ODATADetailLevel,The length of the statement  "                            IEnumerable<NodeFile> ienumStd = task.ListNodeFiles(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(name' 'std')" }); " is 134.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1719609ODATADetailLevel,The length of the statement  "                            listStd.ForEach(x => { if (x.Path.IndexOf("stdout"' StringComparison.InvariantCultureIgnoreCase) >= 0) { stdoutFile = x; } }); " is 126.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1719609ODATADetailLevel,The length of the statement  "                            new List<NodeFile>(task.ListNodeFiles()).ForEach(x => { if (x.Path.IndexOf("stdout"' StringComparison.InvariantCultureIgnoreCase) >= 0) { againViaList = x; } }); " is 161.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1719609ODATADetailLevel,The length of the statement  "                            //This fails due to different time formats used in the header vs in the body of a request.  Since we expect that this will basically never pass " is 143.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1996130_ResourceDoubleRefreshDoesntWork,The length of the statement  "                    string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-" + testName; " is 125.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1996130_ResourceDoubleRefreshDoesntWork,The length of the statement  "                        CloudJobSchedule boundJobSchedule = TestUtilities.WaitForJobOnJobSchedule(batchCli.JobScheduleOperations' jobScheduleId); " is 121.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1959324TestCustomBehaviorWorksOnLists,The length of the statement  "                        //batchClient.CustomBehaviors.Add(new SetOperationContext(Bug1959324SetOperationContext));  // this does not exist in GA " is 120.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1959324TestCustomBehaviorWorksOnLists,The length of the statement  "                        //batchClient.CustomBehaviors.Add(new YieldInjectionInterceptor(Bug1959324YieldInjectionInterceptor));  // this is now done by func replacement. see below " is 154.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1959324TestCustomBehaviorWorksOnLists,The length of the statement  "                        batchCli.CustomBehaviors.Add(new Protocol.RequestInterceptor((o) => { interceptorCount++; this.testOutputHelper.WriteLine("Test: random interceptor"); })); " is 155.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1959324TestCustomBehaviorWorksOnLists,The length of the statement  "                            TestUtilities.HelloWorld(batchCli' this.testOutputHelper' sharedPool' out bug1959324JobId' out taskIdHello' deleteJob: false); " is 126.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1959324TestCustomBehaviorWorksOnLists,The length of the statement  "                            request.ServiceRequestFunc = (token) => { return request.RestClient.Job.GetWithHttpMessagesAsync(bug1959324JobId' request.Options' cancellationToken: token); }; " is 160.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                        string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-" + testName; " is 125.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count); " is 122.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count); " is 143.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count); " is 137.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Add(new MetadataItem("abc"' "abc")); " is 135.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc")); " is 162.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc")); " is 161.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count); " is 122.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count); " is 143.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count); " is 137.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server"); " is 121.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count); " is 122.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count); " is 143.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count); " is 137.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.RemoveAt(1); " is 132.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server"); " is 121.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count); " is 122.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count); " is 143.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            Assert.Equal("abc"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.First().Name); " is 133.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            Assert.Equal("test"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.First().Name); " is 155.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count); " is 137.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            IList<ResourceFile> resourceFiles = boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles; " is 150.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.EnvironmentSettings.Add(new EnvironmentSetting("test"' "test"))); " is 135.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://test"' "test"))); " is 134.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The length of the statement  "                            TestUtilities.AssertThrows<InvalidOperationException>(() => { IList<IFileStagingProvider> filesToStage = boundTask.FilesToStage; }); " is 132.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,TestDisplayNameMutability,The length of the statement  "                        Assert.Equal(originalDisplayName' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.DisplayName); " is 137.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,TestDisplayNameMutability,The length of the statement  "                        this.testOutputHelper.WriteLine("Attempting to set display names on job schedule' job specification' pool specification' and job manager task"); " is 144.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,TestDisplayNameMutability,The length of the statement  "                        boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.DisplayName = updatedDisplayName; " is 123.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,TestDisplayNameMutability,The length of the statement  "                        Assert.Equal(updatedDisplayName' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.DisplayName); " is 136.
Long Statement,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,TestDisplayNameMutability,The length of the statement  "                    CloudPool unboundPool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' 0); " is 143.
Long Statement,BatchClientIntegrationTests,IntegrationObjectModelFeatureTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1770942ExposeBatchRequestProperties,The length of the statement  "                            CloudPool lowerDetailLevel = batchCli.PoolOperations.GetPool(matchingPoolWithFullDetailLevel.Id' new ODATADetailLevel() { SelectClause = "id'state" }); " is 151.
Long Statement,BatchClientIntegrationTests.Application,ApplicationIntegrationCommon,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationIntegrationCommon.cs,DeleteApplicationAsync,The length of the statement  "                await mgmtClient.ApplicationPackage.DeleteAsync(resourceGroupName' accountName' applicationPackage' Version).ConfigureAwait(false); " is 131.
Long Statement,BatchClientIntegrationTests.Application,ApplicationManagementIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationManagementIntegrationTests.cs,End2EndApplicationPackageScenario,The length of the statement  "                            await mgmtClient.Application.UpdateAsync(TestCommon.Configuration.BatchAccountResourceGroup' accountName' ApplicationId' new UpdateApplicationParameters " is 152.
Long Statement,BatchClientIntegrationTests.Application,ApplicationManagementIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationManagementIntegrationTests.cs,End2EndApplicationPackageScenario,The length of the statement  "                            List<ApplicationSummary> applicationSummaries = await client.ApplicationOperations.ListApplicationSummaries().ToListAsync().ConfigureAwait(false); " is 146.
Long Statement,BatchClientIntegrationTests.Application,ApplicationManagementIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationManagementIntegrationTests.cs,End2EndApplicationPackageScenario,The length of the statement  "                            ApplicationSummary getApplicationSummary = await client.ApplicationOperations.GetApplicationSummaryAsync(applicationSummary.Id).ConfigureAwait(false); " is 150.
Long Statement,BatchClientIntegrationTests.Application,ApplicationManagementIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationManagementIntegrationTests.cs,End2EndApplicationPackageScenario,The length of the statement  "                            var application = await mgmtClient.Application.GetAsync(TestCommon.Configuration.BatchAccountResourceGroup' accountName' ApplicationId).ConfigureAwait(false); " is 158.
Long Statement,BatchClientIntegrationTests.Application,ApplicationManagementIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationManagementIntegrationTests.cs,AssertPoolWasCreatedWithApplicationReferences,The length of the statement  "                CloudPool pool = client.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)); " is 131.
Long Statement,BatchClientIntegrationTests.Application,ApplicationManagementIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationManagementIntegrationTests.cs,AssertPoolWasCreatedWithApplicationReferences,The length of the statement  "                pool.ApplicationPackageReferences = new[] { new ApplicationPackageReference { ApplicationId = applicationId' Version = ApplicationIntegrationCommon.Version } }; " is 160.
Long Statement,BatchClientIntegrationTests.Application,ApplicationPackagesIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationPackagesIntegrationTests.cs,IfThereAreApplicationsInTheAccountThenListApplicationSummariesReturnsThem,The length of the statement  "                    List<ApplicationSummary> applicationSummaries = await client.ApplicationOperations.ListApplicationSummaries().ToListAsync().ConfigureAwait(false); " is 146.
Long Statement,BatchClientIntegrationTests.Application,ApplicationPackagesIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationPackagesIntegrationTests.cs,IfThereAreApplicationsInTheAccountThenListApplicationSummariesReturnsThem,The length of the statement  "                    ApplicationSummary getApplicationSummary = await client.ApplicationOperations.GetApplicationSummaryAsync(application.Id).ConfigureAwait(false); " is 143.
Long Statement,BatchClientIntegrationTests.Application,ApplicationPackagesReferencesIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationPackagesReferencesIntegrationTests.cs,IfAPoolIsCommittedWithApplicationPackageReferences_ThenThoseReferencesArePersistedInTheService,The length of the statement  "                        List<ApplicationSummary> applicationSummaries = await client.ApplicationOperations.ListApplicationSummaries().ToListAsync().ConfigureAwait(false); " is 146.
Long Statement,BatchClientIntegrationTests.Application,ApplicationPackagesReferencesIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationPackagesReferencesIntegrationTests.cs,IfAPoolIsCommittedWithApplicationPackageReferences_ThenThoseReferencesArePersistedInTheService,The length of the statement  "                        CloudPool pool = client.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)); " is 131.
Long Statement,BatchClientIntegrationTests.Application,ApplicationPackagesReferencesIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationPackagesReferencesIntegrationTests.cs,IfAPoolIsCommittedWithApplicationPackageReferences_ThenThoseReferencesArePersistedInTheService,The length of the statement  "                        pool.ApplicationPackageReferences = new[] { new ApplicationPackageReference { ApplicationId = ApplicationId' Version = Version } }; " is 131.
Long Statement,BatchClientIntegrationTests.Application,ApplicationPackagesReferencesIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationPackagesReferencesIntegrationTests.cs,UpdateAnExistingPoolWithNewApplicationPackageReferences_AndChecksTheApplicationPackageReferencesIsOnThePool,The length of the statement  "                        CloudPool pool = client.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)); " is 131.
Long Statement,BatchClientIntegrationTests.Application,ApplicationPackagesReferencesIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationPackagesReferencesIntegrationTests.cs,UpdateAnExistingPoolWithNewApplicationPackageReferences_AndChecksTheApplicationPackageReferencesIsOnThePool,The length of the statement  "                        pool.ApplicationPackageReferences = new[] { new ApplicationPackageReference { ApplicationId = ApplicationId' Version = Version } }; " is 131.
Long Statement,BatchClientIntegrationTests.Application,ApplicationPackagesReferencesIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationPackagesReferencesIntegrationTests.cs,IfAPoolSpecifiesANonExistentApplicationPackage_ThenCommittingThePoolThrowsAnException,The length of the statement  "                    CloudPool pool = client.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)); " is 131.
Long Statement,BatchClientIntegrationTests.Application,ApplicationPackagesReferencesIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationPackagesReferencesIntegrationTests.cs,IfAPoolSpecifiesANonExistentApplicationPackage_ThenCommittingThePoolThrowsAnException,The length of the statement  "                    pool.ApplicationPackageReferences = new[] { new ApplicationPackageReference { ApplicationId = "dud"' Version = Version } }; " is 123.
Long Statement,BatchClientIntegrationTests.Application,ApplicationPackagesReferencesIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationPackagesReferencesIntegrationTests.cs,CanCreateAndUpdateJobScheduleWithApplicationReferences,The length of the statement  "            Schedule schedule = new Schedule { DoNotRunAfter = DateTime.UtcNow.AddMinutes(5)' RecurrenceInterval = TimeSpan.FromMinutes(2) }; " is 129.
Long Statement,BatchClientIntegrationTests.Application,ApplicationPackagesReferencesIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationPackagesReferencesIntegrationTests.cs,CanCreateAndUpdateJobScheduleWithApplicationReferences,The length of the statement  "                            ApplicationPackageReference apr = boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.ApplicationPackageReferences.First(); " is 161.
Long Statement,BatchClientIntegrationTests.Application,ApplicationPackagesReferencesIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationPackagesReferencesIntegrationTests.cs,CanCreateAndUpdateJobScheduleWithApplicationReferences,The length of the statement  "                            boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.ApplicationPackageReferences = new [] " is 127.
Long Statement,BatchClientIntegrationTests.Application,ApplicationPackagesReferencesIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationPackagesReferencesIntegrationTests.cs,CanCreateAndUpdateJobScheduleWithApplicationReferences,The length of the statement  "                                updatedBoundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.ApplicationPackageReferences " is 125.
Long Statement,BatchClientIntegrationTests.Application,ApplicationPackagesReferencesIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationPackagesReferencesIntegrationTests.cs,CanCreateJobAndAutoPoolWithAppPackageReferences,The length of the statement  "                        ApplicationPackageReference apr = jobResponse.PoolInformation.AutoPoolSpecification.PoolSpecification.ApplicationPackageReferences.First(); " is 139.
Long Statement,BatchClientIntegrationTests.Application,JobWithApplicationPackageReferencesIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\JobWithApplicationPackageReferencesIntegrationTests.cs,CanCreateJobAndAutoPoolWithAppPackageReferences,The length of the statement  "                        Assert.Equal(response.PoolInformation.AutoPoolSpecification.PoolSpecification.ApplicationPackageReferences.First().ApplicationId' applicationId); " is 145.
Long Statement,BatchClientIntegrationTests.Fixtures,PoolFixture,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Fixtures\PoolFixture.cs,WaitForPoolAllocation,The length of the statement  "            TestUtilities.WaitForPoolToReachStateAsync(client' poolId' AllocationState.Steady' computeNodeAllocationTimeout).Wait(); " is 120.
Long Statement,BatchClientIntegrationTests.Fixtures,PoolFixture,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Fixtures\PoolFixture.cs,WaitForPoolAllocation,The length of the statement  "                    throw new Exception("CreatePool: Timed out waiting for compute nodes in pool to reach idle state.  Timeout: " + computeNodeSteadyTimeout.ToString()); " is 149.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,FileToStage,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\FileUploadUtilities.cs,Validate,The length of the statement  "                throw new FileNotFoundException($"The following local file cannot be staged because it cannot be found: {this.LocalFileToStage}"); " is 130.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,FileToStage,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\FileUploadUtilities.cs,CreateContainerWithPolicySASIfNotExistAsync,The length of the statement  "            CloudStorageAccount storageaccount = new CloudStorageAccount(new Microsoft.WindowsAzure.Storage.Auth.StorageCredentials(account' key)' " is 134.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,FileToStage,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\FileUploadUtilities.cs,CreateContainerWithPolicySASIfNotExistAsync,The length of the statement  "                if (!(permissions == (containerpolicy.Permissions & permissions) && start <= containerpolicy.SharedAccessStartTime && end >= containerpolicy.SharedAccessExpiryTime)) " is 165.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,FileToStage,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\FileUploadUtilities.cs,CreateDefaultBlobContainerAndSASIfNeededReturnAsync,The length of the statement  "                seqArtifact.BlobContainerCreated = FileStagingLinkedSources.ConstructDefaultName(seqArtifact.NamingFragment).ToLowerInvariant(); " is 128.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,FileToStage,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\FileUploadUtilities.cs,CreateDefaultBlobContainerAndSASIfNeededReturnAsync,The length of the statement  "                    string policyName = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + Microsoft.Azure.Batch.FileStaging.Constants.DefaultContainerPolicyFragment; " is 154.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,FileToStage,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\FileUploadUtilities.cs,StageFilesInternalAsync,The length of the statement  "            System.Threading.Tasks.Task createContainerTask = System.Threading.Tasks.Task.Run(async () => { await CreateDefaultBlobContainerAndSASIfNeededReturnAsync(filesToStage' seqArtifact); }); " is 185.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,FileToStage,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\FileUploadUtilities.cs,StageOneFileAsync,The length of the statement  "            // TODO: this flattens all files to the top of the compute node/task relative file directory. solve the hiearchy problem (virt dirs?) " is 133.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,SynchronizationContextHelper,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\SynchronizationContextHelper.cs,RunTestAsync,The length of the statement  "                    Assert.False(true' string.Format("SynchronizationContextHelper has terminated this test due to extreme tardiness. Test timed out after {0}"' timeout)); " is 151.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,OpenBatchClient,The length of the statement  "            //TODO: To avoid including this test assembly via "InternalsVisibleTo" we resort to some reflection trickery... maybe this property " is 131.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,GetStorageCredentialsFromEnvironment,The length of the statement  "            StagingStorageAccount storageStagingCredentials = new StagingStorageAccount(storageAccountName' storageAccountKey' storageAccountBlobEndpoint); " is 143.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,AssertIsBatchExceptionAndHasCorrectAzureErrorCode,The length of the statement  "                 outputHelper.WriteLine(string.Format("AssertIsBatchExceptionAndHasCorrectAzureErrorCode: incorrect exception: {0}"' ex.ToString())); " is 132.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,GenerateResourceId,The length of the statement  "                safeBaseId = safeBaseId.Length > actualMaxLength - minRandomCharacters ? safeBaseId.Substring(0' actualMaxLength - minRandomCharacters) : safeBaseId; " is 149.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DeleteJobIfExistsAsync,The length of the statement  "                    throw; //re-throw in the case where we tried to delete the job and got an exception with a status code which wasn't 409 or 404 " is 126.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DeleteJobScheduleIfExistsAsync,The length of the statement  "                    throw; //re-throw in the case where we tried to delete the job and got an exception with a status code which wasn't 409 or 404 " is 126.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DeletePoolIfExistsAsync,The length of the statement  "                    throw; //re-throw in the case where we tried to delete the job and got an exception with a status code which wasn't 409 or 404 " is 126.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DeleteCertificateIfExistsAsync,The length of the statement  "                    throw; //re-throw in the case where we tried to delete the cert and got an exception with a status code which wasn't 409 or 404 " is 127.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DisplayPools,The length of the statement  "                testOutputHelper.WriteLine("    CurrentDedicated:  " + (curPool.CurrentDedicatedComputeNodes.HasValue ? curPool.CurrentDedicatedComputeNodes.Value.ToString() : "<no value>")); " is 175.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DisplayPools,The length of the statement  "                    testOutputHelper.WriteLine("        AvgCpu: " + curPool.Statistics.ResourceStatistics.AverageCpuPercentage + "' AvgDisk: " + curPool.Statistics.ResourceStatistics.AverageDiskGiB + "' AvgMemory: " + curPool.Statistics.ResourceStatistics.AverageMemoryGiB + "' DiskReadBytes: " + curPool.Statistics.ResourceStatistics.DiskReadGiB); " is 328.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DisplayJobScheduleLong,The length of the statement  "            testOutputHelper.WriteLine("       " + "LastModified: " + (curWI.LastModified.HasValue ? curWI.LastModified.Value.ToLongDateString() : "<null>")); " is 146.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DisplayJobScheduleLong,The length of the statement  "                testOutputHelper.WriteLine("               LastUpdateTime: " + (wiExInfo.EndTime.HasValue ? wiExInfo.EndTime.Value.ToLongDateString() : "<null>")); " is 147.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DisplayJobScheduleLong,The length of the statement  "                testOutputHelper.WriteLine("               NextRuntime: " + (wiExInfo.NextRunTime.HasValue ? wiExInfo.NextRunTime.Value.ToLongDateString() : "<null>")); " is 152.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DisplayJobScheduleLong,The length of the statement  "                testOutputHelper.WriteLine("           Priority: " + (jobSpec.Priority.HasValue ? jobSpec.Priority.ToString() : "<null>")); " is 123.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DisplayJobScheduleLong,The length of the statement  "                    testOutputHelper.WriteLine("             MaxTaskRetryCount: " + (jobCon.MaxTaskRetryCount.HasValue ? jobSpec.Constraints.MaxTaskRetryCount.Value.ToString() : "<null>")); " is 169.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DisplayJobScheduleLong,The length of the statement  "                    testOutputHelper.WriteLine("             MaxWallClockTime: " + (jobCon.MaxWallClockTime.HasValue ? jobSpec.Constraints.MaxWallClockTime.Value.TotalMilliseconds.ToString() : "<null>")); " is 184.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DisplayJobScheduleLong,The length of the statement  "                    testOutputHelper.WriteLine("               KillJobOnCompletion: " + (ijm.KillJobOnCompletion.HasValue ? ijm.KillJobOnCompletion.Value.ToString() : "<null>")); " is 158.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DisplayJobScheduleLong,The length of the statement  "                    testOutputHelper.WriteLine("               RunExclusive       : " + (ijm.RunExclusive.HasValue ? ijm.RunExclusive.Value.ToString() : "<null>")); " is 144.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DisplayJobScheduleLong,The length of the statement  "                        testOutputHelper.WriteLine("                   MaxTaskRetryCount: " + (tc.MaxTaskRetryCount.HasValue ? tc.MaxTaskRetryCount.Value.ToString() : "<null>")); " is 154.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DisplayJobScheduleLong,The length of the statement  "                        testOutputHelper.WriteLine("                   MaxWallClockTime: " + (tc.MaxWallClockTime.HasValue ? tc.MaxWallClockTime.Value.TotalMilliseconds.ToString() : "<null>")); " is 169.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DisplayJobScheduleLong,The length of the statement  "                        testOutputHelper.WriteLine("                   RetentionTime: " + (tc.RetentionTime.HasValue ? tc.RetentionTime.Value.TotalMilliseconds.ToString() : "<null>")); " is 160.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DisplayJobScheduleLong,The length of the statement  "                testOutputHelper.WriteLine("           DoNotRunAfter:" + (sched.DoNotRunAfter.HasValue ? sched.DoNotRunAfter.Value.ToLongDateString() : "<null>")); " is 147.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DisplayJobScheduleLong,The length of the statement  "                testOutputHelper.WriteLine("           DoNotRunUntil: " + (sched.DoNotRunUntil.HasValue ? sched.DoNotRunUntil.Value.ToLongDateString() : "<null>")); " is 148.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DisplayJobScheduleLong,The length of the statement  "                testOutputHelper.WriteLine("           RecurrenceInterval: " + (sched.RecurrenceInterval.HasValue ? sched.RecurrenceInterval.Value.TotalMilliseconds.ToString() : "<null>")); " is 173.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DisplayJobScheduleLong,The length of the statement  "                testOutputHelper.WriteLine("           StartWindow       :" + (sched.StartWindow.HasValue ? sched.StartWindow.Value.TotalMilliseconds.ToString() : "<null>")); " is 158.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,WaitForJobStateAsync,The length of the statement  "                throw new TimeoutException($"Job {cloudJob.Id} did not reach expected state {expected} within time {waitFor}' last observed {cloudJob.State}"); " is 143.
Long Statement,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,GetServiceClient,The length of the statement  "            object protocolLayer = batchClient.GetType().GetProperty("ProtocolLayer"' BindingFlags.Instance | BindingFlags.NonPublic).GetValue(batchClient); " is 144.
Complex Conditional,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,WaitForJobOnJobSchedule,The conditional expression  "refreshableJobSchedule.ExecutionInformation == null ||                  refreshableJobSchedule.ExecutionInformation.RecentJob == null ||                  (!string.IsNullOrEmpty(expectedJobId) && refreshableJobSchedule.ExecutionInformation.RecentJob.Id != expectedJobId)"  is complex.
Empty Catch Block,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,The method has an empty catch block.
Empty Catch Block,BatchClientIntegrationTests.Fixtures,PoolFixture,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Fixtures\PoolFixture.cs,Dispose,The method has an empty catch block.
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchSimple,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>                  {                      using (BatchClient batchCli = await TestUtilities.OpenBatchClientFromEnvironmentAsync())                      {                          await this.AddTasksSimpleTestAsync(batchCli' testName' 50' useJobOperations: useJobOperations).ConfigureAwait(false);                      }                  }'                  TestTimeout);
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchMultipleBatches,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>                  {                      using (BatchClient batchCli = await TestUtilities.OpenBatchClientFromEnvironmentAsync())                      {                          await this.AddTasksSimpleTestAsync(batchCli' testName' 550' useJobOperations: useJobOperations).ConfigureAwait(false);                      }                  }'                  TestTimeout);
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchHugeTaskCount,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>              {                  using (BatchClient batchCli = await TestUtilities.OpenBatchClientFromEnvironmentAsync())                  {                      BatchClientParallelOptions parallelOptions = new BatchClientParallelOptions()                                                                   {                                                                       MaxDegreeOfParallelism = 25                                                                   };                        await this.AddTasksSimpleTestAsync(batchCli' testName' 5025' parallelOptions).ConfigureAwait(false);                  }              }'              LongTestTimeout);
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchHugeTaskCount,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>              {                  using (BatchClient batchCli = await TestUtilities.OpenBatchClientFromEnvironmentAsync())                  {                      BatchClientParallelOptions parallelOptions = new BatchClientParallelOptions()                                                                   {                                                                       MaxDegreeOfParallelism = 25                                                                   };                        await this.AddTasksSimpleTestAsync(batchCli' testName' 5025' parallelOptions).ConfigureAwait(false);                  }              }'              LongTestTimeout);
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchFailure,The following statement contains a magic number: const int countToFailAt = 102;
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchFailure,The following statement contains a magic number: const int taskCount = 407;
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchFailure,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>              {                  using (BatchClient batchCli = await TestUtilities.OpenBatchClientFromEnvironmentAsync())                  {                      BatchClientParallelOptions parallelOptions = new BatchClientParallelOptions()                      {                          MaxDegreeOfParallelism = 2                      };                        var exception = await TestUtilities.AssertThrowsAsync<ParallelOperationsException>(                          async () => await this.AddTasksSimpleTestAsync(                              batchCli'                              testName'                              taskCount'                              parallelOptions'                              resultHandlerFunc'                              useJobOperations: useJobOperations).ConfigureAwait(false)).ConfigureAwait(false);                      Assert.IsType<HttpRequestException>(exception.InnerException);                  }              }'              TestTimeout);
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchRetry,The following statement contains a magic number: Func<AddTaskResult' CancellationToken' AddTaskResultStatus> resultHandlerFunc = (result' token) =>              {                  this.testOutputHelper.WriteLine("Task: {0} got status code: {1}"' result.TaskId' result.Status);                  AddTaskResultStatus resultAction;                    if (result.Status == AddTaskStatus.ClientError)                  {                      ++numberOfTasksWhichHitClientError;                      return AddTaskResultStatus.Success; //Have to count client error as success                  }                    lock (randLock)                  {                      double d = rand.NextDouble();                        if (d > 0.8)                      {                          this.testOutputHelper.WriteLine("Forcing retry for task: {0}"' result.TaskId);                            resultAction = AddTaskResultStatus.Retry;                          ++numberOfTasksWhichWereForcedToRetry;                      }                      else                      {                          resultAction = AddTaskResultStatus.Success;                      }                  }                    return resultAction;              };
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchRetry,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>              {                  StagingStorageAccount storageCredentials = TestUtilities.GetStorageCredentialsFromEnvironment();                  using (BatchClient batchCli = await TestUtilities.OpenBatchClientFromEnvironmentAsync())                  {                      BatchClientParallelOptions parallelOptions = new BatchClientParallelOptions()                      {                          MaxDegreeOfParallelism = 2                      };                        await this.AddTasksSimpleTestAsync(                          batchCli'                          testName'                          1281'                          parallelOptions'                          resultHandlerFunc'                          storageCredentials'                          new List<string> { "TestResources\\Data.txt" }'                          useJobOperations: useJobOperations).ConfigureAwait(false);                  }              }'              LongTestTimeout);
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchRetry,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>              {                  StagingStorageAccount storageCredentials = TestUtilities.GetStorageCredentialsFromEnvironment();                  using (BatchClient batchCli = await TestUtilities.OpenBatchClientFromEnvironmentAsync())                  {                      BatchClientParallelOptions parallelOptions = new BatchClientParallelOptions()                      {                          MaxDegreeOfParallelism = 2                      };                        await this.AddTasksSimpleTestAsync(                          batchCli'                          testName'                          1281'                          parallelOptions'                          resultHandlerFunc'                          storageCredentials'                          new List<string> { "TestResources\\Data.txt" }'                          useJobOperations: useJobOperations).ConfigureAwait(false);                  }              }'              LongTestTimeout);
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchRequestFailure,The following statement contains a magic number: BatchClientBehavior customBehavior = new Protocol.RequestInterceptor(request =>              {                  var typedRequest = request as Protocol.BatchRequests.TaskAddCollectionBatchRequest;                    if (typedRequest != null)                  {                      var originalServiceRequestFunction = typedRequest.ServiceRequestFunc;                        typedRequest.ServiceRequestFunc = token =>                          {                              lock (randLock)                              {                                  double d = rand.NextDouble();                                  if (d > 0.3)                                  {                                      throw new HttpRequestException("Simulating a network problem");                                  }                                  else                                  {                                      return originalServiceRequestFunction(token);                                  }                              }                          };                  }              });
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchRequestFailure,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()' addDefaultRetryPolicy: false))                  {                      batchCli.JobOperations.CustomBehaviors.Add(customBehavior);                        BatchClientParallelOptions parallelOptions = new BatchClientParallelOptions()                      {                          MaxDegreeOfParallelism = 2                      };                        var exception = await TestUtilities.AssertThrowsAsync<ParallelOperationsException>(async () =>                           await this.AddTasksSimpleTestAsync(batchCli' testName' 397' parallelOptions' useJobOperations: useJobOperations).ConfigureAwait(false)                          ).ConfigureAwait(false);                        Assert.IsType<HttpRequestException>(exception.InnerException);                  }              }'              TestTimeout);
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchRequestFailure,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()' addDefaultRetryPolicy: false))                  {                      batchCli.JobOperations.CustomBehaviors.Add(customBehavior);                        BatchClientParallelOptions parallelOptions = new BatchClientParallelOptions()                      {                          MaxDegreeOfParallelism = 2                      };                        var exception = await TestUtilities.AssertThrowsAsync<ParallelOperationsException>(async () =>                           await this.AddTasksSimpleTestAsync(batchCli' testName' 397' parallelOptions' useJobOperations: useJobOperations).ConfigureAwait(false)                          ).ConfigureAwait(false);                        Assert.IsType<HttpRequestException>(exception.InnerException);                  }              }'              TestTimeout);
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchCancelation,The following statement contains a magic number: const int taskCount = 322;
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchCancelation,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>                  {                      using (BatchClient batchCli = await TestUtilities.OpenBatchClientFromEnvironmentAsync())                      {                          using (CancellationTokenSource source = new CancellationTokenSource())                          {                              BatchClientParallelOptions parallelOptions = new BatchClientParallelOptions()                                  {                                      MaxDegreeOfParallelism = 2'                                      CancellationToken = source.Token                                  };                                System.Threading.Tasks.Task t = this.AddTasksSimpleTestAsync(                                  batchCli'                                  testName'                                  taskCount'                                  parallelOptions'                                  useJobOperations: useJobOperations);                              Thread.Sleep(TimeSpan.FromSeconds(.3)); //Wait till we get into the workflow                              this.testOutputHelper.WriteLine("Canceling the work flow");                                source.Cancel();                                try                              {                                  await t.ConfigureAwait(false);                              }                              catch (Exception e)                              {                                  //This is expected to throw one of two possible exception types...                                  if (!(e is TaskCanceledException) && !(e is OperationCanceledException))                                  {                                      throw new ThrowsException(typeof (TaskCanceledException)' e);                                  }                              }                            }                      }                  }'                  TestTimeout);
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchCancelation,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>                  {                      using (BatchClient batchCli = await TestUtilities.OpenBatchClientFromEnvironmentAsync())                      {                          using (CancellationTokenSource source = new CancellationTokenSource())                          {                              BatchClientParallelOptions parallelOptions = new BatchClientParallelOptions()                                  {                                      MaxDegreeOfParallelism = 2'                                      CancellationToken = source.Token                                  };                                System.Threading.Tasks.Task t = this.AddTasksSimpleTestAsync(                                  batchCli'                                  testName'                                  taskCount'                                  parallelOptions'                                  useJobOperations: useJobOperations);                              Thread.Sleep(TimeSpan.FromSeconds(.3)); //Wait till we get into the workflow                              this.testOutputHelper.WriteLine("Canceling the work flow");                                source.Cancel();                                try                              {                                  await t.ConfigureAwait(false);                              }                              catch (Exception e)                              {                                  //This is expected to throw one of two possible exception types...                                  if (!(e is TaskCanceledException) && !(e is OperationCanceledException))                                  {                                      throw new ThrowsException(typeof (TaskCanceledException)' e);                                  }                              }                            }                      }                  }'                  TestTimeout);
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchWithFilesToStage,The following statement contains a magic number: const int taskCount = 499;
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchWithFilesToStage,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>                  {                      StagingStorageAccount storageCredentials = TestUtilities.GetStorageCredentialsFromEnvironment();                      using (BatchClient batchCli = await TestUtilities.OpenBatchClientFromEnvironmentAsync())                      {                          await this.AddTasksSimpleTestAsync(                              batchCli'                              testName'                              taskCount'                              parallelOptions: new BatchClientParallelOptions() { MaxDegreeOfParallelism = 2 }'                              storageCredentials: storageCredentials'                              localFilesToStage: localFilesToStage'                              fileStagingArtifacts: artifacts'                              useJobOperations: useJobOperations).ConfigureAwait(false);                            cts.Cancel();                            await t.ConfigureAwait(false); //Wait for the spawned thread to exit                            this.testOutputHelper.WriteLine("File staging leg count: [");                          foreach (int fileStagingArtifactsCount in legArtifactsCountList)                          {                              this.testOutputHelper.WriteLine(fileStagingArtifactsCount + "' ");                          }                          this.testOutputHelper.WriteLine("]");                            const int expectedFinalFileStagingArtifactsCount = taskCount / 100 + 1;                          const int expectedInitialFileStagingArtifactsCount = 0;                            Assert.Equal(expectedInitialFileStagingArtifactsCount' legArtifactsCountList.First());                          Assert.Equal(expectedFinalFileStagingArtifactsCount' legArtifactsCountList.Last());                      }                  }'                  TestTimeout);
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchWithFilesToStage,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>                  {                      StagingStorageAccount storageCredentials = TestUtilities.GetStorageCredentialsFromEnvironment();                      using (BatchClient batchCli = await TestUtilities.OpenBatchClientFromEnvironmentAsync())                      {                          await this.AddTasksSimpleTestAsync(                              batchCli'                              testName'                              taskCount'                              parallelOptions: new BatchClientParallelOptions() { MaxDegreeOfParallelism = 2 }'                              storageCredentials: storageCredentials'                              localFilesToStage: localFilesToStage'                              fileStagingArtifacts: artifacts'                              useJobOperations: useJobOperations).ConfigureAwait(false);                            cts.Cancel();                            await t.ConfigureAwait(false); //Wait for the spawned thread to exit                            this.testOutputHelper.WriteLine("File staging leg count: [");                          foreach (int fileStagingArtifactsCount in legArtifactsCountList)                          {                              this.testOutputHelper.WriteLine(fileStagingArtifactsCount + "' ");                          }                          this.testOutputHelper.WriteLine("]");                            const int expectedFinalFileStagingArtifactsCount = taskCount / 100 + 1;                          const int expectedInitialFileStagingArtifactsCount = 0;                            Assert.Equal(expectedInitialFileStagingArtifactsCount' legArtifactsCountList.First());                          Assert.Equal(expectedFinalFileStagingArtifactsCount' legArtifactsCountList.Last());                      }                  }'                  TestTimeout);
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchConfirmResultHandlerTaskReadOnly,The following statement contains a magic number: Func<AddTaskResult' CancellationToken' AddTaskResultStatus> resultHandlerFunc = (result' token) =>              {                  //Count everything as a success                  AddTaskResultStatus resultAction = AddTaskResultStatus.Success;                    //Try to set a property of the cloud task                  InvalidOperationException e = TestUtilities.AssertThrows<InvalidOperationException>(() =>                       result.Task.Constraints = new TaskConstraints(TimeSpan.FromSeconds(5)' null' null));                    Assert.Contains("Write access is not allowed."' e.Message);                    //Try to call a method of a CloudTask                  //TODO: This should be blocked but isn't right now...                  //try                  //{                  //    result.Task.Terminate();                  //    Debug.Fail("Should not have gotten here");                  //}                  //catch (Exception e)                  //{                  //    Console.WriteLine(e);                  //    //Swallow this exception as it is expected                  //}                    return resultAction;              };
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchConfirmResultHandlerTaskReadOnly,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>              {                  using (BatchClient batchCli = await TestUtilities.OpenBatchClientFromEnvironmentAsync())                  {                      BatchClientParallelOptions parallelOptions = new BatchClientParallelOptions()                      {                          MaxDegreeOfParallelism = 2                      };                        await this.AddTasksSimpleTestAsync(                          batchCli'                          testName'                          55'                          parallelOptions'                          resultHandlerFunc).ConfigureAwait(false);                  }              }'              TestTimeout);
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchConfirmResultHandlerTaskReadOnly,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>              {                  using (BatchClient batchCli = await TestUtilities.OpenBatchClientFromEnvironmentAsync())                  {                      BatchClientParallelOptions parallelOptions = new BatchClientParallelOptions()                      {                          MaxDegreeOfParallelism = 2                      };                        await this.AddTasksSimpleTestAsync(                          batchCli'                          testName'                          55'                          parallelOptions'                          resultHandlerFunc).ConfigureAwait(false);                  }              }'              TestTimeout);
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,Bug1360227_AddTasksBatchTimeout,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>              {                  using (BatchClient batchCli = await TestUtilities.OpenBatchClientFromEnvironmentAsync())                  {                      var exception = await TestUtilities.AssertThrowsAsync<ParallelOperationsException>(                          async () => await this.AddTasksSimpleTestAsync(                              batchCli'                              testName'                              311'                              timeout: TimeSpan.FromSeconds(1)'                              useJobOperations: useJobOperations).ConfigureAwait(false)).ConfigureAwait(false);                        Assert.IsType<TimeoutException>(exception.InnerException);                  }              }'              TestTimeout);
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,AddTasksFailIfPoisonTaskTooLarge,The following statement contains a magic number: i < 10000
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,AddTasksRequestEntityTooLarge_ReduceChunkSize,The following statement contains a magic number: int numTasks = 176;
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,AddTasksRequestEntityTooLarge_ReduceChunkSize,The following statement contains a magic number: int degreesOfParallelism = 2;
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,AddTasksRequestEntityTooLarge_ReduceChunkSize,The following statement contains a magic number: BatchClientBehavior customBehavior = new Protocol.RequestInterceptor(request =>              {                  var typedRequest = request as Protocol.BatchRequests.TaskAddCollectionBatchRequest;                  if (typedRequest != null)                  {                      if(typedRequest.Parameters.Count > 50)                      {                          Interlocked.Increment(ref countChunksOf100);                      }                  }              });
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,AddTasksRequestEntityTooLarge_ReduceChunkSize,The following statement contains a magic number: i < 100
Magic Number,BatchClientIntegrationTests,AddTaskCollectionIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AddTaskCollectionIntegrationTests.cs,AddTasksRequestEntityTooLarge_ReduceChunkSize,The following statement contains a magic number: Assert.True(countChunksOf100 <= Math.Min(Math.Ceiling(numTasks/100.0)' degreesOfParallelism));
Magic Number,BatchClientIntegrationTests,AutoScaleIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AutoScaleIntegrationTests.cs,AutoScaleEvaluationIntervalTest,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>                  {                      using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()' addDefaultRetryPolicy: false))                      {                          const string poolASFormulaOrig = "$TargetDedicated = 0;";                          TimeSpan evalInterval = TimeSpan.FromMinutes(6);                          string poolId0 = "AutoScaleEvalInterval0-" + TestUtilities.GetMyName();                            try                          {                              // create an empty pool with autoscale and an eval interval                              CloudServiceConfiguration cloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily);                              CloudPool ubPool = batchCli.PoolOperations.CreatePool(                                  poolId0'                                   cloudServiceConfiguration: cloudServiceConfiguration'                                   virtualMachineSize: PoolFixture.VMSize);                              ubPool.AutoScaleEnabled = true;                              ubPool.AutoScaleEvaluationInterval = evalInterval;                              ubPool.AutoScaleFormula = poolASFormulaOrig;                                ubPool.Commit();                                // confirm values are returned                              CloudPool bndPool = batchCli.PoolOperations.GetPool(poolId0);                                Assert.True(bndPool.AutoScaleEnabled.HasValue && bndPool.AutoScaleEnabled.Value);                              Assert.Equal(evalInterval' bndPool.AutoScaleEvaluationInterval);                                // change eval interval                              TimeSpan newEvalInterval = evalInterval + TimeSpan.FromMinutes(1);                                bndPool.EnableAutoScale(autoscaleEvaluationInterval: newEvalInterval);                                int enableCallCounter = 1; // count these to validate server throttle                              const int expectedEnableCallToFail = 2;                                bndPool.Refresh();                                Assert.True(bndPool.AutoScaleEnabled.HasValue && bndPool.AutoScaleEnabled.Value);                              Assert.True(bndPool.AutoScaleEvaluationInterval.HasValue);                              Assert.Equal(newEvalInterval' bndPool.AutoScaleEvaluationInterval.Value);                                // check the interval floor assert                              var batchException = TestUtilities.AssertThrows<BatchException>(                                  () => bndPool.EnableAutoScale(autoscaleEvaluationInterval: TimeSpan.FromMinutes(1)));                              Assert.Equal(Microsoft.Azure.Batch.Common.BatchErrorCodeStrings.InvalidPropertyValue' batchException.RequestInformation.BatchError.Code);                                // check for AutoScaleTooManyRequestsToEnable                              try                              {                                  // spam the server                                  for (int i = 0; i < 99; i++)  // remember there was already one (1) call made above                                  {                                      enableCallCounter++; // one more call                                      bndPool.EnableAutoScale(autoscaleEvaluationInterval: newEvalInterval + TimeSpan.FromSeconds(i));                                  }                                    // server never pushed back on the spam.  this is a bug                                  throw new Exception("AutoScaleEvaluationIntervalTest: unable to force AutoScaleTooManyRequestsToEnable");                              }                              catch (Exception ex)                              {                                  TestUtilities.AssertIsBatchExceptionAndHasCorrectAzureErrorCode(ex' Microsoft.Azure.Batch.Common.BatchErrorCodeStrings.AutoScaleTooManyRequestsToEnable' this.testOutputHelper);                                    // if we get here the exception passed.                                    // confirm that the expected call fails                                  Assert.Equal(expectedEnableCallToFail' enableCallCounter);                              }                          }                          finally                          {                              // cleanup                              TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId0).Wait();                          }                      }                  }'                  TestTimeout);
Magic Number,BatchClientIntegrationTests,AutoScaleIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AutoScaleIntegrationTests.cs,AutoScaleEvaluationIntervalTest,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>                  {                      using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()' addDefaultRetryPolicy: false))                      {                          const string poolASFormulaOrig = "$TargetDedicated = 0;";                          TimeSpan evalInterval = TimeSpan.FromMinutes(6);                          string poolId0 = "AutoScaleEvalInterval0-" + TestUtilities.GetMyName();                            try                          {                              // create an empty pool with autoscale and an eval interval                              CloudServiceConfiguration cloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily);                              CloudPool ubPool = batchCli.PoolOperations.CreatePool(                                  poolId0'                                   cloudServiceConfiguration: cloudServiceConfiguration'                                   virtualMachineSize: PoolFixture.VMSize);                              ubPool.AutoScaleEnabled = true;                              ubPool.AutoScaleEvaluationInterval = evalInterval;                              ubPool.AutoScaleFormula = poolASFormulaOrig;                                ubPool.Commit();                                // confirm values are returned                              CloudPool bndPool = batchCli.PoolOperations.GetPool(poolId0);                                Assert.True(bndPool.AutoScaleEnabled.HasValue && bndPool.AutoScaleEnabled.Value);                              Assert.Equal(evalInterval' bndPool.AutoScaleEvaluationInterval);                                // change eval interval                              TimeSpan newEvalInterval = evalInterval + TimeSpan.FromMinutes(1);                                bndPool.EnableAutoScale(autoscaleEvaluationInterval: newEvalInterval);                                int enableCallCounter = 1; // count these to validate server throttle                              const int expectedEnableCallToFail = 2;                                bndPool.Refresh();                                Assert.True(bndPool.AutoScaleEnabled.HasValue && bndPool.AutoScaleEnabled.Value);                              Assert.True(bndPool.AutoScaleEvaluationInterval.HasValue);                              Assert.Equal(newEvalInterval' bndPool.AutoScaleEvaluationInterval.Value);                                // check the interval floor assert                              var batchException = TestUtilities.AssertThrows<BatchException>(                                  () => bndPool.EnableAutoScale(autoscaleEvaluationInterval: TimeSpan.FromMinutes(1)));                              Assert.Equal(Microsoft.Azure.Batch.Common.BatchErrorCodeStrings.InvalidPropertyValue' batchException.RequestInformation.BatchError.Code);                                // check for AutoScaleTooManyRequestsToEnable                              try                              {                                  // spam the server                                  for (int i = 0; i < 99; i++)  // remember there was already one (1) call made above                                  {                                      enableCallCounter++; // one more call                                      bndPool.EnableAutoScale(autoscaleEvaluationInterval: newEvalInterval + TimeSpan.FromSeconds(i));                                  }                                    // server never pushed back on the spam.  this is a bug                                  throw new Exception("AutoScaleEvaluationIntervalTest: unable to force AutoScaleTooManyRequestsToEnable");                              }                              catch (Exception ex)                              {                                  TestUtilities.AssertIsBatchExceptionAndHasCorrectAzureErrorCode(ex' Microsoft.Azure.Batch.Common.BatchErrorCodeStrings.AutoScaleTooManyRequestsToEnable' this.testOutputHelper);                                    // if we get here the exception passed.                                    // confirm that the expected call fails                                  Assert.Equal(expectedEnableCallToFail' enableCallCounter);                              }                          }                          finally                          {                              // cleanup                              TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId0).Wait();                          }                      }                  }'                  TestTimeout);
Magic Number,BatchClientIntegrationTests,AutoScaleIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\AutoScaleIntegrationTests.cs,AutoScaleEvaluationIntervalTest,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>                  {                      using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()' addDefaultRetryPolicy: false))                      {                          const string poolASFormulaOrig = "$TargetDedicated = 0;";                          TimeSpan evalInterval = TimeSpan.FromMinutes(6);                          string poolId0 = "AutoScaleEvalInterval0-" + TestUtilities.GetMyName();                            try                          {                              // create an empty pool with autoscale and an eval interval                              CloudServiceConfiguration cloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily);                              CloudPool ubPool = batchCli.PoolOperations.CreatePool(                                  poolId0'                                   cloudServiceConfiguration: cloudServiceConfiguration'                                   virtualMachineSize: PoolFixture.VMSize);                              ubPool.AutoScaleEnabled = true;                              ubPool.AutoScaleEvaluationInterval = evalInterval;                              ubPool.AutoScaleFormula = poolASFormulaOrig;                                ubPool.Commit();                                // confirm values are returned                              CloudPool bndPool = batchCli.PoolOperations.GetPool(poolId0);                                Assert.True(bndPool.AutoScaleEnabled.HasValue && bndPool.AutoScaleEnabled.Value);                              Assert.Equal(evalInterval' bndPool.AutoScaleEvaluationInterval);                                // change eval interval                              TimeSpan newEvalInterval = evalInterval + TimeSpan.FromMinutes(1);                                bndPool.EnableAutoScale(autoscaleEvaluationInterval: newEvalInterval);                                int enableCallCounter = 1; // count these to validate server throttle                              const int expectedEnableCallToFail = 2;                                bndPool.Refresh();                                Assert.True(bndPool.AutoScaleEnabled.HasValue && bndPool.AutoScaleEnabled.Value);                              Assert.True(bndPool.AutoScaleEvaluationInterval.HasValue);                              Assert.Equal(newEvalInterval' bndPool.AutoScaleEvaluationInterval.Value);                                // check the interval floor assert                              var batchException = TestUtilities.AssertThrows<BatchException>(                                  () => bndPool.EnableAutoScale(autoscaleEvaluationInterval: TimeSpan.FromMinutes(1)));                              Assert.Equal(Microsoft.Azure.Batch.Common.BatchErrorCodeStrings.InvalidPropertyValue' batchException.RequestInformation.BatchError.Code);                                // check for AutoScaleTooManyRequestsToEnable                              try                              {                                  // spam the server                                  for (int i = 0; i < 99; i++)  // remember there was already one (1) call made above                                  {                                      enableCallCounter++; // one more call                                      bndPool.EnableAutoScale(autoscaleEvaluationInterval: newEvalInterval + TimeSpan.FromSeconds(i));                                  }                                    // server never pushed back on the spam.  this is a bug                                  throw new Exception("AutoScaleEvaluationIntervalTest: unable to force AutoScaleTooManyRequestsToEnable");                              }                              catch (Exception ex)                              {                                  TestUtilities.AssertIsBatchExceptionAndHasCorrectAzureErrorCode(ex' Microsoft.Azure.Batch.Common.BatchErrorCodeStrings.AutoScaleTooManyRequestsToEnable' this.testOutputHelper);                                    // if we get here the exception passed.                                    // confirm that the expected call fails                                  Assert.Equal(expectedEnableCallToFail' enableCallCounter);                              }                          }                          finally                          {                              // cleanup                              TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId0).Wait();                          }                      }                  }'                  TestTimeout);
Magic Number,BatchClientIntegrationTests,BatchRequestIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\BatchRequestIntegrationTests.cs,BatchRequestWithShortClientSideTimeout,The following statement contains a magic number: await Assert.ThrowsAnyAsync<OperationCanceledException>(async () =>                  await SynchronizationContextHelper.RunTestAsync(async () =>                  {                      using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()' addDefaultRetryPolicy: false))                      {                          List<BatchClientBehavior> customBehaviors = new List<BatchClientBehavior>();                          customBehaviors.Add(new RequestInterceptor((req) =>                          {                              //Set the timeout to something small so it is guaranteed to expire before the service has responded                              req.Timeout = TimeSpan.FromMilliseconds(25);                          }));                            await client.JobOperations.GetJobAsync("Foo"' additionalBehaviors: customBehaviors).ConfigureAwait(false);                      }                  }'                  TestTimeout));
Magic Number,BatchClientIntegrationTests,BatchRequestIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\BatchRequestIntegrationTests.cs,BatchRequestWithShortClientSideTimeoutAndRetries,The following statement contains a magic number: const int maxRetries = 5;
Magic Number,BatchClientIntegrationTests,BatchRequestIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\BatchRequestIntegrationTests.cs,BatchRequestWithShortClientSideTimeoutAndRetries,The following statement contains a magic number: await Assert.ThrowsAnyAsync<OperationCanceledException>(async () =>                  await SynchronizationContextHelper.RunTestAsync(async () =>                  {                      using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()' addDefaultRetryPolicy: false))                      {                          client.CustomBehaviors.Add(RetryPolicyProvider.LinearRetryProvider(TimeSpan.FromMilliseconds(250)' maxRetries));                          List<BatchClientBehavior> customBehaviors = new List<BatchClientBehavior>();                          customBehaviors.Add(new RequestInterceptor((req) =>                          {                              //Set the timeout to something small so it is guaranteed to expire before the service has responded                              req.Timeout = TimeSpan.FromMilliseconds(25);                                var castRequest = (JobGetBatchRequest)req;                              Func<CancellationToken' Task<AzureOperationResponse<Microsoft.Azure.Batch.Protocol.Models.CloudJob' Microsoft.Azure.Batch.Protocol.Models.JobGetHeaders>>> oldFunc = castRequest.ServiceRequestFunc;                              castRequest.ServiceRequestFunc = async (token) =>                                                                     {                                                                         actualRequestCount++; //Count the number of calls to the func                                                                         return await oldFunc(token).ConfigureAwait(false);                                                                     };                          }));                            await client.JobOperations.GetJobAsync("Foo"' additionalBehaviors: customBehaviors).ConfigureAwait(false);                      }                  }'                  TestTimeout));
Magic Number,BatchClientIntegrationTests,BatchRequestIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\BatchRequestIntegrationTests.cs,BatchRequestWithShortClientSideTimeoutAndRetries,The following statement contains a magic number: await Assert.ThrowsAnyAsync<OperationCanceledException>(async () =>                  await SynchronizationContextHelper.RunTestAsync(async () =>                  {                      using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()' addDefaultRetryPolicy: false))                      {                          client.CustomBehaviors.Add(RetryPolicyProvider.LinearRetryProvider(TimeSpan.FromMilliseconds(250)' maxRetries));                          List<BatchClientBehavior> customBehaviors = new List<BatchClientBehavior>();                          customBehaviors.Add(new RequestInterceptor((req) =>                          {                              //Set the timeout to something small so it is guaranteed to expire before the service has responded                              req.Timeout = TimeSpan.FromMilliseconds(25);                                var castRequest = (JobGetBatchRequest)req;                              Func<CancellationToken' Task<AzureOperationResponse<Microsoft.Azure.Batch.Protocol.Models.CloudJob' Microsoft.Azure.Batch.Protocol.Models.JobGetHeaders>>> oldFunc = castRequest.ServiceRequestFunc;                              castRequest.ServiceRequestFunc = async (token) =>                                                                     {                                                                         actualRequestCount++; //Count the number of calls to the func                                                                         return await oldFunc(token).ConfigureAwait(false);                                                                     };                          }));                            await client.JobOperations.GetJobAsync("Foo"' additionalBehaviors: customBehaviors).ConfigureAwait(false);                      }                  }'                  TestTimeout));
Magic Number,BatchClientIntegrationTests,BatchRequestIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\BatchRequestIntegrationTests.cs,BatchRequestWithShortUserCancellationToken,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>              {                  //Set the timeout to something small so it is guaranteed to expire before the service has responded                  using(CancellationTokenSource tokenSource = new CancellationTokenSource(TimeSpan.FromMilliseconds(25)))                  {                      using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()' addDefaultRetryPolicy: false))                      {                          List<BatchClientBehavior> customBehaviors = new List<BatchClientBehavior>();                          customBehaviors.Add(new RequestInterceptor((req) =>                          {                              req.CancellationToken = tokenSource.Token;                          }));                            await TestUtilities.AssertThrowsAsync<OperationCanceledException>(async () =>                              await client.JobOperations.GetJobAsync("Foo"' additionalBehaviors: customBehaviors).ConfigureAwait(false)).ConfigureAwait(false);                      }                  }              }'              TestTimeout);
Magic Number,BatchClientIntegrationTests,CloudCertificateIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudCertificateIntegrationTests.cs,WaitForCertificateState,The following statement contains a magic number: TimeSpan timeout = TimeSpan.FromMinutes(3);
Magic Number,BatchClientIntegrationTests,CloudCertificateIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudCertificateIntegrationTests.cs,WaitForCertificateState,The following statement contains a magic number: await Task.Delay(TimeSpan.FromSeconds(5)).ConfigureAwait(false);
Magic Number,BatchClientIntegrationTests,CloudCertificateIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudCertificateIntegrationTests.cs,TestCancelDeleteCertificateAsync,The following statement contains a magic number: await Task.Delay(TimeSpan.FromSeconds(5)).ConfigureAwait(false);
Magic Number,BatchClientIntegrationTests,CloudCertificateIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudCertificateIntegrationTests.cs,TestCancelDeleteCertificateAsync,The following statement contains a magic number: await Task.Delay(TimeSpan.FromSeconds(5)).ConfigureAwait(false);
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Bug1665834TaskStateMonitor,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug1665834Job-" + TestUtilities.GetMyName();                        try                      {                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          unboundJob.PoolInformation.PoolId = this.poolFixture.PoolId;                          unboundJob.Commit();                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            // add some noise tasks                          for (int j = 0; j < 5; j++)                          {                              CloudTask unboundTaskQuick = new CloudTask((10 + j).ToString()' "cmd /c hostname");                                boundJob.AddTask(unboundTaskQuick);                          }                            System.Threading.Thread.Sleep(5000);                            // wait for fast tasks to complete                          {                              bool repeat = true;                                while (repeat)                              {                                  CloudPool boundPool = batchCli.PoolOperations.GetPool(this.poolFixture.PoolId);                                    repeat = false;                                    foreach (CloudTask curTask in boundJob.ListTasks())                                  {                                      if (curTask.State != Microsoft.Azure.Batch.Common.TaskState.Completed)                                      {                                          repeat = true;                                            this.testOutputHelper.WriteLine("Manual Wait Task Id: " + curTask.Id + "' state = " + curTask.State);                                          this.testOutputHelper.WriteLine("   poolstate: " + boundPool.State + "' currentdedicated: " + boundPool.CurrentDedicatedComputeNodes);                                          this.testOutputHelper.WriteLine("      compute nodes:");                                            foreach (ComputeNode curComputeNode in boundPool.ListComputeNodes())                                          {                                              this.testOutputHelper.WriteLine("           computeNode.Id: " + curComputeNode.Id + "' state: " + curComputeNode.State);                                          }                                      }                                  }                              }                          }                            // add some longer running tasks                            this.testOutputHelper.WriteLine("Adding longer running tasks");                            for (int i = 0; i < 15; i++)                          {                              CloudTask unboundTask = new CloudTask(i.ToString() + "_a234567890a234567890a234567890a234567890a234567890a234567890"' "cmd /c ping 127.0.0.1 -n 4");                                boundJob.AddTask(unboundTask);                          }                            Utilities utilities = batchCli.Utilities;                          TaskStateMonitor tsm = utilities.CreateTaskStateMonitor();                            IPagedEnumerable<CloudTask> taskList = boundJob.ListTasks();                          ODATAMonitorControl odmc = new ODATAMonitorControl();                            // try to set really low delay                          odmc.DelayBetweenDataFetch = new TimeSpan(0);                            // confirm the floor is enforced                          Assert.Equal(500' odmc.DelayBetweenDataFetch.Milliseconds);                            this.testOutputHelper.WriteLine("Calling TaskStateMonitor.WaitAll().  This will take a while.");                            TimeSpan timeToWait = TimeSpan.FromMinutes(5);                          Task whenAll = tsm.WhenAll(taskList' Microsoft.Azure.Batch.Common.TaskState.Completed' timeToWait' controlParams: odmc);                            //This could throw' if it does the test will fail' which is what we want                          whenAll.Wait();                            foreach (CloudTask curTask in boundJob.ListTasks())                          {                              Assert.Equal(TaskState.Completed' curTask.State);                          }                      }                      finally                      {                          // cleanup                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Bug1665834TaskStateMonitor,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug1665834Job-" + TestUtilities.GetMyName();                        try                      {                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          unboundJob.PoolInformation.PoolId = this.poolFixture.PoolId;                          unboundJob.Commit();                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            // add some noise tasks                          for (int j = 0; j < 5; j++)                          {                              CloudTask unboundTaskQuick = new CloudTask((10 + j).ToString()' "cmd /c hostname");                                boundJob.AddTask(unboundTaskQuick);                          }                            System.Threading.Thread.Sleep(5000);                            // wait for fast tasks to complete                          {                              bool repeat = true;                                while (repeat)                              {                                  CloudPool boundPool = batchCli.PoolOperations.GetPool(this.poolFixture.PoolId);                                    repeat = false;                                    foreach (CloudTask curTask in boundJob.ListTasks())                                  {                                      if (curTask.State != Microsoft.Azure.Batch.Common.TaskState.Completed)                                      {                                          repeat = true;                                            this.testOutputHelper.WriteLine("Manual Wait Task Id: " + curTask.Id + "' state = " + curTask.State);                                          this.testOutputHelper.WriteLine("   poolstate: " + boundPool.State + "' currentdedicated: " + boundPool.CurrentDedicatedComputeNodes);                                          this.testOutputHelper.WriteLine("      compute nodes:");                                            foreach (ComputeNode curComputeNode in boundPool.ListComputeNodes())                                          {                                              this.testOutputHelper.WriteLine("           computeNode.Id: " + curComputeNode.Id + "' state: " + curComputeNode.State);                                          }                                      }                                  }                              }                          }                            // add some longer running tasks                            this.testOutputHelper.WriteLine("Adding longer running tasks");                            for (int i = 0; i < 15; i++)                          {                              CloudTask unboundTask = new CloudTask(i.ToString() + "_a234567890a234567890a234567890a234567890a234567890a234567890"' "cmd /c ping 127.0.0.1 -n 4");                                boundJob.AddTask(unboundTask);                          }                            Utilities utilities = batchCli.Utilities;                          TaskStateMonitor tsm = utilities.CreateTaskStateMonitor();                            IPagedEnumerable<CloudTask> taskList = boundJob.ListTasks();                          ODATAMonitorControl odmc = new ODATAMonitorControl();                            // try to set really low delay                          odmc.DelayBetweenDataFetch = new TimeSpan(0);                            // confirm the floor is enforced                          Assert.Equal(500' odmc.DelayBetweenDataFetch.Milliseconds);                            this.testOutputHelper.WriteLine("Calling TaskStateMonitor.WaitAll().  This will take a while.");                            TimeSpan timeToWait = TimeSpan.FromMinutes(5);                          Task whenAll = tsm.WhenAll(taskList' Microsoft.Azure.Batch.Common.TaskState.Completed' timeToWait' controlParams: odmc);                            //This could throw' if it does the test will fail' which is what we want                          whenAll.Wait();                            foreach (CloudTask curTask in boundJob.ListTasks())                          {                              Assert.Equal(TaskState.Completed' curTask.State);                          }                      }                      finally                      {                          // cleanup                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Bug1665834TaskStateMonitor,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug1665834Job-" + TestUtilities.GetMyName();                        try                      {                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          unboundJob.PoolInformation.PoolId = this.poolFixture.PoolId;                          unboundJob.Commit();                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            // add some noise tasks                          for (int j = 0; j < 5; j++)                          {                              CloudTask unboundTaskQuick = new CloudTask((10 + j).ToString()' "cmd /c hostname");                                boundJob.AddTask(unboundTaskQuick);                          }                            System.Threading.Thread.Sleep(5000);                            // wait for fast tasks to complete                          {                              bool repeat = true;                                while (repeat)                              {                                  CloudPool boundPool = batchCli.PoolOperations.GetPool(this.poolFixture.PoolId);                                    repeat = false;                                    foreach (CloudTask curTask in boundJob.ListTasks())                                  {                                      if (curTask.State != Microsoft.Azure.Batch.Common.TaskState.Completed)                                      {                                          repeat = true;                                            this.testOutputHelper.WriteLine("Manual Wait Task Id: " + curTask.Id + "' state = " + curTask.State);                                          this.testOutputHelper.WriteLine("   poolstate: " + boundPool.State + "' currentdedicated: " + boundPool.CurrentDedicatedComputeNodes);                                          this.testOutputHelper.WriteLine("      compute nodes:");                                            foreach (ComputeNode curComputeNode in boundPool.ListComputeNodes())                                          {                                              this.testOutputHelper.WriteLine("           computeNode.Id: " + curComputeNode.Id + "' state: " + curComputeNode.State);                                          }                                      }                                  }                              }                          }                            // add some longer running tasks                            this.testOutputHelper.WriteLine("Adding longer running tasks");                            for (int i = 0; i < 15; i++)                          {                              CloudTask unboundTask = new CloudTask(i.ToString() + "_a234567890a234567890a234567890a234567890a234567890a234567890"' "cmd /c ping 127.0.0.1 -n 4");                                boundJob.AddTask(unboundTask);                          }                            Utilities utilities = batchCli.Utilities;                          TaskStateMonitor tsm = utilities.CreateTaskStateMonitor();                            IPagedEnumerable<CloudTask> taskList = boundJob.ListTasks();                          ODATAMonitorControl odmc = new ODATAMonitorControl();                            // try to set really low delay                          odmc.DelayBetweenDataFetch = new TimeSpan(0);                            // confirm the floor is enforced                          Assert.Equal(500' odmc.DelayBetweenDataFetch.Milliseconds);                            this.testOutputHelper.WriteLine("Calling TaskStateMonitor.WaitAll().  This will take a while.");                            TimeSpan timeToWait = TimeSpan.FromMinutes(5);                          Task whenAll = tsm.WhenAll(taskList' Microsoft.Azure.Batch.Common.TaskState.Completed' timeToWait' controlParams: odmc);                            //This could throw' if it does the test will fail' which is what we want                          whenAll.Wait();                            foreach (CloudTask curTask in boundJob.ListTasks())                          {                              Assert.Equal(TaskState.Completed' curTask.State);                          }                      }                      finally                      {                          // cleanup                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Bug1665834TaskStateMonitor,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug1665834Job-" + TestUtilities.GetMyName();                        try                      {                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          unboundJob.PoolInformation.PoolId = this.poolFixture.PoolId;                          unboundJob.Commit();                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            // add some noise tasks                          for (int j = 0; j < 5; j++)                          {                              CloudTask unboundTaskQuick = new CloudTask((10 + j).ToString()' "cmd /c hostname");                                boundJob.AddTask(unboundTaskQuick);                          }                            System.Threading.Thread.Sleep(5000);                            // wait for fast tasks to complete                          {                              bool repeat = true;                                while (repeat)                              {                                  CloudPool boundPool = batchCli.PoolOperations.GetPool(this.poolFixture.PoolId);                                    repeat = false;                                    foreach (CloudTask curTask in boundJob.ListTasks())                                  {                                      if (curTask.State != Microsoft.Azure.Batch.Common.TaskState.Completed)                                      {                                          repeat = true;                                            this.testOutputHelper.WriteLine("Manual Wait Task Id: " + curTask.Id + "' state = " + curTask.State);                                          this.testOutputHelper.WriteLine("   poolstate: " + boundPool.State + "' currentdedicated: " + boundPool.CurrentDedicatedComputeNodes);                                          this.testOutputHelper.WriteLine("      compute nodes:");                                            foreach (ComputeNode curComputeNode in boundPool.ListComputeNodes())                                          {                                              this.testOutputHelper.WriteLine("           computeNode.Id: " + curComputeNode.Id + "' state: " + curComputeNode.State);                                          }                                      }                                  }                              }                          }                            // add some longer running tasks                            this.testOutputHelper.WriteLine("Adding longer running tasks");                            for (int i = 0; i < 15; i++)                          {                              CloudTask unboundTask = new CloudTask(i.ToString() + "_a234567890a234567890a234567890a234567890a234567890a234567890"' "cmd /c ping 127.0.0.1 -n 4");                                boundJob.AddTask(unboundTask);                          }                            Utilities utilities = batchCli.Utilities;                          TaskStateMonitor tsm = utilities.CreateTaskStateMonitor();                            IPagedEnumerable<CloudTask> taskList = boundJob.ListTasks();                          ODATAMonitorControl odmc = new ODATAMonitorControl();                            // try to set really low delay                          odmc.DelayBetweenDataFetch = new TimeSpan(0);                            // confirm the floor is enforced                          Assert.Equal(500' odmc.DelayBetweenDataFetch.Milliseconds);                            this.testOutputHelper.WriteLine("Calling TaskStateMonitor.WaitAll().  This will take a while.");                            TimeSpan timeToWait = TimeSpan.FromMinutes(5);                          Task whenAll = tsm.WhenAll(taskList' Microsoft.Azure.Batch.Common.TaskState.Completed' timeToWait' controlParams: odmc);                            //This could throw' if it does the test will fail' which is what we want                          whenAll.Wait();                            foreach (CloudTask curTask in boundJob.ListTasks())                          {                              Assert.Equal(TaskState.Completed' curTask.State);                          }                      }                      finally                      {                          // cleanup                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Bug1665834TaskStateMonitor,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug1665834Job-" + TestUtilities.GetMyName();                        try                      {                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          unboundJob.PoolInformation.PoolId = this.poolFixture.PoolId;                          unboundJob.Commit();                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            // add some noise tasks                          for (int j = 0; j < 5; j++)                          {                              CloudTask unboundTaskQuick = new CloudTask((10 + j).ToString()' "cmd /c hostname");                                boundJob.AddTask(unboundTaskQuick);                          }                            System.Threading.Thread.Sleep(5000);                            // wait for fast tasks to complete                          {                              bool repeat = true;                                while (repeat)                              {                                  CloudPool boundPool = batchCli.PoolOperations.GetPool(this.poolFixture.PoolId);                                    repeat = false;                                    foreach (CloudTask curTask in boundJob.ListTasks())                                  {                                      if (curTask.State != Microsoft.Azure.Batch.Common.TaskState.Completed)                                      {                                          repeat = true;                                            this.testOutputHelper.WriteLine("Manual Wait Task Id: " + curTask.Id + "' state = " + curTask.State);                                          this.testOutputHelper.WriteLine("   poolstate: " + boundPool.State + "' currentdedicated: " + boundPool.CurrentDedicatedComputeNodes);                                          this.testOutputHelper.WriteLine("      compute nodes:");                                            foreach (ComputeNode curComputeNode in boundPool.ListComputeNodes())                                          {                                              this.testOutputHelper.WriteLine("           computeNode.Id: " + curComputeNode.Id + "' state: " + curComputeNode.State);                                          }                                      }                                  }                              }                          }                            // add some longer running tasks                            this.testOutputHelper.WriteLine("Adding longer running tasks");                            for (int i = 0; i < 15; i++)                          {                              CloudTask unboundTask = new CloudTask(i.ToString() + "_a234567890a234567890a234567890a234567890a234567890a234567890"' "cmd /c ping 127.0.0.1 -n 4");                                boundJob.AddTask(unboundTask);                          }                            Utilities utilities = batchCli.Utilities;                          TaskStateMonitor tsm = utilities.CreateTaskStateMonitor();                            IPagedEnumerable<CloudTask> taskList = boundJob.ListTasks();                          ODATAMonitorControl odmc = new ODATAMonitorControl();                            // try to set really low delay                          odmc.DelayBetweenDataFetch = new TimeSpan(0);                            // confirm the floor is enforced                          Assert.Equal(500' odmc.DelayBetweenDataFetch.Milliseconds);                            this.testOutputHelper.WriteLine("Calling TaskStateMonitor.WaitAll().  This will take a while.");                            TimeSpan timeToWait = TimeSpan.FromMinutes(5);                          Task whenAll = tsm.WhenAll(taskList' Microsoft.Azure.Batch.Common.TaskState.Completed' timeToWait' controlParams: odmc);                            //This could throw' if it does the test will fail' which is what we want                          whenAll.Wait();                            foreach (CloudTask curTask in boundJob.ListTasks())                          {                              Assert.Equal(TaskState.Completed' curTask.State);                          }                      }                      finally                      {                          // cleanup                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Bug1665834TaskStateMonitor,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug1665834Job-" + TestUtilities.GetMyName();                        try                      {                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          unboundJob.PoolInformation.PoolId = this.poolFixture.PoolId;                          unboundJob.Commit();                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            // add some noise tasks                          for (int j = 0; j < 5; j++)                          {                              CloudTask unboundTaskQuick = new CloudTask((10 + j).ToString()' "cmd /c hostname");                                boundJob.AddTask(unboundTaskQuick);                          }                            System.Threading.Thread.Sleep(5000);                            // wait for fast tasks to complete                          {                              bool repeat = true;                                while (repeat)                              {                                  CloudPool boundPool = batchCli.PoolOperations.GetPool(this.poolFixture.PoolId);                                    repeat = false;                                    foreach (CloudTask curTask in boundJob.ListTasks())                                  {                                      if (curTask.State != Microsoft.Azure.Batch.Common.TaskState.Completed)                                      {                                          repeat = true;                                            this.testOutputHelper.WriteLine("Manual Wait Task Id: " + curTask.Id + "' state = " + curTask.State);                                          this.testOutputHelper.WriteLine("   poolstate: " + boundPool.State + "' currentdedicated: " + boundPool.CurrentDedicatedComputeNodes);                                          this.testOutputHelper.WriteLine("      compute nodes:");                                            foreach (ComputeNode curComputeNode in boundPool.ListComputeNodes())                                          {                                              this.testOutputHelper.WriteLine("           computeNode.Id: " + curComputeNode.Id + "' state: " + curComputeNode.State);                                          }                                      }                                  }                              }                          }                            // add some longer running tasks                            this.testOutputHelper.WriteLine("Adding longer running tasks");                            for (int i = 0; i < 15; i++)                          {                              CloudTask unboundTask = new CloudTask(i.ToString() + "_a234567890a234567890a234567890a234567890a234567890a234567890"' "cmd /c ping 127.0.0.1 -n 4");                                boundJob.AddTask(unboundTask);                          }                            Utilities utilities = batchCli.Utilities;                          TaskStateMonitor tsm = utilities.CreateTaskStateMonitor();                            IPagedEnumerable<CloudTask> taskList = boundJob.ListTasks();                          ODATAMonitorControl odmc = new ODATAMonitorControl();                            // try to set really low delay                          odmc.DelayBetweenDataFetch = new TimeSpan(0);                            // confirm the floor is enforced                          Assert.Equal(500' odmc.DelayBetweenDataFetch.Milliseconds);                            this.testOutputHelper.WriteLine("Calling TaskStateMonitor.WaitAll().  This will take a while.");                            TimeSpan timeToWait = TimeSpan.FromMinutes(5);                          Task whenAll = tsm.WhenAll(taskList' Microsoft.Azure.Batch.Common.TaskState.Completed' timeToWait' controlParams: odmc);                            //This could throw' if it does the test will fail' which is what we want                          whenAll.Wait();                            foreach (CloudTask curTask in boundJob.ListTasks())                          {                              Assert.Equal(TaskState.Completed' curTask.State);                          }                      }                      finally                      {                          // cleanup                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,TestBoundJobVerbs,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      //Create a job                        string jobId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestBoundJobVerbs";                        try                      {                          CloudJob cloudJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          cloudJob.PoolInformation = new PoolInformation()                          {                              PoolId = this.poolFixture.PoolId                          };                          cloudJob.Commit();                            //Get the bound job                          CloudJob job = batchCli.JobOperations.GetJob(jobId);                            //Disable the job (via instance)                          job.Disable(DisableJobOption.Terminate);                            //Check the job state                            CloudJob disabledJob = batchCli.JobOperations.GetJob(jobId);                          this.testOutputHelper.WriteLine("DisabledJob State: {0}"' disabledJob.State);                          Assert.True(disabledJob.State == JobState.Disabled || disabledJob.State == JobState.Disabling);                            //Enable the job (via instance)                          job.Enable();                            //Check the job state                          CloudJob enabledJob = batchCli.JobOperations.GetJob(jobId);                          this.testOutputHelper.WriteLine("EnabledJob state: {0}"' enabledJob.State);                          Assert.Equal(JobState.Active' JobState.Active);                            //Disable the job (via operations)                          batchCli.JobOperations.DisableJob(jobId' DisableJobOption.Terminate);                            disabledJob = batchCli.JobOperations.GetJob(jobId);                          this.testOutputHelper.WriteLine("DisabledJob State: {0}"' disabledJob.State);                          Assert.True(disabledJob.State == JobState.Disabled || disabledJob.State == JobState.Disabling);                            //Enable the job (via operations)                          batchCli.JobOperations.EnableJob(jobId);                            //Check the job state                          enabledJob = batchCli.JobOperations.GetJob(jobId);                          this.testOutputHelper.WriteLine("EnabledJob state: {0}"' enabledJob.State);                          Assert.Equal(JobState.Active' JobState.Active);                            //Terminate the job                          job.Terminate("need some reason");                            //Check the job state                          CloudJob terminatedJob = batchCli.JobOperations.GetJob(jobId);                          this.testOutputHelper.WriteLine("TerminatedJob state: {0}"' terminatedJob.State);                          Assert.True(terminatedJob.State == JobState.Terminating || terminatedJob.State == JobState.Completed);                            if (terminatedJob.State == JobState.Terminating)                          {                              Thread.Sleep(TimeSpan.FromSeconds(5)); //Sleep and wait for the job to finish terminating before we issue a delete                          }                            //Delete the job                          job.Delete();                            //Check that the job doesn't exist anymore                            try                          {                              this.testOutputHelper.WriteLine("Expected Exception: testing that job does NOT exist.");                                CloudJob deletedJob = batchCli.JobOperations.GetJob(jobId);                              Assert.Equal(JobState.Deleting' deletedJob.State);                          }                          catch (Exception e)                          {                              Assert.IsAssignableFrom<BatchException>(e);                              BatchException be = e as BatchException;                              Assert.NotNull(be.RequestInformation);                              Assert.NotNull(be.RequestInformation.BatchError);                              Assert.Equal(BatchErrorCodeStrings.JobNotFound' be.RequestInformation.BatchError.Code);                                this.testOutputHelper.WriteLine("Job was deleted successfully");                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Bug1433069TestBoundJobCommit,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestBoundJobCommit";                      try                      {                          //                          // Create the job                          //                          CloudJob cloudJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          cloudJob.PoolInformation = new PoolInformation()                          {                              PoolId = this.poolFixture.PoolId                          };                            this.testOutputHelper.WriteLine("Initial job schedule commit()");                          cloudJob.Commit();                            //Get the job                          CloudJob refreshableJob = batchCli.JobOperations.GetJob(jobId);                            //Update the bound job priority                          const int newJobPriority = 5;                          OnAllTasksComplete newOnAllTasksComplete = OnAllTasksComplete.NoAction;                            this.testOutputHelper.WriteLine("Job priority is: {0}"' refreshableJob.Priority);                          refreshableJob.Priority = newJobPriority;                          refreshableJob.OnAllTasksComplete = newOnAllTasksComplete;                          refreshableJob.Commit();                            AssertJobCorrectness(batchCli.JobOperations' jobId' ref refreshableJob' this.poolFixture.PoolId' newJobPriority' null);                            //Update the bound job pool name                          //Must disable the job first before updating its pool                          refreshableJob.Disable(DisableJobOption.Terminate);                            //Wait for job to reach disabled state (could go to Disabling for a bit)                          //TODO: Use a uBtilities wait helper here                          DateTime jobDisabledStateWaitStartTime = DateTime.UtcNow;                          TimeSpan jobDisabledTimeout = TimeSpan.FromSeconds(120);                          while (refreshableJob.State != JobState.Disabled)                          {                              this.testOutputHelper.WriteLine("Bug1433069TestBoundJobCommit: sleeping for (refreshableJob.State != JobState.Disabled)");                              Thread.Sleep(TimeSpan.FromSeconds(10));                              refreshableJob = batchCli.JobOperations.GetJob(jobId);                                if (DateTime.UtcNow > jobDisabledStateWaitStartTime.Add(jobDisabledTimeout))                              {                                  Assert.False(true' "Timed out waiting for job to go to disabled state");                              }                          }                            const string newPoolId = "testPool";                          refreshableJob.PoolInformation.PoolId = newPoolId;                          refreshableJob.Commit();                            AssertJobCorrectness(batchCli.JobOperations' jobId' ref refreshableJob' newPoolId' newJobPriority' null);                            //Enable the job again                          refreshableJob.Enable();                            //Update the bound job constraints                          JobConstraints newJobConstraints = new JobConstraints(TimeSpan.FromSeconds(200)' 19);                          refreshableJob.Constraints = newJobConstraints;                          refreshableJob.Commit();                            AssertJobCorrectness(batchCli.JobOperations' jobId' ref refreshableJob' newPoolId' newJobPriority' newJobConstraints);                      }                      finally                      {                          batchCli.JobOperations.DeleteJob(jobId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Bug1433069TestBoundJobCommit,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestBoundJobCommit";                      try                      {                          //                          // Create the job                          //                          CloudJob cloudJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          cloudJob.PoolInformation = new PoolInformation()                          {                              PoolId = this.poolFixture.PoolId                          };                            this.testOutputHelper.WriteLine("Initial job schedule commit()");                          cloudJob.Commit();                            //Get the job                          CloudJob refreshableJob = batchCli.JobOperations.GetJob(jobId);                            //Update the bound job priority                          const int newJobPriority = 5;                          OnAllTasksComplete newOnAllTasksComplete = OnAllTasksComplete.NoAction;                            this.testOutputHelper.WriteLine("Job priority is: {0}"' refreshableJob.Priority);                          refreshableJob.Priority = newJobPriority;                          refreshableJob.OnAllTasksComplete = newOnAllTasksComplete;                          refreshableJob.Commit();                            AssertJobCorrectness(batchCli.JobOperations' jobId' ref refreshableJob' this.poolFixture.PoolId' newJobPriority' null);                            //Update the bound job pool name                          //Must disable the job first before updating its pool                          refreshableJob.Disable(DisableJobOption.Terminate);                            //Wait for job to reach disabled state (could go to Disabling for a bit)                          //TODO: Use a uBtilities wait helper here                          DateTime jobDisabledStateWaitStartTime = DateTime.UtcNow;                          TimeSpan jobDisabledTimeout = TimeSpan.FromSeconds(120);                          while (refreshableJob.State != JobState.Disabled)                          {                              this.testOutputHelper.WriteLine("Bug1433069TestBoundJobCommit: sleeping for (refreshableJob.State != JobState.Disabled)");                              Thread.Sleep(TimeSpan.FromSeconds(10));                              refreshableJob = batchCli.JobOperations.GetJob(jobId);                                if (DateTime.UtcNow > jobDisabledStateWaitStartTime.Add(jobDisabledTimeout))                              {                                  Assert.False(true' "Timed out waiting for job to go to disabled state");                              }                          }                            const string newPoolId = "testPool";                          refreshableJob.PoolInformation.PoolId = newPoolId;                          refreshableJob.Commit();                            AssertJobCorrectness(batchCli.JobOperations' jobId' ref refreshableJob' newPoolId' newJobPriority' null);                            //Enable the job again                          refreshableJob.Enable();                            //Update the bound job constraints                          JobConstraints newJobConstraints = new JobConstraints(TimeSpan.FromSeconds(200)' 19);                          refreshableJob.Constraints = newJobConstraints;                          refreshableJob.Commit();                            AssertJobCorrectness(batchCli.JobOperations' jobId' ref refreshableJob' newPoolId' newJobPriority' newJobConstraints);                      }                      finally                      {                          batchCli.JobOperations.DeleteJob(jobId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Bug1433069TestBoundJobCommit,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestBoundJobCommit";                      try                      {                          //                          // Create the job                          //                          CloudJob cloudJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          cloudJob.PoolInformation = new PoolInformation()                          {                              PoolId = this.poolFixture.PoolId                          };                            this.testOutputHelper.WriteLine("Initial job schedule commit()");                          cloudJob.Commit();                            //Get the job                          CloudJob refreshableJob = batchCli.JobOperations.GetJob(jobId);                            //Update the bound job priority                          const int newJobPriority = 5;                          OnAllTasksComplete newOnAllTasksComplete = OnAllTasksComplete.NoAction;                            this.testOutputHelper.WriteLine("Job priority is: {0}"' refreshableJob.Priority);                          refreshableJob.Priority = newJobPriority;                          refreshableJob.OnAllTasksComplete = newOnAllTasksComplete;                          refreshableJob.Commit();                            AssertJobCorrectness(batchCli.JobOperations' jobId' ref refreshableJob' this.poolFixture.PoolId' newJobPriority' null);                            //Update the bound job pool name                          //Must disable the job first before updating its pool                          refreshableJob.Disable(DisableJobOption.Terminate);                            //Wait for job to reach disabled state (could go to Disabling for a bit)                          //TODO: Use a uBtilities wait helper here                          DateTime jobDisabledStateWaitStartTime = DateTime.UtcNow;                          TimeSpan jobDisabledTimeout = TimeSpan.FromSeconds(120);                          while (refreshableJob.State != JobState.Disabled)                          {                              this.testOutputHelper.WriteLine("Bug1433069TestBoundJobCommit: sleeping for (refreshableJob.State != JobState.Disabled)");                              Thread.Sleep(TimeSpan.FromSeconds(10));                              refreshableJob = batchCli.JobOperations.GetJob(jobId);                                if (DateTime.UtcNow > jobDisabledStateWaitStartTime.Add(jobDisabledTimeout))                              {                                  Assert.False(true' "Timed out waiting for job to go to disabled state");                              }                          }                            const string newPoolId = "testPool";                          refreshableJob.PoolInformation.PoolId = newPoolId;                          refreshableJob.Commit();                            AssertJobCorrectness(batchCli.JobOperations' jobId' ref refreshableJob' newPoolId' newJobPriority' null);                            //Enable the job again                          refreshableJob.Enable();                            //Update the bound job constraints                          JobConstraints newJobConstraints = new JobConstraints(TimeSpan.FromSeconds(200)' 19);                          refreshableJob.Constraints = newJobConstraints;                          refreshableJob.Commit();                            AssertJobCorrectness(batchCli.JobOperations' jobId' ref refreshableJob' newPoolId' newJobPriority' newJobConstraints);                      }                      finally                      {                          batchCli.JobOperations.DeleteJob(jobId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Bug1433069TestBoundJobCommit,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestBoundJobCommit";                      try                      {                          //                          // Create the job                          //                          CloudJob cloudJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          cloudJob.PoolInformation = new PoolInformation()                          {                              PoolId = this.poolFixture.PoolId                          };                            this.testOutputHelper.WriteLine("Initial job schedule commit()");                          cloudJob.Commit();                            //Get the job                          CloudJob refreshableJob = batchCli.JobOperations.GetJob(jobId);                            //Update the bound job priority                          const int newJobPriority = 5;                          OnAllTasksComplete newOnAllTasksComplete = OnAllTasksComplete.NoAction;                            this.testOutputHelper.WriteLine("Job priority is: {0}"' refreshableJob.Priority);                          refreshableJob.Priority = newJobPriority;                          refreshableJob.OnAllTasksComplete = newOnAllTasksComplete;                          refreshableJob.Commit();                            AssertJobCorrectness(batchCli.JobOperations' jobId' ref refreshableJob' this.poolFixture.PoolId' newJobPriority' null);                            //Update the bound job pool name                          //Must disable the job first before updating its pool                          refreshableJob.Disable(DisableJobOption.Terminate);                            //Wait for job to reach disabled state (could go to Disabling for a bit)                          //TODO: Use a uBtilities wait helper here                          DateTime jobDisabledStateWaitStartTime = DateTime.UtcNow;                          TimeSpan jobDisabledTimeout = TimeSpan.FromSeconds(120);                          while (refreshableJob.State != JobState.Disabled)                          {                              this.testOutputHelper.WriteLine("Bug1433069TestBoundJobCommit: sleeping for (refreshableJob.State != JobState.Disabled)");                              Thread.Sleep(TimeSpan.FromSeconds(10));                              refreshableJob = batchCli.JobOperations.GetJob(jobId);                                if (DateTime.UtcNow > jobDisabledStateWaitStartTime.Add(jobDisabledTimeout))                              {                                  Assert.False(true' "Timed out waiting for job to go to disabled state");                              }                          }                            const string newPoolId = "testPool";                          refreshableJob.PoolInformation.PoolId = newPoolId;                          refreshableJob.Commit();                            AssertJobCorrectness(batchCli.JobOperations' jobId' ref refreshableJob' newPoolId' newJobPriority' null);                            //Enable the job again                          refreshableJob.Enable();                            //Update the bound job constraints                          JobConstraints newJobConstraints = new JobConstraints(TimeSpan.FromSeconds(200)' 19);                          refreshableJob.Constraints = newJobConstraints;                          refreshableJob.Commit();                            AssertJobCorrectness(batchCli.JobOperations' jobId' ref refreshableJob' newPoolId' newJobPriority' newJobConstraints);                      }                      finally                      {                          batchCli.JobOperations.DeleteJob(jobId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Bug1433069TestBoundJobCommit,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestBoundJobCommit";                      try                      {                          //                          // Create the job                          //                          CloudJob cloudJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          cloudJob.PoolInformation = new PoolInformation()                          {                              PoolId = this.poolFixture.PoolId                          };                            this.testOutputHelper.WriteLine("Initial job schedule commit()");                          cloudJob.Commit();                            //Get the job                          CloudJob refreshableJob = batchCli.JobOperations.GetJob(jobId);                            //Update the bound job priority                          const int newJobPriority = 5;                          OnAllTasksComplete newOnAllTasksComplete = OnAllTasksComplete.NoAction;                            this.testOutputHelper.WriteLine("Job priority is: {0}"' refreshableJob.Priority);                          refreshableJob.Priority = newJobPriority;                          refreshableJob.OnAllTasksComplete = newOnAllTasksComplete;                          refreshableJob.Commit();                            AssertJobCorrectness(batchCli.JobOperations' jobId' ref refreshableJob' this.poolFixture.PoolId' newJobPriority' null);                            //Update the bound job pool name                          //Must disable the job first before updating its pool                          refreshableJob.Disable(DisableJobOption.Terminate);                            //Wait for job to reach disabled state (could go to Disabling for a bit)                          //TODO: Use a uBtilities wait helper here                          DateTime jobDisabledStateWaitStartTime = DateTime.UtcNow;                          TimeSpan jobDisabledTimeout = TimeSpan.FromSeconds(120);                          while (refreshableJob.State != JobState.Disabled)                          {                              this.testOutputHelper.WriteLine("Bug1433069TestBoundJobCommit: sleeping for (refreshableJob.State != JobState.Disabled)");                              Thread.Sleep(TimeSpan.FromSeconds(10));                              refreshableJob = batchCli.JobOperations.GetJob(jobId);                                if (DateTime.UtcNow > jobDisabledStateWaitStartTime.Add(jobDisabledTimeout))                              {                                  Assert.False(true' "Timed out waiting for job to go to disabled state");                              }                          }                            const string newPoolId = "testPool";                          refreshableJob.PoolInformation.PoolId = newPoolId;                          refreshableJob.Commit();                            AssertJobCorrectness(batchCli.JobOperations' jobId' ref refreshableJob' newPoolId' newJobPriority' null);                            //Enable the job again                          refreshableJob.Enable();                            //Update the bound job constraints                          JobConstraints newJobConstraints = new JobConstraints(TimeSpan.FromSeconds(200)' 19);                          refreshableJob.Constraints = newJobConstraints;                          refreshableJob.Commit();                            AssertJobCorrectness(batchCli.JobOperations' jobId' ref refreshableJob' newPoolId' newJobPriority' newJobConstraints);                      }                      finally                      {                          batchCli.JobOperations.DeleteJob(jobId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Bug1996130_JobTaskVerbsFailAfterDoubleRefresh,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug1996130Job-" + TestUtilities.GetMyName();                        try                      {                          // get a job/task to test. use workflow                          CloudJob boundJob = null;                          {                              // need a bound job/task for the tests so set one up                              CloudJob tsh = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                              tsh.PoolInformation.PoolId = this.poolFixture.PoolId;                              tsh.Commit();                                boundJob = batchCli.JobOperations.GetJob(jobId);                                boundJob.AddTask(new CloudTask("Bug1996130_task"' "cmd /c hostname"));                          }                            // test task double refresh                          {                              // get the task                              CloudTask boundTask = batchCli.JobOperations.ListTasks(jobId).First();                                // double refresh                              boundTask.Refresh();                              boundTask.Refresh(); // this branch of the bug actually fixed in the other doublerefesh checkin by matthchr                                // do verbs                              boundTask.Refresh();                              boundTask.Delete();                                Thread.Sleep(5000);  // give server time to do its deed                                List<CloudTask> tasks = batchCli.JobOperations.ListTasks(jobId).ToList();                                // confirm delete suceeded                              Assert.Empty(tasks);                          }                            // test job double refresh and verbs                          {                              boundJob = batchCli.JobOperations.GetJob(jobId);                                // double refresh to taint the instance... lost path variable                              boundJob.Refresh();                              boundJob.Refresh();  // this used to fail/throw                                boundJob.Refresh();  // this should fail but does not                              boundJob.Delete();   // yet another verb that suceeds                                CloudJob job = batchCli.JobOperations.ListJobs().ToList().FirstOrDefault(j => j.Id == jobId);                                // confirm job delete suceeded                              Assert.True(job == null || (JobState.Deleting == job.State));                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }                };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,TestJobCompletesWhenAllItsTasksComplete,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      //Create a job                      string jobId = Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestJobCompletesWhenAllItsTasksComplete";                      string taskIdPrefix = "task-id";                        try                      {                          CloudJob boundJob = CreateBoundJob(client' jobId);                            var cloudTasks = new List<CloudTask>();                          for (var i = 0; i < 4; i++)                          {                              cloudTasks.Add(new CloudTask(taskIdPrefix + "-" + i' "cmd /c ping 127.0.0.1"));                          }                            boundJob.AddTask(cloudTasks);                            boundJob.OnAllTasksComplete = OnAllTasksComplete.TerminateJob;                          boundJob.Commit();                            boundJob.Refresh();                            TestUtilities.WaitForJobStateAsync(boundJob' TimeSpan.FromMinutes(2)' JobState.Completed).Wait();                            Assert.Equal(JobState.Completed' boundJob.State);                          Assert.Equal("AllTasksCompleted"' boundJob.ExecutionInformation.TerminateReason);                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(client' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,TestJobCompletesWhenAllItsTasksComplete,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      //Create a job                      string jobId = Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestJobCompletesWhenAllItsTasksComplete";                      string taskIdPrefix = "task-id";                        try                      {                          CloudJob boundJob = CreateBoundJob(client' jobId);                            var cloudTasks = new List<CloudTask>();                          for (var i = 0; i < 4; i++)                          {                              cloudTasks.Add(new CloudTask(taskIdPrefix + "-" + i' "cmd /c ping 127.0.0.1"));                          }                            boundJob.AddTask(cloudTasks);                            boundJob.OnAllTasksComplete = OnAllTasksComplete.TerminateJob;                          boundJob.Commit();                            boundJob.Refresh();                            TestUtilities.WaitForJobStateAsync(boundJob' TimeSpan.FromMinutes(2)' JobState.Completed).Wait();                            Assert.Equal(JobState.Completed' boundJob.State);                          Assert.Equal("AllTasksCompleted"' boundJob.ExecutionInformation.TerminateReason);                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(client' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,IfJobSetsOnTaskFailed_JobCompletesWhenAnyTaskFails,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      //Create a job                      string jobId = Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-IfJobSetsOnTaskFailedJobCompletesWhenAnyTaskFail";                      string taskId = "task-id-1";                        try                      {                          CloudJob boundJob = null;                          {                              // need a bound job/task for the tests so set one up                              boundJob = CreateBoundJob(client' jobId' j => { j.OnTaskFailure = OnTaskFailure.PerformExitOptionsJobAction; });                                Assert.Equal(OnTaskFailure.PerformExitOptionsJobAction' boundJob.OnTaskFailure);                                CloudTask cloudTask = new CloudTask(taskId' "cmd /c exit 3");                                cloudTask.ExitConditions = new ExitConditions                              {                                  ExitCodeRanges = new List<ExitCodeRangeMapping>                                  {                                      new ExitCodeRangeMapping(2' 4' new ExitOptions { JobAction = JobAction.Terminate})                                  }                              };                                boundJob.AddTask(cloudTask);                              boundJob.Refresh();                                TestUtilities.WaitForJobStateAsync(boundJob' TimeSpan.FromMinutes(2)' JobState.Completed).Wait();                              Assert.Equal(JobState.Completed' boundJob.State);                              Assert.Equal("TaskFailed"' boundJob.ExecutionInformation.TerminateReason);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(client' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,IfJobSetsOnTaskFailed_JobCompletesWhenAnyTaskFails,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      //Create a job                      string jobId = Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-IfJobSetsOnTaskFailedJobCompletesWhenAnyTaskFail";                      string taskId = "task-id-1";                        try                      {                          CloudJob boundJob = null;                          {                              // need a bound job/task for the tests so set one up                              boundJob = CreateBoundJob(client' jobId' j => { j.OnTaskFailure = OnTaskFailure.PerformExitOptionsJobAction; });                                Assert.Equal(OnTaskFailure.PerformExitOptionsJobAction' boundJob.OnTaskFailure);                                CloudTask cloudTask = new CloudTask(taskId' "cmd /c exit 3");                                cloudTask.ExitConditions = new ExitConditions                              {                                  ExitCodeRanges = new List<ExitCodeRangeMapping>                                  {                                      new ExitCodeRangeMapping(2' 4' new ExitOptions { JobAction = JobAction.Terminate})                                  }                              };                                boundJob.AddTask(cloudTask);                              boundJob.Refresh();                                TestUtilities.WaitForJobStateAsync(boundJob' TimeSpan.FromMinutes(2)' JobState.Completed).Wait();                              Assert.Equal(JobState.Completed' boundJob.State);                              Assert.Equal("TaskFailed"' boundJob.ExecutionInformation.TerminateReason);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(client' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,IfJobSetsOnTaskFailed_JobCompletesWhenAnyTaskFails,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      //Create a job                      string jobId = Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-IfJobSetsOnTaskFailedJobCompletesWhenAnyTaskFail";                      string taskId = "task-id-1";                        try                      {                          CloudJob boundJob = null;                          {                              // need a bound job/task for the tests so set one up                              boundJob = CreateBoundJob(client' jobId' j => { j.OnTaskFailure = OnTaskFailure.PerformExitOptionsJobAction; });                                Assert.Equal(OnTaskFailure.PerformExitOptionsJobAction' boundJob.OnTaskFailure);                                CloudTask cloudTask = new CloudTask(taskId' "cmd /c exit 3");                                cloudTask.ExitConditions = new ExitConditions                              {                                  ExitCodeRanges = new List<ExitCodeRangeMapping>                                  {                                      new ExitCodeRangeMapping(2' 4' new ExitOptions { JobAction = JobAction.Terminate})                                  }                              };                                boundJob.AddTask(cloudTask);                              boundJob.Refresh();                                TestUtilities.WaitForJobStateAsync(boundJob' TimeSpan.FromMinutes(2)' JobState.Completed).Wait();                              Assert.Equal(JobState.Completed' boundJob.State);                              Assert.Equal("TaskFailed"' boundJob.ExecutionInformation.TerminateReason);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(client' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,TestExitConditionsAreBeingRoundTrippedCorrectly,The following statement contains a magic number: Action test = () =>               {                   using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      //Create a job                      string jobId = Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestExitConditionsAreBeingRoundTrippedCorrectly";                      string taskId = "task-id-1";                      try                      {                          CloudJob boundJob = null;                          {                              // need a bound job/task for the tests so set one up                              boundJob = CreateBoundJob(client' jobId' j => { j.OnTaskFailure = OnTaskFailure.PerformExitOptionsJobAction; });                              CloudTask cloudTask = new CloudTask(taskId' "cmd /c exit 2");                                cloudTask.ExitConditions = new ExitConditions                              {                                  ExitCodes = new List<ExitCodeMapping> { new ExitCodeMapping(1' new ExitOptions { JobAction = JobAction.None }) }'                                  ExitCodeRanges = new List<ExitCodeRangeMapping>                                  {                                      new ExitCodeRangeMapping(2' 4' new ExitOptions { JobAction = JobAction.Disable })                                  }'                                  PreProcessingError = new ExitOptions { JobAction = JobAction.Terminate }'                                  FileUploadError = new ExitOptions { JobAction = JobAction.Terminate }'                                  Default = new ExitOptions { JobAction = JobAction.Terminate }'                              };                                boundJob.AddTask(cloudTask);                              boundJob.Refresh();                                Assert.Equal(OnTaskFailure.PerformExitOptionsJobAction' boundJob.OnTaskFailure);                              CloudTask boundTask = client.JobOperations.GetTask(jobId' taskId);                                Assert.Equal(JobAction.None' boundTask.ExitConditions.ExitCodes.First().ExitOptions.JobAction);                              Assert.Equal(1' boundTask.ExitConditions.ExitCodes.First().Code);                                var exitCodeRangeMappings = boundTask.ExitConditions.ExitCodeRanges;                              Assert.Equal(2' exitCodeRangeMappings.First().Start);                              Assert.Equal(4' exitCodeRangeMappings.First().End);                              Assert.Equal(JobAction.Disable' exitCodeRangeMappings.First().ExitOptions.JobAction);                              Assert.Equal(JobAction.Terminate' boundTask.ExitConditions.PreProcessingError.JobAction);                              Assert.Equal(JobAction.Terminate' boundTask.ExitConditions.FileUploadError.JobAction);                              Assert.Equal(JobAction.Terminate' boundTask.ExitConditions.Default.JobAction);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(client' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,TestExitConditionsAreBeingRoundTrippedCorrectly,The following statement contains a magic number: Action test = () =>               {                   using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      //Create a job                      string jobId = Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestExitConditionsAreBeingRoundTrippedCorrectly";                      string taskId = "task-id-1";                      try                      {                          CloudJob boundJob = null;                          {                              // need a bound job/task for the tests so set one up                              boundJob = CreateBoundJob(client' jobId' j => { j.OnTaskFailure = OnTaskFailure.PerformExitOptionsJobAction; });                              CloudTask cloudTask = new CloudTask(taskId' "cmd /c exit 2");                                cloudTask.ExitConditions = new ExitConditions                              {                                  ExitCodes = new List<ExitCodeMapping> { new ExitCodeMapping(1' new ExitOptions { JobAction = JobAction.None }) }'                                  ExitCodeRanges = new List<ExitCodeRangeMapping>                                  {                                      new ExitCodeRangeMapping(2' 4' new ExitOptions { JobAction = JobAction.Disable })                                  }'                                  PreProcessingError = new ExitOptions { JobAction = JobAction.Terminate }'                                  FileUploadError = new ExitOptions { JobAction = JobAction.Terminate }'                                  Default = new ExitOptions { JobAction = JobAction.Terminate }'                              };                                boundJob.AddTask(cloudTask);                              boundJob.Refresh();                                Assert.Equal(OnTaskFailure.PerformExitOptionsJobAction' boundJob.OnTaskFailure);                              CloudTask boundTask = client.JobOperations.GetTask(jobId' taskId);                                Assert.Equal(JobAction.None' boundTask.ExitConditions.ExitCodes.First().ExitOptions.JobAction);                              Assert.Equal(1' boundTask.ExitConditions.ExitCodes.First().Code);                                var exitCodeRangeMappings = boundTask.ExitConditions.ExitCodeRanges;                              Assert.Equal(2' exitCodeRangeMappings.First().Start);                              Assert.Equal(4' exitCodeRangeMappings.First().End);                              Assert.Equal(JobAction.Disable' exitCodeRangeMappings.First().ExitOptions.JobAction);                              Assert.Equal(JobAction.Terminate' boundTask.ExitConditions.PreProcessingError.JobAction);                              Assert.Equal(JobAction.Terminate' boundTask.ExitConditions.FileUploadError.JobAction);                              Assert.Equal(JobAction.Terminate' boundTask.ExitConditions.Default.JobAction);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(client' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,TestExitConditionsAreBeingRoundTrippedCorrectly,The following statement contains a magic number: Action test = () =>               {                   using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      //Create a job                      string jobId = Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestExitConditionsAreBeingRoundTrippedCorrectly";                      string taskId = "task-id-1";                      try                      {                          CloudJob boundJob = null;                          {                              // need a bound job/task for the tests so set one up                              boundJob = CreateBoundJob(client' jobId' j => { j.OnTaskFailure = OnTaskFailure.PerformExitOptionsJobAction; });                              CloudTask cloudTask = new CloudTask(taskId' "cmd /c exit 2");                                cloudTask.ExitConditions = new ExitConditions                              {                                  ExitCodes = new List<ExitCodeMapping> { new ExitCodeMapping(1' new ExitOptions { JobAction = JobAction.None }) }'                                  ExitCodeRanges = new List<ExitCodeRangeMapping>                                  {                                      new ExitCodeRangeMapping(2' 4' new ExitOptions { JobAction = JobAction.Disable })                                  }'                                  PreProcessingError = new ExitOptions { JobAction = JobAction.Terminate }'                                  FileUploadError = new ExitOptions { JobAction = JobAction.Terminate }'                                  Default = new ExitOptions { JobAction = JobAction.Terminate }'                              };                                boundJob.AddTask(cloudTask);                              boundJob.Refresh();                                Assert.Equal(OnTaskFailure.PerformExitOptionsJobAction' boundJob.OnTaskFailure);                              CloudTask boundTask = client.JobOperations.GetTask(jobId' taskId);                                Assert.Equal(JobAction.None' boundTask.ExitConditions.ExitCodes.First().ExitOptions.JobAction);                              Assert.Equal(1' boundTask.ExitConditions.ExitCodes.First().Code);                                var exitCodeRangeMappings = boundTask.ExitConditions.ExitCodeRanges;                              Assert.Equal(2' exitCodeRangeMappings.First().Start);                              Assert.Equal(4' exitCodeRangeMappings.First().End);                              Assert.Equal(JobAction.Disable' exitCodeRangeMappings.First().ExitOptions.JobAction);                              Assert.Equal(JobAction.Terminate' boundTask.ExitConditions.PreProcessingError.JobAction);                              Assert.Equal(JobAction.Terminate' boundTask.ExitConditions.FileUploadError.JobAction);                              Assert.Equal(JobAction.Terminate' boundTask.ExitConditions.Default.JobAction);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(client' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,TestExitConditionsAreBeingRoundTrippedCorrectly,The following statement contains a magic number: Action test = () =>               {                   using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      //Create a job                      string jobId = Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestExitConditionsAreBeingRoundTrippedCorrectly";                      string taskId = "task-id-1";                      try                      {                          CloudJob boundJob = null;                          {                              // need a bound job/task for the tests so set one up                              boundJob = CreateBoundJob(client' jobId' j => { j.OnTaskFailure = OnTaskFailure.PerformExitOptionsJobAction; });                              CloudTask cloudTask = new CloudTask(taskId' "cmd /c exit 2");                                cloudTask.ExitConditions = new ExitConditions                              {                                  ExitCodes = new List<ExitCodeMapping> { new ExitCodeMapping(1' new ExitOptions { JobAction = JobAction.None }) }'                                  ExitCodeRanges = new List<ExitCodeRangeMapping>                                  {                                      new ExitCodeRangeMapping(2' 4' new ExitOptions { JobAction = JobAction.Disable })                                  }'                                  PreProcessingError = new ExitOptions { JobAction = JobAction.Terminate }'                                  FileUploadError = new ExitOptions { JobAction = JobAction.Terminate }'                                  Default = new ExitOptions { JobAction = JobAction.Terminate }'                              };                                boundJob.AddTask(cloudTask);                              boundJob.Refresh();                                Assert.Equal(OnTaskFailure.PerformExitOptionsJobAction' boundJob.OnTaskFailure);                              CloudTask boundTask = client.JobOperations.GetTask(jobId' taskId);                                Assert.Equal(JobAction.None' boundTask.ExitConditions.ExitCodes.First().ExitOptions.JobAction);                              Assert.Equal(1' boundTask.ExitConditions.ExitCodes.First().Code);                                var exitCodeRangeMappings = boundTask.ExitConditions.ExitCodeRanges;                              Assert.Equal(2' exitCodeRangeMappings.First().Start);                              Assert.Equal(4' exitCodeRangeMappings.First().End);                              Assert.Equal(JobAction.Disable' exitCodeRangeMappings.First().ExitOptions.JobAction);                              Assert.Equal(JobAction.Terminate' boundTask.ExitConditions.PreProcessingError.JobAction);                              Assert.Equal(JobAction.Terminate' boundTask.ExitConditions.FileUploadError.JobAction);                              Assert.Equal(JobAction.Terminate' boundTask.ExitConditions.Default.JobAction);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(client' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudJobTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,TestJobUpdateWithAndWithoutPoolInfo,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      const string testName = "TestJobUpdateWithAndWithoutPoolInfo";                        // Create a job                      string jobId = testName + "_" + TestUtilities.GetMyName();                      CloudJob unboundJob = batchCli.JobOperations.CreateJob();                      unboundJob.Id = jobId;                        // Use an auto pool with the job' since PoolInformation can't be updated otherwise.                      PoolSpecification poolSpec = new PoolSpecification();                                            poolSpec.CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily' "*");                        poolSpec.TargetDedicatedComputeNodes = 0;                      poolSpec.VirtualMachineSize = PoolFixture.VMSize;                      AutoPoolSpecification autoPoolSpec = new AutoPoolSpecification();                      string autoPoolPrefix = "UpdPIAuto_" + TestUtilities.GetMyName();                      autoPoolSpec.AutoPoolIdPrefix = autoPoolPrefix;                      const bool originalKeepAlive = false;                      autoPoolSpec.KeepAlive = originalKeepAlive;                      autoPoolSpec.PoolLifetimeOption = PoolLifetimeOption.Job;                      autoPoolSpec.PoolSpecification = poolSpec;                      PoolInformation poolInfo = new PoolInformation();                      poolInfo.AutoPoolSpecification = autoPoolSpec;                      unboundJob.PoolInformation = poolInfo;                        const int originalPriority = 0;                      unboundJob.Priority = originalPriority;                      List<MetadataItem> originalMetadata = new List<MetadataItem>();                      originalMetadata.Add(new MetadataItem("meta1"' "value1"));                      originalMetadata.Add(new MetadataItem("meta2"' "value2"));                      unboundJob.Metadata = originalMetadata;                        this.testOutputHelper.WriteLine("Creating job {0}"' jobId);                      unboundJob.Commit();                        try                      {                          // Get bound job                          CloudJob createdJob = batchCli.JobOperations.GetJob(jobId);                            // Verify that we can update something besides PoolInformation without getting an error for not being in the Disabled state.                          Assert.NotEqual(JobState.Disabled' createdJob.State);                            int updatedPriority = originalPriority + 1;                          List<MetadataItem> updatedMetadata = new List<MetadataItem>();                          updatedMetadata.Add(new MetadataItem("updatedMeta1"' "value1"));                          createdJob.Priority = updatedPriority;                          createdJob.Metadata = updatedMetadata;                            this.testOutputHelper.WriteLine("Updating job {0} without altering PoolInformation"' jobId);                            createdJob.Commit();                            // Verify update occurred                          CloudJob updatedJob = batchCli.JobOperations.GetJob(jobId);                            Assert.Equal(updatedPriority' updatedJob.Priority);                          Assert.Equal(updatedJob.Metadata.Count' updatedJob.Priority);                          Assert.Equal(updatedJob.Metadata[0].Name' updatedMetadata[0].Name);                          Assert.Equal(updatedJob.Metadata[0].Value' updatedMetadata[0].Value);                            // Verify that updating the PoolInformation works.                          // PoolInformation can only be changed in the Disabled state.                          this.testOutputHelper.WriteLine("Disabling job {0}"' jobId);                          updatedJob.Disable(DisableJobOption.Terminate);                          while (updatedJob.State != JobState.Disabled)                          {                              Thread.Sleep(500);                              updatedJob.Refresh();                          }                            Assert.Equal(JobState.Disabled' updatedJob.State);                            bool updatedKeepAlive = !originalKeepAlive;                          updatedJob.PoolInformation.AutoPoolSpecification.KeepAlive = updatedKeepAlive;                          int updatedAgainPriority = updatedPriority + 1;                          updatedJob.Priority = updatedAgainPriority;                          this.testOutputHelper.WriteLine("Updating job {0} properties' including PoolInformation"' jobId);                          updatedJob.Commit();                            CloudJob updatedPoolInfoJob = batchCli.JobOperations.GetJob(jobId);                            Assert.Equal(updatedKeepAlive' updatedPoolInfoJob.PoolInformation.AutoPoolSpecification.KeepAlive);                          Assert.Equal(updatedAgainPriority' updatedPoolInfoJob.Priority);                      }                      finally                      {                          this.testOutputHelper.WriteLine("Deleting job {0}"' jobId);                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                            // Explicitly delete auto pool                          foreach (CloudPool pool in batchCli.PoolOperations.ListPools(new ODATADetailLevel(filterClause: string.Format("startswith(id''{0}')"' autoPoolPrefix))))                          {                              this.testOutputHelper.WriteLine("Deleting pool {0}"' pool.Id);                              TestUtilities.DeletePoolIfExistsAsync(batchCli' pool.Id).Wait();                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudJobTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,LongRunning_Bug1965363Wat7OSVersionFeaturesQuickJobWithAutoPool,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug1965363Job-" + TestUtilities.GetMyName();                      try                      {                            PoolInformation poolInfo = new PoolInformation()                          {                              AutoPoolSpecification = new AutoPoolSpecification()                              {                                  PoolLifetimeOption = PoolLifetimeOption.Job'                                  PoolSpecification = new PoolSpecification()                                  {                                      CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily)'                                      VirtualMachineSize = PoolFixture.VMSize'                                      TargetDedicatedComputeNodes = 1                                  }                              }                          };                            CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' poolInfo);                            this.testOutputHelper.WriteLine("Commiting quickjob");                          unboundJob.Commit();                            CloudTask task = new CloudTask("Bug1965363Wat7OSVersionFeaturesQuickJobWithAutoPoolTask"' "cmd /c echo Bug1965363");                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                          boundJob.AddTask(task);                            this.testOutputHelper.WriteLine("Getting pool name: {0}"' boundJob.ExecutionInformation.PoolId);                            CloudPool boundPool = batchCli.PoolOperations.GetPool(boundJob.ExecutionInformation.PoolId);                          TaskStateMonitor tsm = batchCli.Utilities.CreateTaskStateMonitor();                          ODATAMonitorControl odControl = new ODATAMonitorControl();                            // we know that the autopool compute nodes will take a long time to become scheduleable so we slow down polling/spam                          odControl.DelayBetweenDataFetch = TimeSpan.FromSeconds(5);                            this.testOutputHelper.WriteLine("Invoking TaskStateMonitor");                            tsm.WaitAll(                              boundJob.ListTasks()'                              TaskState.Completed'                              TimeSpan.FromMinutes(15)'                              odControl'                              new[] {                                  // spam/logging interceptor                                  new Microsoft.Azure.Batch.Protocol.RequestInterceptor((x) =>                                  {                                      this.testOutputHelper.WriteLine("Issuing request type: " + x.GetType().ToString());                                        // print out the compute node states... we are actually waiting on the compute nodes                                      List<ComputeNode> allComputeNodes = boundPool.ListComputeNodes().ToList();                                      this.testOutputHelper.WriteLine("    #comnpute nodes: " + allComputeNodes.Count);                                        allComputeNodes.ForEach((icn) => { this.testOutputHelper.WriteLine("  computeNode.id: " + icn.Id + "' state: " + icn.State); });                                      this.testOutputHelper.WriteLine("");                                  })                              });                            // confirm the task ran by inspecting the stdOut                          string stdOut = boundJob.ListTasks().ToList()[0].GetNodeFile(Constants.StandardOutFileName).ReadAsString();                            Assert.Contains("Bug1965363"' stdOut);                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudJobTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,LongRunning_Bug1965363Wat7OSVersionFeaturesQuickJobWithAutoPool,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug1965363Job-" + TestUtilities.GetMyName();                      try                      {                            PoolInformation poolInfo = new PoolInformation()                          {                              AutoPoolSpecification = new AutoPoolSpecification()                              {                                  PoolLifetimeOption = PoolLifetimeOption.Job'                                  PoolSpecification = new PoolSpecification()                                  {                                      CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily)'                                      VirtualMachineSize = PoolFixture.VMSize'                                      TargetDedicatedComputeNodes = 1                                  }                              }                          };                            CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' poolInfo);                            this.testOutputHelper.WriteLine("Commiting quickjob");                          unboundJob.Commit();                            CloudTask task = new CloudTask("Bug1965363Wat7OSVersionFeaturesQuickJobWithAutoPoolTask"' "cmd /c echo Bug1965363");                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                          boundJob.AddTask(task);                            this.testOutputHelper.WriteLine("Getting pool name: {0}"' boundJob.ExecutionInformation.PoolId);                            CloudPool boundPool = batchCli.PoolOperations.GetPool(boundJob.ExecutionInformation.PoolId);                          TaskStateMonitor tsm = batchCli.Utilities.CreateTaskStateMonitor();                          ODATAMonitorControl odControl = new ODATAMonitorControl();                            // we know that the autopool compute nodes will take a long time to become scheduleable so we slow down polling/spam                          odControl.DelayBetweenDataFetch = TimeSpan.FromSeconds(5);                            this.testOutputHelper.WriteLine("Invoking TaskStateMonitor");                            tsm.WaitAll(                              boundJob.ListTasks()'                              TaskState.Completed'                              TimeSpan.FromMinutes(15)'                              odControl'                              new[] {                                  // spam/logging interceptor                                  new Microsoft.Azure.Batch.Protocol.RequestInterceptor((x) =>                                  {                                      this.testOutputHelper.WriteLine("Issuing request type: " + x.GetType().ToString());                                        // print out the compute node states... we are actually waiting on the compute nodes                                      List<ComputeNode> allComputeNodes = boundPool.ListComputeNodes().ToList();                                      this.testOutputHelper.WriteLine("    #comnpute nodes: " + allComputeNodes.Count);                                        allComputeNodes.ForEach((icn) => { this.testOutputHelper.WriteLine("  computeNode.id: " + icn.Id + "' state: " + icn.State); });                                      this.testOutputHelper.WriteLine("");                                  })                              });                            // confirm the task ran by inspecting the stdOut                          string stdOut = boundJob.ListTasks().ToList()[0].GetNodeFile(Constants.StandardOutFileName).ReadAsString();                            Assert.Contains("Bug1965363"' stdOut);                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudJobTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,SetUpdateJobConditionalHeader,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClientFromEnvironmentAsync().Result)                  {                      string jobId = "JobConditionalHeaders-" + TestUtilities.GetMyName();                      try                      {                          PoolInformation poolInfo = new PoolInformation()                              {                                  PoolId = "Fake"                              };                            CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' poolInfo);                          unboundJob.Commit();                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            string capturedEtag1 = boundJob.ETag;                          this.testOutputHelper.WriteLine("Etag is: {0}"' capturedEtag1);                          Assert.NotNull(capturedEtag1);                            boundJob.Constraints = new JobConstraints(TimeSpan.FromMinutes(60)' 0);                            BatchClientBehavior updateInterceptor = new Protocol.RequestInterceptor(                              (req) =>                                  {                                      var typedParams = req.Options as Protocol.Models.JobUpdateOptions;                                      if (typedParams != null)                                      {                                          typedParams.IfMatch = capturedEtag1;                                      }                                  });                            //Update bound job with if-match header' it should succeed                          boundJob.Commit(additionalBehaviors: new[] { updateInterceptor });                            boundJob = batchCli.JobOperations.GetJob(jobId);                            boundJob.Constraints = new JobConstraints(TimeSpan.FromMinutes(30)' 1);                            //Update bound job with if-match header' it should fail                          Exception e = TestUtilities.AssertThrows<BatchException>(() => boundJob.Commit(additionalBehaviors: new[] { updateInterceptor }));                          TestUtilities.AssertIsBatchExceptionAndHasCorrectAzureErrorCode(e' BatchErrorCodeStrings.ConditionNotMet' this.testOutputHelper);                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudJobTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,SetUpdateJobConditionalHeader,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClientFromEnvironmentAsync().Result)                  {                      string jobId = "JobConditionalHeaders-" + TestUtilities.GetMyName();                      try                      {                          PoolInformation poolInfo = new PoolInformation()                              {                                  PoolId = "Fake"                              };                            CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' poolInfo);                          unboundJob.Commit();                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            string capturedEtag1 = boundJob.ETag;                          this.testOutputHelper.WriteLine("Etag is: {0}"' capturedEtag1);                          Assert.NotNull(capturedEtag1);                            boundJob.Constraints = new JobConstraints(TimeSpan.FromMinutes(60)' 0);                            BatchClientBehavior updateInterceptor = new Protocol.RequestInterceptor(                              (req) =>                                  {                                      var typedParams = req.Options as Protocol.Models.JobUpdateOptions;                                      if (typedParams != null)                                      {                                          typedParams.IfMatch = capturedEtag1;                                      }                                  });                            //Update bound job with if-match header' it should succeed                          boundJob.Commit(additionalBehaviors: new[] { updateInterceptor });                            boundJob = batchCli.JobOperations.GetJob(jobId);                            boundJob.Constraints = new JobConstraints(TimeSpan.FromMinutes(30)' 1);                            //Update bound job with if-match header' it should fail                          Exception e = TestUtilities.AssertThrows<BatchException>(() => boundJob.Commit(additionalBehaviors: new[] { updateInterceptor }));                          TestUtilities.AssertIsBatchExceptionAndHasCorrectAzureErrorCode(e' BatchErrorCodeStrings.ConditionNotMet' this.testOutputHelper);                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudJobTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Job_GetTaskCounts_ReturnsCorrectCount,The following statement contains a magic number: Func<Task> test = async () =>              {                  using (BatchClient batchCli = await TestUtilities.OpenBatchClientFromEnvironmentAsync().ConfigureAwait(false))                  {                      string jobId = "TestJobGetTaskCounts-" + TestUtilities.GetMyName();                      try                      {                          PoolInformation poolInfo = new PoolInformation()                          {                              PoolId = "Fake"                          };                            CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' poolInfo);                          await unboundJob.CommitAsync().ConfigureAwait(false);                          await unboundJob.RefreshAsync().ConfigureAwait(false);                            CloudTask t1 = new CloudTask("t1"' "cmd /c dir");                          CloudTask t2 = new CloudTask("t2"' "cmd /c ping 127.0.0.1 -n 4");                            await unboundJob.AddTaskAsync(new[] {t1' t2}).ConfigureAwait(false);                            await Task.Delay(TimeSpan.FromSeconds(5)).ConfigureAwait(false); // Give the service some time to get the counts                            var counts = await unboundJob.GetTaskCountsAsync().ConfigureAwait(false);                            Assert.Equal(2' counts.Active);                      }                      finally                      {                          await TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudJobTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobIntegrationTests.cs,Job_GetTaskCounts_ReturnsCorrectCount,The following statement contains a magic number: Func<Task> test = async () =>              {                  using (BatchClient batchCli = await TestUtilities.OpenBatchClientFromEnvironmentAsync().ConfigureAwait(false))                  {                      string jobId = "TestJobGetTaskCounts-" + TestUtilities.GetMyName();                      try                      {                          PoolInformation poolInfo = new PoolInformation()                          {                              PoolId = "Fake"                          };                            CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' poolInfo);                          await unboundJob.CommitAsync().ConfigureAwait(false);                          await unboundJob.RefreshAsync().ConfigureAwait(false);                            CloudTask t1 = new CloudTask("t1"' "cmd /c dir");                          CloudTask t2 = new CloudTask("t2"' "cmd /c ping 127.0.0.1 -n 4");                            await unboundJob.AddTaskAsync(new[] {t1' t2}).ConfigureAwait(false);                            await Task.Delay(TimeSpan.FromSeconds(5)).ConfigureAwait(false); // Give the service some time to get the counts                            var counts = await unboundJob.GetTaskCountsAsync().ConfigureAwait(false);                            Assert.Equal(2' counts.Active);                      }                      finally                      {                          await TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobScheduleIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,TestBoundJobScheduleCommit,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestBoundJobScheduleCommit";                      try                      {                          //                          // Create the job schedule                          //                          const int jobSchedulePriority = 5;                          const string jobManagerId = "TestBoundJobScheduleCommit";                          const string jobManagerCommandLine = "ping 127.0.0.1 -n 500";                            IList<MetadataItem> metadata = new List<MetadataItem> { new MetadataItem("key1"' "test1")' new MetadataItem("key2"' "test2") };                          CloudJobSchedule jobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                          TimeSpan firstRecurrenceInterval = TimeSpan.FromMinutes(2);                          jobSchedule.Schedule = new Schedule() { RecurrenceInterval = firstRecurrenceInterval };                          PoolInformation poolInfo = new PoolInformation()                              {                                  PoolId = this.poolFixture.PoolId                              };                            jobSchedule.JobSpecification = new JobSpecification(poolInfo)                              {                                  Priority = jobSchedulePriority'                                  JobManagerTask = new JobManagerTask(jobManagerId' jobManagerCommandLine)                              };                            jobSchedule.Metadata = metadata;                            this.testOutputHelper.WriteLine("Initial job schedule commit()");                          jobSchedule.Commit();                            //Get the bound job schedule                          CloudJobSchedule boundJobSchedule = batchCli.JobScheduleOperations.GetJobSchedule(jobScheduleId);                            //Ensure the job schedule is structured as expected                          AssertJobScheduleCorrectness(batchCli.JobScheduleOperations' boundJobSchedule' this.poolFixture.PoolId' jobSchedulePriority' jobManagerId' jobManagerCommandLine' firstRecurrenceInterval' metadata);                            //Update the bound job schedule schedule                          TimeSpan recurrenceInterval = TimeSpan.FromMinutes(5);                          boundJobSchedule.Schedule = new Schedule()                          {                              RecurrenceInterval = recurrenceInterval                          };                            this.testOutputHelper.WriteLine("Updating JobSchedule Schedule");                          boundJobSchedule.Commit();                            //Ensure the job schedule is correct after commit                          AssertJobScheduleCorrectness(batchCli.JobScheduleOperations' boundJobSchedule' this.poolFixture.PoolId' jobSchedulePriority' jobManagerId' jobManagerCommandLine' recurrenceInterval' metadata);                            //Update the bound job schedule priority                          const int newJobSchedulePriority = 1;                          boundJobSchedule.JobSpecification.Priority = newJobSchedulePriority;                            this.testOutputHelper.WriteLine("Updating JobSpecification.Priority");                          boundJobSchedule.Commit();                            //Ensure the job schedule is correct after commit                          AssertJobScheduleCorrectness(batchCli.JobScheduleOperations' boundJobSchedule' this.poolFixture.PoolId' newJobSchedulePriority' jobManagerId' jobManagerCommandLine' recurrenceInterval' metadata);                            //Update the bound job schedule job manager commandline                          const string newJobManagerCommandLine = "ping 127.0.0.1 -n 150";                          boundJobSchedule.JobSpecification.JobManagerTask.CommandLine = newJobManagerCommandLine;                            this.testOutputHelper.WriteLine("Updating JobSpecification.JobManagerTask.CommandLine");                          boundJobSchedule.Commit();                            //Ensure the job schedule is correct after commit                          AssertJobScheduleCorrectness(batchCli.JobScheduleOperations' boundJobSchedule' this.poolFixture.PoolId' newJobSchedulePriority' jobManagerId' newJobManagerCommandLine' recurrenceInterval' metadata);                            //Update the bound job schedule PoolInformation                          const string newPoolId = "TestPool";                            boundJobSchedule.JobSpecification.PoolInformation = new PoolInformation() { PoolId = newPoolId };                            this.testOutputHelper.WriteLine("Updating PoolInformation");                          boundJobSchedule.Commit();                            //Ensure the job schedule is correct after commit                          AssertJobScheduleCorrectness(                              batchCli.JobScheduleOperations'                              boundJobSchedule'                              newPoolId'                              newJobSchedulePriority'                              jobManagerId'                              newJobManagerCommandLine'                              recurrenceInterval'                              metadata);                            //Update the bound job schedule Metadata                          IList<MetadataItem> newMetadata = new List<MetadataItem> { new MetadataItem("Object"' "Model") };                          boundJobSchedule.Metadata = newMetadata;                            this.testOutputHelper.WriteLine("Updating Metadata");                          boundJobSchedule.Commit();                            //Ensure the job schedule is correct after commit                          AssertJobScheduleCorrectness(                              batchCli.JobScheduleOperations'                              boundJobSchedule'                              newPoolId'                              newJobSchedulePriority'                              jobManagerId'                              newJobManagerCommandLine'                              recurrenceInterval'                              newMetadata);                      }                      finally                      {                          batchCli.JobScheduleOperations.DeleteJobSchedule(jobScheduleId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobScheduleIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,TestBoundJobScheduleCommit,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestBoundJobScheduleCommit";                      try                      {                          //                          // Create the job schedule                          //                          const int jobSchedulePriority = 5;                          const string jobManagerId = "TestBoundJobScheduleCommit";                          const string jobManagerCommandLine = "ping 127.0.0.1 -n 500";                            IList<MetadataItem> metadata = new List<MetadataItem> { new MetadataItem("key1"' "test1")' new MetadataItem("key2"' "test2") };                          CloudJobSchedule jobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                          TimeSpan firstRecurrenceInterval = TimeSpan.FromMinutes(2);                          jobSchedule.Schedule = new Schedule() { RecurrenceInterval = firstRecurrenceInterval };                          PoolInformation poolInfo = new PoolInformation()                              {                                  PoolId = this.poolFixture.PoolId                              };                            jobSchedule.JobSpecification = new JobSpecification(poolInfo)                              {                                  Priority = jobSchedulePriority'                                  JobManagerTask = new JobManagerTask(jobManagerId' jobManagerCommandLine)                              };                            jobSchedule.Metadata = metadata;                            this.testOutputHelper.WriteLine("Initial job schedule commit()");                          jobSchedule.Commit();                            //Get the bound job schedule                          CloudJobSchedule boundJobSchedule = batchCli.JobScheduleOperations.GetJobSchedule(jobScheduleId);                            //Ensure the job schedule is structured as expected                          AssertJobScheduleCorrectness(batchCli.JobScheduleOperations' boundJobSchedule' this.poolFixture.PoolId' jobSchedulePriority' jobManagerId' jobManagerCommandLine' firstRecurrenceInterval' metadata);                            //Update the bound job schedule schedule                          TimeSpan recurrenceInterval = TimeSpan.FromMinutes(5);                          boundJobSchedule.Schedule = new Schedule()                          {                              RecurrenceInterval = recurrenceInterval                          };                            this.testOutputHelper.WriteLine("Updating JobSchedule Schedule");                          boundJobSchedule.Commit();                            //Ensure the job schedule is correct after commit                          AssertJobScheduleCorrectness(batchCli.JobScheduleOperations' boundJobSchedule' this.poolFixture.PoolId' jobSchedulePriority' jobManagerId' jobManagerCommandLine' recurrenceInterval' metadata);                            //Update the bound job schedule priority                          const int newJobSchedulePriority = 1;                          boundJobSchedule.JobSpecification.Priority = newJobSchedulePriority;                            this.testOutputHelper.WriteLine("Updating JobSpecification.Priority");                          boundJobSchedule.Commit();                            //Ensure the job schedule is correct after commit                          AssertJobScheduleCorrectness(batchCli.JobScheduleOperations' boundJobSchedule' this.poolFixture.PoolId' newJobSchedulePriority' jobManagerId' jobManagerCommandLine' recurrenceInterval' metadata);                            //Update the bound job schedule job manager commandline                          const string newJobManagerCommandLine = "ping 127.0.0.1 -n 150";                          boundJobSchedule.JobSpecification.JobManagerTask.CommandLine = newJobManagerCommandLine;                            this.testOutputHelper.WriteLine("Updating JobSpecification.JobManagerTask.CommandLine");                          boundJobSchedule.Commit();                            //Ensure the job schedule is correct after commit                          AssertJobScheduleCorrectness(batchCli.JobScheduleOperations' boundJobSchedule' this.poolFixture.PoolId' newJobSchedulePriority' jobManagerId' newJobManagerCommandLine' recurrenceInterval' metadata);                            //Update the bound job schedule PoolInformation                          const string newPoolId = "TestPool";                            boundJobSchedule.JobSpecification.PoolInformation = new PoolInformation() { PoolId = newPoolId };                            this.testOutputHelper.WriteLine("Updating PoolInformation");                          boundJobSchedule.Commit();                            //Ensure the job schedule is correct after commit                          AssertJobScheduleCorrectness(                              batchCli.JobScheduleOperations'                              boundJobSchedule'                              newPoolId'                              newJobSchedulePriority'                              jobManagerId'                              newJobManagerCommandLine'                              recurrenceInterval'                              metadata);                            //Update the bound job schedule Metadata                          IList<MetadataItem> newMetadata = new List<MetadataItem> { new MetadataItem("Object"' "Model") };                          boundJobSchedule.Metadata = newMetadata;                            this.testOutputHelper.WriteLine("Updating Metadata");                          boundJobSchedule.Commit();                            //Ensure the job schedule is correct after commit                          AssertJobScheduleCorrectness(                              batchCli.JobScheduleOperations'                              boundJobSchedule'                              newPoolId'                              newJobSchedulePriority'                              jobManagerId'                              newJobManagerCommandLine'                              recurrenceInterval'                              newMetadata);                      }                      finally                      {                          batchCli.JobScheduleOperations.DeleteJobSchedule(jobScheduleId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudJobScheduleIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,TestBoundJobScheduleCommit,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestBoundJobScheduleCommit";                      try                      {                          //                          // Create the job schedule                          //                          const int jobSchedulePriority = 5;                          const string jobManagerId = "TestBoundJobScheduleCommit";                          const string jobManagerCommandLine = "ping 127.0.0.1 -n 500";                            IList<MetadataItem> metadata = new List<MetadataItem> { new MetadataItem("key1"' "test1")' new MetadataItem("key2"' "test2") };                          CloudJobSchedule jobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                          TimeSpan firstRecurrenceInterval = TimeSpan.FromMinutes(2);                          jobSchedule.Schedule = new Schedule() { RecurrenceInterval = firstRecurrenceInterval };                          PoolInformation poolInfo = new PoolInformation()                              {                                  PoolId = this.poolFixture.PoolId                              };                            jobSchedule.JobSpecification = new JobSpecification(poolInfo)                              {                                  Priority = jobSchedulePriority'                                  JobManagerTask = new JobManagerTask(jobManagerId' jobManagerCommandLine)                              };                            jobSchedule.Metadata = metadata;                            this.testOutputHelper.WriteLine("Initial job schedule commit()");                          jobSchedule.Commit();                            //Get the bound job schedule                          CloudJobSchedule boundJobSchedule = batchCli.JobScheduleOperations.GetJobSchedule(jobScheduleId);                            //Ensure the job schedule is structured as expected                          AssertJobScheduleCorrectness(batchCli.JobScheduleOperations' boundJobSchedule' this.poolFixture.PoolId' jobSchedulePriority' jobManagerId' jobManagerCommandLine' firstRecurrenceInterval' metadata);                            //Update the bound job schedule schedule                          TimeSpan recurrenceInterval = TimeSpan.FromMinutes(5);                          boundJobSchedule.Schedule = new Schedule()                          {                              RecurrenceInterval = recurrenceInterval                          };                            this.testOutputHelper.WriteLine("Updating JobSchedule Schedule");                          boundJobSchedule.Commit();                            //Ensure the job schedule is correct after commit                          AssertJobScheduleCorrectness(batchCli.JobScheduleOperations' boundJobSchedule' this.poolFixture.PoolId' jobSchedulePriority' jobManagerId' jobManagerCommandLine' recurrenceInterval' metadata);                            //Update the bound job schedule priority                          const int newJobSchedulePriority = 1;                          boundJobSchedule.JobSpecification.Priority = newJobSchedulePriority;                            this.testOutputHelper.WriteLine("Updating JobSpecification.Priority");                          boundJobSchedule.Commit();                            //Ensure the job schedule is correct after commit                          AssertJobScheduleCorrectness(batchCli.JobScheduleOperations' boundJobSchedule' this.poolFixture.PoolId' newJobSchedulePriority' jobManagerId' jobManagerCommandLine' recurrenceInterval' metadata);                            //Update the bound job schedule job manager commandline                          const string newJobManagerCommandLine = "ping 127.0.0.1 -n 150";                          boundJobSchedule.JobSpecification.JobManagerTask.CommandLine = newJobManagerCommandLine;                            this.testOutputHelper.WriteLine("Updating JobSpecification.JobManagerTask.CommandLine");                          boundJobSchedule.Commit();                            //Ensure the job schedule is correct after commit                          AssertJobScheduleCorrectness(batchCli.JobScheduleOperations' boundJobSchedule' this.poolFixture.PoolId' newJobSchedulePriority' jobManagerId' newJobManagerCommandLine' recurrenceInterval' metadata);                            //Update the bound job schedule PoolInformation                          const string newPoolId = "TestPool";                            boundJobSchedule.JobSpecification.PoolInformation = new PoolInformation() { PoolId = newPoolId };                            this.testOutputHelper.WriteLine("Updating PoolInformation");                          boundJobSchedule.Commit();                            //Ensure the job schedule is correct after commit                          AssertJobScheduleCorrectness(                              batchCli.JobScheduleOperations'                              boundJobSchedule'                              newPoolId'                              newJobSchedulePriority'                              jobManagerId'                              newJobManagerCommandLine'                              recurrenceInterval'                              metadata);                            //Update the bound job schedule Metadata                          IList<MetadataItem> newMetadata = new List<MetadataItem> { new MetadataItem("Object"' "Model") };                          boundJobSchedule.Metadata = newMetadata;                            this.testOutputHelper.WriteLine("Updating Metadata");                          boundJobSchedule.Commit();                            //Ensure the job schedule is correct after commit                          AssertJobScheduleCorrectness(                              batchCli.JobScheduleOperations'                              boundJobSchedule'                              newPoolId'                              newJobSchedulePriority'                              jobManagerId'                              newJobManagerCommandLine'                              recurrenceInterval'                              newMetadata);                      }                      finally                      {                          batchCli.JobScheduleOperations.DeleteJobSchedule(jobScheduleId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudJobScheduleTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,JobSchedulePatch,The following statement contains a magic number: Func<Task> test = async () =>              {                  using (BatchClient batchCli = await TestUtilities.OpenBatchClientFromEnvironmentAsync().ConfigureAwait(false))                  {                      string jobScheduleId = "TestPatchJobSchedule-" + TestUtilities.GetMyName();                      const string newJobManagerCommandLine = "cmd /c dir";                      const string metadataKey = "Foo";                      const string metadataValue = "Bar";                      TimeSpan newRecurrenceInterval = TimeSpan.FromDays(2);                      try                      {                          CloudJobSchedule jobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(                              jobScheduleId'                              new Schedule()                                  {                                      RecurrenceInterval = TimeSpan.FromDays(1)                                  }'                              new JobSpecification(new PoolInformation() { PoolId = "DummyPool" })                                  {                                      JobManagerTask = new JobManagerTask(id: "Foo"' commandLine: "Foo")                                  });                            await jobSchedule.CommitAsync().ConfigureAwait(false);                          await jobSchedule.RefreshAsync().ConfigureAwait(false);                            jobSchedule.JobSpecification.JobManagerTask.CommandLine = newJobManagerCommandLine;                          jobSchedule.Metadata = new List<MetadataItem>()                              {                                  new MetadataItem(metadataKey' metadataValue)                              };                          jobSchedule.Schedule.RecurrenceInterval = newRecurrenceInterval;                            await jobSchedule.CommitChangesAsync().ConfigureAwait(false);                            await jobSchedule.RefreshAsync().ConfigureAwait(false);                            Assert.Equal(newRecurrenceInterval' jobSchedule.Schedule.RecurrenceInterval);                          Assert.Equal(newJobManagerCommandLine' jobSchedule.JobSpecification.JobManagerTask.CommandLine);                          Assert.Equal(metadataKey' jobSchedule.Metadata.Single().Name);                          Assert.Equal(metadataValue' jobSchedule.Metadata.Single().Value);                      }                      finally                      {                          await TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jobScheduleId).ConfigureAwait(false);                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudJobScheduleTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,SampleCreateJobScheduleAutoPool,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jsId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-CreateWiAutoPoolTest";                      try                      {                          CloudJobSchedule newJobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(jsId' null' null);                          {                              newJobSchedule.Metadata = MakeMetaData("onCreateName"' "onCreateValue");                                PoolInformation poolInformation = new PoolInformation();                              AutoPoolSpecification iaps = new AutoPoolSpecification();                              Schedule schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(18) };                              poolInformation.AutoPoolSpecification = iaps;                                iaps.AutoPoolIdPrefix = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName();                              iaps.PoolLifetimeOption = Microsoft.Azure.Batch.Common.PoolLifetimeOption.Job;                              iaps.KeepAlive = false;                                PoolSpecification ps = new PoolSpecification();                                iaps.PoolSpecification = ps;                                ps.TargetDedicatedComputeNodes = 1;                              ps.VirtualMachineSize = PoolFixture.VMSize;                                                            ps.CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily);                                ps.Metadata = MakeMetaData("pusMDIName"' "pusMDIValue");                                JobSpecification jobSpec = newJobSchedule.JobSpecification;                              Assert.Null(jobSpec);                                jobSpec = new JobSpecification(poolInformation);                                JobManagerTask jobMgr = jobSpec.JobManagerTask;                                Assert.Null(jobMgr);                                jobMgr = new JobManagerTask(TestUtilities.GetMyName() + "-JobManagerTest"' "hostname");                                jobMgr.KillJobOnCompletion = false;                                // set the JobManagerTask on the JobSpecification                              jobSpec.JobManagerTask = jobMgr;                                // set the JobSpecifcation on the Job Schedule                              newJobSchedule.JobSpecification = jobSpec;                                newJobSchedule.Schedule = schedule;                                newJobSchedule.Commit();                          }                            CloudJobSchedule jobSchedule = batchCli.JobScheduleOperations.GetJobSchedule(jsId);                          {                              TestUtilities.DisplayJobScheduleLong(this.testOutputHelper' jobSchedule);                                List<MetadataItem> mdi = new List<MetadataItem>(jobSchedule.Metadata);                                // check the values specified for AddJobSchedule are correct.                              foreach (MetadataItem curIMDI in mdi)                              {                                  Assert.Equal("onCreateName"' curIMDI.Name);                                  Assert.Equal("onCreateValue"' curIMDI.Value);                              }                                // add metadata items                              mdi.Add(new MetadataItem("modifiedName"' "modifiedValue"));                                jobSchedule.Metadata = mdi;                                jobSchedule.Commit();                                // confirm metadata updated correctly                              CloudJobSchedule jsUpdated = batchCli.JobScheduleOperations.GetJobSchedule(jsId);                              {                                  List<MetadataItem> updatedMDI = new List<MetadataItem>(jsUpdated.Metadata);                                    Assert.Equal(2' updatedMDI.Count);                                    Assert.Equal("onCreateName"' updatedMDI[0].Name);                                  Assert.Equal("onCreateValue"' updatedMDI[0].Value);                                    Assert.Equal("modifiedName"' updatedMDI[1].Name);                                  Assert.Equal("modifiedValue"' updatedMDI[1].Value);                              }                                jobSchedule.Refresh();                                TestUtilities.DisplayJobScheduleLong(this.testOutputHelper' jobSchedule);                          }                      }                      finally                      {                          // clean up                          TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jsId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudJobScheduleTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,SampleCreateJobScheduleAutoPool,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jsId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-CreateWiAutoPoolTest";                      try                      {                          CloudJobSchedule newJobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(jsId' null' null);                          {                              newJobSchedule.Metadata = MakeMetaData("onCreateName"' "onCreateValue");                                PoolInformation poolInformation = new PoolInformation();                              AutoPoolSpecification iaps = new AutoPoolSpecification();                              Schedule schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(18) };                              poolInformation.AutoPoolSpecification = iaps;                                iaps.AutoPoolIdPrefix = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName();                              iaps.PoolLifetimeOption = Microsoft.Azure.Batch.Common.PoolLifetimeOption.Job;                              iaps.KeepAlive = false;                                PoolSpecification ps = new PoolSpecification();                                iaps.PoolSpecification = ps;                                ps.TargetDedicatedComputeNodes = 1;                              ps.VirtualMachineSize = PoolFixture.VMSize;                                                            ps.CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily);                                ps.Metadata = MakeMetaData("pusMDIName"' "pusMDIValue");                                JobSpecification jobSpec = newJobSchedule.JobSpecification;                              Assert.Null(jobSpec);                                jobSpec = new JobSpecification(poolInformation);                                JobManagerTask jobMgr = jobSpec.JobManagerTask;                                Assert.Null(jobMgr);                                jobMgr = new JobManagerTask(TestUtilities.GetMyName() + "-JobManagerTest"' "hostname");                                jobMgr.KillJobOnCompletion = false;                                // set the JobManagerTask on the JobSpecification                              jobSpec.JobManagerTask = jobMgr;                                // set the JobSpecifcation on the Job Schedule                              newJobSchedule.JobSpecification = jobSpec;                                newJobSchedule.Schedule = schedule;                                newJobSchedule.Commit();                          }                            CloudJobSchedule jobSchedule = batchCli.JobScheduleOperations.GetJobSchedule(jsId);                          {                              TestUtilities.DisplayJobScheduleLong(this.testOutputHelper' jobSchedule);                                List<MetadataItem> mdi = new List<MetadataItem>(jobSchedule.Metadata);                                // check the values specified for AddJobSchedule are correct.                              foreach (MetadataItem curIMDI in mdi)                              {                                  Assert.Equal("onCreateName"' curIMDI.Name);                                  Assert.Equal("onCreateValue"' curIMDI.Value);                              }                                // add metadata items                              mdi.Add(new MetadataItem("modifiedName"' "modifiedValue"));                                jobSchedule.Metadata = mdi;                                jobSchedule.Commit();                                // confirm metadata updated correctly                              CloudJobSchedule jsUpdated = batchCli.JobScheduleOperations.GetJobSchedule(jsId);                              {                                  List<MetadataItem> updatedMDI = new List<MetadataItem>(jsUpdated.Metadata);                                    Assert.Equal(2' updatedMDI.Count);                                    Assert.Equal("onCreateName"' updatedMDI[0].Name);                                  Assert.Equal("onCreateValue"' updatedMDI[0].Value);                                    Assert.Equal("modifiedName"' updatedMDI[1].Name);                                  Assert.Equal("modifiedValue"' updatedMDI[1].Value);                              }                                jobSchedule.Refresh();                                TestUtilities.DisplayJobScheduleLong(this.testOutputHelper' jobSchedule);                          }                      }                      finally                      {                          // clean up                          TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jsId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudJobScheduleTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,Bug1433008JobScheduleScheduleNewable,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jsId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-Bug1433008JobScheduleScheduleNewable";                        try                      {                          DateTime unboundDNRU = DateTime.UtcNow.AddYears(1);                            CloudJobSchedule newJobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(jsId' null' null);                          {                              AutoPoolSpecification iaps = new AutoPoolSpecification();                              PoolSpecification ips = new PoolSpecification();                              JobSpecification jobSpecification = new JobSpecification(new PoolInformation() { AutoPoolSpecification = iaps });                              iaps.PoolSpecification = ips;                                iaps.AutoPoolIdPrefix = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName();                              iaps.PoolLifetimeOption = Microsoft.Azure.Batch.Common.PoolLifetimeOption.Job;                              iaps.KeepAlive = false;                                PoolSpecification ps = iaps.PoolSpecification;                                ps.TargetDedicatedComputeNodes = 1;                              ps.VirtualMachineSize = PoolFixture.VMSize;                                                            ps.CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily);                                Schedule sched = new Schedule();                                sched.DoNotRunUntil = unboundDNRU;                                newJobSchedule.Schedule = sched;                              newJobSchedule.JobSpecification = jobSpecification;                                newJobSchedule.Commit();                          }                            CloudJobSchedule jobSchedule = batchCli.JobScheduleOperations.GetJobSchedule(jsId);                            // confirm that the original value(s) are set                          TestUtilities.DisplayJobScheduleLong(this.testOutputHelper' jobSchedule);                            Assert.Equal(unboundDNRU' jobSchedule.Schedule.DoNotRunUntil);                            // now update the schedule and confirm                            DateTime boundDNRU = DateTime.UtcNow.AddYears(2);                            jobSchedule.Schedule.DoNotRunUntil = boundDNRU;                            jobSchedule.Commit();                            jobSchedule.Refresh();                            // confirm that the new value(s) are set                          TestUtilities.DisplayJobScheduleLong(this.testOutputHelper' jobSchedule);                            Assert.Equal(boundDNRU' jobSchedule.Schedule.DoNotRunUntil);                      }                      finally                      {                          // clean up                          TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jsId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudJobScheduleTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,TestListJobsByJobSchedule,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestListJobsByJobSchedule";                        try                      {                          Schedule schedule = new Schedule()                          {                              DoNotRunAfter = DateTime.UtcNow.Add(TimeSpan.FromDays(1))'                              RecurrenceInterval = TimeSpan.FromMinutes(1)                          };                            JobSpecification jobSpecification = new JobSpecification(new PoolInformation()                              {                                  PoolId = "DummyPool"                              });                            CloudJobSchedule unboundJobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(jobScheduleId' schedule' jobSpecification);                          unboundJobSchedule.Commit();                            //List the jobs under this JobSchedule                          for (int i = 1; i <= 3; i++)                          {                              string expectedJobId = string.Format("{0}:job-{1}"' jobScheduleId' i);                              CloudJobSchedule boundJobSchedule = TestUtilities.WaitForJobOnJobSchedule(                                  batchCli.JobScheduleOperations'                                  jobScheduleId'                                   expectedJobId: expectedJobId'                                   timeout: TimeSpan.FromSeconds(70));                                List<CloudJob> jobs = boundJobSchedule.ListJobs().ToList();                              Assert.Equal(i' jobs.Count);                                jobs = batchCli.JobScheduleOperations.ListJobs(jobScheduleId).ToList();                              Assert.Equal(i' jobs.Count);                                //Terminate the current job to force a new job to be created                              batchCli.JobOperations.TerminateJob(expectedJobId);                          }                      }                      finally                      {                          // clean up                          TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jobScheduleId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudJobScheduleTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,TestListJobsByJobSchedule,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestListJobsByJobSchedule";                        try                      {                          Schedule schedule = new Schedule()                          {                              DoNotRunAfter = DateTime.UtcNow.Add(TimeSpan.FromDays(1))'                              RecurrenceInterval = TimeSpan.FromMinutes(1)                          };                            JobSpecification jobSpecification = new JobSpecification(new PoolInformation()                              {                                  PoolId = "DummyPool"                              });                            CloudJobSchedule unboundJobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(jobScheduleId' schedule' jobSpecification);                          unboundJobSchedule.Commit();                            //List the jobs under this JobSchedule                          for (int i = 1; i <= 3; i++)                          {                              string expectedJobId = string.Format("{0}:job-{1}"' jobScheduleId' i);                              CloudJobSchedule boundJobSchedule = TestUtilities.WaitForJobOnJobSchedule(                                  batchCli.JobScheduleOperations'                                  jobScheduleId'                                   expectedJobId: expectedJobId'                                   timeout: TimeSpan.FromSeconds(70));                                List<CloudJob> jobs = boundJobSchedule.ListJobs().ToList();                              Assert.Equal(i' jobs.Count);                                jobs = batchCli.JobScheduleOperations.ListJobs(jobScheduleId).ToList();                              Assert.Equal(i' jobs.Count);                                //Terminate the current job to force a new job to be created                              batchCli.JobOperations.TerminateJob(expectedJobId);                          }                      }                      finally                      {                          // clean up                          TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jobScheduleId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudJobScheduleTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudJobScheduleIntegrationTests.cs,TestJobScheduleVerbs,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestEnableDisableDeleteJobSchedule";                        try                      {                          Schedule schedule = new Schedule()                          {                              DoNotRunAfter = DateTime.UtcNow.Add(TimeSpan.FromDays(1))                          };                            JobSpecification jobSpecification = new JobSpecification(new PoolInformation()                              {                                  PoolId = "DummyPool"                              });                            CloudJobSchedule unboundJobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(jobScheduleId' schedule' jobSpecification);                          unboundJobSchedule.Commit();                            CloudJobSchedule boundJobSchedule = batchCli.JobScheduleOperations.GetJobSchedule(jobScheduleId);                            //Disable the job schedule via instance                          boundJobSchedule.Disable();                          boundJobSchedule.Refresh();                                                    Assert.NotNull(boundJobSchedule.State);                          Assert.Equal(JobScheduleState.Disabled' boundJobSchedule.State);                            //Enable the job schedule via instance                          boundJobSchedule.Enable();                          boundJobSchedule.Refresh();                            Assert.NotNull(boundJobSchedule.State);                          Assert.Equal(JobScheduleState.Active' boundJobSchedule.State);                            //Disable the job schedule via operations                          batchCli.JobScheduleOperations.DisableJobSchedule(jobScheduleId);                          boundJobSchedule.Refresh();                            Assert.NotNull(boundJobSchedule.State);                          Assert.Equal(JobScheduleState.Disabled' boundJobSchedule.State);                            //Enable the job schedule via instance                          batchCli.JobScheduleOperations.EnableJobSchedule(jobScheduleId);                          boundJobSchedule.Refresh();                            Assert.NotNull(boundJobSchedule.State);                          Assert.Equal(JobScheduleState.Active' boundJobSchedule.State);                            //Terminate the job schedule                          batchCli.JobScheduleOperations.TerminateJobSchedule(jobScheduleId);                            boundJobSchedule.Refresh();                          Assert.True(boundJobSchedule.State == JobScheduleState.Completed || boundJobSchedule.State == JobScheduleState.Terminating);                            //Delete the job schedule                          boundJobSchedule.Delete();                                                    //Wait for deletion to take                          BatchException be = TestUtilities.AssertThrowsEventuallyAsync<BatchException>(() => boundJobSchedule.RefreshAsync()' TimeSpan.FromSeconds(30)).Result;                          Assert.NotNull(be.RequestInformation);                          Assert.NotNull(be.RequestInformation.BatchError);                          Assert.Equal("JobScheduleNotFound"' be.RequestInformation.BatchError.Code);                      }                      finally                      {                          // clean up                          TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jobScheduleId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,Bug1505248SupportMultipleTasksPerComputeNodeOnPoolAndPoolUserSpec,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      // create a pool with the two new props                      string poolId = "Bug1505248SupportMultipleTasksPerComputeNode-pool-" + TestUtilities.GetMyName();                      try                      {                          CloudPool newPool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: 0);                            newPool.MaxTasksPerComputeNode = 3;                            newPool.TaskSchedulingPolicy =                              new TaskSchedulingPolicy(Microsoft.Azure.Batch.Common.ComputeNodeFillType.Pack);                            newPool.Commit();                            CloudPool boundPool = batchCli.PoolOperations.GetPool(poolId);                            Assert.Equal(3' boundPool.MaxTasksPerComputeNode);                          Assert.Equal(ComputeNodeFillType.Pack' boundPool.TaskSchedulingPolicy.ComputeNodeFillType);                      }                      finally                      {                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                      }                        string jobId = "Bug1505248SupportMultipleTasksPerComputeNode-Job-" + TestUtilities.GetMyName();                      try                      {                          // create a job with new props set on pooluserspec                          {                              CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                              AutoPoolSpecification unboundAPS = new AutoPoolSpecification();                              PoolSpecification unboundPS = new PoolSpecification();                              unboundJob.PoolInformation.AutoPoolSpecification = unboundAPS;                              unboundAPS.PoolSpecification = unboundPS;                                unboundPS.MaxTasksPerComputeNode = 3;                              unboundAPS.PoolSpecification.TargetDedicatedComputeNodes = 0; // don't use up compute nodes for this test                              unboundPS.TaskSchedulingPolicy = new TaskSchedulingPolicy(Microsoft.Azure.Batch.Common.ComputeNodeFillType.Pack);                                // required but unrelated to test                              unboundPS.VirtualMachineSize = PoolFixture.VMSize;                                unboundPS.CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily);                                unboundAPS.PoolLifetimeOption = Microsoft.Azure.Batch.Common.PoolLifetimeOption.Job;                                unboundJob.Commit();                          }                            // confirm props were set                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                          PoolInformation poolInformation = boundJob.PoolInformation;                          AutoPoolSpecification boundAPS = poolInformation.AutoPoolSpecification;                          PoolSpecification boundPUS = boundAPS.PoolSpecification;                            Assert.Equal(3' boundPUS.MaxTasksPerComputeNode);                          Assert.Equal(ComputeNodeFillType.Pack' boundPUS.TaskSchedulingPolicy.ComputeNodeFillType);                            // change the props                            //TODO: Possible change this test to use a JobSchedule here?                          //boundPUS.MaxTasksPerComputeNode = 2;                          //boundPUS.TaskSchedulingPolicy = new TaskSchedulingPolicy(Microsoft.Azure.Batch.Common.ComputeNodeFillType.Spread);                            //boundJob.Commit();                          //boundJob.Refresh();                            //boundAPS = boundJob.PoolInformation.AutoPoolSpecification;                          //boundPUS = boundAPS.PoolSpecification;                            //Debug.Assert(2 == boundPUS.MaxTasksPerComputeNode);                          //Debug.Assert(Microsoft.Azure.Batch.Common.ComputeNodeFillType.Spread == boundPUS.TaskSchedulingPolicy.ComputeNodeFillType);                        }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,Bug1505248SupportMultipleTasksPerComputeNodeOnPoolAndPoolUserSpec,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      // create a pool with the two new props                      string poolId = "Bug1505248SupportMultipleTasksPerComputeNode-pool-" + TestUtilities.GetMyName();                      try                      {                          CloudPool newPool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: 0);                            newPool.MaxTasksPerComputeNode = 3;                            newPool.TaskSchedulingPolicy =                              new TaskSchedulingPolicy(Microsoft.Azure.Batch.Common.ComputeNodeFillType.Pack);                            newPool.Commit();                            CloudPool boundPool = batchCli.PoolOperations.GetPool(poolId);                            Assert.Equal(3' boundPool.MaxTasksPerComputeNode);                          Assert.Equal(ComputeNodeFillType.Pack' boundPool.TaskSchedulingPolicy.ComputeNodeFillType);                      }                      finally                      {                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                      }                        string jobId = "Bug1505248SupportMultipleTasksPerComputeNode-Job-" + TestUtilities.GetMyName();                      try                      {                          // create a job with new props set on pooluserspec                          {                              CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                              AutoPoolSpecification unboundAPS = new AutoPoolSpecification();                              PoolSpecification unboundPS = new PoolSpecification();                              unboundJob.PoolInformation.AutoPoolSpecification = unboundAPS;                              unboundAPS.PoolSpecification = unboundPS;                                unboundPS.MaxTasksPerComputeNode = 3;                              unboundAPS.PoolSpecification.TargetDedicatedComputeNodes = 0; // don't use up compute nodes for this test                              unboundPS.TaskSchedulingPolicy = new TaskSchedulingPolicy(Microsoft.Azure.Batch.Common.ComputeNodeFillType.Pack);                                // required but unrelated to test                              unboundPS.VirtualMachineSize = PoolFixture.VMSize;                                unboundPS.CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily);                                unboundAPS.PoolLifetimeOption = Microsoft.Azure.Batch.Common.PoolLifetimeOption.Job;                                unboundJob.Commit();                          }                            // confirm props were set                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                          PoolInformation poolInformation = boundJob.PoolInformation;                          AutoPoolSpecification boundAPS = poolInformation.AutoPoolSpecification;                          PoolSpecification boundPUS = boundAPS.PoolSpecification;                            Assert.Equal(3' boundPUS.MaxTasksPerComputeNode);                          Assert.Equal(ComputeNodeFillType.Pack' boundPUS.TaskSchedulingPolicy.ComputeNodeFillType);                            // change the props                            //TODO: Possible change this test to use a JobSchedule here?                          //boundPUS.MaxTasksPerComputeNode = 2;                          //boundPUS.TaskSchedulingPolicy = new TaskSchedulingPolicy(Microsoft.Azure.Batch.Common.ComputeNodeFillType.Spread);                            //boundJob.Commit();                          //boundJob.Refresh();                            //boundAPS = boundJob.PoolInformation.AutoPoolSpecification;                          //boundPUS = boundAPS.PoolSpecification;                            //Debug.Assert(2 == boundPUS.MaxTasksPerComputeNode);                          //Debug.Assert(Microsoft.Azure.Batch.Common.ComputeNodeFillType.Spread == boundPUS.TaskSchedulingPolicy.ComputeNodeFillType);                        }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,Bug1505248SupportMultipleTasksPerComputeNodeOnPoolAndPoolUserSpec,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      // create a pool with the two new props                      string poolId = "Bug1505248SupportMultipleTasksPerComputeNode-pool-" + TestUtilities.GetMyName();                      try                      {                          CloudPool newPool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: 0);                            newPool.MaxTasksPerComputeNode = 3;                            newPool.TaskSchedulingPolicy =                              new TaskSchedulingPolicy(Microsoft.Azure.Batch.Common.ComputeNodeFillType.Pack);                            newPool.Commit();                            CloudPool boundPool = batchCli.PoolOperations.GetPool(poolId);                            Assert.Equal(3' boundPool.MaxTasksPerComputeNode);                          Assert.Equal(ComputeNodeFillType.Pack' boundPool.TaskSchedulingPolicy.ComputeNodeFillType);                      }                      finally                      {                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                      }                        string jobId = "Bug1505248SupportMultipleTasksPerComputeNode-Job-" + TestUtilities.GetMyName();                      try                      {                          // create a job with new props set on pooluserspec                          {                              CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                              AutoPoolSpecification unboundAPS = new AutoPoolSpecification();                              PoolSpecification unboundPS = new PoolSpecification();                              unboundJob.PoolInformation.AutoPoolSpecification = unboundAPS;                              unboundAPS.PoolSpecification = unboundPS;                                unboundPS.MaxTasksPerComputeNode = 3;                              unboundAPS.PoolSpecification.TargetDedicatedComputeNodes = 0; // don't use up compute nodes for this test                              unboundPS.TaskSchedulingPolicy = new TaskSchedulingPolicy(Microsoft.Azure.Batch.Common.ComputeNodeFillType.Pack);                                // required but unrelated to test                              unboundPS.VirtualMachineSize = PoolFixture.VMSize;                                unboundPS.CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily);                                unboundAPS.PoolLifetimeOption = Microsoft.Azure.Batch.Common.PoolLifetimeOption.Job;                                unboundJob.Commit();                          }                            // confirm props were set                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                          PoolInformation poolInformation = boundJob.PoolInformation;                          AutoPoolSpecification boundAPS = poolInformation.AutoPoolSpecification;                          PoolSpecification boundPUS = boundAPS.PoolSpecification;                            Assert.Equal(3' boundPUS.MaxTasksPerComputeNode);                          Assert.Equal(ComputeNodeFillType.Pack' boundPUS.TaskSchedulingPolicy.ComputeNodeFillType);                            // change the props                            //TODO: Possible change this test to use a JobSchedule here?                          //boundPUS.MaxTasksPerComputeNode = 2;                          //boundPUS.TaskSchedulingPolicy = new TaskSchedulingPolicy(Microsoft.Azure.Batch.Common.ComputeNodeFillType.Spread);                            //boundJob.Commit();                          //boundJob.Refresh();                            //boundAPS = boundJob.PoolInformation.AutoPoolSpecification;                          //boundPUS = boundAPS.PoolSpecification;                            //Debug.Assert(2 == boundPUS.MaxTasksPerComputeNode);                          //Debug.Assert(Microsoft.Azure.Batch.Common.ComputeNodeFillType.Spread == boundPUS.TaskSchedulingPolicy.ComputeNodeFillType);                        }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,Bug1505248SupportMultipleTasksPerComputeNodeOnPoolAndPoolUserSpec,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      // create a pool with the two new props                      string poolId = "Bug1505248SupportMultipleTasksPerComputeNode-pool-" + TestUtilities.GetMyName();                      try                      {                          CloudPool newPool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: 0);                            newPool.MaxTasksPerComputeNode = 3;                            newPool.TaskSchedulingPolicy =                              new TaskSchedulingPolicy(Microsoft.Azure.Batch.Common.ComputeNodeFillType.Pack);                            newPool.Commit();                            CloudPool boundPool = batchCli.PoolOperations.GetPool(poolId);                            Assert.Equal(3' boundPool.MaxTasksPerComputeNode);                          Assert.Equal(ComputeNodeFillType.Pack' boundPool.TaskSchedulingPolicy.ComputeNodeFillType);                      }                      finally                      {                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                      }                        string jobId = "Bug1505248SupportMultipleTasksPerComputeNode-Job-" + TestUtilities.GetMyName();                      try                      {                          // create a job with new props set on pooluserspec                          {                              CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                              AutoPoolSpecification unboundAPS = new AutoPoolSpecification();                              PoolSpecification unboundPS = new PoolSpecification();                              unboundJob.PoolInformation.AutoPoolSpecification = unboundAPS;                              unboundAPS.PoolSpecification = unboundPS;                                unboundPS.MaxTasksPerComputeNode = 3;                              unboundAPS.PoolSpecification.TargetDedicatedComputeNodes = 0; // don't use up compute nodes for this test                              unboundPS.TaskSchedulingPolicy = new TaskSchedulingPolicy(Microsoft.Azure.Batch.Common.ComputeNodeFillType.Pack);                                // required but unrelated to test                              unboundPS.VirtualMachineSize = PoolFixture.VMSize;                                unboundPS.CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily);                                unboundAPS.PoolLifetimeOption = Microsoft.Azure.Batch.Common.PoolLifetimeOption.Job;                                unboundJob.Commit();                          }                            // confirm props were set                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                          PoolInformation poolInformation = boundJob.PoolInformation;                          AutoPoolSpecification boundAPS = poolInformation.AutoPoolSpecification;                          PoolSpecification boundPUS = boundAPS.PoolSpecification;                            Assert.Equal(3' boundPUS.MaxTasksPerComputeNode);                          Assert.Equal(ComputeNodeFillType.Pack' boundPUS.TaskSchedulingPolicy.ComputeNodeFillType);                            // change the props                            //TODO: Possible change this test to use a JobSchedule here?                          //boundPUS.MaxTasksPerComputeNode = 2;                          //boundPUS.TaskSchedulingPolicy = new TaskSchedulingPolicy(Microsoft.Azure.Batch.Common.ComputeNodeFillType.Spread);                            //boundJob.Commit();                          //boundJob.Refresh();                            //boundAPS = boundJob.PoolInformation.AutoPoolSpecification;                          //boundPUS = boundAPS.PoolSpecification;                            //Debug.Assert(2 == boundPUS.MaxTasksPerComputeNode);                          //Debug.Assert(Microsoft.Azure.Batch.Common.ComputeNodeFillType.Spread == boundPUS.TaskSchedulingPolicy.ComputeNodeFillType);                        }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,Bug1587303StartTaskResourceFilesNotPushedToServer,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = "Bug1587303Pool-" + TestUtilities.GetMyName();                        const string resourceFileSas = "http://azure.com";                      const string resourceFileValue = "count0ResFiles.exe";                        const string envSettingName = "envName";                      const string envSettingValue = "envValue";                        try                      {                          // create a pool with env-settings and ResFiles                          {                              CloudPool myPool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: 0);                                StartTask st = new StartTask("dir");                                MakeResourceFiles(st' resourceFileSas' resourceFileValue);                              AddEnviornmentSettingsToStartTask(st' envSettingName' envSettingValue);                                // set the pool's start task so the collections get pushed                              myPool.StartTask = st;                                myPool.Commit();                          }                            // confirm pool has correct values                          CloudPool boundPool = batchCli.PoolOperations.GetPool(poolId);                            CheckResourceFiles(boundPool.StartTask' resourceFileSas' resourceFileValue);                          CheckEnvironmentSettingsOnStartTask(boundPool.StartTask' envSettingName' envSettingValue);                            // clear the collections                          boundPool.StartTask.EnvironmentSettings = null;                          boundPool.StartTask.ResourceFiles = null;                            boundPool.Commit();                          boundPool.Refresh();                            StartTask boundST = boundPool.StartTask;                            // confirm the collections are cleared/null                          Assert.Null(boundST.ResourceFiles);                          Assert.Null(boundST.EnvironmentSettings);                            // set the collections again                          MakeResourceFiles(boundST' resourceFileSas' resourceFileValue);                          AddEnviornmentSettingsToStartTask(boundST' envSettingName' envSettingValue);                            boundPool.Commit();                          boundPool.Refresh();                            // confirm the collectsion are correctly re-established                          CheckResourceFiles(boundPool.StartTask' resourceFileSas' resourceFileValue);                          CheckEnvironmentSettingsOnStartTask(boundPool.StartTask' envSettingName' envSettingValue);                            //set collections to empty-but-non-null collections                          IList<ResourceFile> emptyResfiles = new List<ResourceFile>();                          IList<EnvironmentSetting> emptyEnvSettings = new List<EnvironmentSetting>();                            boundPool.StartTask.EnvironmentSettings = emptyEnvSettings;                          boundPool.StartTask.ResourceFiles = emptyResfiles;                            boundPool.Commit();                          boundPool.Refresh();                            boundST = boundPool.StartTask;                            var count0ResFiles = boundPool.StartTask.ResourceFiles;                          var count0EnvSettings = boundPool.StartTask.EnvironmentSettings;                            // confirm that the collections are non-null and have count-0                          Assert.NotNull(count0ResFiles);                          Assert.NotNull(count0EnvSettings);                          Assert.Empty(count0ResFiles);                          Assert.Empty(count0EnvSettings);                            //clean up                          boundPool.Delete();                            System.Threading.Thread.Sleep(5000); // wait for pool to be deleted                            // check pool create with empty-but-non-null collections                          {                              CloudPool myPool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: 0);                                StartTask st = new StartTask("dir");                              // use the empty collections from above                              st.ResourceFiles = emptyResfiles;                              st.EnvironmentSettings = emptyEnvSettings;                                // set the pool's start task so the collections get pushed                              myPool.StartTask = st;                                myPool.Commit();                          }                            boundPool = batchCli.PoolOperations.GetPool(poolId);                          boundST = boundPool.StartTask;                            count0ResFiles = boundPool.StartTask.ResourceFiles;                          count0EnvSettings = boundPool.StartTask.EnvironmentSettings;                            // confirm that the collections are non-null and have count-0                          Assert.NotNull(count0ResFiles);                          Assert.NotNull(count0EnvSettings);                          Assert.Empty(count0ResFiles);                          Assert.Empty(count0EnvSettings);                      }                      finally                      {                          // cleanup                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,Bug1433123PoolMissingResizeTimeout,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = "Bug1433123PoolMissingResizeTimeout-" + TestUtilities.GetMyName();                        try                      {                          TimeSpan referenceRST = TimeSpan.FromMinutes(5);                            // create a pool with env-settings and ResFiles                          {                              CloudPool myPool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: 0);                                // set the reference value                              myPool.ResizeTimeout = referenceRST;                                myPool.Commit();                          }                            // confirm pool has correct values                          CloudPool boundPool = batchCli.PoolOperations.GetPool(poolId);                            // confirm value is correct                          Assert.Equal(referenceRST' boundPool.ResizeTimeout);                            // confirm constraint does not allow changes to bound object                            TestUtilities.AssertThrows<InvalidOperationException>(() => boundPool.ResizeTimeout = TimeSpan.FromMinutes(1));                      }                      finally                      {                          // cleanup                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,Bug1656475PoolLifetimeOption,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jsId = "Bug1656475PoolLifetimeOption-" + TestUtilities.GetMyName();                        try                      {                          {                              CloudJobSchedule unboundJobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule();                              unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(10) };                              unboundJobSchedule.Id = jsId;                                AutoPoolSpecification iaps = new AutoPoolSpecification();                                // test that it can be read from unbound/unset object                              PoolLifetimeOption defaultVal = iaps.PoolLifetimeOption;                                // test it can be set on unbound and read back                              iaps.PoolLifetimeOption = PoolLifetimeOption.JobSchedule;                                // read it back and confirm value                              Assert.Equal(PoolLifetimeOption.JobSchedule' iaps.PoolLifetimeOption);                                unboundJobSchedule.JobSpecification = new JobSpecification(new PoolInformation() { AutoPoolSpecification = iaps });                                // make ias viable for adding the wi                              iaps.AutoPoolIdPrefix = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName();                                PoolSpecification ips = new PoolSpecification();                                iaps.PoolSpecification = ips;                                ips.TargetDedicatedComputeNodes = 0;                              ips.VirtualMachineSize = PoolFixture.VMSize;                                ips.CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily);                                unboundJobSchedule.Commit();                          }                            CloudJobSchedule boundJobSchedule = batchCli.JobScheduleOperations.GetJobSchedule(jsId);                            // confirm the PLO is set correctly on bound WI                          Assert.NotNull(boundJobSchedule);                          Assert.NotNull(boundJobSchedule.JobSpecification);                          Assert.NotNull(boundJobSchedule.JobSpecification.PoolInformation);                          Assert.NotNull(boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification);                            AutoPoolSpecification boundIAPS = boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification;                            Assert.Equal(PoolLifetimeOption.JobSchedule' boundIAPS.PoolLifetimeOption);                            // in phase 1 PLO is read-only on bound WI/APS so no tests to change it here                      }                      finally                      {                          // cleanup                          TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jsId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,Bug1432812SetAutoScaleMissingOnPoolPoolMgr,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = "Bug1432812-" + TestUtilities.GetMyName();                      const string poolASFormulaOrig = "$TargetDedicatedNodes=0;";                      const string poolASFormula2 = "$TargetDedicatedNodes=1;";                      // craft exactly how it would be returned by Evaluate so indexof can work                        try                      {                          // create a pool.. empty for now                          {                              CloudPool unboundPool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily));                                unboundPool.AutoScaleEnabled = true;                              unboundPool.AutoScaleFormula = poolASFormulaOrig;                                unboundPool.Commit();                                TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromSeconds(20)).Wait();                          }                            // EvaluteAutoScale                          CloudPool boundPool = batchCli.PoolOperations.GetPool(poolId);                            Assert.True(boundPool.AutoScaleEnabled.HasValue);                          Assert.True(boundPool.AutoScaleEnabled.Value);                          Assert.Equal(poolASFormulaOrig' boundPool.AutoScaleFormula);                            AutoScaleRun eval = boundPool.EvaluateAutoScale(poolASFormula2);                            Assert.Contains(poolASFormula2' eval.Results);                            // DisableAutoScale                          boundPool.DisableAutoScale();                            boundPool.Refresh();                            // autoscale should be disabled now                          Assert.True(boundPool.AutoScaleEnabled.HasValue);                          Assert.False(boundPool.AutoScaleEnabled.Value);                            // EnableAutoScale                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(5)).Wait();                            boundPool.EnableAutoScale(poolASFormula2);                            boundPool.Refresh();                            // confirm is enabled and formula has correct value                            Assert.True(boundPool.AutoScaleEnabled.HasValue);                          Assert.True(boundPool.AutoScaleEnabled.Value);                          Assert.Equal(poolASFormula2' boundPool.AutoScaleFormula);                        }                      finally                      {                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,Bug1432812SetAutoScaleMissingOnPoolPoolMgr,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = "Bug1432812-" + TestUtilities.GetMyName();                      const string poolASFormulaOrig = "$TargetDedicatedNodes=0;";                      const string poolASFormula2 = "$TargetDedicatedNodes=1;";                      // craft exactly how it would be returned by Evaluate so indexof can work                        try                      {                          // create a pool.. empty for now                          {                              CloudPool unboundPool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily));                                unboundPool.AutoScaleEnabled = true;                              unboundPool.AutoScaleFormula = poolASFormulaOrig;                                unboundPool.Commit();                                TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromSeconds(20)).Wait();                          }                            // EvaluteAutoScale                          CloudPool boundPool = batchCli.PoolOperations.GetPool(poolId);                            Assert.True(boundPool.AutoScaleEnabled.HasValue);                          Assert.True(boundPool.AutoScaleEnabled.Value);                          Assert.Equal(poolASFormulaOrig' boundPool.AutoScaleFormula);                            AutoScaleRun eval = boundPool.EvaluateAutoScale(poolASFormula2);                            Assert.Contains(poolASFormula2' eval.Results);                            // DisableAutoScale                          boundPool.DisableAutoScale();                            boundPool.Refresh();                            // autoscale should be disabled now                          Assert.True(boundPool.AutoScaleEnabled.HasValue);                          Assert.False(boundPool.AutoScaleEnabled.Value);                            // EnableAutoScale                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(5)).Wait();                            boundPool.EnableAutoScale(poolASFormula2);                            boundPool.Refresh();                            // confirm is enabled and formula has correct value                            Assert.True(boundPool.AutoScaleEnabled.HasValue);                          Assert.True(boundPool.AutoScaleEnabled.Value);                          Assert.Equal(poolASFormula2' boundPool.AutoScaleFormula);                        }                      finally                      {                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestListPoolUsageMetrics,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      // test via faking data                      DateTime endTime = DateTime.UtcNow.AddYears(-1);                      DateTime startTime = DateTime.UtcNow;                      const int totalCoreHours = 1;                      const string virtualMachineSize = "really really big";                        List<Protocol.Models.PoolUsageMetrics> pums = new List<Protocol.Models.PoolUsageMetrics>();                        // create some data to return                      for (int i = 0; i < 4; i++)                      {                          string id = "my fancy pool id " + i.ToString();                          Protocol.Models.PoolUsageMetrics newPum = new Protocol.Models.PoolUsageMetrics()                          {                              PoolId = id'                              EndTime = endTime'                              StartTime = startTime'                              TotalCoreHours = totalCoreHours'                              VmSize = virtualMachineSize                          };                            pums.Add(newPum);                      }                        // our injector of fake data                      TestListPoolUsageMetricsFakesYieldInjector injectsTheFakeData = new TestListPoolUsageMetricsFakesYieldInjector(pums);                        // trigger the call and get our own data back to be tested                      List<Microsoft.Azure.Batch.PoolUsageMetrics> clList = batchCli.PoolOperations.ListPoolUsageMetrics(additionalBehaviors: new[] { injectsTheFakeData }).ToList();                        // test that our data are honored                        for (int j = 0; j < 4; j++)                      {                          string id = "my fancy pool id " + j.ToString();                          Assert.Equal(id' clList[j].PoolId);                          Assert.Equal(endTime' clList[j].EndTime);                          Assert.Equal(startTime' clList[j].StartTime);                          Assert.Equal(totalCoreHours' clList[j].TotalCoreHours);                          Assert.Equal(virtualMachineSize' clList[j].VirtualMachineSize);                      }                        List<PoolUsageMetrics> list = batchCli.PoolOperations.ListPoolUsageMetrics(DateTime.Now - TimeSpan.FromDays(1)).ToList();                  }              };
Magic Number,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestListPoolUsageMetrics,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      // test via faking data                      DateTime endTime = DateTime.UtcNow.AddYears(-1);                      DateTime startTime = DateTime.UtcNow;                      const int totalCoreHours = 1;                      const string virtualMachineSize = "really really big";                        List<Protocol.Models.PoolUsageMetrics> pums = new List<Protocol.Models.PoolUsageMetrics>();                        // create some data to return                      for (int i = 0; i < 4; i++)                      {                          string id = "my fancy pool id " + i.ToString();                          Protocol.Models.PoolUsageMetrics newPum = new Protocol.Models.PoolUsageMetrics()                          {                              PoolId = id'                              EndTime = endTime'                              StartTime = startTime'                              TotalCoreHours = totalCoreHours'                              VmSize = virtualMachineSize                          };                            pums.Add(newPum);                      }                        // our injector of fake data                      TestListPoolUsageMetricsFakesYieldInjector injectsTheFakeData = new TestListPoolUsageMetricsFakesYieldInjector(pums);                        // trigger the call and get our own data back to be tested                      List<Microsoft.Azure.Batch.PoolUsageMetrics> clList = batchCli.PoolOperations.ListPoolUsageMetrics(additionalBehaviors: new[] { injectsTheFakeData }).ToList();                        // test that our data are honored                        for (int j = 0; j < 4; j++)                      {                          string id = "my fancy pool id " + j.ToString();                          Assert.Equal(id' clList[j].PoolId);                          Assert.Equal(endTime' clList[j].EndTime);                          Assert.Equal(startTime' clList[j].StartTime);                          Assert.Equal(totalCoreHours' clList[j].TotalCoreHours);                          Assert.Equal(virtualMachineSize' clList[j].VirtualMachineSize);                      }                        List<PoolUsageMetrics> list = batchCli.PoolOperations.ListPoolUsageMetrics(DateTime.Now - TimeSpan.FromDays(1)).ToList();                  }              };
Magic Number,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestPoolObjectResizeStopResize,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = "TestPoolObjectResizeStopResize" + TestUtilities.GetMyName();                      const int targetDedicated = 0;                      const int newTargetDedicated = 1;                      try                      {                          //Create a pool                          CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: targetDedicated);                          pool.Commit();                            TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromSeconds(20)).Wait();                            this.testOutputHelper.WriteLine($"Created pool {poolId}");                            CloudPool boundPool = batchCli.PoolOperations.GetPool(poolId);                            //Resize the pool                          boundPool.Resize(newTargetDedicated' 0);                            boundPool.Refresh();                          Assert.Equal(AllocationState.Resizing' boundPool.AllocationState);                            boundPool.StopResize();                          boundPool.Refresh();                            //The pool could be in stopping or steady state                          this.testOutputHelper.WriteLine($"Pool allocation state: {boundPool.AllocationState}");                          Assert.True(boundPool.AllocationState == AllocationState.Steady || boundPool.AllocationState == AllocationState.Stopping);                      }                      finally                      {                          //Delete the pool                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestPoolAutoscaleVerbs,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = TestUtilities.GenerateResourceId();                      const int targetDedicated = 0;                      const string autoscaleFormula1 = "$TargetDedicatedNodes=0;$TargetLowPriorityNodes=0;$NodeDeallocationOption=requeue";                      const string autoscaleFormula2 = "$TargetDedicatedNodes=0;$TargetLowPriorityNodes=0;$NodeDeallocationOption=terminate";                        const string evaluateAutoscaleFormula = "myActiveSamples=$ActiveTasks.GetSample(5);";                      TimeSpan enableAutoScaleMinimumDelay = TimeSpan.FromSeconds(30);  // compiler says can't be const                        try                      {                          //Create a pool                          CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicated);                          pool.Commit();                            TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromSeconds(20)).Wait();                            CloudPool boundPool = batchCli.PoolOperations.GetPool(poolId);                            //Enable autoscale (via instance)                          boundPool.EnableAutoScale(autoscaleFormula1);                          DateTime utcEarliestCanCallEnableASAgain = DateTime.UtcNow + enableAutoScaleMinimumDelay;                            boundPool.Refresh();                          Assert.True(boundPool.AutoScaleEnabled);                          Assert.Equal(autoscaleFormula1' boundPool.AutoScaleFormula);                          this.testOutputHelper.WriteLine($"Got the pool");                            Assert.NotNull(boundPool.AutoScaleRun);                          Assert.NotNull(boundPool.AutoScaleRun.Results);                          Assert.Contains(autoscaleFormula1' boundPool.AutoScaleRun.Results);                            //Evaluate a different formula                          AutoScaleRun evaluation = boundPool.EvaluateAutoScale(evaluateAutoscaleFormula);                            this.testOutputHelper.WriteLine("Autoscale evaluate results: {0}"' evaluation.Results);                            Assert.NotNull(evaluation.Results);                          Assert.Contains("myActiveSamples"' evaluation.Results);                            //Disable autoscale (via instance)                          boundPool.DisableAutoScale();                          boundPool.Refresh();                            Assert.False(boundPool.AutoScaleEnabled);                            //Wait for the pool to go to steady state                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(2)).Wait();                            // about to call EnableAutoScale again' must delay to avoid throttle exception                          if (DateTime.UtcNow < utcEarliestCanCallEnableASAgain)                          {                              TimeSpan delayBeforeNextEnableASCall = utcEarliestCanCallEnableASAgain - DateTime.UtcNow;                                Thread.Sleep(delayBeforeNextEnableASCall);                          }                            //Enable autoscale (via operations)                          batchCli.PoolOperations.EnableAutoScale(poolId' autoscaleFormula2);                          boundPool.Refresh();                            Assert.True(boundPool.AutoScaleEnabled);                          Assert.Equal(autoscaleFormula2' boundPool.AutoScaleFormula);                          Assert.NotNull(boundPool.AutoScaleRun);                          Assert.NotNull(boundPool.AutoScaleRun.Results);                          Assert.Contains(autoscaleFormula2' boundPool.AutoScaleRun.Results);                            evaluation = batchCli.PoolOperations.EvaluateAutoScale(poolId' evaluateAutoscaleFormula);                            this.testOutputHelper.WriteLine("Autoscale evaluate results: {0}"' evaluation.Results);                            Assert.NotNull(evaluation);                          Assert.Contains("myActiveSamples"' evaluation.Results);                            batchCli.PoolOperations.DisableAutoScale(poolId);                          boundPool.Refresh();                            Assert.False(boundPool.AutoScaleEnabled);                      }                      finally                      {                          //Delete the pool                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestPoolAutoscaleVerbs,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = TestUtilities.GenerateResourceId();                      const int targetDedicated = 0;                      const string autoscaleFormula1 = "$TargetDedicatedNodes=0;$TargetLowPriorityNodes=0;$NodeDeallocationOption=requeue";                      const string autoscaleFormula2 = "$TargetDedicatedNodes=0;$TargetLowPriorityNodes=0;$NodeDeallocationOption=terminate";                        const string evaluateAutoscaleFormula = "myActiveSamples=$ActiveTasks.GetSample(5);";                      TimeSpan enableAutoScaleMinimumDelay = TimeSpan.FromSeconds(30);  // compiler says can't be const                        try                      {                          //Create a pool                          CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicated);                          pool.Commit();                            TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromSeconds(20)).Wait();                            CloudPool boundPool = batchCli.PoolOperations.GetPool(poolId);                            //Enable autoscale (via instance)                          boundPool.EnableAutoScale(autoscaleFormula1);                          DateTime utcEarliestCanCallEnableASAgain = DateTime.UtcNow + enableAutoScaleMinimumDelay;                            boundPool.Refresh();                          Assert.True(boundPool.AutoScaleEnabled);                          Assert.Equal(autoscaleFormula1' boundPool.AutoScaleFormula);                          this.testOutputHelper.WriteLine($"Got the pool");                            Assert.NotNull(boundPool.AutoScaleRun);                          Assert.NotNull(boundPool.AutoScaleRun.Results);                          Assert.Contains(autoscaleFormula1' boundPool.AutoScaleRun.Results);                            //Evaluate a different formula                          AutoScaleRun evaluation = boundPool.EvaluateAutoScale(evaluateAutoscaleFormula);                            this.testOutputHelper.WriteLine("Autoscale evaluate results: {0}"' evaluation.Results);                            Assert.NotNull(evaluation.Results);                          Assert.Contains("myActiveSamples"' evaluation.Results);                            //Disable autoscale (via instance)                          boundPool.DisableAutoScale();                          boundPool.Refresh();                            Assert.False(boundPool.AutoScaleEnabled);                            //Wait for the pool to go to steady state                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(2)).Wait();                            // about to call EnableAutoScale again' must delay to avoid throttle exception                          if (DateTime.UtcNow < utcEarliestCanCallEnableASAgain)                          {                              TimeSpan delayBeforeNextEnableASCall = utcEarliestCanCallEnableASAgain - DateTime.UtcNow;                                Thread.Sleep(delayBeforeNextEnableASCall);                          }                            //Enable autoscale (via operations)                          batchCli.PoolOperations.EnableAutoScale(poolId' autoscaleFormula2);                          boundPool.Refresh();                            Assert.True(boundPool.AutoScaleEnabled);                          Assert.Equal(autoscaleFormula2' boundPool.AutoScaleFormula);                          Assert.NotNull(boundPool.AutoScaleRun);                          Assert.NotNull(boundPool.AutoScaleRun.Results);                          Assert.Contains(autoscaleFormula2' boundPool.AutoScaleRun.Results);                            evaluation = batchCli.PoolOperations.EvaluateAutoScale(poolId' evaluateAutoscaleFormula);                            this.testOutputHelper.WriteLine("Autoscale evaluate results: {0}"' evaluation.Results);                            Assert.NotNull(evaluation);                          Assert.Contains("myActiveSamples"' evaluation.Results);                            batchCli.PoolOperations.DisableAutoScale(poolId);                          boundPool.Refresh();                            Assert.False(boundPool.AutoScaleEnabled);                      }                      finally                      {                          //Delete the pool                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestPoolAutoscaleVerbs,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = TestUtilities.GenerateResourceId();                      const int targetDedicated = 0;                      const string autoscaleFormula1 = "$TargetDedicatedNodes=0;$TargetLowPriorityNodes=0;$NodeDeallocationOption=requeue";                      const string autoscaleFormula2 = "$TargetDedicatedNodes=0;$TargetLowPriorityNodes=0;$NodeDeallocationOption=terminate";                        const string evaluateAutoscaleFormula = "myActiveSamples=$ActiveTasks.GetSample(5);";                      TimeSpan enableAutoScaleMinimumDelay = TimeSpan.FromSeconds(30);  // compiler says can't be const                        try                      {                          //Create a pool                          CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicated);                          pool.Commit();                            TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromSeconds(20)).Wait();                            CloudPool boundPool = batchCli.PoolOperations.GetPool(poolId);                            //Enable autoscale (via instance)                          boundPool.EnableAutoScale(autoscaleFormula1);                          DateTime utcEarliestCanCallEnableASAgain = DateTime.UtcNow + enableAutoScaleMinimumDelay;                            boundPool.Refresh();                          Assert.True(boundPool.AutoScaleEnabled);                          Assert.Equal(autoscaleFormula1' boundPool.AutoScaleFormula);                          this.testOutputHelper.WriteLine($"Got the pool");                            Assert.NotNull(boundPool.AutoScaleRun);                          Assert.NotNull(boundPool.AutoScaleRun.Results);                          Assert.Contains(autoscaleFormula1' boundPool.AutoScaleRun.Results);                            //Evaluate a different formula                          AutoScaleRun evaluation = boundPool.EvaluateAutoScale(evaluateAutoscaleFormula);                            this.testOutputHelper.WriteLine("Autoscale evaluate results: {0}"' evaluation.Results);                            Assert.NotNull(evaluation.Results);                          Assert.Contains("myActiveSamples"' evaluation.Results);                            //Disable autoscale (via instance)                          boundPool.DisableAutoScale();                          boundPool.Refresh();                            Assert.False(boundPool.AutoScaleEnabled);                            //Wait for the pool to go to steady state                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(2)).Wait();                            // about to call EnableAutoScale again' must delay to avoid throttle exception                          if (DateTime.UtcNow < utcEarliestCanCallEnableASAgain)                          {                              TimeSpan delayBeforeNextEnableASCall = utcEarliestCanCallEnableASAgain - DateTime.UtcNow;                                Thread.Sleep(delayBeforeNextEnableASCall);                          }                            //Enable autoscale (via operations)                          batchCli.PoolOperations.EnableAutoScale(poolId' autoscaleFormula2);                          boundPool.Refresh();                            Assert.True(boundPool.AutoScaleEnabled);                          Assert.Equal(autoscaleFormula2' boundPool.AutoScaleFormula);                          Assert.NotNull(boundPool.AutoScaleRun);                          Assert.NotNull(boundPool.AutoScaleRun.Results);                          Assert.Contains(autoscaleFormula2' boundPool.AutoScaleRun.Results);                            evaluation = batchCli.PoolOperations.EvaluateAutoScale(poolId' evaluateAutoscaleFormula);                            this.testOutputHelper.WriteLine("Autoscale evaluate results: {0}"' evaluation.Results);                            Assert.NotNull(evaluation);                          Assert.Contains("myActiveSamples"' evaluation.Results);                            batchCli.PoolOperations.DisableAutoScale(poolId);                          boundPool.Refresh();                            Assert.False(boundPool.AutoScaleEnabled);                      }                      finally                      {                          //Delete the pool                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestPoolCreatedDataDiskSucceeds,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClientFromEnvironmentAsync().Result)                  {                      string poolId = nameof(TestPoolCreatedDataDiskSucceeds) + TestUtilities.GetMyName();                      const int targetDedicated = 0;                      try                      {                          var imageDetails = IaasLinuxPoolFixture.GetUbuntuImageDetails(batchCli);                          const int lun = 50;                          const int diskSizeGB = 50;                            //Create a pool                          CloudPool pool = batchCli.PoolOperations.CreatePool(                              poolId'                              PoolFixture.VMSize'                              new VirtualMachineConfiguration(                                  imageDetails.ImageReference'                                  imageDetails.NodeAgentSkuId)                              {                                  DataDisks =  new List<DataDisk>                                  {                                      new DataDisk(lun' diskSizeGB)                                  }                              }'                              targetDedicated);                          pool.Commit();                          pool.Refresh();                            Assert.Equal(lun' pool.VirtualMachineConfiguration.DataDisks.Single().Lun);                          Assert.Equal(diskSizeGB' pool.VirtualMachineConfiguration.DataDisks.Single().DiskSizeGB);                      }                      finally                      {                          //Delete the pool                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,TestPoolCreatedDataDiskSucceeds,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClientFromEnvironmentAsync().Result)                  {                      string poolId = nameof(TestPoolCreatedDataDiskSucceeds) + TestUtilities.GetMyName();                      const int targetDedicated = 0;                      try                      {                          var imageDetails = IaasLinuxPoolFixture.GetUbuntuImageDetails(batchCli);                          const int lun = 50;                          const int diskSizeGB = 50;                            //Create a pool                          CloudPool pool = batchCli.PoolOperations.CreatePool(                              poolId'                              PoolFixture.VMSize'                              new VirtualMachineConfiguration(                                  imageDetails.ImageReference'                                  imageDetails.NodeAgentSkuId)                              {                                  DataDisks =  new List<DataDisk>                                  {                                      new DataDisk(lun' diskSizeGB)                                  }                              }'                              targetDedicated);                          pool.Commit();                          pool.Refresh();                            Assert.Equal(lun' pool.VirtualMachineConfiguration.DataDisks.Single().Lun);                          Assert.Equal(diskSizeGB' pool.VirtualMachineConfiguration.DataDisks.Single().DiskSizeGB);                      }                      finally                      {                          //Delete the pool                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,ResizePool_AcceptedByServer,The following statement contains a magic number: Func<Task> test = async () =>              {                  using (BatchClient batchCli = await TestUtilities.OpenBatchClientFromEnvironmentAsync().ConfigureAwait(false))                  {                      string poolId = TestUtilities.GenerateResourceId();                        try                      {                          CloudPool pool = batchCli.PoolOperations.CreatePool(                              poolId'                              PoolFixture.VMSize'                              new CloudServiceConfiguration(PoolFixture.OSFamily));                            await pool.CommitAsync().ConfigureAwait(false);                          await pool.RefreshAsync().ConfigureAwait(false);                            await TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(1));                            await pool.ResizeAsync(                              targetDedicatedComputeNodes: targetDedicated'                              targetLowPriorityComputeNodes: targetLowPriority'                              resizeTimeout: TimeSpan.FromMinutes(10)).ConfigureAwait(false);                          await pool.RefreshAsync().ConfigureAwait(false);                            Assert.Equal(targetDedicated ?? 0' pool.TargetDedicatedComputeNodes);                          Assert.Equal(targetLowPriority ?? 0' pool.TargetLowPriorityComputeNodes);                          Assert.Equal(AllocationState.Resizing' pool.AllocationState);                      }                      finally                      {                          await TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).ConfigureAwait(false);                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudPoolIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,ListSupportedImages,The following statement contains a magic number: SynchronizationContextHelper.RunTest(test' timeout: TimeSpan.FromSeconds(60));
Magic Number,BatchClientIntegrationTests,IntegrationCloudPoolLongRunningTests01,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_RemovePoolComputeNodesResizeTimeout_ResizeErrorsPopulated,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = "Bug2251050_TestRemoveComputeNodesResizeTimeout_LR" + TestUtilities.GetMyName();                      string jobId = "Bug2251050Job-" + TestUtilities.GetMyName();                      const int targetDedicated = 2;                      try                      {                          //Create a pool with 2 compute nodes                          CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: targetDedicated);                          pool.Commit();                            this.testOutputHelper.WriteLine("Created pool {0}"' poolId);                            CloudPool refreshablePool = batchCli.PoolOperations.GetPool(poolId);                          //Wait for compute node allocation                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(5)).Wait();                          refreshablePool.Refresh();                          Assert.Equal(targetDedicated' refreshablePool.CurrentDedicatedComputeNodes);                            IEnumerable<ComputeNode> computeNodes = refreshablePool.ListComputeNodes();                            Assert.Equal(targetDedicated' computeNodes.Count());                            //                          //Create a job on this pool with targetDedicated tasks which run for 10m each                          //                          CloudJob workflowJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = poolId });                          workflowJob.Commit();                            const int taskDurationSeconds = 600;                          string taskCmdLine = string.Format("ping 127.0.0.1 -n {0}"' taskDurationSeconds);                            for (int i = 0; i < targetDedicated; i++)                          {                              string taskId = string.Format("T_{0}"' i);                              batchCli.JobOperations.AddTask(jobId' new CloudTask(taskId' taskCmdLine));                          }                            //                          // Wait for tasks to both go to running                          //                          Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Running'                              TimeSpan.FromMinutes(20));                            //                          // Remove pool compute nodes                          //                          TimeSpan resizeTimeout = TimeSpan.FromMinutes(5);                          batchCli.PoolOperations.RemoveFromPool(poolId' computeNodes' ComputeNodeDeallocationOption.TaskCompletion' resizeTimeout);                            //                          // Wait for the resize to timeout                          //                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(6)).Wait();                          refreshablePool.Refresh();                            Assert.NotNull(refreshablePool.ResizeErrors);                          Assert.Equal(1' refreshablePool.ResizeErrors.Count);                            var resizeError = refreshablePool.ResizeErrors.Single();                          Assert.Equal(PoolResizeErrorCodes.AllocationTimedOut' resizeError.Code);                            this.testOutputHelper.WriteLine("Resize error: {0}"' resizeError.Message);                      }                      finally                      {                          //Delete the pool                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                            //Delete the job schedule                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudPoolLongRunningTests01,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_RemovePoolComputeNodesResizeTimeout_ResizeErrorsPopulated,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = "Bug2251050_TestRemoveComputeNodesResizeTimeout_LR" + TestUtilities.GetMyName();                      string jobId = "Bug2251050Job-" + TestUtilities.GetMyName();                      const int targetDedicated = 2;                      try                      {                          //Create a pool with 2 compute nodes                          CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: targetDedicated);                          pool.Commit();                            this.testOutputHelper.WriteLine("Created pool {0}"' poolId);                            CloudPool refreshablePool = batchCli.PoolOperations.GetPool(poolId);                          //Wait for compute node allocation                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(5)).Wait();                          refreshablePool.Refresh();                          Assert.Equal(targetDedicated' refreshablePool.CurrentDedicatedComputeNodes);                            IEnumerable<ComputeNode> computeNodes = refreshablePool.ListComputeNodes();                            Assert.Equal(targetDedicated' computeNodes.Count());                            //                          //Create a job on this pool with targetDedicated tasks which run for 10m each                          //                          CloudJob workflowJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = poolId });                          workflowJob.Commit();                            const int taskDurationSeconds = 600;                          string taskCmdLine = string.Format("ping 127.0.0.1 -n {0}"' taskDurationSeconds);                            for (int i = 0; i < targetDedicated; i++)                          {                              string taskId = string.Format("T_{0}"' i);                              batchCli.JobOperations.AddTask(jobId' new CloudTask(taskId' taskCmdLine));                          }                            //                          // Wait for tasks to both go to running                          //                          Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Running'                              TimeSpan.FromMinutes(20));                            //                          // Remove pool compute nodes                          //                          TimeSpan resizeTimeout = TimeSpan.FromMinutes(5);                          batchCli.PoolOperations.RemoveFromPool(poolId' computeNodes' ComputeNodeDeallocationOption.TaskCompletion' resizeTimeout);                            //                          // Wait for the resize to timeout                          //                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(6)).Wait();                          refreshablePool.Refresh();                            Assert.NotNull(refreshablePool.ResizeErrors);                          Assert.Equal(1' refreshablePool.ResizeErrors.Count);                            var resizeError = refreshablePool.ResizeErrors.Single();                          Assert.Equal(PoolResizeErrorCodes.AllocationTimedOut' resizeError.Code);                            this.testOutputHelper.WriteLine("Resize error: {0}"' resizeError.Message);                      }                      finally                      {                          //Delete the pool                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                            //Delete the job schedule                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudPoolLongRunningTests01,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_RemovePoolComputeNodesResizeTimeout_ResizeErrorsPopulated,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = "Bug2251050_TestRemoveComputeNodesResizeTimeout_LR" + TestUtilities.GetMyName();                      string jobId = "Bug2251050Job-" + TestUtilities.GetMyName();                      const int targetDedicated = 2;                      try                      {                          //Create a pool with 2 compute nodes                          CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: targetDedicated);                          pool.Commit();                            this.testOutputHelper.WriteLine("Created pool {0}"' poolId);                            CloudPool refreshablePool = batchCli.PoolOperations.GetPool(poolId);                          //Wait for compute node allocation                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(5)).Wait();                          refreshablePool.Refresh();                          Assert.Equal(targetDedicated' refreshablePool.CurrentDedicatedComputeNodes);                            IEnumerable<ComputeNode> computeNodes = refreshablePool.ListComputeNodes();                            Assert.Equal(targetDedicated' computeNodes.Count());                            //                          //Create a job on this pool with targetDedicated tasks which run for 10m each                          //                          CloudJob workflowJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = poolId });                          workflowJob.Commit();                            const int taskDurationSeconds = 600;                          string taskCmdLine = string.Format("ping 127.0.0.1 -n {0}"' taskDurationSeconds);                            for (int i = 0; i < targetDedicated; i++)                          {                              string taskId = string.Format("T_{0}"' i);                              batchCli.JobOperations.AddTask(jobId' new CloudTask(taskId' taskCmdLine));                          }                            //                          // Wait for tasks to both go to running                          //                          Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Running'                              TimeSpan.FromMinutes(20));                            //                          // Remove pool compute nodes                          //                          TimeSpan resizeTimeout = TimeSpan.FromMinutes(5);                          batchCli.PoolOperations.RemoveFromPool(poolId' computeNodes' ComputeNodeDeallocationOption.TaskCompletion' resizeTimeout);                            //                          // Wait for the resize to timeout                          //                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(6)).Wait();                          refreshablePool.Refresh();                            Assert.NotNull(refreshablePool.ResizeErrors);                          Assert.Equal(1' refreshablePool.ResizeErrors.Count);                            var resizeError = refreshablePool.ResizeErrors.Single();                          Assert.Equal(PoolResizeErrorCodes.AllocationTimedOut' resizeError.Code);                            this.testOutputHelper.WriteLine("Resize error: {0}"' resizeError.Message);                      }                      finally                      {                          //Delete the pool                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                            //Delete the job schedule                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudPoolLongRunningTests01,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_RemovePoolComputeNodesResizeTimeout_ResizeErrorsPopulated,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = "Bug2251050_TestRemoveComputeNodesResizeTimeout_LR" + TestUtilities.GetMyName();                      string jobId = "Bug2251050Job-" + TestUtilities.GetMyName();                      const int targetDedicated = 2;                      try                      {                          //Create a pool with 2 compute nodes                          CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: targetDedicated);                          pool.Commit();                            this.testOutputHelper.WriteLine("Created pool {0}"' poolId);                            CloudPool refreshablePool = batchCli.PoolOperations.GetPool(poolId);                          //Wait for compute node allocation                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(5)).Wait();                          refreshablePool.Refresh();                          Assert.Equal(targetDedicated' refreshablePool.CurrentDedicatedComputeNodes);                            IEnumerable<ComputeNode> computeNodes = refreshablePool.ListComputeNodes();                            Assert.Equal(targetDedicated' computeNodes.Count());                            //                          //Create a job on this pool with targetDedicated tasks which run for 10m each                          //                          CloudJob workflowJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = poolId });                          workflowJob.Commit();                            const int taskDurationSeconds = 600;                          string taskCmdLine = string.Format("ping 127.0.0.1 -n {0}"' taskDurationSeconds);                            for (int i = 0; i < targetDedicated; i++)                          {                              string taskId = string.Format("T_{0}"' i);                              batchCli.JobOperations.AddTask(jobId' new CloudTask(taskId' taskCmdLine));                          }                            //                          // Wait for tasks to both go to running                          //                          Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Running'                              TimeSpan.FromMinutes(20));                            //                          // Remove pool compute nodes                          //                          TimeSpan resizeTimeout = TimeSpan.FromMinutes(5);                          batchCli.PoolOperations.RemoveFromPool(poolId' computeNodes' ComputeNodeDeallocationOption.TaskCompletion' resizeTimeout);                            //                          // Wait for the resize to timeout                          //                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(6)).Wait();                          refreshablePool.Refresh();                            Assert.NotNull(refreshablePool.ResizeErrors);                          Assert.Equal(1' refreshablePool.ResizeErrors.Count);                            var resizeError = refreshablePool.ResizeErrors.Single();                          Assert.Equal(PoolResizeErrorCodes.AllocationTimedOut' resizeError.Code);                            this.testOutputHelper.WriteLine("Resize error: {0}"' resizeError.Message);                      }                      finally                      {                          //Delete the pool                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                            //Delete the job schedule                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudPoolLongRunningTests01,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_RemovePoolComputeNodesResizeTimeout_ResizeErrorsPopulated,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = "Bug2251050_TestRemoveComputeNodesResizeTimeout_LR" + TestUtilities.GetMyName();                      string jobId = "Bug2251050Job-" + TestUtilities.GetMyName();                      const int targetDedicated = 2;                      try                      {                          //Create a pool with 2 compute nodes                          CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: targetDedicated);                          pool.Commit();                            this.testOutputHelper.WriteLine("Created pool {0}"' poolId);                            CloudPool refreshablePool = batchCli.PoolOperations.GetPool(poolId);                          //Wait for compute node allocation                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(5)).Wait();                          refreshablePool.Refresh();                          Assert.Equal(targetDedicated' refreshablePool.CurrentDedicatedComputeNodes);                            IEnumerable<ComputeNode> computeNodes = refreshablePool.ListComputeNodes();                            Assert.Equal(targetDedicated' computeNodes.Count());                            //                          //Create a job on this pool with targetDedicated tasks which run for 10m each                          //                          CloudJob workflowJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = poolId });                          workflowJob.Commit();                            const int taskDurationSeconds = 600;                          string taskCmdLine = string.Format("ping 127.0.0.1 -n {0}"' taskDurationSeconds);                            for (int i = 0; i < targetDedicated; i++)                          {                              string taskId = string.Format("T_{0}"' i);                              batchCli.JobOperations.AddTask(jobId' new CloudTask(taskId' taskCmdLine));                          }                            //                          // Wait for tasks to both go to running                          //                          Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Running'                              TimeSpan.FromMinutes(20));                            //                          // Remove pool compute nodes                          //                          TimeSpan resizeTimeout = TimeSpan.FromMinutes(5);                          batchCli.PoolOperations.RemoveFromPool(poolId' computeNodes' ComputeNodeDeallocationOption.TaskCompletion' resizeTimeout);                            //                          // Wait for the resize to timeout                          //                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(6)).Wait();                          refreshablePool.Refresh();                            Assert.NotNull(refreshablePool.ResizeErrors);                          Assert.Equal(1' refreshablePool.ResizeErrors.Count);                            var resizeError = refreshablePool.ResizeErrors.Single();                          Assert.Equal(PoolResizeErrorCodes.AllocationTimedOut' resizeError.Code);                            this.testOutputHelper.WriteLine("Resize error: {0}"' resizeError.Message);                      }                      finally                      {                          //Delete the pool                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                            //Delete the job schedule                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudPoolLongRunningTests01,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_RemovePoolComputeNodesResizeTimeout_ResizeErrorsPopulated,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = "Bug2251050_TestRemoveComputeNodesResizeTimeout_LR" + TestUtilities.GetMyName();                      string jobId = "Bug2251050Job-" + TestUtilities.GetMyName();                      const int targetDedicated = 2;                      try                      {                          //Create a pool with 2 compute nodes                          CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: targetDedicated);                          pool.Commit();                            this.testOutputHelper.WriteLine("Created pool {0}"' poolId);                            CloudPool refreshablePool = batchCli.PoolOperations.GetPool(poolId);                          //Wait for compute node allocation                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(5)).Wait();                          refreshablePool.Refresh();                          Assert.Equal(targetDedicated' refreshablePool.CurrentDedicatedComputeNodes);                            IEnumerable<ComputeNode> computeNodes = refreshablePool.ListComputeNodes();                            Assert.Equal(targetDedicated' computeNodes.Count());                            //                          //Create a job on this pool with targetDedicated tasks which run for 10m each                          //                          CloudJob workflowJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = poolId });                          workflowJob.Commit();                            const int taskDurationSeconds = 600;                          string taskCmdLine = string.Format("ping 127.0.0.1 -n {0}"' taskDurationSeconds);                            for (int i = 0; i < targetDedicated; i++)                          {                              string taskId = string.Format("T_{0}"' i);                              batchCli.JobOperations.AddTask(jobId' new CloudTask(taskId' taskCmdLine));                          }                            //                          // Wait for tasks to both go to running                          //                          Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Running'                              TimeSpan.FromMinutes(20));                            //                          // Remove pool compute nodes                          //                          TimeSpan resizeTimeout = TimeSpan.FromMinutes(5);                          batchCli.PoolOperations.RemoveFromPool(poolId' computeNodes' ComputeNodeDeallocationOption.TaskCompletion' resizeTimeout);                            //                          // Wait for the resize to timeout                          //                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(6)).Wait();                          refreshablePool.Refresh();                            Assert.NotNull(refreshablePool.ResizeErrors);                          Assert.Equal(1' refreshablePool.ResizeErrors.Count);                            var resizeError = refreshablePool.ResizeErrors.Single();                          Assert.Equal(PoolResizeErrorCodes.AllocationTimedOut' resizeError.Code);                            this.testOutputHelper.WriteLine("Resize error: {0}"' resizeError.Message);                      }                      finally                      {                          //Delete the pool                          TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).Wait();                            //Delete the job schedule                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudPoolLongRunningTests02,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_TestRemovePoolComputeNodes,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = "TestRemovePoolComputeNodes_LongRunning" + TestUtilities.GetMyName();                      const int targetDedicated = 3;                      try                      {                          //Create a pool                          CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: targetDedicated);                            pool.Commit();                            this.testOutputHelper.WriteLine("Created pool {0}"' poolId);                            CloudPool refreshablePool = batchCli.PoolOperations.GetPool(poolId);                          //Wait for compute node allocation                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                          refreshablePool.Refresh();                          Assert.Equal(targetDedicated' refreshablePool.CurrentDedicatedComputeNodes);                            IEnumerable<ComputeNode> computeNodes = refreshablePool.ListComputeNodes();                            Assert.Equal(targetDedicated' computeNodes.Count());                            //                          //Remove first compute node from the pool                          //                          ComputeNode computeNodeToRemove = computeNodes.First();                            //For Bug234298 ensure start task property doesn't throw                          Assert.Null(computeNodeToRemove.StartTask);                            this.testOutputHelper.WriteLine("Will remove compute node: {0}"' computeNodeToRemove.Id);                            //Remove the compute node from the pool by instance                          refreshablePool.RemoveFromPool(computeNodeToRemove);                            //Wait for pool to got to steady state again                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                            refreshablePool.Refresh();                          //Ensure that the other ComputeNodes were not impacted and we now have 1 less ComputeNode                          List<ComputeNode> computeNodesAfterRemove = refreshablePool.ListComputeNodes().ToList();                            Assert.Equal(targetDedicated - 1' computeNodesAfterRemove.Count);                            List<string> remainingComputeNodeIds = computeNodesAfterRemove.Select(computeNode => computeNode.Id).ToList();                          foreach (ComputeNode originalComputeNode in computeNodes)                          {                              Assert.Contains(originalComputeNode.Id' remainingComputeNodeIds);                          }                            this.testOutputHelper.WriteLine("Verified that the compute node was removed correctly");                            //                          //Remove a second compute node from the pool                          //                            ComputeNode secondComputeNodeToRemove = computeNodesAfterRemove.First();                          string secondComputeNodeToRemoveId = secondComputeNodeToRemove.Id;                            //Remove the IComputeNode from the pool by id                          refreshablePool.RemoveFromPool(secondComputeNodeToRemoveId);                            //Wait for pool to got to steady state again                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                          refreshablePool.Refresh();                            //Ensure that the other ComputeNodes were not impacted and we now have 1 less ComputeNode                          computeNodesAfterRemove = refreshablePool.ListComputeNodes().ToList();                            Assert.Single(computeNodesAfterRemove);                            this.testOutputHelper.WriteLine("Verified that the compute node was removed correctly");                            //                          //Remove a 3rd compute node from pool                          //                            ComputeNode thirdComputeNodeToRemove = computeNodesAfterRemove.First();                          string thirdComputeNodeToRemoveId = thirdComputeNodeToRemove.Id;                          this.testOutputHelper.WriteLine("Will remove compute node: {0}"' thirdComputeNodeToRemoveId);                            //Remove the IComputeNode from the pool using the ComputeNode object                          thirdComputeNodeToRemove.RemoveFromPool();                            //Wait for pool to got to steady state again                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                            //Ensure that the other ComputeNodes were not impacted and we now have 1 less ComputeNode                          computeNodesAfterRemove = refreshablePool.ListComputeNodes().ToList();                          Assert.Empty(computeNodesAfterRemove);                            this.testOutputHelper.WriteLine("Verified that the ComputeNode was removed correctly");                      }                      finally                      {                          //Delete the pool                          batchCli.PoolOperations.DeletePool(poolId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudPoolLongRunningTests02,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_TestRemovePoolComputeNodes,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = "TestRemovePoolComputeNodes_LongRunning" + TestUtilities.GetMyName();                      const int targetDedicated = 3;                      try                      {                          //Create a pool                          CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: targetDedicated);                            pool.Commit();                            this.testOutputHelper.WriteLine("Created pool {0}"' poolId);                            CloudPool refreshablePool = batchCli.PoolOperations.GetPool(poolId);                          //Wait for compute node allocation                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                          refreshablePool.Refresh();                          Assert.Equal(targetDedicated' refreshablePool.CurrentDedicatedComputeNodes);                            IEnumerable<ComputeNode> computeNodes = refreshablePool.ListComputeNodes();                            Assert.Equal(targetDedicated' computeNodes.Count());                            //                          //Remove first compute node from the pool                          //                          ComputeNode computeNodeToRemove = computeNodes.First();                            //For Bug234298 ensure start task property doesn't throw                          Assert.Null(computeNodeToRemove.StartTask);                            this.testOutputHelper.WriteLine("Will remove compute node: {0}"' computeNodeToRemove.Id);                            //Remove the compute node from the pool by instance                          refreshablePool.RemoveFromPool(computeNodeToRemove);                            //Wait for pool to got to steady state again                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                            refreshablePool.Refresh();                          //Ensure that the other ComputeNodes were not impacted and we now have 1 less ComputeNode                          List<ComputeNode> computeNodesAfterRemove = refreshablePool.ListComputeNodes().ToList();                            Assert.Equal(targetDedicated - 1' computeNodesAfterRemove.Count);                            List<string> remainingComputeNodeIds = computeNodesAfterRemove.Select(computeNode => computeNode.Id).ToList();                          foreach (ComputeNode originalComputeNode in computeNodes)                          {                              Assert.Contains(originalComputeNode.Id' remainingComputeNodeIds);                          }                            this.testOutputHelper.WriteLine("Verified that the compute node was removed correctly");                            //                          //Remove a second compute node from the pool                          //                            ComputeNode secondComputeNodeToRemove = computeNodesAfterRemove.First();                          string secondComputeNodeToRemoveId = secondComputeNodeToRemove.Id;                            //Remove the IComputeNode from the pool by id                          refreshablePool.RemoveFromPool(secondComputeNodeToRemoveId);                            //Wait for pool to got to steady state again                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                          refreshablePool.Refresh();                            //Ensure that the other ComputeNodes were not impacted and we now have 1 less ComputeNode                          computeNodesAfterRemove = refreshablePool.ListComputeNodes().ToList();                            Assert.Single(computeNodesAfterRemove);                            this.testOutputHelper.WriteLine("Verified that the compute node was removed correctly");                            //                          //Remove a 3rd compute node from pool                          //                            ComputeNode thirdComputeNodeToRemove = computeNodesAfterRemove.First();                          string thirdComputeNodeToRemoveId = thirdComputeNodeToRemove.Id;                          this.testOutputHelper.WriteLine("Will remove compute node: {0}"' thirdComputeNodeToRemoveId);                            //Remove the IComputeNode from the pool using the ComputeNode object                          thirdComputeNodeToRemove.RemoveFromPool();                            //Wait for pool to got to steady state again                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                            //Ensure that the other ComputeNodes were not impacted and we now have 1 less ComputeNode                          computeNodesAfterRemove = refreshablePool.ListComputeNodes().ToList();                          Assert.Empty(computeNodesAfterRemove);                            this.testOutputHelper.WriteLine("Verified that the ComputeNode was removed correctly");                      }                      finally                      {                          //Delete the pool                          batchCli.PoolOperations.DeletePool(poolId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudPoolLongRunningTests02,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_TestRemovePoolComputeNodes,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = "TestRemovePoolComputeNodes_LongRunning" + TestUtilities.GetMyName();                      const int targetDedicated = 3;                      try                      {                          //Create a pool                          CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: targetDedicated);                            pool.Commit();                            this.testOutputHelper.WriteLine("Created pool {0}"' poolId);                            CloudPool refreshablePool = batchCli.PoolOperations.GetPool(poolId);                          //Wait for compute node allocation                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                          refreshablePool.Refresh();                          Assert.Equal(targetDedicated' refreshablePool.CurrentDedicatedComputeNodes);                            IEnumerable<ComputeNode> computeNodes = refreshablePool.ListComputeNodes();                            Assert.Equal(targetDedicated' computeNodes.Count());                            //                          //Remove first compute node from the pool                          //                          ComputeNode computeNodeToRemove = computeNodes.First();                            //For Bug234298 ensure start task property doesn't throw                          Assert.Null(computeNodeToRemove.StartTask);                            this.testOutputHelper.WriteLine("Will remove compute node: {0}"' computeNodeToRemove.Id);                            //Remove the compute node from the pool by instance                          refreshablePool.RemoveFromPool(computeNodeToRemove);                            //Wait for pool to got to steady state again                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                            refreshablePool.Refresh();                          //Ensure that the other ComputeNodes were not impacted and we now have 1 less ComputeNode                          List<ComputeNode> computeNodesAfterRemove = refreshablePool.ListComputeNodes().ToList();                            Assert.Equal(targetDedicated - 1' computeNodesAfterRemove.Count);                            List<string> remainingComputeNodeIds = computeNodesAfterRemove.Select(computeNode => computeNode.Id).ToList();                          foreach (ComputeNode originalComputeNode in computeNodes)                          {                              Assert.Contains(originalComputeNode.Id' remainingComputeNodeIds);                          }                            this.testOutputHelper.WriteLine("Verified that the compute node was removed correctly");                            //                          //Remove a second compute node from the pool                          //                            ComputeNode secondComputeNodeToRemove = computeNodesAfterRemove.First();                          string secondComputeNodeToRemoveId = secondComputeNodeToRemove.Id;                            //Remove the IComputeNode from the pool by id                          refreshablePool.RemoveFromPool(secondComputeNodeToRemoveId);                            //Wait for pool to got to steady state again                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                          refreshablePool.Refresh();                            //Ensure that the other ComputeNodes were not impacted and we now have 1 less ComputeNode                          computeNodesAfterRemove = refreshablePool.ListComputeNodes().ToList();                            Assert.Single(computeNodesAfterRemove);                            this.testOutputHelper.WriteLine("Verified that the compute node was removed correctly");                            //                          //Remove a 3rd compute node from pool                          //                            ComputeNode thirdComputeNodeToRemove = computeNodesAfterRemove.First();                          string thirdComputeNodeToRemoveId = thirdComputeNodeToRemove.Id;                          this.testOutputHelper.WriteLine("Will remove compute node: {0}"' thirdComputeNodeToRemoveId);                            //Remove the IComputeNode from the pool using the ComputeNode object                          thirdComputeNodeToRemove.RemoveFromPool();                            //Wait for pool to got to steady state again                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                            //Ensure that the other ComputeNodes were not impacted and we now have 1 less ComputeNode                          computeNodesAfterRemove = refreshablePool.ListComputeNodes().ToList();                          Assert.Empty(computeNodesAfterRemove);                            this.testOutputHelper.WriteLine("Verified that the ComputeNode was removed correctly");                      }                      finally                      {                          //Delete the pool                          batchCli.PoolOperations.DeletePool(poolId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudPoolLongRunningTests02,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_TestRemovePoolComputeNodes,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = "TestRemovePoolComputeNodes_LongRunning" + TestUtilities.GetMyName();                      const int targetDedicated = 3;                      try                      {                          //Create a pool                          CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: targetDedicated);                            pool.Commit();                            this.testOutputHelper.WriteLine("Created pool {0}"' poolId);                            CloudPool refreshablePool = batchCli.PoolOperations.GetPool(poolId);                          //Wait for compute node allocation                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                          refreshablePool.Refresh();                          Assert.Equal(targetDedicated' refreshablePool.CurrentDedicatedComputeNodes);                            IEnumerable<ComputeNode> computeNodes = refreshablePool.ListComputeNodes();                            Assert.Equal(targetDedicated' computeNodes.Count());                            //                          //Remove first compute node from the pool                          //                          ComputeNode computeNodeToRemove = computeNodes.First();                            //For Bug234298 ensure start task property doesn't throw                          Assert.Null(computeNodeToRemove.StartTask);                            this.testOutputHelper.WriteLine("Will remove compute node: {0}"' computeNodeToRemove.Id);                            //Remove the compute node from the pool by instance                          refreshablePool.RemoveFromPool(computeNodeToRemove);                            //Wait for pool to got to steady state again                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                            refreshablePool.Refresh();                          //Ensure that the other ComputeNodes were not impacted and we now have 1 less ComputeNode                          List<ComputeNode> computeNodesAfterRemove = refreshablePool.ListComputeNodes().ToList();                            Assert.Equal(targetDedicated - 1' computeNodesAfterRemove.Count);                            List<string> remainingComputeNodeIds = computeNodesAfterRemove.Select(computeNode => computeNode.Id).ToList();                          foreach (ComputeNode originalComputeNode in computeNodes)                          {                              Assert.Contains(originalComputeNode.Id' remainingComputeNodeIds);                          }                            this.testOutputHelper.WriteLine("Verified that the compute node was removed correctly");                            //                          //Remove a second compute node from the pool                          //                            ComputeNode secondComputeNodeToRemove = computeNodesAfterRemove.First();                          string secondComputeNodeToRemoveId = secondComputeNodeToRemove.Id;                            //Remove the IComputeNode from the pool by id                          refreshablePool.RemoveFromPool(secondComputeNodeToRemoveId);                            //Wait for pool to got to steady state again                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                          refreshablePool.Refresh();                            //Ensure that the other ComputeNodes were not impacted and we now have 1 less ComputeNode                          computeNodesAfterRemove = refreshablePool.ListComputeNodes().ToList();                            Assert.Single(computeNodesAfterRemove);                            this.testOutputHelper.WriteLine("Verified that the compute node was removed correctly");                            //                          //Remove a 3rd compute node from pool                          //                            ComputeNode thirdComputeNodeToRemove = computeNodesAfterRemove.First();                          string thirdComputeNodeToRemoveId = thirdComputeNodeToRemove.Id;                          this.testOutputHelper.WriteLine("Will remove compute node: {0}"' thirdComputeNodeToRemoveId);                            //Remove the IComputeNode from the pool using the ComputeNode object                          thirdComputeNodeToRemove.RemoveFromPool();                            //Wait for pool to got to steady state again                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                            //Ensure that the other ComputeNodes were not impacted and we now have 1 less ComputeNode                          computeNodesAfterRemove = refreshablePool.ListComputeNodes().ToList();                          Assert.Empty(computeNodesAfterRemove);                            this.testOutputHelper.WriteLine("Verified that the ComputeNode was removed correctly");                      }                      finally                      {                          //Delete the pool                          batchCli.PoolOperations.DeletePool(poolId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudPoolLongRunningTests02,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_TestRemovePoolComputeNodes,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = "TestRemovePoolComputeNodes_LongRunning" + TestUtilities.GetMyName();                      const int targetDedicated = 3;                      try                      {                          //Create a pool                          CloudPool pool = batchCli.PoolOperations.CreatePool(poolId' PoolFixture.VMSize' new CloudServiceConfiguration(PoolFixture.OSFamily)' targetDedicatedComputeNodes: targetDedicated);                            pool.Commit();                            this.testOutputHelper.WriteLine("Created pool {0}"' poolId);                            CloudPool refreshablePool = batchCli.PoolOperations.GetPool(poolId);                          //Wait for compute node allocation                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                          refreshablePool.Refresh();                          Assert.Equal(targetDedicated' refreshablePool.CurrentDedicatedComputeNodes);                            IEnumerable<ComputeNode> computeNodes = refreshablePool.ListComputeNodes();                            Assert.Equal(targetDedicated' computeNodes.Count());                            //                          //Remove first compute node from the pool                          //                          ComputeNode computeNodeToRemove = computeNodes.First();                            //For Bug234298 ensure start task property doesn't throw                          Assert.Null(computeNodeToRemove.StartTask);                            this.testOutputHelper.WriteLine("Will remove compute node: {0}"' computeNodeToRemove.Id);                            //Remove the compute node from the pool by instance                          refreshablePool.RemoveFromPool(computeNodeToRemove);                            //Wait for pool to got to steady state again                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                            refreshablePool.Refresh();                          //Ensure that the other ComputeNodes were not impacted and we now have 1 less ComputeNode                          List<ComputeNode> computeNodesAfterRemove = refreshablePool.ListComputeNodes().ToList();                            Assert.Equal(targetDedicated - 1' computeNodesAfterRemove.Count);                            List<string> remainingComputeNodeIds = computeNodesAfterRemove.Select(computeNode => computeNode.Id).ToList();                          foreach (ComputeNode originalComputeNode in computeNodes)                          {                              Assert.Contains(originalComputeNode.Id' remainingComputeNodeIds);                          }                            this.testOutputHelper.WriteLine("Verified that the compute node was removed correctly");                            //                          //Remove a second compute node from the pool                          //                            ComputeNode secondComputeNodeToRemove = computeNodesAfterRemove.First();                          string secondComputeNodeToRemoveId = secondComputeNodeToRemove.Id;                            //Remove the IComputeNode from the pool by id                          refreshablePool.RemoveFromPool(secondComputeNodeToRemoveId);                            //Wait for pool to got to steady state again                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                          refreshablePool.Refresh();                            //Ensure that the other ComputeNodes were not impacted and we now have 1 less ComputeNode                          computeNodesAfterRemove = refreshablePool.ListComputeNodes().ToList();                            Assert.Single(computeNodesAfterRemove);                            this.testOutputHelper.WriteLine("Verified that the compute node was removed correctly");                            //                          //Remove a 3rd compute node from pool                          //                            ComputeNode thirdComputeNodeToRemove = computeNodesAfterRemove.First();                          string thirdComputeNodeToRemoveId = thirdComputeNodeToRemove.Id;                          this.testOutputHelper.WriteLine("Will remove compute node: {0}"' thirdComputeNodeToRemoveId);                            //Remove the IComputeNode from the pool using the ComputeNode object                          thirdComputeNodeToRemove.RemoveFromPool();                            //Wait for pool to got to steady state again                          TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).Wait();                            //Ensure that the other ComputeNodes were not impacted and we now have 1 less ComputeNode                          computeNodesAfterRemove = refreshablePool.ListComputeNodes().ToList();                          Assert.Empty(computeNodesAfterRemove);                            this.testOutputHelper.WriteLine("Verified that the ComputeNode was removed correctly");                      }                      finally                      {                          //Delete the pool                          batchCli.PoolOperations.DeletePool(poolId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudPoolLongRunningTests03,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_LowPriorityComputeNodeAllocated_IsDedicatedFalse,The following statement contains a magic number: Func<Task> test = async () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string poolId = "TestLowPri_LongRunning" + TestUtilities.GetMyName();                      const int targetLowPriority = 1;                      try                      {                          //Create a pool                          CloudPool pool = batchCli.PoolOperations.CreatePool(                              poolId'                              PoolFixture.VMSize'                              new CloudServiceConfiguration(PoolFixture.OSFamily)'                              targetLowPriorityComputeNodes: targetLowPriority);                            await pool.CommitAsync().ConfigureAwait(false);                            this.testOutputHelper.WriteLine("Created pool {0}"' poolId);                          await pool.RefreshAsync().ConfigureAwait(false);                            //Wait for compute node allocation                          await TestUtilities.WaitForPoolToReachStateAsync(batchCli' poolId' AllocationState.Steady' TimeSpan.FromMinutes(10)).ConfigureAwait(false);                            //Refresh pool to get latest from server                          await pool.RefreshAsync().ConfigureAwait(false);                            Assert.Equal(targetLowPriority' pool.CurrentLowPriorityComputeNodes);                            IEnumerable<ComputeNode> computeNodes = pool.ListComputeNodes();                          Assert.Single(computeNodes);                            ComputeNode node = computeNodes.Single();                          Assert.False(node.IsDedicated);                      }                      finally                      {                          //Delete the pool                          await TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId).ConfigureAwait(false);                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudPoolTestsWithSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_Bug1771277_1771278_RebootReimageComputeNode,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "LongRunning_Bug1771277_1771278_RebootReimageComputeNode" + TestUtilities.GetMyName();                        try                      {                          //                          // Get the pool and check its targets                          //                          CloudPool pool = batchCli.PoolOperations.GetPool(this.poolFixture.PoolId);                            //                          //Create a job on this pool with targetDedicated tasks which run for 2m each                          //                          const int taskDurationSeconds = 600;                            CloudJob workflowJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId });                          workflowJob.Commit();                            CloudJob boundWorkflowJob = batchCli.JobOperations.GetJob(jobId);                            string taskCmdLine = string.Format("ping 127.0.0.1 -n {0}"' taskDurationSeconds);                            for (int i = 0; i < pool.CurrentDedicatedComputeNodes; i++)                          {                              string taskId = string.Format("T_{0}"' i);                              boundWorkflowJob.AddTask(new CloudTask(taskId' taskCmdLine));                          }                            //                          // Wait for tasks to go to running                          //                          TaskStateMonitor taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Running'                              TimeSpan.FromMinutes(2));                            //                          // Reboot the compute nodes from the pool with requeue option and ensure tasks goes to Active again and compute node state goes to rebooting                          //                            IEnumerable<ComputeNode> computeNodes = pool.ListComputeNodes();                            foreach (ComputeNode computeNode in computeNodes)                          {                              computeNode.Reboot(ComputeNodeRebootOption.Requeue);                          }                            //Ensure task goes to active state                          taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Active'                              TimeSpan.FromMinutes(1));                            //Ensure each compute node goes to rebooting state                          IEnumerable<ComputeNode> rebootingComputeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId);                          foreach (ComputeNode computeNode in rebootingComputeNodes)                          {                              Assert.Equal(ComputeNodeState.Rebooting' computeNode.State);                          }                            //Wait for tasks to start to run again                          taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Running'                              TimeSpan.FromMinutes(10));                          //                          // Reimage a compute node from the pool with terminate option and ensure task goes to completed and compute node state goes to reimaging                          //                          computeNodes = pool.ListComputeNodes();                            foreach (ComputeNode computeNode in computeNodes)                          {                              computeNode.Reimage(ComputeNodeReimageOption.Terminate);                          }                            //Ensure task goes to completed state                          taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Completed'                              TimeSpan.FromMinutes(1));                            //Ensure each compute node goes to reimaging state                          IEnumerable<ComputeNode> reimagingComputeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId);                          foreach (ComputeNode computeNode in reimagingComputeNodes)                          {                              Assert.Equal(ComputeNodeState.Reimaging' computeNode.State);                          }                      }                      finally                      {                          //Delete the job                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                            //Wait until the compute nodes are idle again                          //TODO: Use a Utilities waiter                          TimeSpan computeNodeSteadyTimeout = TimeSpan.FromMinutes(15);                          DateTime allocationWaitStartTime = DateTime.UtcNow;                          DateTime timeoutAfterThisTimeUtc = allocationWaitStartTime.Add(computeNodeSteadyTimeout);                            IEnumerable<ComputeNode> computeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId);                            while (computeNodes.Any(computeNode => computeNode.State != ComputeNodeState.Idle))                          {                              Thread.Sleep(TimeSpan.FromSeconds(10));                              computeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId).ToList();                              Assert.False(DateTime.UtcNow > timeoutAfterThisTimeUtc' "Timed out waiting for compute nodes in pool to reach idle state");                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudPoolTestsWithSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_Bug1771277_1771278_RebootReimageComputeNode,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "LongRunning_Bug1771277_1771278_RebootReimageComputeNode" + TestUtilities.GetMyName();                        try                      {                          //                          // Get the pool and check its targets                          //                          CloudPool pool = batchCli.PoolOperations.GetPool(this.poolFixture.PoolId);                            //                          //Create a job on this pool with targetDedicated tasks which run for 2m each                          //                          const int taskDurationSeconds = 600;                            CloudJob workflowJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId });                          workflowJob.Commit();                            CloudJob boundWorkflowJob = batchCli.JobOperations.GetJob(jobId);                            string taskCmdLine = string.Format("ping 127.0.0.1 -n {0}"' taskDurationSeconds);                            for (int i = 0; i < pool.CurrentDedicatedComputeNodes; i++)                          {                              string taskId = string.Format("T_{0}"' i);                              boundWorkflowJob.AddTask(new CloudTask(taskId' taskCmdLine));                          }                            //                          // Wait for tasks to go to running                          //                          TaskStateMonitor taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Running'                              TimeSpan.FromMinutes(2));                            //                          // Reboot the compute nodes from the pool with requeue option and ensure tasks goes to Active again and compute node state goes to rebooting                          //                            IEnumerable<ComputeNode> computeNodes = pool.ListComputeNodes();                            foreach (ComputeNode computeNode in computeNodes)                          {                              computeNode.Reboot(ComputeNodeRebootOption.Requeue);                          }                            //Ensure task goes to active state                          taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Active'                              TimeSpan.FromMinutes(1));                            //Ensure each compute node goes to rebooting state                          IEnumerable<ComputeNode> rebootingComputeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId);                          foreach (ComputeNode computeNode in rebootingComputeNodes)                          {                              Assert.Equal(ComputeNodeState.Rebooting' computeNode.State);                          }                            //Wait for tasks to start to run again                          taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Running'                              TimeSpan.FromMinutes(10));                          //                          // Reimage a compute node from the pool with terminate option and ensure task goes to completed and compute node state goes to reimaging                          //                          computeNodes = pool.ListComputeNodes();                            foreach (ComputeNode computeNode in computeNodes)                          {                              computeNode.Reimage(ComputeNodeReimageOption.Terminate);                          }                            //Ensure task goes to completed state                          taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Completed'                              TimeSpan.FromMinutes(1));                            //Ensure each compute node goes to reimaging state                          IEnumerable<ComputeNode> reimagingComputeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId);                          foreach (ComputeNode computeNode in reimagingComputeNodes)                          {                              Assert.Equal(ComputeNodeState.Reimaging' computeNode.State);                          }                      }                      finally                      {                          //Delete the job                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                            //Wait until the compute nodes are idle again                          //TODO: Use a Utilities waiter                          TimeSpan computeNodeSteadyTimeout = TimeSpan.FromMinutes(15);                          DateTime allocationWaitStartTime = DateTime.UtcNow;                          DateTime timeoutAfterThisTimeUtc = allocationWaitStartTime.Add(computeNodeSteadyTimeout);                            IEnumerable<ComputeNode> computeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId);                            while (computeNodes.Any(computeNode => computeNode.State != ComputeNodeState.Idle))                          {                              Thread.Sleep(TimeSpan.FromSeconds(10));                              computeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId).ToList();                              Assert.False(DateTime.UtcNow > timeoutAfterThisTimeUtc' "Timed out waiting for compute nodes in pool to reach idle state");                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudPoolTestsWithSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_Bug1771277_1771278_RebootReimageComputeNode,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "LongRunning_Bug1771277_1771278_RebootReimageComputeNode" + TestUtilities.GetMyName();                        try                      {                          //                          // Get the pool and check its targets                          //                          CloudPool pool = batchCli.PoolOperations.GetPool(this.poolFixture.PoolId);                            //                          //Create a job on this pool with targetDedicated tasks which run for 2m each                          //                          const int taskDurationSeconds = 600;                            CloudJob workflowJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId });                          workflowJob.Commit();                            CloudJob boundWorkflowJob = batchCli.JobOperations.GetJob(jobId);                            string taskCmdLine = string.Format("ping 127.0.0.1 -n {0}"' taskDurationSeconds);                            for (int i = 0; i < pool.CurrentDedicatedComputeNodes; i++)                          {                              string taskId = string.Format("T_{0}"' i);                              boundWorkflowJob.AddTask(new CloudTask(taskId' taskCmdLine));                          }                            //                          // Wait for tasks to go to running                          //                          TaskStateMonitor taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Running'                              TimeSpan.FromMinutes(2));                            //                          // Reboot the compute nodes from the pool with requeue option and ensure tasks goes to Active again and compute node state goes to rebooting                          //                            IEnumerable<ComputeNode> computeNodes = pool.ListComputeNodes();                            foreach (ComputeNode computeNode in computeNodes)                          {                              computeNode.Reboot(ComputeNodeRebootOption.Requeue);                          }                            //Ensure task goes to active state                          taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Active'                              TimeSpan.FromMinutes(1));                            //Ensure each compute node goes to rebooting state                          IEnumerable<ComputeNode> rebootingComputeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId);                          foreach (ComputeNode computeNode in rebootingComputeNodes)                          {                              Assert.Equal(ComputeNodeState.Rebooting' computeNode.State);                          }                            //Wait for tasks to start to run again                          taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Running'                              TimeSpan.FromMinutes(10));                          //                          // Reimage a compute node from the pool with terminate option and ensure task goes to completed and compute node state goes to reimaging                          //                          computeNodes = pool.ListComputeNodes();                            foreach (ComputeNode computeNode in computeNodes)                          {                              computeNode.Reimage(ComputeNodeReimageOption.Terminate);                          }                            //Ensure task goes to completed state                          taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Completed'                              TimeSpan.FromMinutes(1));                            //Ensure each compute node goes to reimaging state                          IEnumerable<ComputeNode> reimagingComputeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId);                          foreach (ComputeNode computeNode in reimagingComputeNodes)                          {                              Assert.Equal(ComputeNodeState.Reimaging' computeNode.State);                          }                      }                      finally                      {                          //Delete the job                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                            //Wait until the compute nodes are idle again                          //TODO: Use a Utilities waiter                          TimeSpan computeNodeSteadyTimeout = TimeSpan.FromMinutes(15);                          DateTime allocationWaitStartTime = DateTime.UtcNow;                          DateTime timeoutAfterThisTimeUtc = allocationWaitStartTime.Add(computeNodeSteadyTimeout);                            IEnumerable<ComputeNode> computeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId);                            while (computeNodes.Any(computeNode => computeNode.State != ComputeNodeState.Idle))                          {                              Thread.Sleep(TimeSpan.FromSeconds(10));                              computeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId).ToList();                              Assert.False(DateTime.UtcNow > timeoutAfterThisTimeUtc' "Timed out waiting for compute nodes in pool to reach idle state");                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudPoolTestsWithSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_Bug1771277_1771278_RebootReimageComputeNode,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "LongRunning_Bug1771277_1771278_RebootReimageComputeNode" + TestUtilities.GetMyName();                        try                      {                          //                          // Get the pool and check its targets                          //                          CloudPool pool = batchCli.PoolOperations.GetPool(this.poolFixture.PoolId);                            //                          //Create a job on this pool with targetDedicated tasks which run for 2m each                          //                          const int taskDurationSeconds = 600;                            CloudJob workflowJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId });                          workflowJob.Commit();                            CloudJob boundWorkflowJob = batchCli.JobOperations.GetJob(jobId);                            string taskCmdLine = string.Format("ping 127.0.0.1 -n {0}"' taskDurationSeconds);                            for (int i = 0; i < pool.CurrentDedicatedComputeNodes; i++)                          {                              string taskId = string.Format("T_{0}"' i);                              boundWorkflowJob.AddTask(new CloudTask(taskId' taskCmdLine));                          }                            //                          // Wait for tasks to go to running                          //                          TaskStateMonitor taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Running'                              TimeSpan.FromMinutes(2));                            //                          // Reboot the compute nodes from the pool with requeue option and ensure tasks goes to Active again and compute node state goes to rebooting                          //                            IEnumerable<ComputeNode> computeNodes = pool.ListComputeNodes();                            foreach (ComputeNode computeNode in computeNodes)                          {                              computeNode.Reboot(ComputeNodeRebootOption.Requeue);                          }                            //Ensure task goes to active state                          taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Active'                              TimeSpan.FromMinutes(1));                            //Ensure each compute node goes to rebooting state                          IEnumerable<ComputeNode> rebootingComputeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId);                          foreach (ComputeNode computeNode in rebootingComputeNodes)                          {                              Assert.Equal(ComputeNodeState.Rebooting' computeNode.State);                          }                            //Wait for tasks to start to run again                          taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Running'                              TimeSpan.FromMinutes(10));                          //                          // Reimage a compute node from the pool with terminate option and ensure task goes to completed and compute node state goes to reimaging                          //                          computeNodes = pool.ListComputeNodes();                            foreach (ComputeNode computeNode in computeNodes)                          {                              computeNode.Reimage(ComputeNodeReimageOption.Terminate);                          }                            //Ensure task goes to completed state                          taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Completed'                              TimeSpan.FromMinutes(1));                            //Ensure each compute node goes to reimaging state                          IEnumerable<ComputeNode> reimagingComputeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId);                          foreach (ComputeNode computeNode in reimagingComputeNodes)                          {                              Assert.Equal(ComputeNodeState.Reimaging' computeNode.State);                          }                      }                      finally                      {                          //Delete the job                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                            //Wait until the compute nodes are idle again                          //TODO: Use a Utilities waiter                          TimeSpan computeNodeSteadyTimeout = TimeSpan.FromMinutes(15);                          DateTime allocationWaitStartTime = DateTime.UtcNow;                          DateTime timeoutAfterThisTimeUtc = allocationWaitStartTime.Add(computeNodeSteadyTimeout);                            IEnumerable<ComputeNode> computeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId);                            while (computeNodes.Any(computeNode => computeNode.State != ComputeNodeState.Idle))                          {                              Thread.Sleep(TimeSpan.FromSeconds(10));                              computeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId).ToList();                              Assert.False(DateTime.UtcNow > timeoutAfterThisTimeUtc' "Timed out waiting for compute nodes in pool to reach idle state");                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudPoolTestsWithSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudPoolIntegrationTests.cs,LongRunning_Bug1771277_1771278_RebootReimageComputeNode,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "LongRunning_Bug1771277_1771278_RebootReimageComputeNode" + TestUtilities.GetMyName();                        try                      {                          //                          // Get the pool and check its targets                          //                          CloudPool pool = batchCli.PoolOperations.GetPool(this.poolFixture.PoolId);                            //                          //Create a job on this pool with targetDedicated tasks which run for 2m each                          //                          const int taskDurationSeconds = 600;                            CloudJob workflowJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId });                          workflowJob.Commit();                            CloudJob boundWorkflowJob = batchCli.JobOperations.GetJob(jobId);                            string taskCmdLine = string.Format("ping 127.0.0.1 -n {0}"' taskDurationSeconds);                            for (int i = 0; i < pool.CurrentDedicatedComputeNodes; i++)                          {                              string taskId = string.Format("T_{0}"' i);                              boundWorkflowJob.AddTask(new CloudTask(taskId' taskCmdLine));                          }                            //                          // Wait for tasks to go to running                          //                          TaskStateMonitor taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Running'                              TimeSpan.FromMinutes(2));                            //                          // Reboot the compute nodes from the pool with requeue option and ensure tasks goes to Active again and compute node state goes to rebooting                          //                            IEnumerable<ComputeNode> computeNodes = pool.ListComputeNodes();                            foreach (ComputeNode computeNode in computeNodes)                          {                              computeNode.Reboot(ComputeNodeRebootOption.Requeue);                          }                            //Ensure task goes to active state                          taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Active'                              TimeSpan.FromMinutes(1));                            //Ensure each compute node goes to rebooting state                          IEnumerable<ComputeNode> rebootingComputeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId);                          foreach (ComputeNode computeNode in rebootingComputeNodes)                          {                              Assert.Equal(ComputeNodeState.Rebooting' computeNode.State);                          }                            //Wait for tasks to start to run again                          taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Running'                              TimeSpan.FromMinutes(10));                          //                          // Reimage a compute node from the pool with terminate option and ensure task goes to completed and compute node state goes to reimaging                          //                          computeNodes = pool.ListComputeNodes();                            foreach (ComputeNode computeNode in computeNodes)                          {                              computeNode.Reimage(ComputeNodeReimageOption.Terminate);                          }                            //Ensure task goes to completed state                          taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          taskStateMonitor.WaitAll(                              batchCli.JobOperations.ListTasks(jobId)'                              Microsoft.Azure.Batch.Common.TaskState.Completed'                              TimeSpan.FromMinutes(1));                            //Ensure each compute node goes to reimaging state                          IEnumerable<ComputeNode> reimagingComputeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId);                          foreach (ComputeNode computeNode in reimagingComputeNodes)                          {                              Assert.Equal(ComputeNodeState.Reimaging' computeNode.State);                          }                      }                      finally                      {                          //Delete the job                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                            //Wait until the compute nodes are idle again                          //TODO: Use a Utilities waiter                          TimeSpan computeNodeSteadyTimeout = TimeSpan.FromMinutes(15);                          DateTime allocationWaitStartTime = DateTime.UtcNow;                          DateTime timeoutAfterThisTimeUtc = allocationWaitStartTime.Add(computeNodeSteadyTimeout);                            IEnumerable<ComputeNode> computeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId);                            while (computeNodes.Any(computeNode => computeNode.State != ComputeNodeState.Idle))                          {                              Thread.Sleep(TimeSpan.FromSeconds(10));                              computeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId).ToList();                              Assert.False(DateTime.UtcNow > timeoutAfterThisTimeUtc' "Timed out waiting for compute nodes in pool to reach idle state");                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,CreatePool,The following statement contains a magic number: CloudPool newPool = poolOp.CreatePool(                  poolId'                  PoolFixture.VMSize'                  new CloudServiceConfiguration(PoolFixture.OSFamily)'                  targetDedicatedComputeNodes: 3);
Magic Number,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,CreatePool,The following statement contains a magic number: TimeSpan computeNodeAllocationTimeout = TimeSpan.FromMinutes(10);
Magic Number,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,CreatePool,The following statement contains a magic number: TimeSpan computeNodeSteadyTimeout = TimeSpan.FromMinutes(10);
Magic Number,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,CreatePool,The following statement contains a magic number: Thread.Sleep(TimeSpan.FromSeconds(10));
Magic Number,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,BasicMultiInstanceTasks,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClientFromEnvironmentAsync().Result)                  {                      string jobId = "MultiInstance-" + TestUtilities.GetMyName();                        try                      {                          // here we show how to use an unbound Job + Commit() to run a simple "Hello World" task                          // get an empty unbound Job                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolId });                          unboundJob.Commit();                            // Open the new Job as bound.                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            // get an empty unbound Task                          CloudTask hwTask = new CloudTask(id: "multi1"' commandline: "hostname");                          hwTask.MultiInstanceSettings = new MultiInstanceSettings("cmd /c set"' numberOfInstances: 3);                            // add Task to Job                          boundJob.AddTask(hwTask);                            {                              // wait for the task to complete                              Utilities utilities = batchCli.Utilities;                              TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                                taskStateMonitor.WaitAll(                                  boundJob.ListTasks()'                                  Microsoft.Azure.Batch.Common.TaskState.Completed'                                  TimeSpan.FromMinutes(3));                                CloudTask myCompletedTask = new List<CloudTask>(boundJob.ListTasks())[0];                                Assert.Equal<TaskState?>(TaskState.Completed' myCompletedTask.State);                                Assert.NotNull(myCompletedTask.MultiInstanceSettings);                              Assert.Equal(3' myCompletedTask.MultiInstanceSettings.NumberOfInstances);                              Assert.Equal("cmd /c set"' myCompletedTask.MultiInstanceSettings.CoordinationCommandLine);                                string stdOut = myCompletedTask.GetNodeFile(Constants.StandardOutFileName).ReadAsString();                              string stdErr = myCompletedTask.GetNodeFile(Constants.StandardErrorFileName).ReadAsString();                                this.testOutputHelper.WriteLine("StdOut: ");                              this.testOutputHelper.WriteLine("");                              this.testOutputHelper.WriteLine(stdOut);                              this.testOutputHelper.WriteLine("");                                this.testOutputHelper.WriteLine("StdErr: ");                              this.testOutputHelper.WriteLine(stdErr);                              this.testOutputHelper.WriteLine("");                                  List<SubtaskInformation> subtasks;                              Stopwatch sw = new Stopwatch();                              sw.Start();                              do                              {                                  IPagedEnumerable<SubtaskInformation> results = myCompletedTask.ListSubtasks();                                    subtasks = results.ToList();                                  if (subtasks.All(t => t.State == SubtaskState.Completed))                                  {                                      break;                                  }                                  Thread.Sleep(500);                              } while (sw.Elapsed <= checkSubtasksStateTimeout);                                Assert.True(sw.Elapsed <= checkSubtasksStateTimeout' string.Format("The subtasks state is not set to Complete after {0} seconds"' checkSubtasksStateTimeout.TotalSeconds));                              Assert.Equal(2' subtasks.Count);                              Assert.Equal(0' subtasks[0].ExitCode);                              Assert.Null(subtasks[0].FailureInformation);                              Assert.Equal(0' subtasks[1].ExitCode);                              Assert.Null(subtasks[1].FailureInformation);                              // Shouldnot assume the subtasks have order.                              Assert.True((subtasks[0].Id == 1 && subtasks[1].Id == 2) || (subtasks[0].Id == 2 && subtasks[1].Id == 1));                                this.testOutputHelper.WriteLine("Multi-instance test complete");                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,BasicMultiInstanceTasks,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClientFromEnvironmentAsync().Result)                  {                      string jobId = "MultiInstance-" + TestUtilities.GetMyName();                        try                      {                          // here we show how to use an unbound Job + Commit() to run a simple "Hello World" task                          // get an empty unbound Job                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolId });                          unboundJob.Commit();                            // Open the new Job as bound.                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            // get an empty unbound Task                          CloudTask hwTask = new CloudTask(id: "multi1"' commandline: "hostname");                          hwTask.MultiInstanceSettings = new MultiInstanceSettings("cmd /c set"' numberOfInstances: 3);                            // add Task to Job                          boundJob.AddTask(hwTask);                            {                              // wait for the task to complete                              Utilities utilities = batchCli.Utilities;                              TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                                taskStateMonitor.WaitAll(                                  boundJob.ListTasks()'                                  Microsoft.Azure.Batch.Common.TaskState.Completed'                                  TimeSpan.FromMinutes(3));                                CloudTask myCompletedTask = new List<CloudTask>(boundJob.ListTasks())[0];                                Assert.Equal<TaskState?>(TaskState.Completed' myCompletedTask.State);                                Assert.NotNull(myCompletedTask.MultiInstanceSettings);                              Assert.Equal(3' myCompletedTask.MultiInstanceSettings.NumberOfInstances);                              Assert.Equal("cmd /c set"' myCompletedTask.MultiInstanceSettings.CoordinationCommandLine);                                string stdOut = myCompletedTask.GetNodeFile(Constants.StandardOutFileName).ReadAsString();                              string stdErr = myCompletedTask.GetNodeFile(Constants.StandardErrorFileName).ReadAsString();                                this.testOutputHelper.WriteLine("StdOut: ");                              this.testOutputHelper.WriteLine("");                              this.testOutputHelper.WriteLine(stdOut);                              this.testOutputHelper.WriteLine("");                                this.testOutputHelper.WriteLine("StdErr: ");                              this.testOutputHelper.WriteLine(stdErr);                              this.testOutputHelper.WriteLine("");                                  List<SubtaskInformation> subtasks;                              Stopwatch sw = new Stopwatch();                              sw.Start();                              do                              {                                  IPagedEnumerable<SubtaskInformation> results = myCompletedTask.ListSubtasks();                                    subtasks = results.ToList();                                  if (subtasks.All(t => t.State == SubtaskState.Completed))                                  {                                      break;                                  }                                  Thread.Sleep(500);                              } while (sw.Elapsed <= checkSubtasksStateTimeout);                                Assert.True(sw.Elapsed <= checkSubtasksStateTimeout' string.Format("The subtasks state is not set to Complete after {0} seconds"' checkSubtasksStateTimeout.TotalSeconds));                              Assert.Equal(2' subtasks.Count);                              Assert.Equal(0' subtasks[0].ExitCode);                              Assert.Null(subtasks[0].FailureInformation);                              Assert.Equal(0' subtasks[1].ExitCode);                              Assert.Null(subtasks[1].FailureInformation);                              // Shouldnot assume the subtasks have order.                              Assert.True((subtasks[0].Id == 1 && subtasks[1].Id == 2) || (subtasks[0].Id == 2 && subtasks[1].Id == 1));                                this.testOutputHelper.WriteLine("Multi-instance test complete");                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,BasicMultiInstanceTasks,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClientFromEnvironmentAsync().Result)                  {                      string jobId = "MultiInstance-" + TestUtilities.GetMyName();                        try                      {                          // here we show how to use an unbound Job + Commit() to run a simple "Hello World" task                          // get an empty unbound Job                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolId });                          unboundJob.Commit();                            // Open the new Job as bound.                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            // get an empty unbound Task                          CloudTask hwTask = new CloudTask(id: "multi1"' commandline: "hostname");                          hwTask.MultiInstanceSettings = new MultiInstanceSettings("cmd /c set"' numberOfInstances: 3);                            // add Task to Job                          boundJob.AddTask(hwTask);                            {                              // wait for the task to complete                              Utilities utilities = batchCli.Utilities;                              TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                                taskStateMonitor.WaitAll(                                  boundJob.ListTasks()'                                  Microsoft.Azure.Batch.Common.TaskState.Completed'                                  TimeSpan.FromMinutes(3));                                CloudTask myCompletedTask = new List<CloudTask>(boundJob.ListTasks())[0];                                Assert.Equal<TaskState?>(TaskState.Completed' myCompletedTask.State);                                Assert.NotNull(myCompletedTask.MultiInstanceSettings);                              Assert.Equal(3' myCompletedTask.MultiInstanceSettings.NumberOfInstances);                              Assert.Equal("cmd /c set"' myCompletedTask.MultiInstanceSettings.CoordinationCommandLine);                                string stdOut = myCompletedTask.GetNodeFile(Constants.StandardOutFileName).ReadAsString();                              string stdErr = myCompletedTask.GetNodeFile(Constants.StandardErrorFileName).ReadAsString();                                this.testOutputHelper.WriteLine("StdOut: ");                              this.testOutputHelper.WriteLine("");                              this.testOutputHelper.WriteLine(stdOut);                              this.testOutputHelper.WriteLine("");                                this.testOutputHelper.WriteLine("StdErr: ");                              this.testOutputHelper.WriteLine(stdErr);                              this.testOutputHelper.WriteLine("");                                  List<SubtaskInformation> subtasks;                              Stopwatch sw = new Stopwatch();                              sw.Start();                              do                              {                                  IPagedEnumerable<SubtaskInformation> results = myCompletedTask.ListSubtasks();                                    subtasks = results.ToList();                                  if (subtasks.All(t => t.State == SubtaskState.Completed))                                  {                                      break;                                  }                                  Thread.Sleep(500);                              } while (sw.Elapsed <= checkSubtasksStateTimeout);                                Assert.True(sw.Elapsed <= checkSubtasksStateTimeout' string.Format("The subtasks state is not set to Complete after {0} seconds"' checkSubtasksStateTimeout.TotalSeconds));                              Assert.Equal(2' subtasks.Count);                              Assert.Equal(0' subtasks[0].ExitCode);                              Assert.Null(subtasks[0].FailureInformation);                              Assert.Equal(0' subtasks[1].ExitCode);                              Assert.Null(subtasks[1].FailureInformation);                              // Shouldnot assume the subtasks have order.                              Assert.True((subtasks[0].Id == 1 && subtasks[1].Id == 2) || (subtasks[0].Id == 2 && subtasks[1].Id == 1));                                this.testOutputHelper.WriteLine("Multi-instance test complete");                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,BasicMultiInstanceTasks,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClientFromEnvironmentAsync().Result)                  {                      string jobId = "MultiInstance-" + TestUtilities.GetMyName();                        try                      {                          // here we show how to use an unbound Job + Commit() to run a simple "Hello World" task                          // get an empty unbound Job                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolId });                          unboundJob.Commit();                            // Open the new Job as bound.                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            // get an empty unbound Task                          CloudTask hwTask = new CloudTask(id: "multi1"' commandline: "hostname");                          hwTask.MultiInstanceSettings = new MultiInstanceSettings("cmd /c set"' numberOfInstances: 3);                            // add Task to Job                          boundJob.AddTask(hwTask);                            {                              // wait for the task to complete                              Utilities utilities = batchCli.Utilities;                              TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                                taskStateMonitor.WaitAll(                                  boundJob.ListTasks()'                                  Microsoft.Azure.Batch.Common.TaskState.Completed'                                  TimeSpan.FromMinutes(3));                                CloudTask myCompletedTask = new List<CloudTask>(boundJob.ListTasks())[0];                                Assert.Equal<TaskState?>(TaskState.Completed' myCompletedTask.State);                                Assert.NotNull(myCompletedTask.MultiInstanceSettings);                              Assert.Equal(3' myCompletedTask.MultiInstanceSettings.NumberOfInstances);                              Assert.Equal("cmd /c set"' myCompletedTask.MultiInstanceSettings.CoordinationCommandLine);                                string stdOut = myCompletedTask.GetNodeFile(Constants.StandardOutFileName).ReadAsString();                              string stdErr = myCompletedTask.GetNodeFile(Constants.StandardErrorFileName).ReadAsString();                                this.testOutputHelper.WriteLine("StdOut: ");                              this.testOutputHelper.WriteLine("");                              this.testOutputHelper.WriteLine(stdOut);                              this.testOutputHelper.WriteLine("");                                this.testOutputHelper.WriteLine("StdErr: ");                              this.testOutputHelper.WriteLine(stdErr);                              this.testOutputHelper.WriteLine("");                                  List<SubtaskInformation> subtasks;                              Stopwatch sw = new Stopwatch();                              sw.Start();                              do                              {                                  IPagedEnumerable<SubtaskInformation> results = myCompletedTask.ListSubtasks();                                    subtasks = results.ToList();                                  if (subtasks.All(t => t.State == SubtaskState.Completed))                                  {                                      break;                                  }                                  Thread.Sleep(500);                              } while (sw.Elapsed <= checkSubtasksStateTimeout);                                Assert.True(sw.Elapsed <= checkSubtasksStateTimeout' string.Format("The subtasks state is not set to Complete after {0} seconds"' checkSubtasksStateTimeout.TotalSeconds));                              Assert.Equal(2' subtasks.Count);                              Assert.Equal(0' subtasks[0].ExitCode);                              Assert.Null(subtasks[0].FailureInformation);                              Assert.Equal(0' subtasks[1].ExitCode);                              Assert.Null(subtasks[1].FailureInformation);                              // Shouldnot assume the subtasks have order.                              Assert.True((subtasks[0].Id == 1 && subtasks[1].Id == 2) || (subtasks[0].Id == 2 && subtasks[1].Id == 1));                                this.testOutputHelper.WriteLine("Multi-instance test complete");                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,BasicMultiInstanceTasks,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClientFromEnvironmentAsync().Result)                  {                      string jobId = "MultiInstance-" + TestUtilities.GetMyName();                        try                      {                          // here we show how to use an unbound Job + Commit() to run a simple "Hello World" task                          // get an empty unbound Job                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolId });                          unboundJob.Commit();                            // Open the new Job as bound.                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            // get an empty unbound Task                          CloudTask hwTask = new CloudTask(id: "multi1"' commandline: "hostname");                          hwTask.MultiInstanceSettings = new MultiInstanceSettings("cmd /c set"' numberOfInstances: 3);                            // add Task to Job                          boundJob.AddTask(hwTask);                            {                              // wait for the task to complete                              Utilities utilities = batchCli.Utilities;                              TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                                taskStateMonitor.WaitAll(                                  boundJob.ListTasks()'                                  Microsoft.Azure.Batch.Common.TaskState.Completed'                                  TimeSpan.FromMinutes(3));                                CloudTask myCompletedTask = new List<CloudTask>(boundJob.ListTasks())[0];                                Assert.Equal<TaskState?>(TaskState.Completed' myCompletedTask.State);                                Assert.NotNull(myCompletedTask.MultiInstanceSettings);                              Assert.Equal(3' myCompletedTask.MultiInstanceSettings.NumberOfInstances);                              Assert.Equal("cmd /c set"' myCompletedTask.MultiInstanceSettings.CoordinationCommandLine);                                string stdOut = myCompletedTask.GetNodeFile(Constants.StandardOutFileName).ReadAsString();                              string stdErr = myCompletedTask.GetNodeFile(Constants.StandardErrorFileName).ReadAsString();                                this.testOutputHelper.WriteLine("StdOut: ");                              this.testOutputHelper.WriteLine("");                              this.testOutputHelper.WriteLine(stdOut);                              this.testOutputHelper.WriteLine("");                                this.testOutputHelper.WriteLine("StdErr: ");                              this.testOutputHelper.WriteLine(stdErr);                              this.testOutputHelper.WriteLine("");                                  List<SubtaskInformation> subtasks;                              Stopwatch sw = new Stopwatch();                              sw.Start();                              do                              {                                  IPagedEnumerable<SubtaskInformation> results = myCompletedTask.ListSubtasks();                                    subtasks = results.ToList();                                  if (subtasks.All(t => t.State == SubtaskState.Completed))                                  {                                      break;                                  }                                  Thread.Sleep(500);                              } while (sw.Elapsed <= checkSubtasksStateTimeout);                                Assert.True(sw.Elapsed <= checkSubtasksStateTimeout' string.Format("The subtasks state is not set to Complete after {0} seconds"' checkSubtasksStateTimeout.TotalSeconds));                              Assert.Equal(2' subtasks.Count);                              Assert.Equal(0' subtasks[0].ExitCode);                              Assert.Null(subtasks[0].FailureInformation);                              Assert.Equal(0' subtasks[1].ExitCode);                              Assert.Null(subtasks[1].FailureInformation);                              // Shouldnot assume the subtasks have order.                              Assert.True((subtasks[0].Id == 1 && subtasks[1].Id == 2) || (subtasks[0].Id == 2 && subtasks[1].Id == 1));                                this.testOutputHelper.WriteLine("Multi-instance test complete");                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,BasicMultiInstanceTasks,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClientFromEnvironmentAsync().Result)                  {                      string jobId = "MultiInstance-" + TestUtilities.GetMyName();                        try                      {                          // here we show how to use an unbound Job + Commit() to run a simple "Hello World" task                          // get an empty unbound Job                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolId });                          unboundJob.Commit();                            // Open the new Job as bound.                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            // get an empty unbound Task                          CloudTask hwTask = new CloudTask(id: "multi1"' commandline: "hostname");                          hwTask.MultiInstanceSettings = new MultiInstanceSettings("cmd /c set"' numberOfInstances: 3);                            // add Task to Job                          boundJob.AddTask(hwTask);                            {                              // wait for the task to complete                              Utilities utilities = batchCli.Utilities;                              TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                                taskStateMonitor.WaitAll(                                  boundJob.ListTasks()'                                  Microsoft.Azure.Batch.Common.TaskState.Completed'                                  TimeSpan.FromMinutes(3));                                CloudTask myCompletedTask = new List<CloudTask>(boundJob.ListTasks())[0];                                Assert.Equal<TaskState?>(TaskState.Completed' myCompletedTask.State);                                Assert.NotNull(myCompletedTask.MultiInstanceSettings);                              Assert.Equal(3' myCompletedTask.MultiInstanceSettings.NumberOfInstances);                              Assert.Equal("cmd /c set"' myCompletedTask.MultiInstanceSettings.CoordinationCommandLine);                                string stdOut = myCompletedTask.GetNodeFile(Constants.StandardOutFileName).ReadAsString();                              string stdErr = myCompletedTask.GetNodeFile(Constants.StandardErrorFileName).ReadAsString();                                this.testOutputHelper.WriteLine("StdOut: ");                              this.testOutputHelper.WriteLine("");                              this.testOutputHelper.WriteLine(stdOut);                              this.testOutputHelper.WriteLine("");                                this.testOutputHelper.WriteLine("StdErr: ");                              this.testOutputHelper.WriteLine(stdErr);                              this.testOutputHelper.WriteLine("");                                  List<SubtaskInformation> subtasks;                              Stopwatch sw = new Stopwatch();                              sw.Start();                              do                              {                                  IPagedEnumerable<SubtaskInformation> results = myCompletedTask.ListSubtasks();                                    subtasks = results.ToList();                                  if (subtasks.All(t => t.State == SubtaskState.Completed))                                  {                                      break;                                  }                                  Thread.Sleep(500);                              } while (sw.Elapsed <= checkSubtasksStateTimeout);                                Assert.True(sw.Elapsed <= checkSubtasksStateTimeout' string.Format("The subtasks state is not set to Complete after {0} seconds"' checkSubtasksStateTimeout.TotalSeconds));                              Assert.Equal(2' subtasks.Count);                              Assert.Equal(0' subtasks[0].ExitCode);                              Assert.Null(subtasks[0].FailureInformation);                              Assert.Equal(0' subtasks[1].ExitCode);                              Assert.Null(subtasks[1].FailureInformation);                              // Shouldnot assume the subtasks have order.                              Assert.True((subtasks[0].Id == 1 && subtasks[1].Id == 2) || (subtasks[0].Id == 2 && subtasks[1].Id == 1));                                this.testOutputHelper.WriteLine("Multi-instance test complete");                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,BasicMultiInstanceTasks,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClientFromEnvironmentAsync().Result)                  {                      string jobId = "MultiInstance-" + TestUtilities.GetMyName();                        try                      {                          // here we show how to use an unbound Job + Commit() to run a simple "Hello World" task                          // get an empty unbound Job                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolId });                          unboundJob.Commit();                            // Open the new Job as bound.                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            // get an empty unbound Task                          CloudTask hwTask = new CloudTask(id: "multi1"' commandline: "hostname");                          hwTask.MultiInstanceSettings = new MultiInstanceSettings("cmd /c set"' numberOfInstances: 3);                            // add Task to Job                          boundJob.AddTask(hwTask);                            {                              // wait for the task to complete                              Utilities utilities = batchCli.Utilities;                              TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                                taskStateMonitor.WaitAll(                                  boundJob.ListTasks()'                                  Microsoft.Azure.Batch.Common.TaskState.Completed'                                  TimeSpan.FromMinutes(3));                                CloudTask myCompletedTask = new List<CloudTask>(boundJob.ListTasks())[0];                                Assert.Equal<TaskState?>(TaskState.Completed' myCompletedTask.State);                                Assert.NotNull(myCompletedTask.MultiInstanceSettings);                              Assert.Equal(3' myCompletedTask.MultiInstanceSettings.NumberOfInstances);                              Assert.Equal("cmd /c set"' myCompletedTask.MultiInstanceSettings.CoordinationCommandLine);                                string stdOut = myCompletedTask.GetNodeFile(Constants.StandardOutFileName).ReadAsString();                              string stdErr = myCompletedTask.GetNodeFile(Constants.StandardErrorFileName).ReadAsString();                                this.testOutputHelper.WriteLine("StdOut: ");                              this.testOutputHelper.WriteLine("");                              this.testOutputHelper.WriteLine(stdOut);                              this.testOutputHelper.WriteLine("");                                this.testOutputHelper.WriteLine("StdErr: ");                              this.testOutputHelper.WriteLine(stdErr);                              this.testOutputHelper.WriteLine("");                                  List<SubtaskInformation> subtasks;                              Stopwatch sw = new Stopwatch();                              sw.Start();                              do                              {                                  IPagedEnumerable<SubtaskInformation> results = myCompletedTask.ListSubtasks();                                    subtasks = results.ToList();                                  if (subtasks.All(t => t.State == SubtaskState.Completed))                                  {                                      break;                                  }                                  Thread.Sleep(500);                              } while (sw.Elapsed <= checkSubtasksStateTimeout);                                Assert.True(sw.Elapsed <= checkSubtasksStateTimeout' string.Format("The subtasks state is not set to Complete after {0} seconds"' checkSubtasksStateTimeout.TotalSeconds));                              Assert.Equal(2' subtasks.Count);                              Assert.Equal(0' subtasks[0].ExitCode);                              Assert.Null(subtasks[0].FailureInformation);                              Assert.Equal(0' subtasks[1].ExitCode);                              Assert.Null(subtasks[1].FailureInformation);                              // Shouldnot assume the subtasks have order.                              Assert.True((subtasks[0].Id == 1 && subtasks[1].Id == 2) || (subtasks[0].Id == 2 && subtasks[1].Id == 1));                                this.testOutputHelper.WriteLine("Multi-instance test complete");                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,RealMpiTasks,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClientFromEnvironmentAsync().Result)                  {                      string jobId = "MPI-" + TestUtilities.GetMyName();                        try                      {                          // here we show how to use an unbound Job + Commit() to run a simple "Hello World" task                          // get an empty unbound Job                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolId });                          unboundJob.Commit();                            // Open the new Job as bound.                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            // get an empty unbound Task                          CloudTask hwTask = new CloudTask(id: "mpi"' commandline: @"cmd /c ""%MSMPI_BIN%\mpiexec.exe"" -p 6050 -wdir %AZ_BATCH_TASK_SHARED_DIR%\ Sieve.exe 1000");                          hwTask.MultiInstanceSettings = new MultiInstanceSettings(@"cmd /c start cmd /c ""%MSMPI_BIN%\smpd.exe"" -d 3 -p 6050"' 3);                          hwTask.MultiInstanceSettings.CommonResourceFiles = new List<ResourceFile>();                          hwTask.MultiInstanceSettings.CommonResourceFiles.Add(ResourceFile.FromUrl("https://manoj123.blob.core.windows.net/mpi/Sieve.exe"' "Sieve.exe"));                            // add Task to Job                          boundJob.AddTask(hwTask);                            {                              // wait for the task to complete                              Utilities utilities = batchCli.Utilities;                              TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                                taskStateMonitor.WaitAll(                                  boundJob.ListTasks()'                                  Microsoft.Azure.Batch.Common.TaskState.Completed'                                  TimeSpan.FromMinutes(3));                                CloudTask myCompletedTask = new List<CloudTask>(boundJob.ListTasks()).Single();                                string stdOut = myCompletedTask.GetNodeFile(Constants.StandardOutFileName).ReadAsString();                              string stdErr = myCompletedTask.GetNodeFile(Constants.StandardErrorFileName).ReadAsString();                                this.testOutputHelper.WriteLine("StdOut: ");                              this.testOutputHelper.WriteLine("");                              this.testOutputHelper.WriteLine(stdOut);                              this.testOutputHelper.WriteLine("");                                this.testOutputHelper.WriteLine("StdErr: ");                              this.testOutputHelper.WriteLine(stdErr);                              this.testOutputHelper.WriteLine("");                                Assert.Contains("There are 168 primes less than or equal to 1000"' stdOut);                                List<SubtaskInformation> subtasks;                              Stopwatch sw = new Stopwatch();                              sw.Start();                              do                              {                                  IPagedEnumerable<SubtaskInformation> results = batchCli.JobOperations.ListSubtasks(jobId' myCompletedTask.Id);                                    subtasks = results.ToList();                                  if (subtasks.All(t => t.State == SubtaskState.Completed))                                  {                                      break;                                  }                                  Thread.Sleep(500);                              } while (sw.Elapsed <= checkSubtasksStateTimeout);                                Assert.True(sw.Elapsed <= checkSubtasksStateTimeout' string.Format("The subtasks state is not set to Complete after {0} seconds"' checkSubtasksStateTimeout.TotalSeconds));                                this.testOutputHelper.WriteLine("MPI test complete");                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,RealMpiTasks,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClientFromEnvironmentAsync().Result)                  {                      string jobId = "MPI-" + TestUtilities.GetMyName();                        try                      {                          // here we show how to use an unbound Job + Commit() to run a simple "Hello World" task                          // get an empty unbound Job                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolId });                          unboundJob.Commit();                            // Open the new Job as bound.                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            // get an empty unbound Task                          CloudTask hwTask = new CloudTask(id: "mpi"' commandline: @"cmd /c ""%MSMPI_BIN%\mpiexec.exe"" -p 6050 -wdir %AZ_BATCH_TASK_SHARED_DIR%\ Sieve.exe 1000");                          hwTask.MultiInstanceSettings = new MultiInstanceSettings(@"cmd /c start cmd /c ""%MSMPI_BIN%\smpd.exe"" -d 3 -p 6050"' 3);                          hwTask.MultiInstanceSettings.CommonResourceFiles = new List<ResourceFile>();                          hwTask.MultiInstanceSettings.CommonResourceFiles.Add(ResourceFile.FromUrl("https://manoj123.blob.core.windows.net/mpi/Sieve.exe"' "Sieve.exe"));                            // add Task to Job                          boundJob.AddTask(hwTask);                            {                              // wait for the task to complete                              Utilities utilities = batchCli.Utilities;                              TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                                taskStateMonitor.WaitAll(                                  boundJob.ListTasks()'                                  Microsoft.Azure.Batch.Common.TaskState.Completed'                                  TimeSpan.FromMinutes(3));                                CloudTask myCompletedTask = new List<CloudTask>(boundJob.ListTasks()).Single();                                string stdOut = myCompletedTask.GetNodeFile(Constants.StandardOutFileName).ReadAsString();                              string stdErr = myCompletedTask.GetNodeFile(Constants.StandardErrorFileName).ReadAsString();                                this.testOutputHelper.WriteLine("StdOut: ");                              this.testOutputHelper.WriteLine("");                              this.testOutputHelper.WriteLine(stdOut);                              this.testOutputHelper.WriteLine("");                                this.testOutputHelper.WriteLine("StdErr: ");                              this.testOutputHelper.WriteLine(stdErr);                              this.testOutputHelper.WriteLine("");                                Assert.Contains("There are 168 primes less than or equal to 1000"' stdOut);                                List<SubtaskInformation> subtasks;                              Stopwatch sw = new Stopwatch();                              sw.Start();                              do                              {                                  IPagedEnumerable<SubtaskInformation> results = batchCli.JobOperations.ListSubtasks(jobId' myCompletedTask.Id);                                    subtasks = results.ToList();                                  if (subtasks.All(t => t.State == SubtaskState.Completed))                                  {                                      break;                                  }                                  Thread.Sleep(500);                              } while (sw.Elapsed <= checkSubtasksStateTimeout);                                Assert.True(sw.Elapsed <= checkSubtasksStateTimeout' string.Format("The subtasks state is not set to Complete after {0} seconds"' checkSubtasksStateTimeout.TotalSeconds));                                this.testOutputHelper.WriteLine("MPI test complete");                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationMultiInstanceCloudTaskTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,RealMpiTasks,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClientFromEnvironmentAsync().Result)                  {                      string jobId = "MPI-" + TestUtilities.GetMyName();                        try                      {                          // here we show how to use an unbound Job + Commit() to run a simple "Hello World" task                          // get an empty unbound Job                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolId });                          unboundJob.Commit();                            // Open the new Job as bound.                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            // get an empty unbound Task                          CloudTask hwTask = new CloudTask(id: "mpi"' commandline: @"cmd /c ""%MSMPI_BIN%\mpiexec.exe"" -p 6050 -wdir %AZ_BATCH_TASK_SHARED_DIR%\ Sieve.exe 1000");                          hwTask.MultiInstanceSettings = new MultiInstanceSettings(@"cmd /c start cmd /c ""%MSMPI_BIN%\smpd.exe"" -d 3 -p 6050"' 3);                          hwTask.MultiInstanceSettings.CommonResourceFiles = new List<ResourceFile>();                          hwTask.MultiInstanceSettings.CommonResourceFiles.Add(ResourceFile.FromUrl("https://manoj123.blob.core.windows.net/mpi/Sieve.exe"' "Sieve.exe"));                            // add Task to Job                          boundJob.AddTask(hwTask);                            {                              // wait for the task to complete                              Utilities utilities = batchCli.Utilities;                              TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                                taskStateMonitor.WaitAll(                                  boundJob.ListTasks()'                                  Microsoft.Azure.Batch.Common.TaskState.Completed'                                  TimeSpan.FromMinutes(3));                                CloudTask myCompletedTask = new List<CloudTask>(boundJob.ListTasks()).Single();                                string stdOut = myCompletedTask.GetNodeFile(Constants.StandardOutFileName).ReadAsString();                              string stdErr = myCompletedTask.GetNodeFile(Constants.StandardErrorFileName).ReadAsString();                                this.testOutputHelper.WriteLine("StdOut: ");                              this.testOutputHelper.WriteLine("");                              this.testOutputHelper.WriteLine(stdOut);                              this.testOutputHelper.WriteLine("");                                this.testOutputHelper.WriteLine("StdErr: ");                              this.testOutputHelper.WriteLine(stdErr);                              this.testOutputHelper.WriteLine("");                                Assert.Contains("There are 168 primes less than or equal to 1000"' stdOut);                                List<SubtaskInformation> subtasks;                              Stopwatch sw = new Stopwatch();                              sw.Start();                              do                              {                                  IPagedEnumerable<SubtaskInformation> results = batchCli.JobOperations.ListSubtasks(jobId' myCompletedTask.Id);                                    subtasks = results.ToList();                                  if (subtasks.All(t => t.State == SubtaskState.Completed))                                  {                                      break;                                  }                                  Thread.Sleep(500);                              } while (sw.Elapsed <= checkSubtasksStateTimeout);                                Assert.True(sw.Elapsed <= checkSubtasksStateTimeout' string.Format("The subtasks state is not set to Complete after {0} seconds"' checkSubtasksStateTimeout.TotalSeconds));                                this.testOutputHelper.WriteLine("MPI test complete");                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,Bug1432830TaskEnvSettings,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug1432830Job-" + TestUtilities.GetMyName();                        try                      {                          // remember how many env settings we create                          int numEnvSettings = 0;                            // here we show how to use an unbound Job + Commit() to run a simple "Hello World" task                          // get an empty unbound Job                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId });                          unboundJob.Commit();                            // Open the new Job as bound.                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            // get an empty unbound Task                          CloudTask hwTask = new CloudTask(id: "dwsHelloWorldTask"' commandline: "cmd /c echo Hello World");                            // get settings off of unbound task to confirm null                          IEnumerable<EnvironmentSetting> envSettings = hwTask.EnvironmentSettings;                            // unbound task should have null for env settings                          Assert.Null(envSettings);                            // construct sample settings to test feature                          List<EnvironmentSetting> newEnvSettings = new List<EnvironmentSetting>();                          EnvironmentSetting myES = new EnvironmentSetting("bug1432830EnvName"' "bug1432830EnvValue");                            newEnvSettings.Add(myES);                            // remember how many we create                          numEnvSettings = newEnvSettings.Count;                            // set the env settings                          hwTask.EnvironmentSettings = newEnvSettings;                            // add Task to Job                          boundJob.AddTask(hwTask);                            {                              // wait for the task to complete                              Utilities utilities = batchCli.Utilities;                              TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                                taskStateMonitor.WaitAll(                                  boundJob.ListTasks()'                                  Microsoft.Azure.Batch.Common.TaskState.Completed'                                  TimeSpan.FromMinutes(3));                                CloudTask myCompletedTask = new List<CloudTask>(boundJob.ListTasks())[0];                                string stdOut = myCompletedTask.GetNodeFile(Constants.StandardOutFileName).ReadAsString();                              string stdErr = myCompletedTask.GetNodeFile(Constants.StandardErrorFileName).ReadAsString();                                this.testOutputHelper.WriteLine("StdOut: ");                              this.testOutputHelper.WriteLine("");                              this.testOutputHelper.WriteLine(stdOut);                              this.testOutputHelper.WriteLine("");                                this.testOutputHelper.WriteLine("StdErr: ");                              this.testOutputHelper.WriteLine(stdErr);                              this.testOutputHelper.WriteLine("");                                // get env settings                              IEnumerable<EnvironmentSetting> boundSettings = myCompletedTask.EnvironmentSettings;                                // we set above so there should be a collection                              Assert.NotNull(boundSettings);                                List<EnvironmentSetting> compEnvSettings = new List<EnvironmentSetting>(boundSettings);                                // confirm #                              Assert.Equal(numEnvSettings' compEnvSettings.Count);                                this.testOutputHelper.WriteLine("Environement Settings: ");                                foreach (EnvironmentSetting curEnvSetting in boundSettings)                              {                                  this.testOutputHelper.WriteLine("    Name: " + curEnvSetting.Name + "' Value: " + curEnvSetting.Value);                              }                                this.testOutputHelper.WriteLine("Env Setting test complete");                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,Bug1447214TaskMissingExeInfoStatsAndConstraints,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug1447214Job-" + TestUtilities.GetMyName();                        try                      {                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId });                          unboundJob.Commit();                            // Open the new Job as bound.                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            CloudTask myTask = new CloudTask(id: "Bug1447214Task"' commandline: @"hostname");                            TaskConstraints ts = new TaskConstraints(maxWallClockTime: TimeSpan.FromHours(1)' retentionTime: TimeSpan.FromHours(1)' maxTaskRetryCount: 99);                            myTask.Constraints = ts;                            // add the task to the job                          boundJob.AddTask(myTask);                            // wait for the task to complete                          Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                            taskStateMonitor.WaitAll(                              boundJob.ListTasks()'                              Microsoft.Azure.Batch.Common.TaskState.Completed'                              TimeSpan.FromMinutes(3));                                                    CloudTask myCompletedTask = new List<CloudTask>(boundJob.ListTasks(null))[0];                            string stdOut = myCompletedTask.GetNodeFile(Constants.StandardOutFileName).ReadAsString();                          string stdErr = myCompletedTask.GetNodeFile(Constants.StandardErrorFileName).ReadAsString();                            this.testOutputHelper.WriteLine("TaskId: " + myCompletedTask.Id);                          this.testOutputHelper.WriteLine("StdOut: ");                          this.testOutputHelper.WriteLine(stdOut);                          this.testOutputHelper.WriteLine("");                            this.testOutputHelper.WriteLine("StdErr: ");                          this.testOutputHelper.WriteLine(stdErr);                          this.testOutputHelper.WriteLine("");                            this.testOutputHelper.WriteLine("TaskConstraints:");                            TaskConstraints compTC = myCompletedTask.Constraints;                            Assert.NotNull(compTC);                            if (null == compTC)                          {                              this.testOutputHelper.WriteLine("<null>");                          }                          else                          {                              this.testOutputHelper.WriteLine("");                              this.testOutputHelper.WriteLine("    maxWallClockTime: " + (compTC.MaxWallClockTime.HasValue ? compTC.MaxWallClockTime.ToString() : "<null>"));                              this.testOutputHelper.WriteLine("    retentionTime: " + (compTC.RetentionTime.HasValue ? compTC.RetentionTime.Value.ToString() : "<null>"));                              this.testOutputHelper.WriteLine("    maxTaskRetryCount: " + (compTC.MaxTaskRetryCount.HasValue ? compTC.MaxTaskRetryCount.Value.ToString() : "<null>"));                                Assert.True(compTC.MaxTaskRetryCount.HasValue);                              Assert.Equal(99' compTC.MaxTaskRetryCount.Value);                          }                            this.testOutputHelper.WriteLine("TaskExecutionInfo: ");                            TaskExecutionInformation tei = myCompletedTask.ExecutionInformation;                            Assert.NotNull(tei);                            if (null == tei)                          {                              this.testOutputHelper.WriteLine("<null>");                          }                          else                          {                              this.testOutputHelper.WriteLine("");                              this.testOutputHelper.WriteLine("    StartTime: " + (tei.StartTime.HasValue ? tei.StartTime.Value.ToString() : "<null>"));                              this.testOutputHelper.WriteLine("    LastUpdateTime:   " + (tei.EndTime.HasValue ? tei.EndTime.Value.ToString() : "<null>"));                              this.testOutputHelper.WriteLine("    ExitCode:  " + (tei.ExitCode.HasValue ? tei.ExitCode.Value.ToString() : "<null>"));                          }                            this.testOutputHelper.WriteLine("Stats: ");                            TaskStatistics compTS = myCompletedTask.Statistics;                            if (null == compTS)                          {                              this.testOutputHelper.WriteLine("<null>");                          }                          else                          {                              this.testOutputHelper.WriteLine("Url: " + compTS.Url);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,Bug1447214TaskMissingExeInfoStatsAndConstraints,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug1447214Job-" + TestUtilities.GetMyName();                        try                      {                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId });                          unboundJob.Commit();                            // Open the new Job as bound.                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            CloudTask myTask = new CloudTask(id: "Bug1447214Task"' commandline: @"hostname");                            TaskConstraints ts = new TaskConstraints(maxWallClockTime: TimeSpan.FromHours(1)' retentionTime: TimeSpan.FromHours(1)' maxTaskRetryCount: 99);                            myTask.Constraints = ts;                            // add the task to the job                          boundJob.AddTask(myTask);                            // wait for the task to complete                          Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                            taskStateMonitor.WaitAll(                              boundJob.ListTasks()'                              Microsoft.Azure.Batch.Common.TaskState.Completed'                              TimeSpan.FromMinutes(3));                                                    CloudTask myCompletedTask = new List<CloudTask>(boundJob.ListTasks(null))[0];                            string stdOut = myCompletedTask.GetNodeFile(Constants.StandardOutFileName).ReadAsString();                          string stdErr = myCompletedTask.GetNodeFile(Constants.StandardErrorFileName).ReadAsString();                            this.testOutputHelper.WriteLine("TaskId: " + myCompletedTask.Id);                          this.testOutputHelper.WriteLine("StdOut: ");                          this.testOutputHelper.WriteLine(stdOut);                          this.testOutputHelper.WriteLine("");                            this.testOutputHelper.WriteLine("StdErr: ");                          this.testOutputHelper.WriteLine(stdErr);                          this.testOutputHelper.WriteLine("");                            this.testOutputHelper.WriteLine("TaskConstraints:");                            TaskConstraints compTC = myCompletedTask.Constraints;                            Assert.NotNull(compTC);                            if (null == compTC)                          {                              this.testOutputHelper.WriteLine("<null>");                          }                          else                          {                              this.testOutputHelper.WriteLine("");                              this.testOutputHelper.WriteLine("    maxWallClockTime: " + (compTC.MaxWallClockTime.HasValue ? compTC.MaxWallClockTime.ToString() : "<null>"));                              this.testOutputHelper.WriteLine("    retentionTime: " + (compTC.RetentionTime.HasValue ? compTC.RetentionTime.Value.ToString() : "<null>"));                              this.testOutputHelper.WriteLine("    maxTaskRetryCount: " + (compTC.MaxTaskRetryCount.HasValue ? compTC.MaxTaskRetryCount.Value.ToString() : "<null>"));                                Assert.True(compTC.MaxTaskRetryCount.HasValue);                              Assert.Equal(99' compTC.MaxTaskRetryCount.Value);                          }                            this.testOutputHelper.WriteLine("TaskExecutionInfo: ");                            TaskExecutionInformation tei = myCompletedTask.ExecutionInformation;                            Assert.NotNull(tei);                            if (null == tei)                          {                              this.testOutputHelper.WriteLine("<null>");                          }                          else                          {                              this.testOutputHelper.WriteLine("");                              this.testOutputHelper.WriteLine("    StartTime: " + (tei.StartTime.HasValue ? tei.StartTime.Value.ToString() : "<null>"));                              this.testOutputHelper.WriteLine("    LastUpdateTime:   " + (tei.EndTime.HasValue ? tei.EndTime.Value.ToString() : "<null>"));                              this.testOutputHelper.WriteLine("    ExitCode:  " + (tei.ExitCode.HasValue ? tei.ExitCode.Value.ToString() : "<null>"));                          }                            this.testOutputHelper.WriteLine("Stats: ");                            TaskStatistics compTS = myCompletedTask.Statistics;                            if (null == compTS)                          {                              this.testOutputHelper.WriteLine("<null>");                          }                          else                          {                              this.testOutputHelper.WriteLine("Url: " + compTS.Url);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,Bug1447214TaskMissingExeInfoStatsAndConstraints,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug1447214Job-" + TestUtilities.GetMyName();                        try                      {                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId });                          unboundJob.Commit();                            // Open the new Job as bound.                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            CloudTask myTask = new CloudTask(id: "Bug1447214Task"' commandline: @"hostname");                            TaskConstraints ts = new TaskConstraints(maxWallClockTime: TimeSpan.FromHours(1)' retentionTime: TimeSpan.FromHours(1)' maxTaskRetryCount: 99);                            myTask.Constraints = ts;                            // add the task to the job                          boundJob.AddTask(myTask);                            // wait for the task to complete                          Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                            taskStateMonitor.WaitAll(                              boundJob.ListTasks()'                              Microsoft.Azure.Batch.Common.TaskState.Completed'                              TimeSpan.FromMinutes(3));                                                    CloudTask myCompletedTask = new List<CloudTask>(boundJob.ListTasks(null))[0];                            string stdOut = myCompletedTask.GetNodeFile(Constants.StandardOutFileName).ReadAsString();                          string stdErr = myCompletedTask.GetNodeFile(Constants.StandardErrorFileName).ReadAsString();                            this.testOutputHelper.WriteLine("TaskId: " + myCompletedTask.Id);                          this.testOutputHelper.WriteLine("StdOut: ");                          this.testOutputHelper.WriteLine(stdOut);                          this.testOutputHelper.WriteLine("");                            this.testOutputHelper.WriteLine("StdErr: ");                          this.testOutputHelper.WriteLine(stdErr);                          this.testOutputHelper.WriteLine("");                            this.testOutputHelper.WriteLine("TaskConstraints:");                            TaskConstraints compTC = myCompletedTask.Constraints;                            Assert.NotNull(compTC);                            if (null == compTC)                          {                              this.testOutputHelper.WriteLine("<null>");                          }                          else                          {                              this.testOutputHelper.WriteLine("");                              this.testOutputHelper.WriteLine("    maxWallClockTime: " + (compTC.MaxWallClockTime.HasValue ? compTC.MaxWallClockTime.ToString() : "<null>"));                              this.testOutputHelper.WriteLine("    retentionTime: " + (compTC.RetentionTime.HasValue ? compTC.RetentionTime.Value.ToString() : "<null>"));                              this.testOutputHelper.WriteLine("    maxTaskRetryCount: " + (compTC.MaxTaskRetryCount.HasValue ? compTC.MaxTaskRetryCount.Value.ToString() : "<null>"));                                Assert.True(compTC.MaxTaskRetryCount.HasValue);                              Assert.Equal(99' compTC.MaxTaskRetryCount.Value);                          }                            this.testOutputHelper.WriteLine("TaskExecutionInfo: ");                            TaskExecutionInformation tei = myCompletedTask.ExecutionInformation;                            Assert.NotNull(tei);                            if (null == tei)                          {                              this.testOutputHelper.WriteLine("<null>");                          }                          else                          {                              this.testOutputHelper.WriteLine("");                              this.testOutputHelper.WriteLine("    StartTime: " + (tei.StartTime.HasValue ? tei.StartTime.Value.ToString() : "<null>"));                              this.testOutputHelper.WriteLine("    LastUpdateTime:   " + (tei.EndTime.HasValue ? tei.EndTime.Value.ToString() : "<null>"));                              this.testOutputHelper.WriteLine("    ExitCode:  " + (tei.ExitCode.HasValue ? tei.ExitCode.Value.ToString() : "<null>"));                          }                            this.testOutputHelper.WriteLine("Stats: ");                            TaskStatistics compTS = myCompletedTask.Statistics;                            if (null == compTS)                          {                              this.testOutputHelper.WriteLine("<null>");                          }                          else                          {                              this.testOutputHelper.WriteLine("Url: " + compTS.Url);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,Bug1535329JobOperationsMissingAddTaskMethods,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      StagingStorageAccount stagingStorageAccount = TestUtilities.GetStorageCredentialsFromEnvironment();                        string jobId = "Bug1535329Job-" + TestUtilities.GetMyName();                        try                      {                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId });                          unboundJob.Commit();                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            CloudTask unboundTask = new CloudTask(id: "bug1535329Task0"' commandline: "hostname");                            boundJob.AddTask(unboundTask);                            CloudTask newTaskToAdd = new CloudTask(id: "bug1535329NewTask"' commandline: "hostname");                            // add some files to confirm file staging is working                          FileToStage wordsDotText = new FileToStage(Resources.LocalWordsDotText' stagingStorageAccount);                            newTaskToAdd.FilesToStage = new List<IFileStagingProvider>();                            newTaskToAdd.FilesToStage.Add(wordsDotText);                            batchCli.JobOperations.AddTask(jobId' newTaskToAdd);                            bool foundLocalWords = false;                            Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                            taskStateMonitor.WaitAll(                              boundJob.ListTasks()'                              Microsoft.Azure.Batch.Common.TaskState.Completed'                              TimeSpan.FromMinutes(5));                            foreach (CloudTask curTask in boundJob.ListTasks())                          {                              this.testOutputHelper.WriteLine("TaskId: " + curTask.Id);                                foreach (NodeFile curFile in curTask.ListNodeFiles(recursive: true))                              {                                  this.testOutputHelper.WriteLine("    filename: " + curFile.Path);                                    if (curFile.Path.IndexOf("localWords.txt"' StringComparison.InvariantCultureIgnoreCase) >= 0)                                  {                                      Assert.False(foundLocalWords);                                      foundLocalWords = true;                                  }                              }                          }                            Assert.True(foundLocalWords);                      }                      finally                      {                          // clean up                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,Bug1611592ComputeNodeInfoMissingOnTask,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug1611592Job-" + TestUtilities.GetMyName();                      try                      {                          CloudJob unJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId });                          unJob.Commit();                            CloudTask unTask = new CloudTask("Bug1611592"' "hostname");                          TestUtilities.AssertThrows<InvalidOperationException>(() => { var f = unTask.ComputeNodeInformation; });                            CloudJob bndJob = batchCli.JobOperations.GetJob(jobId);                            bndJob.AddTask(unTask);                            Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                            taskStateMonitor.WaitAll(                              bndJob.ListTasks()'                              Microsoft.Azure.Batch.Common.TaskState.Completed'                              TimeSpan.FromMinutes(5));                            foreach (CloudTask curTask in bndJob.ListTasks())                          {                              ComputeNodeInformation computeNodeInfo = curTask.ComputeNodeInformation;                                Assert.NotNull(computeNodeInfo);                                this.testOutputHelper.WriteLine("Task: " + curTask.Id);                              this.testOutputHelper.WriteLine("ComputeNodeInfo:");                                this.testOutputHelper.WriteLine("    PoolId: " + computeNodeInfo.PoolId);                              this.testOutputHelper.WriteLine("    ComputeNodeId: " + computeNodeInfo.ComputeNodeId);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,TestBoundTaskTerminateAndDelete,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestBoundTaskTerminateAndDelete";                        try                      {                          //Create the job                          CloudJob cloudJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          cloudJob.PoolInformation = new PoolInformation()                          {                              PoolId = this.poolFixture.PoolId                          };                          this.testOutputHelper.WriteLine("Creating job: {0}"' jobId);                          cloudJob.Commit();                            {                              //Create a task                              const string taskId = "T1";                              CloudTask taskToAdd = new CloudTask(taskId' "ping 127.0.0.1 -n 60"); //Task which runs for 60s                                //Add the task                              this.testOutputHelper.WriteLine("Adding task: {0}"' taskId);                              batchCli.JobOperations.AddTask(jobId' taskToAdd);                                //Wait for the task to go to running state                              List<CloudTask> tasks = batchCli.JobOperations.ListTasks(jobId).ToList();                                Assert.Single(tasks);                                //Check that the task is running                              TaskStateMonitor taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                                //Wait for the task state to be running                              taskStateMonitor.WaitAll(                                  tasks'                                  TaskState.Running'                                  TimeSpan.FromSeconds(30)'                                  new ODATAMonitorControl {DelayBetweenDataFetch = TimeSpan.FromSeconds(5)});                                //Terminate the running task                              this.testOutputHelper.WriteLine("Terminating task {0}"' taskId);                              CloudTask runningTask = batchCli.JobOperations.GetTask(jobId' taskId);                              runningTask.Terminate();                                //Check task state                              runningTask.Refresh();                                Assert.Equal(TaskState.Completed' runningTask.State);                                runningTask.Refresh();                                //Delete the task                              this.testOutputHelper.WriteLine("Deleting task {0}"' taskId);                              runningTask.Delete();                                List<CloudTask> taskListAfterDelete = batchCli.JobOperations.ListTasks(jobId).ToList();                                Assert.Empty(taskListAfterDelete);                          }                            {                              //Create a task                              const string taskId = "T2";                              CloudTask taskToAdd = new CloudTask(taskId' "ping 127.0.0.1 -n 60"); //Task which runs for 60s                                //Add the task                              this.testOutputHelper.WriteLine("Adding task: {0}"' taskId);                              batchCli.JobOperations.AddTask(jobId' taskToAdd);                                //Wait for the task to go to running state                              List<CloudTask> tasks = batchCli.JobOperations.ListTasks(jobId).ToList();                                Assert.Single(tasks);                                //Check that the task is running                              TaskStateMonitor taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                                //Wait for the task state to be running                                taskStateMonitor.WaitAll(                                  tasks'                                  TaskState.Running'                                  TimeSpan.FromSeconds(30)'                                  new ODATAMonitorControl { DelayBetweenDataFetch = TimeSpan.FromSeconds(5) });                                                            //Terminate the running task                              this.testOutputHelper.WriteLine("Terminating task {0}"' taskId);                              CloudTask runningTask = batchCli.JobOperations.GetTask(jobId' taskId);                              batchCli.JobOperations.TerminateTask(jobId' taskId);                                //Check task state                              runningTask.Refresh();                                Assert.Equal(TaskState.Completed' runningTask.State);                                runningTask.Refresh();                                //Delete the task                              this.testOutputHelper.WriteLine("Deleting task {0}"' taskId);                              runningTask.Delete();                                List<CloudTask> taskListAfterDelete = batchCli.JobOperations.ListTasks(jobId).ToList();                                Assert.Empty(taskListAfterDelete);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,TestBoundTaskTerminateAndDelete,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestBoundTaskTerminateAndDelete";                        try                      {                          //Create the job                          CloudJob cloudJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          cloudJob.PoolInformation = new PoolInformation()                          {                              PoolId = this.poolFixture.PoolId                          };                          this.testOutputHelper.WriteLine("Creating job: {0}"' jobId);                          cloudJob.Commit();                            {                              //Create a task                              const string taskId = "T1";                              CloudTask taskToAdd = new CloudTask(taskId' "ping 127.0.0.1 -n 60"); //Task which runs for 60s                                //Add the task                              this.testOutputHelper.WriteLine("Adding task: {0}"' taskId);                              batchCli.JobOperations.AddTask(jobId' taskToAdd);                                //Wait for the task to go to running state                              List<CloudTask> tasks = batchCli.JobOperations.ListTasks(jobId).ToList();                                Assert.Single(tasks);                                //Check that the task is running                              TaskStateMonitor taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                                //Wait for the task state to be running                              taskStateMonitor.WaitAll(                                  tasks'                                  TaskState.Running'                                  TimeSpan.FromSeconds(30)'                                  new ODATAMonitorControl {DelayBetweenDataFetch = TimeSpan.FromSeconds(5)});                                //Terminate the running task                              this.testOutputHelper.WriteLine("Terminating task {0}"' taskId);                              CloudTask runningTask = batchCli.JobOperations.GetTask(jobId' taskId);                              runningTask.Terminate();                                //Check task state                              runningTask.Refresh();                                Assert.Equal(TaskState.Completed' runningTask.State);                                runningTask.Refresh();                                //Delete the task                              this.testOutputHelper.WriteLine("Deleting task {0}"' taskId);                              runningTask.Delete();                                List<CloudTask> taskListAfterDelete = batchCli.JobOperations.ListTasks(jobId).ToList();                                Assert.Empty(taskListAfterDelete);                          }                            {                              //Create a task                              const string taskId = "T2";                              CloudTask taskToAdd = new CloudTask(taskId' "ping 127.0.0.1 -n 60"); //Task which runs for 60s                                //Add the task                              this.testOutputHelper.WriteLine("Adding task: {0}"' taskId);                              batchCli.JobOperations.AddTask(jobId' taskToAdd);                                //Wait for the task to go to running state                              List<CloudTask> tasks = batchCli.JobOperations.ListTasks(jobId).ToList();                                Assert.Single(tasks);                                //Check that the task is running                              TaskStateMonitor taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                                //Wait for the task state to be running                                taskStateMonitor.WaitAll(                                  tasks'                                  TaskState.Running'                                  TimeSpan.FromSeconds(30)'                                  new ODATAMonitorControl { DelayBetweenDataFetch = TimeSpan.FromSeconds(5) });                                                            //Terminate the running task                              this.testOutputHelper.WriteLine("Terminating task {0}"' taskId);                              CloudTask runningTask = batchCli.JobOperations.GetTask(jobId' taskId);                              batchCli.JobOperations.TerminateTask(jobId' taskId);                                //Check task state                              runningTask.Refresh();                                Assert.Equal(TaskState.Completed' runningTask.State);                                runningTask.Refresh();                                //Delete the task                              this.testOutputHelper.WriteLine("Deleting task {0}"' taskId);                              runningTask.Delete();                                List<CloudTask> taskListAfterDelete = batchCli.JobOperations.ListTasks(jobId).ToList();                                Assert.Empty(taskListAfterDelete);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,TestBoundTaskTerminateAndDelete,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestBoundTaskTerminateAndDelete";                        try                      {                          //Create the job                          CloudJob cloudJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          cloudJob.PoolInformation = new PoolInformation()                          {                              PoolId = this.poolFixture.PoolId                          };                          this.testOutputHelper.WriteLine("Creating job: {0}"' jobId);                          cloudJob.Commit();                            {                              //Create a task                              const string taskId = "T1";                              CloudTask taskToAdd = new CloudTask(taskId' "ping 127.0.0.1 -n 60"); //Task which runs for 60s                                //Add the task                              this.testOutputHelper.WriteLine("Adding task: {0}"' taskId);                              batchCli.JobOperations.AddTask(jobId' taskToAdd);                                //Wait for the task to go to running state                              List<CloudTask> tasks = batchCli.JobOperations.ListTasks(jobId).ToList();                                Assert.Single(tasks);                                //Check that the task is running                              TaskStateMonitor taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                                //Wait for the task state to be running                              taskStateMonitor.WaitAll(                                  tasks'                                  TaskState.Running'                                  TimeSpan.FromSeconds(30)'                                  new ODATAMonitorControl {DelayBetweenDataFetch = TimeSpan.FromSeconds(5)});                                //Terminate the running task                              this.testOutputHelper.WriteLine("Terminating task {0}"' taskId);                              CloudTask runningTask = batchCli.JobOperations.GetTask(jobId' taskId);                              runningTask.Terminate();                                //Check task state                              runningTask.Refresh();                                Assert.Equal(TaskState.Completed' runningTask.State);                                runningTask.Refresh();                                //Delete the task                              this.testOutputHelper.WriteLine("Deleting task {0}"' taskId);                              runningTask.Delete();                                List<CloudTask> taskListAfterDelete = batchCli.JobOperations.ListTasks(jobId).ToList();                                Assert.Empty(taskListAfterDelete);                          }                            {                              //Create a task                              const string taskId = "T2";                              CloudTask taskToAdd = new CloudTask(taskId' "ping 127.0.0.1 -n 60"); //Task which runs for 60s                                //Add the task                              this.testOutputHelper.WriteLine("Adding task: {0}"' taskId);                              batchCli.JobOperations.AddTask(jobId' taskToAdd);                                //Wait for the task to go to running state                              List<CloudTask> tasks = batchCli.JobOperations.ListTasks(jobId).ToList();                                Assert.Single(tasks);                                //Check that the task is running                              TaskStateMonitor taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                                //Wait for the task state to be running                                taskStateMonitor.WaitAll(                                  tasks'                                  TaskState.Running'                                  TimeSpan.FromSeconds(30)'                                  new ODATAMonitorControl { DelayBetweenDataFetch = TimeSpan.FromSeconds(5) });                                                            //Terminate the running task                              this.testOutputHelper.WriteLine("Terminating task {0}"' taskId);                              CloudTask runningTask = batchCli.JobOperations.GetTask(jobId' taskId);                              batchCli.JobOperations.TerminateTask(jobId' taskId);                                //Check task state                              runningTask.Refresh();                                Assert.Equal(TaskState.Completed' runningTask.State);                                runningTask.Refresh();                                //Delete the task                              this.testOutputHelper.WriteLine("Deleting task {0}"' taskId);                              runningTask.Delete();                                List<CloudTask> taskListAfterDelete = batchCli.JobOperations.ListTasks(jobId).ToList();                                Assert.Empty(taskListAfterDelete);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,TestBoundTaskTerminateAndDelete,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-TestBoundTaskTerminateAndDelete";                        try                      {                          //Create the job                          CloudJob cloudJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          cloudJob.PoolInformation = new PoolInformation()                          {                              PoolId = this.poolFixture.PoolId                          };                          this.testOutputHelper.WriteLine("Creating job: {0}"' jobId);                          cloudJob.Commit();                            {                              //Create a task                              const string taskId = "T1";                              CloudTask taskToAdd = new CloudTask(taskId' "ping 127.0.0.1 -n 60"); //Task which runs for 60s                                //Add the task                              this.testOutputHelper.WriteLine("Adding task: {0}"' taskId);                              batchCli.JobOperations.AddTask(jobId' taskToAdd);                                //Wait for the task to go to running state                              List<CloudTask> tasks = batchCli.JobOperations.ListTasks(jobId).ToList();                                Assert.Single(tasks);                                //Check that the task is running                              TaskStateMonitor taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                                //Wait for the task state to be running                              taskStateMonitor.WaitAll(                                  tasks'                                  TaskState.Running'                                  TimeSpan.FromSeconds(30)'                                  new ODATAMonitorControl {DelayBetweenDataFetch = TimeSpan.FromSeconds(5)});                                //Terminate the running task                              this.testOutputHelper.WriteLine("Terminating task {0}"' taskId);                              CloudTask runningTask = batchCli.JobOperations.GetTask(jobId' taskId);                              runningTask.Terminate();                                //Check task state                              runningTask.Refresh();                                Assert.Equal(TaskState.Completed' runningTask.State);                                runningTask.Refresh();                                //Delete the task                              this.testOutputHelper.WriteLine("Deleting task {0}"' taskId);                              runningTask.Delete();                                List<CloudTask> taskListAfterDelete = batchCli.JobOperations.ListTasks(jobId).ToList();                                Assert.Empty(taskListAfterDelete);                          }                            {                              //Create a task                              const string taskId = "T2";                              CloudTask taskToAdd = new CloudTask(taskId' "ping 127.0.0.1 -n 60"); //Task which runs for 60s                                //Add the task                              this.testOutputHelper.WriteLine("Adding task: {0}"' taskId);                              batchCli.JobOperations.AddTask(jobId' taskToAdd);                                //Wait for the task to go to running state                              List<CloudTask> tasks = batchCli.JobOperations.ListTasks(jobId).ToList();                                Assert.Single(tasks);                                //Check that the task is running                              TaskStateMonitor taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                                //Wait for the task state to be running                                taskStateMonitor.WaitAll(                                  tasks'                                  TaskState.Running'                                  TimeSpan.FromSeconds(30)'                                  new ODATAMonitorControl { DelayBetweenDataFetch = TimeSpan.FromSeconds(5) });                                                            //Terminate the running task                              this.testOutputHelper.WriteLine("Terminating task {0}"' taskId);                              CloudTask runningTask = batchCli.JobOperations.GetTask(jobId' taskId);                              batchCli.JobOperations.TerminateTask(jobId' taskId);                                //Check task state                              runningTask.Refresh();                                Assert.Equal(TaskState.Completed' runningTask.State);                                runningTask.Refresh();                                //Delete the task                              this.testOutputHelper.WriteLine("Deleting task {0}"' taskId);                              runningTask.Delete();                                List<CloudTask> taskListAfterDelete = batchCli.JobOperations.ListTasks(jobId).ToList();                                Assert.Empty(taskListAfterDelete);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,FailedTaskCanBeReactivated,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + Guid.NewGuid();                        try                      {                          //Create the job                          CloudJob cloudJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          cloudJob.PoolInformation = new PoolInformation() { PoolId = this.poolFixture.PoolId };                          this.testOutputHelper.WriteLine("Creating job: {0}"' jobId);                          cloudJob.Commit();                                                    //Create a task                          const string taskId = "T1";                          CloudTask taskToAdd = new CloudTask(taskId' "cmd /c \"ping 127.0.0.1 -n 20 > nul && exit /b 3\"");                            //Add the task                          this.testOutputHelper.WriteLine("Adding task: {0}"' taskId);                          batchCli.JobOperations.AddTask(jobId' taskToAdd);                            CloudTask task = batchCli.JobOperations.GetTask(jobId' taskId);                          TaskStateMonitor taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                            //Wait for the task state to complete                           taskStateMonitor.WaitAll(new[] { task }' TaskState.Completed' TimeSpan.FromMinutes(2));                            task.Refresh();                          Assert.Equal(3' task.ExecutionInformation.ExitCode);                            // If you disable the job the tasks stay in the active state.                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                          boundJob.Disable(DisableJobOption.Requeue);                            //Reactivate failed task                          task.Reactivate();                          task.Refresh();                          Assert.Equal(TaskState.Active' task.State);                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,FailedTaskCanBeReactivated,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + Guid.NewGuid();                        try                      {                          //Create the job                          CloudJob cloudJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          cloudJob.PoolInformation = new PoolInformation() { PoolId = this.poolFixture.PoolId };                          this.testOutputHelper.WriteLine("Creating job: {0}"' jobId);                          cloudJob.Commit();                                                    //Create a task                          const string taskId = "T1";                          CloudTask taskToAdd = new CloudTask(taskId' "cmd /c \"ping 127.0.0.1 -n 20 > nul && exit /b 3\"");                            //Add the task                          this.testOutputHelper.WriteLine("Adding task: {0}"' taskId);                          batchCli.JobOperations.AddTask(jobId' taskToAdd);                            CloudTask task = batchCli.JobOperations.GetTask(jobId' taskId);                          TaskStateMonitor taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                            //Wait for the task state to complete                           taskStateMonitor.WaitAll(new[] { task }' TaskState.Completed' TimeSpan.FromMinutes(2));                            task.Refresh();                          Assert.Equal(3' task.ExecutionInformation.ExitCode);                            // If you disable the job the tasks stay in the active state.                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                          boundJob.Disable(DisableJobOption.Requeue);                            //Reactivate failed task                          task.Reactivate();                          task.Refresh();                          Assert.Equal(TaskState.Active' task.State);                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudTaskIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,DependencyActionIsRoundTripped,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + Guid.NewGuid();                        try                      {                          //Create the job                          CloudJob cloudJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId });                          cloudJob.OnTaskFailure = OnTaskFailure.PerformExitOptionsJobAction;                            cloudJob.UsesTaskDependencies = true;                          cloudJob.Commit();                            //Create a task                          const string taskId = "T1";                          CloudTask taskToAdd = new CloudTask(taskId' "cmd /c \"ping 127.0.0.1 \"");                                                    //Add the task                          this.testOutputHelper.WriteLine("Adding task: {0}"' taskId);                          taskToAdd.ExitConditions = new ExitConditions { Default = new ExitOptions {JobAction = JobAction.Terminate' DependencyAction = DependencyAction.Satisfy} };                          batchCli.JobOperations.AddTask(jobId' taskToAdd);                            CloudTask task = batchCli.JobOperations.GetTask(jobId' taskId);                          TaskStateMonitor taskStateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                            //Wait for the task state to complete                           taskStateMonitor.WaitAll(new[] { task }' TaskState.Completed' TimeSpan.FromMinutes(2));                            task.Refresh();                          Assert.Equal(DependencyAction.Satisfy' task.ExitConditions.Default.DependencyAction);                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudTaskTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,UpdateTask_TaskIsUpdatedAsExpected,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      const string taskId = "task1";                        string jobId = TestUtilities.GenerateResourceId();                      TaskConstraints defaultConstraints = new TaskConstraints(TimeSpan.MaxValue' TimeSpan.FromDays(7)' 0);                      try                      {                          //                          // Create the job                          //                          CloudJob jobSchedule = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          jobSchedule.PoolInformation = new PoolInformation()                          {                              PoolId = "PoolWhoDoesntExist"                          };                            this.testOutputHelper.WriteLine("Initial job schedule commit()");                          jobSchedule.Commit();                            //Get the job                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                          CloudTask myTask = new CloudTask(taskId' "cmd /c echo hello world");                            //Add the task                          this.testOutputHelper.WriteLine("Adding task: {0}"' taskId);                          boundJob.AddTask(myTask);                            //Get the task and check the constraints                          CloudTask boundTask = batchCli.JobOperations.GetTask(jobId' taskId);                            Assert.Equal(defaultConstraints.MaxTaskRetryCount' boundTask.Constraints.MaxTaskRetryCount);                          Assert.Equal(defaultConstraints.MaxWallClockTime' boundTask.Constraints.MaxWallClockTime);                          Assert.Equal(defaultConstraints.RetentionTime' boundTask.Constraints.RetentionTime);                            TimeSpan maxWallClockTime = TimeSpan.FromHours(1);                          TimeSpan dataRetentionTime = TimeSpan.FromHours(2);                          const int maxRetryCount = 1;                          boundTask.Constraints = new TaskConstraints(maxWallClockTime' dataRetentionTime' maxRetryCount);                            this.testOutputHelper.WriteLine("Updating task constraints");                            boundTask.Commit();                            //Ensure the commit worked                          boundTask.Refresh();                            Assert.Equal(maxRetryCount' boundTask.Constraints.MaxTaskRetryCount);                          Assert.Equal(maxWallClockTime' boundTask.Constraints.MaxWallClockTime);                          Assert.Equal(dataRetentionTime' boundTask.Constraints.RetentionTime);                            CloudTask freshTask = batchCli.JobOperations.GetTask(jobId' taskId);                            Assert.Equal(maxRetryCount' freshTask.Constraints.MaxTaskRetryCount);                          Assert.Equal(maxWallClockTime' freshTask.Constraints.MaxWallClockTime);                          Assert.Equal(dataRetentionTime' freshTask.Constraints.RetentionTime);                            //Update the task constraints to be null again                          freshTask.Constraints = null;                          freshTask.Commit();                            freshTask.Refresh();                            //Ensure the commit worked                          Assert.Equal(defaultConstraints.MaxTaskRetryCount' freshTask.Constraints.MaxTaskRetryCount);                          Assert.Equal(defaultConstraints.MaxWallClockTime' freshTask.Constraints.MaxWallClockTime);                          Assert.Equal(defaultConstraints.RetentionTime' freshTask.Constraints.RetentionTime);                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudTaskTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,UpdateTask_TaskIsUpdatedAsExpected,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      const string taskId = "task1";                        string jobId = TestUtilities.GenerateResourceId();                      TaskConstraints defaultConstraints = new TaskConstraints(TimeSpan.MaxValue' TimeSpan.FromDays(7)' 0);                      try                      {                          //                          // Create the job                          //                          CloudJob jobSchedule = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          jobSchedule.PoolInformation = new PoolInformation()                          {                              PoolId = "PoolWhoDoesntExist"                          };                            this.testOutputHelper.WriteLine("Initial job schedule commit()");                          jobSchedule.Commit();                            //Get the job                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                          CloudTask myTask = new CloudTask(taskId' "cmd /c echo hello world");                            //Add the task                          this.testOutputHelper.WriteLine("Adding task: {0}"' taskId);                          boundJob.AddTask(myTask);                            //Get the task and check the constraints                          CloudTask boundTask = batchCli.JobOperations.GetTask(jobId' taskId);                            Assert.Equal(defaultConstraints.MaxTaskRetryCount' boundTask.Constraints.MaxTaskRetryCount);                          Assert.Equal(defaultConstraints.MaxWallClockTime' boundTask.Constraints.MaxWallClockTime);                          Assert.Equal(defaultConstraints.RetentionTime' boundTask.Constraints.RetentionTime);                            TimeSpan maxWallClockTime = TimeSpan.FromHours(1);                          TimeSpan dataRetentionTime = TimeSpan.FromHours(2);                          const int maxRetryCount = 1;                          boundTask.Constraints = new TaskConstraints(maxWallClockTime' dataRetentionTime' maxRetryCount);                            this.testOutputHelper.WriteLine("Updating task constraints");                            boundTask.Commit();                            //Ensure the commit worked                          boundTask.Refresh();                            Assert.Equal(maxRetryCount' boundTask.Constraints.MaxTaskRetryCount);                          Assert.Equal(maxWallClockTime' boundTask.Constraints.MaxWallClockTime);                          Assert.Equal(dataRetentionTime' boundTask.Constraints.RetentionTime);                            CloudTask freshTask = batchCli.JobOperations.GetTask(jobId' taskId);                            Assert.Equal(maxRetryCount' freshTask.Constraints.MaxTaskRetryCount);                          Assert.Equal(maxWallClockTime' freshTask.Constraints.MaxWallClockTime);                          Assert.Equal(dataRetentionTime' freshTask.Constraints.RetentionTime);                            //Update the task constraints to be null again                          freshTask.Constraints = null;                          freshTask.Commit();                            freshTask.Refresh();                            //Ensure the commit worked                          Assert.Equal(defaultConstraints.MaxTaskRetryCount' freshTask.Constraints.MaxTaskRetryCount);                          Assert.Equal(defaultConstraints.MaxWallClockTime' freshTask.Constraints.MaxWallClockTime);                          Assert.Equal(defaultConstraints.RetentionTime' freshTask.Constraints.RetentionTime);                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationCloudTaskTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskIntegrationTests.cs,SetTaskConditionalHeaders,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClientFromEnvironmentAsync().Result)                  {                      string jobId = "TaskConditionalHeaders-" + TestUtilities.GetMyName();                      try                      {                          PoolInformation poolInfo = new PoolInformation()                          {                              PoolId = "Fake"                          };                            CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' poolInfo);                          unboundJob.Commit();                            const string taskId = "T1";                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                          boundJob.AddTask(new CloudTask(taskId' "cmd /c dir"));                            CloudTask boundTask = batchCli.JobOperations.GetTask(jobId' taskId);                          string capturedEtag1 = boundTask.ETag;                            boundTask.Constraints = new TaskConstraints(null' null' 5);                            BatchClientBehavior interceptor = new Protocol.RequestInterceptor(                              (req) =>                              {                                  var typedParams = req.Options as Protocol.Models.TaskUpdateOptions;                                  if (typedParams != null)                                  {                                      typedParams.IfMatch = capturedEtag1;                                  }                              });                            //Update bound task with if-match header' it should succeed                          boundTask.Commit(additionalBehaviors: new[] { interceptor });                            boundTask = batchCli.JobOperations.GetTask(jobId' taskId);                            interceptor = new Protocol.RequestInterceptor(                              (req) =>                              {                                  var typedParams = req.Options as Protocol.Models.TaskTerminateOptions;                                  if (typedParams != null)                                  {                                      typedParams.IfMatch = capturedEtag1;                                  }                              });                            //Terminate bound task with if-match header' it should fail                          Exception e = TestUtilities.AssertThrows<BatchException>(() => boundTask.Terminate(additionalBehaviors: new[] { interceptor }));                          TestUtilities.AssertIsBatchExceptionAndHasCorrectAzureErrorCode(e' BatchErrorCodeStrings.ConditionNotMet' this.testOutputHelper);                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudTaskLinuxIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskLinuxIntegrationTests.cs,RunTaskAndUploadFiles_FilesAreSuccessfullyUploaded,The following statement contains a magic number: Action test = async () =>              {                  string containerName = "runtaskanduploadfiles";                  StagingStorageAccount storageAccount = TestUtilities.GetStorageCredentialsFromEnvironment();                  CloudStorageAccount cloudStorageAccount = new CloudStorageAccount(                      new StorageCredentials(storageAccount.StorageAccount' storageAccount.StorageAccountKey)'                      blobEndpoint: storageAccount.BlobUri'                      queueEndpoint: null'                      tableEndpoint: null'                      fileEndpoint: null);                  CloudBlobClient blobClient = cloudStorageAccount.CreateCloudBlobClient();                    using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "RunTaskAndUploadFiles-" + TestUtilities.GetMyName();                        try                      {                          // Create container and writeable SAS                          var container = blobClient.GetContainerReference(containerName);                          await container.CreateIfNotExistsAsync();                          var sas = container.GetSharedAccessSignature(new SharedAccessBlobPolicy()                          {                              Permissions = SharedAccessBlobPermissions.Write'                              SharedAccessExpiryTime = DateTime.UtcNow.AddDays(1)                          });                          var fullSas = container.Uri + sas;                            CloudJob createJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId });                          createJob.Commit();                            const string blobPrefix = "foo/bar";                          const string taskId = "simpletask";                          CloudTask unboundTask = new CloudTask(taskId' "echo test")                          {                              OutputFiles = new List<OutputFile>                              {                                  new OutputFile(                                      filePattern: @"../*.txt"'                                      destination: new OutputFileDestination(new OutputFileBlobContainerDestination(fullSas' blobPrefix))'                                      uploadOptions: new OutputFileUploadOptions(uploadCondition: OutputFileUploadCondition.TaskCompletion))                              }                          };                            batchCli.JobOperations.AddTask(jobId' unboundTask);                            var tasks = batchCli.JobOperations.ListTasks(jobId);                            var monitor = batchCli.Utilities.CreateTaskStateMonitor();                          monitor.WaitAll(tasks' TaskState.Completed' TimeSpan.FromMinutes(1));                            // Ensure that the correct files got uploaded                          var blobs = await BlobStorageExtensions.ListBlobs(container' useFlatBlobListing: true);                          blobs = blobs.ToList();                          Assert.Equal(4' blobs.Count()); //There are 4 .txt files created' stdout' stderr' fileuploadout' and fileuploaderr                          foreach (var blob in blobs)                          {                              var blockBlob = blob as CloudBlockBlob;                              Assert.StartsWith(blobPrefix' blockBlob.Name);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                          var container = blobClient.GetContainerReference(containerName);                          await container.DeleteIfExistsAsync();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudTaskLinuxIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskLinuxIntegrationTests.cs,TestContainerTask,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "ContainerJob" + TestUtilities.GetMyName();                        try                      {                          var job = client.JobOperations.CreateJob(jobId' new PoolInformation()                          {                              PoolId = this.poolFixture.PoolId                          });                          job.Commit();                            var newTask = new CloudTask("a"' "cat /etc/centos-release")                          {                              ContainerSettings = new TaskContainerSettings("centos")                          };                          client.JobOperations.AddTask(jobId' newTask);                            var tasks = client.JobOperations.ListTasks(jobId);                            var monitor = client.Utilities.CreateTaskStateMonitor();                          monitor.WaitAll(tasks' TaskState.Completed' TimeSpan.FromMinutes(7));                            var task = tasks.Single();                          task.Refresh();                            Assert.Equal("ContainerPoolNotSupported"' task.ExecutionInformation.FailureInformation.Code);                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(client' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,CloudTaskLinuxIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\CloudTaskLinuxIntegrationTests.cs,TestContainerTask,The following statement contains a magic number: SynchronizationContextHelper.RunTest(test' TimeSpan.FromMinutes(10));
Magic Number,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug2302907_TestComputeNodeDoesInheritBehaviors,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()' addDefaultRetryPolicy: false))                  {                      Microsoft.Azure.Batch.Protocol.RequestInterceptor interceptor = new Microsoft.Azure.Batch.Protocol.RequestInterceptor();                      batchCli.PoolOperations.CustomBehaviors.Add(interceptor);                        List<ComputeNode> computeNodeList = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId).ToList();                        ComputeNode computeNode = computeNodeList.First();                        Assert.Equal(2' computeNode.CustomBehaviors.Count);                      Assert.Contains(interceptor' computeNode.CustomBehaviors);                  }              };
Magic Number,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug2329884_ComputeNodeRecentTasksAndComputeNodeError,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug2329884Job-" + TestUtilities.GetMyName();                      Protocol.RequestInterceptor interceptor = null;                        try                      {                          const string taskId = "hiWorld";                            //                          // Create the job                          //                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          unboundJob.PoolInformation.PoolId = this.poolFixture.PoolId;                            unboundJob.Commit();                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                          CloudTask myTask = new CloudTask(taskId' "cmd /c echo hello world");                            boundJob.AddTask(myTask);                            this.testOutputHelper.WriteLine("Initial job commit()");                            //                          // Wait for task to go to completion                          //                          Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                            taskStateMonitor.WaitAll(                              boundJob.ListTasks()'                              Microsoft.Azure.Batch.Common.TaskState.Completed'                              new TimeSpan(0' 3 /*min*/' 0));                            CloudTask boundTask = boundJob.GetTask(taskId);                            //Since the compute node name comes back as "Node:<computeNodeId>" we need to split on : to get the actual compute node name                          string computeNodeId = boundTask.ComputeNodeInformation.AffinityId.Split(':')[1];                            //                          // Check recent tasks                          //                          ComputeNode computeNode = batchCli.PoolOperations.GetComputeNode(this.poolFixture.PoolId' computeNodeId);                            this.testOutputHelper.WriteLine("Recent tasks:");                            foreach (TaskInformation recentTask in computeNode.RecentTasks)                          {                              this.testOutputHelper.WriteLine("Compute node has recent task Job: {0}' Task: {1}' State: {2}' Subtask: {3}"'                                  recentTask.JobId'                                  recentTask.TaskId'                                  recentTask.TaskState'                                  recentTask.SubtaskId);                          }                            TaskInformation myTaskInfo = computeNode.RecentTasks.First(taskInfo => taskInfo.JobId.Equals(                              jobId' StringComparison.InvariantCultureIgnoreCase) &&                              taskInfo.TaskId.Equals(taskId' StringComparison.InvariantCultureIgnoreCase));                            Assert.Equal(TaskState.Completed' myTaskInfo.TaskState);                          Assert.NotNull(myTaskInfo.ExecutionInformation);                          Assert.Equal(0' myTaskInfo.ExecutionInformation.ExitCode);                            //                          // Check compute node Error                          //                          const string expectedErrorCode = "TestErrorCode";                          const string expectedErrorMessage = "Test error message";                          const string nvpValue = "Test";                            //We use mocking to return a fake compute node object here to test Compute Node Error because we cannot force one easily                          interceptor = new Protocol.RequestInterceptor((req =>                          {                              if (req is ComputeNodeGetBatchRequest)                              {                                  var typedRequest = req as ComputeNodeGetBatchRequest;                                    typedRequest.ServiceRequestFunc = (token) =>                                  {                                      var response = new AzureOperationResponse<Protocol.Models.ComputeNode' Protocol.Models.ComputeNodeGetHeaders>();                                        List<Protocol.Models.ComputeNodeError> errors =                                          new List<Protocol.Models.ComputeNodeError>();                                        //Generate first Compute Node Error                                      List<Protocol.Models.NameValuePair> nvps =                                          new List<Protocol.Models.NameValuePair>();                                      nvps.Add(new Protocol.Models.NameValuePair() { Name = nvpValue' Value = nvpValue });                                        Protocol.Models.ComputeNodeError error1 = new Protocol.Models.ComputeNodeError();                                      error1.Code = expectedErrorCode;                                      error1.Message = expectedErrorMessage;                                      error1.ErrorDetails = nvps;                                        errors.Add(error1);                                        //Generate second Compute Node Error                                      nvps = new List<Protocol.Models.NameValuePair>();                                      nvps.Add(new Protocol.Models.NameValuePair() { Name = nvpValue' Value = nvpValue });                                        Protocol.Models.ComputeNodeError error2 = new Protocol.Models.ComputeNodeError();                                      error2.Code = expectedErrorCode;                                      error2.Message = expectedErrorMessage;                                      error2.ErrorDetails = nvps;                                        errors.Add(error2);                                        Protocol.Models.ComputeNode protoComputeNode = new Protocol.Models.ComputeNode();                                      protoComputeNode.Id = computeNodeId;                                      protoComputeNode.State = Protocol.Models.ComputeNodeState.Idle;                                      protoComputeNode.Errors = errors;                                        response.Body = protoComputeNode;                                        return Task.FromResult(response);                                  };                              }                          }));                            batchCli.PoolOperations.CustomBehaviors.Add(interceptor);                            computeNode = batchCli.PoolOperations.GetComputeNode(this.poolFixture.PoolId' computeNodeId);                            Assert.Equal(computeNodeId' computeNode.Id);                          Assert.NotNull(computeNode.Errors);                          Assert.Equal(2' computeNode.Errors.Count());                            foreach (ComputeNodeError computeNodeError in computeNode.Errors)                          {                              Assert.Equal(expectedErrorCode' computeNodeError.Code);                              Assert.Equal(expectedErrorMessage' computeNodeError.Message);                              Assert.NotNull(computeNodeError.ErrorDetails);                              Assert.Single(computeNodeError.ErrorDetails);                              Assert.Contains(nvpValue' computeNodeError.ErrorDetails.First().Name);                          }                      }                      finally                      {                          batchCli.JobOperations.DeleteJob(jobId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug2329884_ComputeNodeRecentTasksAndComputeNodeError,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug2329884Job-" + TestUtilities.GetMyName();                      Protocol.RequestInterceptor interceptor = null;                        try                      {                          const string taskId = "hiWorld";                            //                          // Create the job                          //                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          unboundJob.PoolInformation.PoolId = this.poolFixture.PoolId;                            unboundJob.Commit();                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                          CloudTask myTask = new CloudTask(taskId' "cmd /c echo hello world");                            boundJob.AddTask(myTask);                            this.testOutputHelper.WriteLine("Initial job commit()");                            //                          // Wait for task to go to completion                          //                          Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                            taskStateMonitor.WaitAll(                              boundJob.ListTasks()'                              Microsoft.Azure.Batch.Common.TaskState.Completed'                              new TimeSpan(0' 3 /*min*/' 0));                            CloudTask boundTask = boundJob.GetTask(taskId);                            //Since the compute node name comes back as "Node:<computeNodeId>" we need to split on : to get the actual compute node name                          string computeNodeId = boundTask.ComputeNodeInformation.AffinityId.Split(':')[1];                            //                          // Check recent tasks                          //                          ComputeNode computeNode = batchCli.PoolOperations.GetComputeNode(this.poolFixture.PoolId' computeNodeId);                            this.testOutputHelper.WriteLine("Recent tasks:");                            foreach (TaskInformation recentTask in computeNode.RecentTasks)                          {                              this.testOutputHelper.WriteLine("Compute node has recent task Job: {0}' Task: {1}' State: {2}' Subtask: {3}"'                                  recentTask.JobId'                                  recentTask.TaskId'                                  recentTask.TaskState'                                  recentTask.SubtaskId);                          }                            TaskInformation myTaskInfo = computeNode.RecentTasks.First(taskInfo => taskInfo.JobId.Equals(                              jobId' StringComparison.InvariantCultureIgnoreCase) &&                              taskInfo.TaskId.Equals(taskId' StringComparison.InvariantCultureIgnoreCase));                            Assert.Equal(TaskState.Completed' myTaskInfo.TaskState);                          Assert.NotNull(myTaskInfo.ExecutionInformation);                          Assert.Equal(0' myTaskInfo.ExecutionInformation.ExitCode);                            //                          // Check compute node Error                          //                          const string expectedErrorCode = "TestErrorCode";                          const string expectedErrorMessage = "Test error message";                          const string nvpValue = "Test";                            //We use mocking to return a fake compute node object here to test Compute Node Error because we cannot force one easily                          interceptor = new Protocol.RequestInterceptor((req =>                          {                              if (req is ComputeNodeGetBatchRequest)                              {                                  var typedRequest = req as ComputeNodeGetBatchRequest;                                    typedRequest.ServiceRequestFunc = (token) =>                                  {                                      var response = new AzureOperationResponse<Protocol.Models.ComputeNode' Protocol.Models.ComputeNodeGetHeaders>();                                        List<Protocol.Models.ComputeNodeError> errors =                                          new List<Protocol.Models.ComputeNodeError>();                                        //Generate first Compute Node Error                                      List<Protocol.Models.NameValuePair> nvps =                                          new List<Protocol.Models.NameValuePair>();                                      nvps.Add(new Protocol.Models.NameValuePair() { Name = nvpValue' Value = nvpValue });                                        Protocol.Models.ComputeNodeError error1 = new Protocol.Models.ComputeNodeError();                                      error1.Code = expectedErrorCode;                                      error1.Message = expectedErrorMessage;                                      error1.ErrorDetails = nvps;                                        errors.Add(error1);                                        //Generate second Compute Node Error                                      nvps = new List<Protocol.Models.NameValuePair>();                                      nvps.Add(new Protocol.Models.NameValuePair() { Name = nvpValue' Value = nvpValue });                                        Protocol.Models.ComputeNodeError error2 = new Protocol.Models.ComputeNodeError();                                      error2.Code = expectedErrorCode;                                      error2.Message = expectedErrorMessage;                                      error2.ErrorDetails = nvps;                                        errors.Add(error2);                                        Protocol.Models.ComputeNode protoComputeNode = new Protocol.Models.ComputeNode();                                      protoComputeNode.Id = computeNodeId;                                      protoComputeNode.State = Protocol.Models.ComputeNodeState.Idle;                                      protoComputeNode.Errors = errors;                                        response.Body = protoComputeNode;                                        return Task.FromResult(response);                                  };                              }                          }));                            batchCli.PoolOperations.CustomBehaviors.Add(interceptor);                            computeNode = batchCli.PoolOperations.GetComputeNode(this.poolFixture.PoolId' computeNodeId);                            Assert.Equal(computeNodeId' computeNode.Id);                          Assert.NotNull(computeNode.Errors);                          Assert.Equal(2' computeNode.Errors.Count());                            foreach (ComputeNodeError computeNodeError in computeNode.Errors)                          {                              Assert.Equal(expectedErrorCode' computeNodeError.Code);                              Assert.Equal(expectedErrorMessage' computeNodeError.Message);                              Assert.NotNull(computeNodeError.ErrorDetails);                              Assert.Single(computeNodeError.ErrorDetails);                              Assert.Contains(nvpValue' computeNodeError.ErrorDetails.First().Name);                          }                      }                      finally                      {                          batchCli.JobOperations.DeleteJob(jobId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug1770933_1770935_1771164_AddUserCRUDAndGetRDP,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      // names to create/delete                      List<string> names = new List<string>() { TestUtilities.GetMyName()' TestUtilities.GetMyName() + "1"' TestUtilities.GetMyName() + "2"' TestUtilities.GetMyName() + "3"' TestUtilities.GetMyName() + "4" };                        // pick a compute node to victimize with user accounts                      IEnumerable<ComputeNode> ienmComputeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId);                      List<ComputeNode> computeNodeList = new List<ComputeNode>(ienmComputeNodes);                      ComputeNode computeNode = computeNodeList[0];                        try                      {                          string rdpFileName = "Bug1770933.rdp";                            // test user public constructor and IPoolMgr verbs                          {                              ComputeNodeUser newUser = batchCli.PoolOperations.CreateComputeNodeUser(this.poolFixture.PoolId' computeNode.Id);                                newUser.Name = names[0];                              newUser.IsAdmin = true;                              newUser.ExpiryTime = DateTime.UtcNow + TimeSpan.FromHours(1.0);                              newUser.Password = @"!!Admin!!";                                // commit that creates/adds the user                              newUser.Commit(ComputeNodeUserCommitSemantics.AddUser);                                // now update the user's password                              newUser.Password = @"!!!Admin!!!";                                // commit that updates                              newUser.Commit(ComputeNodeUserCommitSemantics.UpdateUser);                                // clean up from prev run                              if (File.Exists(rdpFileName))                              {                                  File.Delete(rdpFileName);                              }                                // pull the rdp file                              batchCli.PoolOperations.GetRDPFile(this.poolFixture.PoolId' computeNode.Id' rdpFileName);                                // simple validation tests on the rdp file                              TestFileExistsAndHasLength(rdpFileName);                                // cleanup the rdp file                              File.Delete(rdpFileName);                                // "test" delete user from IPoolMgr                              // TODO: when GET/LIST User is available we should close the loop and confirm the user is gone.                              batchCli.PoolOperations.DeleteComputeNodeUser(this.poolFixture.PoolId' computeNode.Id' newUser.Name);                          }                            // test IPoolMgr CreateUser                          {                              ComputeNodeUser pmcUser = batchCli.PoolOperations.CreateComputeNodeUser(this.poolFixture.PoolId' computeNode.Id);                                pmcUser.Name = names[1];                              pmcUser.IsAdmin = true;                              pmcUser.ExpiryTime = DateTime.UtcNow + TimeSpan.FromHours(1.0);                              pmcUser.Password = @"!!!Admin!!!";                                // add the user                              pmcUser.Commit(ComputeNodeUserCommitSemantics.AddUser);                                // pull rdp file                              batchCli.PoolOperations.GetRDPFile(this.poolFixture.PoolId' computeNode.Id' rdpFileName);                                // simple validation on rdp file                              TestFileExistsAndHasLength(rdpFileName);                                // cleanup                              File.Delete(rdpFileName);                                // delete user                              batchCli.PoolOperations.DeleteComputeNodeUser(this.poolFixture.PoolId' computeNode.Id' pmcUser.Name);                          }                            // test IComputeNode verbs                          {                              ComputeNodeUser poolMgrUser = batchCli.PoolOperations.CreateComputeNodeUser(this.poolFixture.PoolId' computeNode.Id);                                poolMgrUser.Name = names[2];                              poolMgrUser.IsAdmin = true;                              poolMgrUser.ExpiryTime = DateTime.UtcNow + TimeSpan.FromHours(1.0);                              poolMgrUser.Password = @"!!!Admin!!!";                                poolMgrUser.Commit(ComputeNodeUserCommitSemantics.AddUser);                                // pull rdp file                              computeNode.GetRDPFile(rdpFileName);                                // simple validation on rdp file                              TestFileExistsAndHasLength(rdpFileName);                                // cleanup                              File.Delete(rdpFileName);                                // delete user                              computeNode.DeleteComputeNodeUser(poolMgrUser.Name);                          }                            // test ComputeNodeUser.Delete                          {                              ComputeNodeUser usrDelete = batchCli.PoolOperations.CreateComputeNodeUser(this.poolFixture.PoolId' computeNode.Id);                                usrDelete.Name = names[3];                              usrDelete.ExpiryTime = DateTime.UtcNow + TimeSpan.FromHours(1.0);                              usrDelete.Password = @"!!!Admin!!!";                                usrDelete.Commit(ComputeNodeUserCommitSemantics.AddUser);                                usrDelete.Delete();                          }                            // test rdp-by-stream IPoolMgr and IComputeNode                          // the by-stream paths do not converge with the by-filename paths until IProtocol so we test them seperately                          {                              ComputeNodeUser byStreamUser = batchCli.PoolOperations.CreateComputeNodeUser(this.poolFixture.PoolId' computeNode.Id);                                byStreamUser.Name = names[4];                              byStreamUser.IsAdmin = true;                              byStreamUser.ExpiryTime = DateTime.UtcNow + TimeSpan.FromHours(1.0);                              byStreamUser.Password = @"!!!Admin!!!";                                byStreamUser.Commit(ComputeNodeUserCommitSemantics.AddUser);                                // IPoolMgr                              using (Stream rdpStreamPoolMgr = File.Create(rdpFileName))                              {                                  batchCli.PoolOperations.GetRDPFile(this.poolFixture.PoolId' computeNode.Id' rdpStreamPoolMgr);                                    rdpStreamPoolMgr.Flush();                                  rdpStreamPoolMgr.Close();                                    TestFileExistsAndHasLength(rdpFileName);                                    File.Delete(rdpFileName);                              }                                // IComputeNode                              using (Stream rdpViaIComputeNode = File.Create(rdpFileName))                              {                                  computeNode.GetRDPFile(rdpViaIComputeNode);                                    rdpViaIComputeNode.Flush();                                  rdpViaIComputeNode.Close();                                    TestFileExistsAndHasLength(rdpFileName);                                    File.Delete(rdpFileName);                              }                                // delete the user account                              byStreamUser.Delete();                          }                      }                      finally                      {                          // clear any old accounts                          foreach (string curName in names)                          {                              bool hitException = false;                                try                              {                                  ComputeNodeUser deleteThis = batchCli.PoolOperations.CreateComputeNodeUser(this.poolFixture.PoolId' computeNode.Id);                                  deleteThis.Name = curName;                                  deleteThis.Delete();                              }                              catch (BatchException ex)                              {                                  Assert.Equal(BatchErrorCodeStrings.NodeUserNotFound' ex.RequestInformation.BatchError.Code);                                  hitException = true;                                                             }                                Assert.True(hitException' "Should have hit exception on user: " + curName + "' compute node: " + computeNode.Id + ".");                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug1770933_1770935_1771164_AddUserCRUDAndGetRDP,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      // names to create/delete                      List<string> names = new List<string>() { TestUtilities.GetMyName()' TestUtilities.GetMyName() + "1"' TestUtilities.GetMyName() + "2"' TestUtilities.GetMyName() + "3"' TestUtilities.GetMyName() + "4" };                        // pick a compute node to victimize with user accounts                      IEnumerable<ComputeNode> ienmComputeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId);                      List<ComputeNode> computeNodeList = new List<ComputeNode>(ienmComputeNodes);                      ComputeNode computeNode = computeNodeList[0];                        try                      {                          string rdpFileName = "Bug1770933.rdp";                            // test user public constructor and IPoolMgr verbs                          {                              ComputeNodeUser newUser = batchCli.PoolOperations.CreateComputeNodeUser(this.poolFixture.PoolId' computeNode.Id);                                newUser.Name = names[0];                              newUser.IsAdmin = true;                              newUser.ExpiryTime = DateTime.UtcNow + TimeSpan.FromHours(1.0);                              newUser.Password = @"!!Admin!!";                                // commit that creates/adds the user                              newUser.Commit(ComputeNodeUserCommitSemantics.AddUser);                                // now update the user's password                              newUser.Password = @"!!!Admin!!!";                                // commit that updates                              newUser.Commit(ComputeNodeUserCommitSemantics.UpdateUser);                                // clean up from prev run                              if (File.Exists(rdpFileName))                              {                                  File.Delete(rdpFileName);                              }                                // pull the rdp file                              batchCli.PoolOperations.GetRDPFile(this.poolFixture.PoolId' computeNode.Id' rdpFileName);                                // simple validation tests on the rdp file                              TestFileExistsAndHasLength(rdpFileName);                                // cleanup the rdp file                              File.Delete(rdpFileName);                                // "test" delete user from IPoolMgr                              // TODO: when GET/LIST User is available we should close the loop and confirm the user is gone.                              batchCli.PoolOperations.DeleteComputeNodeUser(this.poolFixture.PoolId' computeNode.Id' newUser.Name);                          }                            // test IPoolMgr CreateUser                          {                              ComputeNodeUser pmcUser = batchCli.PoolOperations.CreateComputeNodeUser(this.poolFixture.PoolId' computeNode.Id);                                pmcUser.Name = names[1];                              pmcUser.IsAdmin = true;                              pmcUser.ExpiryTime = DateTime.UtcNow + TimeSpan.FromHours(1.0);                              pmcUser.Password = @"!!!Admin!!!";                                // add the user                              pmcUser.Commit(ComputeNodeUserCommitSemantics.AddUser);                                // pull rdp file                              batchCli.PoolOperations.GetRDPFile(this.poolFixture.PoolId' computeNode.Id' rdpFileName);                                // simple validation on rdp file                              TestFileExistsAndHasLength(rdpFileName);                                // cleanup                              File.Delete(rdpFileName);                                // delete user                              batchCli.PoolOperations.DeleteComputeNodeUser(this.poolFixture.PoolId' computeNode.Id' pmcUser.Name);                          }                            // test IComputeNode verbs                          {                              ComputeNodeUser poolMgrUser = batchCli.PoolOperations.CreateComputeNodeUser(this.poolFixture.PoolId' computeNode.Id);                                poolMgrUser.Name = names[2];                              poolMgrUser.IsAdmin = true;                              poolMgrUser.ExpiryTime = DateTime.UtcNow + TimeSpan.FromHours(1.0);                              poolMgrUser.Password = @"!!!Admin!!!";                                poolMgrUser.Commit(ComputeNodeUserCommitSemantics.AddUser);                                // pull rdp file                              computeNode.GetRDPFile(rdpFileName);                                // simple validation on rdp file                              TestFileExistsAndHasLength(rdpFileName);                                // cleanup                              File.Delete(rdpFileName);                                // delete user                              computeNode.DeleteComputeNodeUser(poolMgrUser.Name);                          }                            // test ComputeNodeUser.Delete                          {                              ComputeNodeUser usrDelete = batchCli.PoolOperations.CreateComputeNodeUser(this.poolFixture.PoolId' computeNode.Id);                                usrDelete.Name = names[3];                              usrDelete.ExpiryTime = DateTime.UtcNow + TimeSpan.FromHours(1.0);                              usrDelete.Password = @"!!!Admin!!!";                                usrDelete.Commit(ComputeNodeUserCommitSemantics.AddUser);                                usrDelete.Delete();                          }                            // test rdp-by-stream IPoolMgr and IComputeNode                          // the by-stream paths do not converge with the by-filename paths until IProtocol so we test them seperately                          {                              ComputeNodeUser byStreamUser = batchCli.PoolOperations.CreateComputeNodeUser(this.poolFixture.PoolId' computeNode.Id);                                byStreamUser.Name = names[4];                              byStreamUser.IsAdmin = true;                              byStreamUser.ExpiryTime = DateTime.UtcNow + TimeSpan.FromHours(1.0);                              byStreamUser.Password = @"!!!Admin!!!";                                byStreamUser.Commit(ComputeNodeUserCommitSemantics.AddUser);                                // IPoolMgr                              using (Stream rdpStreamPoolMgr = File.Create(rdpFileName))                              {                                  batchCli.PoolOperations.GetRDPFile(this.poolFixture.PoolId' computeNode.Id' rdpStreamPoolMgr);                                    rdpStreamPoolMgr.Flush();                                  rdpStreamPoolMgr.Close();                                    TestFileExistsAndHasLength(rdpFileName);                                    File.Delete(rdpFileName);                              }                                // IComputeNode                              using (Stream rdpViaIComputeNode = File.Create(rdpFileName))                              {                                  computeNode.GetRDPFile(rdpViaIComputeNode);                                    rdpViaIComputeNode.Flush();                                  rdpViaIComputeNode.Close();                                    TestFileExistsAndHasLength(rdpFileName);                                    File.Delete(rdpFileName);                              }                                // delete the user account                              byStreamUser.Delete();                          }                      }                      finally                      {                          // clear any old accounts                          foreach (string curName in names)                          {                              bool hitException = false;                                try                              {                                  ComputeNodeUser deleteThis = batchCli.PoolOperations.CreateComputeNodeUser(this.poolFixture.PoolId' computeNode.Id);                                  deleteThis.Name = curName;                                  deleteThis.Delete();                              }                              catch (BatchException ex)                              {                                  Assert.Equal(BatchErrorCodeStrings.NodeUserNotFound' ex.RequestInformation.BatchError.Code);                                  hitException = true;                                                             }                                Assert.True(hitException' "Should have hit exception on user: " + curName + "' compute node: " + computeNode.Id + ".");                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug1770933_1770935_1771164_AddUserCRUDAndGetRDP,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      // names to create/delete                      List<string> names = new List<string>() { TestUtilities.GetMyName()' TestUtilities.GetMyName() + "1"' TestUtilities.GetMyName() + "2"' TestUtilities.GetMyName() + "3"' TestUtilities.GetMyName() + "4" };                        // pick a compute node to victimize with user accounts                      IEnumerable<ComputeNode> ienmComputeNodes = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId);                      List<ComputeNode> computeNodeList = new List<ComputeNode>(ienmComputeNodes);                      ComputeNode computeNode = computeNodeList[0];                        try                      {                          string rdpFileName = "Bug1770933.rdp";                            // test user public constructor and IPoolMgr verbs                          {                              ComputeNodeUser newUser = batchCli.PoolOperations.CreateComputeNodeUser(this.poolFixture.PoolId' computeNode.Id);                                newUser.Name = names[0];                              newUser.IsAdmin = true;                              newUser.ExpiryTime = DateTime.UtcNow + TimeSpan.FromHours(1.0);                              newUser.Password = @"!!Admin!!";                                // commit that creates/adds the user                              newUser.Commit(ComputeNodeUserCommitSemantics.AddUser);                                // now update the user's password                              newUser.Password = @"!!!Admin!!!";                                // commit that updates                              newUser.Commit(ComputeNodeUserCommitSemantics.UpdateUser);                                // clean up from prev run                              if (File.Exists(rdpFileName))                              {                                  File.Delete(rdpFileName);                              }                                // pull the rdp file                              batchCli.PoolOperations.GetRDPFile(this.poolFixture.PoolId' computeNode.Id' rdpFileName);                                // simple validation tests on the rdp file                              TestFileExistsAndHasLength(rdpFileName);                                // cleanup the rdp file                              File.Delete(rdpFileName);                                // "test" delete user from IPoolMgr                              // TODO: when GET/LIST User is available we should close the loop and confirm the user is gone.                              batchCli.PoolOperations.DeleteComputeNodeUser(this.poolFixture.PoolId' computeNode.Id' newUser.Name);                          }                            // test IPoolMgr CreateUser                          {                              ComputeNodeUser pmcUser = batchCli.PoolOperations.CreateComputeNodeUser(this.poolFixture.PoolId' computeNode.Id);                                pmcUser.Name = names[1];                              pmcUser.IsAdmin = true;                              pmcUser.ExpiryTime = DateTime.UtcNow + TimeSpan.FromHours(1.0);                              pmcUser.Password = @"!!!Admin!!!";                                // add the user                              pmcUser.Commit(ComputeNodeUserCommitSemantics.AddUser);                                // pull rdp file                              batchCli.PoolOperations.GetRDPFile(this.poolFixture.PoolId' computeNode.Id' rdpFileName);                                // simple validation on rdp file                              TestFileExistsAndHasLength(rdpFileName);                                // cleanup                              File.Delete(rdpFileName);                                // delete user                              batchCli.PoolOperations.DeleteComputeNodeUser(this.poolFixture.PoolId' computeNode.Id' pmcUser.Name);                          }                            // test IComputeNode verbs                          {                              ComputeNodeUser poolMgrUser = batchCli.PoolOperations.CreateComputeNodeUser(this.poolFixture.PoolId' computeNode.Id);                                poolMgrUser.Name = names[2];                              poolMgrUser.IsAdmin = true;                              poolMgrUser.ExpiryTime = DateTime.UtcNow + TimeSpan.FromHours(1.0);                              poolMgrUser.Password = @"!!!Admin!!!";                                poolMgrUser.Commit(ComputeNodeUserCommitSemantics.AddUser);                                // pull rdp file                              computeNode.GetRDPFile(rdpFileName);                                // simple validation on rdp file                              TestFileExistsAndHasLength(rdpFileName);                                // cleanup                              File.Delete(rdpFileName);                                // delete user                              computeNode.DeleteComputeNodeUser(poolMgrUser.Name);                          }                            // test ComputeNodeUser.Delete                          {                              ComputeNodeUser usrDelete = batchCli.PoolOperations.CreateComputeNodeUser(this.poolFixture.PoolId' computeNode.Id);                                usrDelete.Name = names[3];                              usrDelete.ExpiryTime = DateTime.UtcNow + TimeSpan.FromHours(1.0);                              usrDelete.Password = @"!!!Admin!!!";                                usrDelete.Commit(ComputeNodeUserCommitSemantics.AddUser);                                usrDelete.Delete();                          }                            // test rdp-by-stream IPoolMgr and IComputeNode                          // the by-stream paths do not converge with the by-filename paths until IProtocol so we test them seperately                          {                              ComputeNodeUser byStreamUser = batchCli.PoolOperations.CreateComputeNodeUser(this.poolFixture.PoolId' computeNode.Id);                                byStreamUser.Name = names[4];                              byStreamUser.IsAdmin = true;                              byStreamUser.ExpiryTime = DateTime.UtcNow + TimeSpan.FromHours(1.0);                              byStreamUser.Password = @"!!!Admin!!!";                                byStreamUser.Commit(ComputeNodeUserCommitSemantics.AddUser);                                // IPoolMgr                              using (Stream rdpStreamPoolMgr = File.Create(rdpFileName))                              {                                  batchCli.PoolOperations.GetRDPFile(this.poolFixture.PoolId' computeNode.Id' rdpStreamPoolMgr);                                    rdpStreamPoolMgr.Flush();                                  rdpStreamPoolMgr.Close();                                    TestFileExistsAndHasLength(rdpFileName);                                    File.Delete(rdpFileName);                              }                                // IComputeNode                              using (Stream rdpViaIComputeNode = File.Create(rdpFileName))                              {                                  computeNode.GetRDPFile(rdpViaIComputeNode);                                    rdpViaIComputeNode.Flush();                                  rdpViaIComputeNode.Close();                                    TestFileExistsAndHasLength(rdpFileName);                                    File.Delete(rdpFileName);                              }                                // delete the user account                              byStreamUser.Delete();                          }                      }                      finally                      {                          // clear any old accounts                          foreach (string curName in names)                          {                              bool hitException = false;                                try                              {                                  ComputeNodeUser deleteThis = batchCli.PoolOperations.CreateComputeNodeUser(this.poolFixture.PoolId' computeNode.Id);                                  deleteThis.Name = curName;                                  deleteThis.Delete();                              }                              catch (BatchException ex)                              {                                  Assert.Equal(BatchErrorCodeStrings.NodeUserNotFound' ex.RequestInformation.BatchError.Code);                                  hitException = true;                                                             }                                Assert.True(hitException' "Should have hit exception on user: " + curName + "' compute node: " + computeNode.Id + ".");                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,Bug2342986_StartTaskMissingOnComputeNode,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      CloudPool pool = batchCli.PoolOperations.GetPool(this.poolFixture.PoolId);                        this.testOutputHelper.WriteLine("Getting pool");                      StartTask poolStartTask = pool.StartTask;                        Assert.NotNull(poolStartTask);                      Assert.NotNull(poolStartTask.EnvironmentSettings);                        IEnumerable<ComputeNode> computeNodes = pool.ListComputeNodes();                        Assert.True(computeNodes.Any());                        this.testOutputHelper.WriteLine("Checking every compute nodes start task in the pool matches the pools start task");                      foreach (ComputeNode computeNode in computeNodes)                      {                          this.testOutputHelper.WriteLine("Checking start task of compute node: {0}"' computeNode.Id);                            //Check that the property is correctly set on each compute node                          Assert.NotNull(computeNode.StartTask);                            Assert.Equal(poolStartTask.CommandLine' computeNode.StartTask.CommandLine);                          Assert.Equal(poolStartTask.MaxTaskRetryCount' computeNode.StartTask.MaxTaskRetryCount);                          Assert.Equal(AutoUserScope.Pool' poolStartTask.UserIdentity.AutoUser.Scope);                          Assert.Equal(AutoUserScope.Pool' computeNode.StartTask.UserIdentity.AutoUser.Scope);                          Assert.Equal(poolStartTask.WaitForSuccess' computeNode.StartTask.WaitForSuccess);                            if (poolStartTask.EnvironmentSettings != null)                          {                              Assert.Equal(poolStartTask.EnvironmentSettings.Count' computeNode.StartTask.EnvironmentSettings.Count);                              foreach (EnvironmentSetting environmentSetting in poolStartTask.EnvironmentSettings)                              {                                  EnvironmentSetting matchingEnvSetting = computeNode.StartTask.EnvironmentSettings.FirstOrDefault(envSetting => envSetting.Name == environmentSetting.Name);                                    Assert.NotNull(matchingEnvSetting);                                  Assert.Equal(environmentSetting.Name' matchingEnvSetting.Name);                                  Assert.Equal(environmentSetting.Value' matchingEnvSetting.Value);                              }                          }                            if (poolStartTask.ResourceFiles != null)                          {                              Assert.Equal(poolStartTask.ResourceFiles.Count' computeNode.StartTask.ResourceFiles.Count);                                foreach (ResourceFile resourceFile in poolStartTask.ResourceFiles)                              {                                  ResourceFile matchingResourceFile = computeNode.StartTask.ResourceFiles.FirstOrDefault(item => item.HttpUrl == resourceFile.HttpUrl);                                    Assert.NotNull(matchingResourceFile);                                  Assert.Equal(resourceFile.HttpUrl' matchingResourceFile.HttpUrl);                                  Assert.Equal(resourceFile.FilePath' matchingResourceFile.FilePath);                              }                          }                            //Try to set some properties of the compute node's start task and ensure it fails                            TestUtilities.AssertThrows<InvalidOperationException>(() => { computeNode.StartTask.CommandLine = "Test"; });                          TestUtilities.AssertThrows<InvalidOperationException>(() => { computeNode.StartTask.MaxTaskRetryCount = 5; });                          TestUtilities.AssertThrows<InvalidOperationException>(() => { computeNode.StartTask.UserIdentity = new UserIdentity("foo"); });                          TestUtilities.AssertThrows<InvalidOperationException>(() => { computeNode.StartTask.WaitForSuccess = true; });                          TestUtilities.AssertThrows<InvalidOperationException>(() => { computeNode.StartTask.EnvironmentSettings = new List<EnvironmentSetting>(); });                            if (computeNode.StartTask.EnvironmentSettings != null)                          {                              TestUtilities.AssertThrows<InvalidOperationException>(() => { computeNode.StartTask.EnvironmentSettings.Add(new EnvironmentSetting("test"' "test")); });                          }                          TestUtilities.AssertThrows<InvalidOperationException>(() => { computeNode.StartTask.ResourceFiles = new List<ResourceFile>(); });                          if (computeNode.StartTask.ResourceFiles != null)                          {                              TestUtilities.AssertThrows<InvalidOperationException>(() => { computeNode.StartTask.ResourceFiles.Add(ResourceFile.FromUrl("test"' "test")); });                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,ComputeNodeIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,OnlineOfflineTest,The following statement contains a magic number: await SynchronizationContextHelper.RunTestAsync(async () =>                  {                      using (BatchClient batchCli = await TestUtilities.OpenBatchClientFromEnvironmentAsync())                      {                          TimeSpan refreshPollingTimeout = TimeSpan.FromMinutes(3);                          CloudPool pool = this.poolFixture.Pool;                            List<ComputeNode> nodes = pool.ListComputeNodes().ToList();                            Assert.True(nodes.Count > 0);                            // pick a victim compute node.  cleanup code needs this set                          ComputeNode victim = nodes[0];                            try                          {                              Assert.True(victim.SchedulingState.HasValue && (SchedulingState.Enabled == victim.SchedulingState));                              Assert.True(victim.State.HasValue && (ComputeNodeState.Idle == victim.State));                                // PoolOperations methods                              {                                  // disable task scheduling                                  batchCli.PoolOperations.DisableComputeNodeScheduling(pool.Id' victim.Id' DisableComputeNodeSchedulingOption.Terminate);                                    // Li says state change is not atomic so we will sleep                                  // asserted above this node is idle so no need to wait for task fussery                                  await TestUtilities.RefreshBasedPollingWithTimeoutAsync(                                          refreshing: victim'                                          condition: () => Task.FromResult(victim.SchedulingState.HasValue && (SchedulingState.Disabled == victim.SchedulingState))'                                          timeout: refreshPollingTimeout).ConfigureAwait(false);                                    Assert.Equal<SchedulingState?>(SchedulingState.Disabled' victim.SchedulingState);                                    // enable task scheduling                                  batchCli.PoolOperations.EnableComputeNodeScheduling(pool.Id' victim.Id);                                    await TestUtilities.RefreshBasedPollingWithTimeoutAsync(                                          refreshing: victim'                                          condition: () => Task.FromResult(victim.SchedulingState.HasValue && (SchedulingState.Enabled == victim.SchedulingState))'                                          timeout: refreshPollingTimeout);                                    Assert.Equal<SchedulingState?>(SchedulingState.Enabled' victim.SchedulingState);                              }                                // ComputeNode methods                              {                                  // disable task scheduling                                    victim.DisableScheduling(DisableComputeNodeSchedulingOption.TaskCompletion);                                    await TestUtilities.RefreshBasedPollingWithTimeoutAsync(                                          refreshing: victim'                                          condition: () => Task.FromResult(victim.SchedulingState.HasValue && (SchedulingState.Disabled == victim.SchedulingState))'                                          timeout: refreshPollingTimeout).ConfigureAwait(false);                                    Assert.Equal<SchedulingState?>(SchedulingState.Disabled' victim.SchedulingState);                                    // enable task scheduling                                    victim.EnableScheduling();                                    await TestUtilities.RefreshBasedPollingWithTimeoutAsync(                                          refreshing: victim'                                          condition: () => Task.FromResult(victim.SchedulingState.HasValue && (SchedulingState.Enabled == victim.SchedulingState))'                                          timeout: refreshPollingTimeout).ConfigureAwait(false);                                    Assert.Equal<SchedulingState?>(SchedulingState.Enabled' victim.SchedulingState);                                    // now test azureerror code for: NodeAlreadyInTargetSchedulingState                                  bool gotCorrectException = false;                                    try                                  {                                      victim.EnableScheduling();  // it is already enabled so this should trigger exception                                  }                                  catch (Exception ex)                                  {                                      TestUtilities.AssertIsBatchExceptionAndHasCorrectAzureErrorCode(ex' Microsoft.Azure.Batch.Common.BatchErrorCodeStrings.NodeAlreadyInTargetSchedulingState' this.testOutputHelper);                                        gotCorrectException = true;                                  }                                    if (!gotCorrectException)                                  {                                      throw new Exception("OnlineOfflineTest: failed to see an exception for NodeAlreadyInTargetSchedulingState test");                                  }                              }                          }                          finally // restore state of victim compute node                          {                              try                              {                                  // do not pollute the shared pool with disabled scheduling                                  if (null != victim)                                  {                                      victim.EnableScheduling();                                  }                              }                              catch (Exception ex)                              {                                  this.testOutputHelper.WriteLine(string.Format("OnlineOfflineTest: exception during exit trying to restore scheduling state: {0}"' ex.ToString()));                              }                          }                      }                  }'                  TestTimeout);
Magic Number,BatchClientIntegrationTests,IntegrationComputeNodeLinuxTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,TestComputeNodeUserIaas,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      CloudPool sharedPool = this.poolFixture.Pool;                      List<string> cnuNamesToDelete = new List<string>();                        // pick a compute node to victimize with user accounts                      var nodes = sharedPool.ListComputeNodes().ToList();                        ComputeNode cn = nodes[0];                        try                      {                          ComputeNodeUser bob = batchCli.PoolOperations.CreateComputeNodeUser(sharedPool.Id' cn.Id);                            bob.Name = "bob";                          bob.ExpiryTime = DateTime.UtcNow + TimeSpan.FromHours(25);                          bob.Password = "password";                          bob.SshPublicKey = "base64==";                            cnuNamesToDelete.Add(bob.Name); // remember to clean this up                            bob.Commit(ComputeNodeUserCommitSemantics.AddUser);                            bob.SshPublicKey = "base65==";                            bob.Commit(ComputeNodeUserCommitSemantics.UpdateUser);                            // TODO:  need to close the loop on this somehow... move to unit/interceptor-based?                          //        currently the server is timing out.                        }                      finally                      {                          // clear any old accounts                          try                          {                              foreach (string curCNUName in cnuNamesToDelete)                              {                                  this.testOutputHelper.WriteLine("TestComputeNodeUserIAAS attempting to delete the following <nodeid'user>: <{0}'{1}>"' cn.Id' curCNUName);                                  cn.DeleteComputeNodeUser(curCNUName);                              }                          }                          catch (Exception ex)                          {                              this.testOutputHelper.WriteLine("TestComputeNodeUserIAAS: exception deleting user account.  ex: " + ex.ToString());                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationComputeNodeLinuxTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,ComputeNodeUploadLogs,The following statement contains a magic number: Action test = async () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClientFromEnvironmentAsync().Result)                  {                      var node = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId).First();                        // Generate a storage container URL                      StagingStorageAccount storageAccount = TestUtilities.GetStorageCredentialsFromEnvironment();                      CloudStorageAccount cloudStorageAccount = new CloudStorageAccount(                          new StorageCredentials(storageAccount.StorageAccount' storageAccount.StorageAccountKey)'                          blobEndpoint: storageAccount.BlobUri'                          queueEndpoint: null'                          tableEndpoint: null'                          fileEndpoint: null);                      CloudBlobClient blobClient = cloudStorageAccount.CreateCloudBlobClient();                      const string containerName = "computenodelogscontainer";                      var container = blobClient.GetContainerReference(containerName);                        try                      {                          await container.CreateIfNotExistsAsync();                          var blobs = await BlobStorageExtensions.ListBlobs(container);                            // Ensure that there are no items in the container to begin with                          Assert.Empty(blobs);                            var sas = container.GetSharedAccessSignature(new SharedAccessBlobPolicy()                          {                              Permissions = SharedAccessBlobPermissions.Write'                              SharedAccessExpiryTime = DateTime.UtcNow.AddDays(1)                          });                          var fullSas = container.Uri + sas;                            var startTime = DateTime.UtcNow.Subtract(TimeSpan.FromMinutes(5));                            var result = batchCli.PoolOperations.UploadComputeNodeBatchServiceLogs(                              this.poolFixture.PoolId'                              node.Id'                              fullSas'                              startTime);                            Assert.NotEqual(0' result.NumberOfFilesUploaded);                          Assert.NotEmpty(result.VirtualDirectoryName);                            // Allow up to 2m for files to get uploaded                          DateTime timeoutAt = DateTime.UtcNow.AddMinutes(2);                          while (DateTime.UtcNow < timeoutAt)                          {                              blobs = await BlobStorageExtensions.ListBlobs(container);                              if (blobs.Any())                              {                                  break;                              }                          }                            Assert.NotEmpty(blobs);                      }                      finally                      {                          await container.DeleteIfExistsAsync();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationComputeNodeLinuxTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ComputeNodeIntegrationTests.cs,ComputeNodeUploadLogs,The following statement contains a magic number: Action test = async () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClientFromEnvironmentAsync().Result)                  {                      var node = batchCli.PoolOperations.ListComputeNodes(this.poolFixture.PoolId).First();                        // Generate a storage container URL                      StagingStorageAccount storageAccount = TestUtilities.GetStorageCredentialsFromEnvironment();                      CloudStorageAccount cloudStorageAccount = new CloudStorageAccount(                          new StorageCredentials(storageAccount.StorageAccount' storageAccount.StorageAccountKey)'                          blobEndpoint: storageAccount.BlobUri'                          queueEndpoint: null'                          tableEndpoint: null'                          fileEndpoint: null);                      CloudBlobClient blobClient = cloudStorageAccount.CreateCloudBlobClient();                      const string containerName = "computenodelogscontainer";                      var container = blobClient.GetContainerReference(containerName);                        try                      {                          await container.CreateIfNotExistsAsync();                          var blobs = await BlobStorageExtensions.ListBlobs(container);                            // Ensure that there are no items in the container to begin with                          Assert.Empty(blobs);                            var sas = container.GetSharedAccessSignature(new SharedAccessBlobPolicy()                          {                              Permissions = SharedAccessBlobPermissions.Write'                              SharedAccessExpiryTime = DateTime.UtcNow.AddDays(1)                          });                          var fullSas = container.Uri + sas;                            var startTime = DateTime.UtcNow.Subtract(TimeSpan.FromMinutes(5));                            var result = batchCli.PoolOperations.UploadComputeNodeBatchServiceLogs(                              this.poolFixture.PoolId'                              node.Id'                              fullSas'                              startTime);                            Assert.NotEqual(0' result.NumberOfFilesUploaded);                          Assert.NotEmpty(result.VirtualDirectoryName);                            // Allow up to 2m for files to get uploaded                          DateTime timeoutAt = DateTime.UtcNow.AddMinutes(2);                          while (DateTime.UtcNow < timeoutAt)                          {                              blobs = await BlobStorageExtensions.ListBlobs(container);                              if (blobs.Any())                              {                                  break;                              }                          }                            Assert.NotEmpty(blobs);                      }                      finally                      {                          await container.DeleteIfExistsAsync();                      }                  }              };
Magic Number,BatchClientIntegrationTests,EndToEndIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\EndToEndIntegrationTests.cs,TestSampleWithFilesAndPool,The following statement contains a magic number: Action test = () =>              {                  StagingStorageAccount storageCreds = TestUtilities.GetStorageCredentialsFromEnvironment();                    using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "SampleWithFilesJob-" + TestUtilities.GetMyName();                          try                      {                          CloudJob quickJob = batchCli.JobOperations.CreateJob();                          quickJob.Id = jobId;                          quickJob.PoolInformation = new PoolInformation() { PoolId = this.poolFixture.PoolId };                          quickJob.Commit();                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            CloudTask myTask = new CloudTask(id: "CountWordsTask"' commandline: @"cmd /c dir /s .. & dir & wc localwords.txt");                            // first we have local files that we want pushed to the compute node before the commandline is invoked                          FileToStage wordsDotText = new FileToStage(Resources.LocalWordsDotText' storageCreds);                // use "default" mapping to base name of local file                            myTask.FilesToStage = new List<IFileStagingProvider>();                            myTask.FilesToStage.Add(wordsDotText);                            // add the task to the job                          var artifacts = boundJob.AddTask(myTask);                          var specificArtifact = artifacts[typeof(FileToStage)];                          SequentialFileStagingArtifact sfsa = specificArtifact as SequentialFileStagingArtifact;                            Assert.NotNull(sfsa);                            // add a million more tasks...                            // test to ensure the task is read only                          TestUtilities.AssertThrows<InvalidOperationException>(() => myTask.FilesToStage = new List<IFileStagingProvider>());                                                    // Open the new Job as bound.                          CloudPool boundPool = batchCli.PoolOperations.GetPool(boundJob.ExecutionInformation.PoolId);                            // wait for the task to complete                          Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                            taskStateMonitor.WaitAll(                              boundJob.ListTasks()'                              Microsoft.Azure.Batch.Common.TaskState.Completed'                              TimeSpan.FromMinutes(10)'                              controlParams: null'                              additionalBehaviors:                                  new[]                          {                              // spam/logging interceptor                              new Microsoft.Azure.Batch.Protocol.RequestInterceptor((x) =>                              {                                  this.testOutputHelper.WriteLine("Issuing request type: " + x.GetType().ToString());                                    try                                  {                                      // print out the compute node states... we are actually waiting on the compute nodes                                      List<ComputeNode> allComputeNodes = boundPool.ListComputeNodes().ToList();                                        this.testOutputHelper.WriteLine("    #compute nodes: " + allComputeNodes.Count);                                        allComputeNodes.ForEach(                                          (icn) =>                                          {                                              this.testOutputHelper.WriteLine("  computeNode.id: " + icn.Id + "' state: " + icn.State);                                          });                                  }                                  catch (Exception ex)                                  {                                      // there is a race between the pool-life-job and the end of the job.. and the ListComputeNodes above                                      Assert.True(false' "SampleWithFilesAndPool probably can ignore this if its pool not found: " + ex.ToString());                                  }                              })                          });                                                    List<CloudTask> tasks = boundJob.ListTasks(null).ToList();                          CloudTask myCompletedTask = tasks[0];                            foreach (CloudTask curTask in tasks)                          {                              this.testOutputHelper.WriteLine("Task Id: " + curTask.Id + "' state: " + curTask.State);                          }                            boundPool.Refresh();                            this.testOutputHelper.WriteLine("Pool Id: " + boundPool.Id + "' state: " + boundPool.State);                            string stdOut = myCompletedTask.GetNodeFile(Constants.StandardOutFileName).ReadAsString();                          string stdErr = myCompletedTask.GetNodeFile(Constants.StandardErrorFileName).ReadAsString();                            this.testOutputHelper.WriteLine("StdOut: ");                          this.testOutputHelper.WriteLine(stdOut);                            this.testOutputHelper.WriteLine("StdErr: ");                          this.testOutputHelper.WriteLine(stdErr);                            this.testOutputHelper.WriteLine("Task Files:");                            foreach (NodeFile curFile in myCompletedTask.ListNodeFiles(recursive: true))                          {                              this.testOutputHelper.WriteLine("    FilePath: " + curFile.Path);                          }                            // confirm the files are there                          Assert.True(FoundFile("localwords.txt"' myCompletedTask.ListNodeFiles(recursive: true))' "mising file: localwords.txt");                            // test validation of StagingStorageAccount                            TestUtilities.AssertThrows<ArgumentOutOfRangeException>(() => { new StagingStorageAccount(storageAccount: " "' storageAccountKey: "key"' blobEndpoint: "blob"); });                          TestUtilities.AssertThrows<ArgumentOutOfRangeException>(() => { new StagingStorageAccount(storageAccount: "account"' storageAccountKey: " "' blobEndpoint: "blob"); });                          TestUtilities.AssertThrows<ArgumentOutOfRangeException>(() => { new StagingStorageAccount(storageAccount: "account"' storageAccountKey: "key"' blobEndpoint: ""); });                            if (null != sfsa)                          {                              // TODO: delete the container!                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,InboundEndpointIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\InboundEndpointIntegrationTests.cs,GetNetworkConfiguration,The following statement contains a magic number: var inboundNatPools = new List<InboundNatPool>              {                  new InboundNatPool("endpoint1"' InboundEndpointProtocol.Tcp' 1024' 20000' 20050)'                    new InboundNatPool("endpoint2"' InboundEndpointProtocol.Udp' 2048' 30000' 30050'                      new List<NetworkSecurityGroupRule>                      {                          new NetworkSecurityGroupRule(200' NetworkSecurityGroupRuleAccess.Allow' "10.0.0.1")'                          new NetworkSecurityGroupRule(250' NetworkSecurityGroupRuleAccess.Deny' "*")'                      })'              };
Magic Number,BatchClientIntegrationTests,InboundEndpointIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\InboundEndpointIntegrationTests.cs,GetNetworkConfiguration,The following statement contains a magic number: var inboundNatPools = new List<InboundNatPool>              {                  new InboundNatPool("endpoint1"' InboundEndpointProtocol.Tcp' 1024' 20000' 20050)'                    new InboundNatPool("endpoint2"' InboundEndpointProtocol.Udp' 2048' 30000' 30050'                      new List<NetworkSecurityGroupRule>                      {                          new NetworkSecurityGroupRule(200' NetworkSecurityGroupRuleAccess.Allow' "10.0.0.1")'                          new NetworkSecurityGroupRule(250' NetworkSecurityGroupRuleAccess.Deny' "*")'                      })'              };
Magic Number,BatchClientIntegrationTests,InboundEndpointIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\InboundEndpointIntegrationTests.cs,GetNetworkConfiguration,The following statement contains a magic number: var inboundNatPools = new List<InboundNatPool>              {                  new InboundNatPool("endpoint1"' InboundEndpointProtocol.Tcp' 1024' 20000' 20050)'                    new InboundNatPool("endpoint2"' InboundEndpointProtocol.Udp' 2048' 30000' 30050'                      new List<NetworkSecurityGroupRule>                      {                          new NetworkSecurityGroupRule(200' NetworkSecurityGroupRuleAccess.Allow' "10.0.0.1")'                          new NetworkSecurityGroupRule(250' NetworkSecurityGroupRuleAccess.Deny' "*")'                      })'              };
Magic Number,BatchClientIntegrationTests,InboundEndpointIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\InboundEndpointIntegrationTests.cs,GetNetworkConfiguration,The following statement contains a magic number: var inboundNatPools = new List<InboundNatPool>              {                  new InboundNatPool("endpoint1"' InboundEndpointProtocol.Tcp' 1024' 20000' 20050)'                    new InboundNatPool("endpoint2"' InboundEndpointProtocol.Udp' 2048' 30000' 30050'                      new List<NetworkSecurityGroupRule>                      {                          new NetworkSecurityGroupRule(200' NetworkSecurityGroupRuleAccess.Allow' "10.0.0.1")'                          new NetworkSecurityGroupRule(250' NetworkSecurityGroupRuleAccess.Deny' "*")'                      })'              };
Magic Number,BatchClientIntegrationTests,InboundEndpointIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\InboundEndpointIntegrationTests.cs,GetNetworkConfiguration,The following statement contains a magic number: var inboundNatPools = new List<InboundNatPool>              {                  new InboundNatPool("endpoint1"' InboundEndpointProtocol.Tcp' 1024' 20000' 20050)'                    new InboundNatPool("endpoint2"' InboundEndpointProtocol.Udp' 2048' 30000' 30050'                      new List<NetworkSecurityGroupRule>                      {                          new NetworkSecurityGroupRule(200' NetworkSecurityGroupRuleAccess.Allow' "10.0.0.1")'                          new NetworkSecurityGroupRule(250' NetworkSecurityGroupRuleAccess.Deny' "*")'                      })'              };
Magic Number,BatchClientIntegrationTests,InboundEndpointIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\InboundEndpointIntegrationTests.cs,GetNetworkConfiguration,The following statement contains a magic number: var inboundNatPools = new List<InboundNatPool>              {                  new InboundNatPool("endpoint1"' InboundEndpointProtocol.Tcp' 1024' 20000' 20050)'                    new InboundNatPool("endpoint2"' InboundEndpointProtocol.Udp' 2048' 30000' 30050'                      new List<NetworkSecurityGroupRule>                      {                          new NetworkSecurityGroupRule(200' NetworkSecurityGroupRuleAccess.Allow' "10.0.0.1")'                          new NetworkSecurityGroupRule(250' NetworkSecurityGroupRuleAccess.Deny' "*")'                      })'              };
Magic Number,BatchClientIntegrationTests,InboundEndpointIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\InboundEndpointIntegrationTests.cs,GetNetworkConfiguration,The following statement contains a magic number: var inboundNatPools = new List<InboundNatPool>              {                  new InboundNatPool("endpoint1"' InboundEndpointProtocol.Tcp' 1024' 20000' 20050)'                    new InboundNatPool("endpoint2"' InboundEndpointProtocol.Udp' 2048' 30000' 30050'                      new List<NetworkSecurityGroupRule>                      {                          new NetworkSecurityGroupRule(200' NetworkSecurityGroupRuleAccess.Allow' "10.0.0.1")'                          new NetworkSecurityGroupRule(250' NetworkSecurityGroupRuleAccess.Deny' "*")'                      })'              };
Magic Number,BatchClientIntegrationTests,InboundEndpointIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\InboundEndpointIntegrationTests.cs,GetNetworkConfiguration,The following statement contains a magic number: var inboundNatPools = new List<InboundNatPool>              {                  new InboundNatPool("endpoint1"' InboundEndpointProtocol.Tcp' 1024' 20000' 20050)'                    new InboundNatPool("endpoint2"' InboundEndpointProtocol.Udp' 2048' 30000' 30050'                      new List<NetworkSecurityGroupRule>                      {                          new NetworkSecurityGroupRule(200' NetworkSecurityGroupRuleAccess.Allow' "10.0.0.1")'                          new NetworkSecurityGroupRule(250' NetworkSecurityGroupRuleAccess.Deny' "*")'                      })'              };
Magic Number,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestOMJobSpecAndRelease,The following statement contains a magic number: Action test = () =>              {                  StagingStorageAccount stagingCreds = TestUtilities.GetStorageCredentialsFromEnvironment();                  using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jsId = "JobPrepAndRelease-" + /* "OM-static-c" */ "dynamic-" + CraftTimeString() + "-" + TestUtilities.GetMyName();                        try                      {                          // increase request timeout interceptor                          Protocol.RequestInterceptor increaseTimeoutInterceptor =                              new Protocol.RequestInterceptor((x) =>                              {                                  this.testOutputHelper.WriteLine("TestOMJobSpecAndRelease: setting request timeout.  Request type: " + x.GetType().ToString() + "' ClientRequestID: " + x.Options.ClientRequestId);                                  var timeoutOptions = x.Options as Protocol.Models.ITimeoutOptions;                                  timeoutOptions.Timeout = 5 * 60;                              });                            // lets use a timer too                          CallTimerViaInterceptors timerInterceptor = new CallTimerViaInterceptors();                            // seeing client side timeouts... so increase the durations on every call                          client.CustomBehaviors.Add(increaseTimeoutInterceptor);                          // add a call timer spammer/logger                          client.CustomBehaviors.Add(timerInterceptor.ReqInterceptor);                            // get some resource files to play with                          IList<ResourceFile> resFiles = UploadFilesMakeResFiles(stagingCreds);                            // create job schedule with prep/release                          {                              CloudJobSchedule unboundJobSchedule = client.JobScheduleOperations.CreateJobSchedule(jsId' null' null);                              unboundJobSchedule.JobSpecification = new JobSpecification(new PoolInformation());                              unboundJobSchedule.JobSpecification.PoolInformation.PoolId = this.poolFixture.PoolId;                              unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(3) };                                // add the jobPrep task to the job schedule                              {                                  JobPreparationTask prep = new JobPreparationTask(JobPrepCommandLine);                                  unboundJobSchedule.JobSpecification.JobPreparationTask = prep;                                    List<EnvironmentSetting> prepEnvSettings = new List<EnvironmentSetting>();                                  prepEnvSettings.Add(JobPrepEnvSettingOM);                                  prep.EnvironmentSettings = prepEnvSettings;                                    prep.Id = JobPrepId;                                  prep.RerunOnComputeNodeRebootAfterSuccess = JobPrepRerunOnComputeNodeRebootAfterSuccess;                                    prep.ResourceFiles = resFiles; // bug: incorrect type this should be IList<>                                    /*                                      prep.ResourceFiles = new List<ResourceFile>();  // this is actually read into our concurrent iList thing                                        // why not' merge them in.  exersize the concurent  IList thing                                      foreach (ResourceFile curRF in resFiles)                                      {                                          prep.ResourceFiles.Add(curRF);                                      }                                      */                                    prep.UserIdentity = new UserIdentity(JobPrepUserSpec);                                  prep.Constraints = JobPrepTaskConstraintsOM;                                  prep.WaitForSuccess = JobPrepWaitForSuccessCreate;                              }                                // add a jobRelease task to the job schedule                              {                                  JobReleaseTask relTask = new JobReleaseTask(JobReleaseTaskCommandLine);                                  unboundJobSchedule.JobSpecification.JobReleaseTask = relTask;                                                                    List<EnvironmentSetting> relEnvSettings = new List<EnvironmentSetting>();                                  relEnvSettings.Add(JobRelEnvSettingOM);                                  relTask.EnvironmentSettings = relEnvSettings;                                    relTask.MaxWallClockTime = JobRelMaxWallClockTime;                                    relTask.Id = JobRelId;                                    relTask.ResourceFiles = null;                                    relTask.ResourceFiles = new List<ResourceFile>();                                    // why not' merge them in.  work the concurrent  IList thing                                  foreach (ResourceFile curRF in resFiles)                                  {                                      relTask.ResourceFiles.Add(curRF);                                  }                                    relTask.RetentionTime = JobRelRetentionTime;                                  relTask.UserIdentity = new UserIdentity(JobRelUserSpec);                              }                                // set JobCommonEnvSettings                              {                                  List<EnvironmentSetting> jobCommonES = new List<EnvironmentSetting>();                                    jobCommonES.Add(JobCommonEnvSettingOM);                                    unboundJobSchedule.JobSpecification.CommonEnvironmentSettings = jobCommonES;                              }                                // add the job schedule to the service                              unboundJobSchedule.Commit();                          }                            // now we have a jobschedule with jobprep/release...now test the values on the jobschedule                          {                              CloudJobSchedule boundJobSchedule = client.JobScheduleOperations.GetJobSchedule(jsId);                                Assert.NotNull(boundJobSchedule);                              Assert.NotNull(boundJobSchedule.JobSpecification);                              Assert.NotNull(boundJobSchedule.JobSpecification.JobPreparationTask);                              Assert.NotNull(boundJobSchedule.JobSpecification.JobReleaseTask);                              Assert.NotNull(boundJobSchedule.JobSpecification.CommonEnvironmentSettings);                                AssertGoodCommonEnvSettingsOM(boundJobSchedule.JobSpecification.CommonEnvironmentSettings);                              AssertGoodJobPrepTaskOM(boundJobSchedule.JobSpecification.JobPreparationTask);                              AssertGoodJobReleaseTaskOM(boundJobSchedule.JobSpecification.JobReleaseTask);                              AssertGoodResourceFiles(resFiles' boundJobSchedule.JobSpecification.JobPreparationTask.ResourceFiles);                              AssertGoodResourceFiles(resFiles' boundJobSchedule.JobSpecification.JobReleaseTask.ResourceFiles);                                //todo: test mutability                          }                            CloudJobSchedule boundJobScheduleWithJob; // set on job test                            // test the values on the job                          {                              boundJobScheduleWithJob = TestUtilities.WaitForJobOnJobSchedule(client.JobScheduleOperations' jsId);                              CloudJob bndJob = client.JobOperations.GetJob(boundJobScheduleWithJob.ExecutionInformation.RecentJob.Id);                                Assert.NotNull(bndJob);                              Assert.NotNull(bndJob.CommonEnvironmentSettings);                              Assert.NotNull(bndJob.JobPreparationTask);                              Assert.NotNull(bndJob.JobReleaseTask);                                AssertGoodCommonEnvSettingsOM(bndJob.CommonEnvironmentSettings as IList<EnvironmentSetting>                                  /* we know it is our internal IList */);                              AssertGoodJobPrepTaskOM(bndJob.JobPreparationTask);                              AssertGoodJobReleaseTaskOM(bndJob.JobReleaseTask);                              AssertGoodResourceFiles(resFiles' bndJob.JobPreparationTask.ResourceFiles);                              AssertGoodResourceFiles(resFiles' bndJob.JobReleaseTask.ResourceFiles);                                //TODO: test immutability                          }                            // used for on get-status test                          CloudJobSchedule updatedJobSchedule;                            // test update on the WI jobprep/jobrelease                          {                              // change props                              boundJobScheduleWithJob.JobSpecification.JobPreparationTask.WaitForSuccess = JobPrepWaitForSuccessUpdate;                                // commit changes                              boundJobScheduleWithJob.Commit();                                // get new values                              updatedJobSchedule = client.JobScheduleOperations.GetJobSchedule(jsId);                                // confirm values changed                              Assert.Equal(JobPrepWaitForSuccessUpdate' updatedJobSchedule.JobSpecification.JobPreparationTask.WaitForSuccess);                          }                            TestGetPrepReleaseStatusCalls(client' updatedJobSchedule' this.poolFixture.PoolId' resFiles);                      }                      finally                      {                          // cleanup                          TestUtilities.DeleteJobScheduleIfExistsAsync(client' jsId).Wait();                      }                  }                };
Magic Number,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestOMJobSpecAndRelease,The following statement contains a magic number: Action test = () =>              {                  StagingStorageAccount stagingCreds = TestUtilities.GetStorageCredentialsFromEnvironment();                  using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jsId = "JobPrepAndRelease-" + /* "OM-static-c" */ "dynamic-" + CraftTimeString() + "-" + TestUtilities.GetMyName();                        try                      {                          // increase request timeout interceptor                          Protocol.RequestInterceptor increaseTimeoutInterceptor =                              new Protocol.RequestInterceptor((x) =>                              {                                  this.testOutputHelper.WriteLine("TestOMJobSpecAndRelease: setting request timeout.  Request type: " + x.GetType().ToString() + "' ClientRequestID: " + x.Options.ClientRequestId);                                  var timeoutOptions = x.Options as Protocol.Models.ITimeoutOptions;                                  timeoutOptions.Timeout = 5 * 60;                              });                            // lets use a timer too                          CallTimerViaInterceptors timerInterceptor = new CallTimerViaInterceptors();                            // seeing client side timeouts... so increase the durations on every call                          client.CustomBehaviors.Add(increaseTimeoutInterceptor);                          // add a call timer spammer/logger                          client.CustomBehaviors.Add(timerInterceptor.ReqInterceptor);                            // get some resource files to play with                          IList<ResourceFile> resFiles = UploadFilesMakeResFiles(stagingCreds);                            // create job schedule with prep/release                          {                              CloudJobSchedule unboundJobSchedule = client.JobScheduleOperations.CreateJobSchedule(jsId' null' null);                              unboundJobSchedule.JobSpecification = new JobSpecification(new PoolInformation());                              unboundJobSchedule.JobSpecification.PoolInformation.PoolId = this.poolFixture.PoolId;                              unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(3) };                                // add the jobPrep task to the job schedule                              {                                  JobPreparationTask prep = new JobPreparationTask(JobPrepCommandLine);                                  unboundJobSchedule.JobSpecification.JobPreparationTask = prep;                                    List<EnvironmentSetting> prepEnvSettings = new List<EnvironmentSetting>();                                  prepEnvSettings.Add(JobPrepEnvSettingOM);                                  prep.EnvironmentSettings = prepEnvSettings;                                    prep.Id = JobPrepId;                                  prep.RerunOnComputeNodeRebootAfterSuccess = JobPrepRerunOnComputeNodeRebootAfterSuccess;                                    prep.ResourceFiles = resFiles; // bug: incorrect type this should be IList<>                                    /*                                      prep.ResourceFiles = new List<ResourceFile>();  // this is actually read into our concurrent iList thing                                        // why not' merge them in.  exersize the concurent  IList thing                                      foreach (ResourceFile curRF in resFiles)                                      {                                          prep.ResourceFiles.Add(curRF);                                      }                                      */                                    prep.UserIdentity = new UserIdentity(JobPrepUserSpec);                                  prep.Constraints = JobPrepTaskConstraintsOM;                                  prep.WaitForSuccess = JobPrepWaitForSuccessCreate;                              }                                // add a jobRelease task to the job schedule                              {                                  JobReleaseTask relTask = new JobReleaseTask(JobReleaseTaskCommandLine);                                  unboundJobSchedule.JobSpecification.JobReleaseTask = relTask;                                                                    List<EnvironmentSetting> relEnvSettings = new List<EnvironmentSetting>();                                  relEnvSettings.Add(JobRelEnvSettingOM);                                  relTask.EnvironmentSettings = relEnvSettings;                                    relTask.MaxWallClockTime = JobRelMaxWallClockTime;                                    relTask.Id = JobRelId;                                    relTask.ResourceFiles = null;                                    relTask.ResourceFiles = new List<ResourceFile>();                                    // why not' merge them in.  work the concurrent  IList thing                                  foreach (ResourceFile curRF in resFiles)                                  {                                      relTask.ResourceFiles.Add(curRF);                                  }                                    relTask.RetentionTime = JobRelRetentionTime;                                  relTask.UserIdentity = new UserIdentity(JobRelUserSpec);                              }                                // set JobCommonEnvSettings                              {                                  List<EnvironmentSetting> jobCommonES = new List<EnvironmentSetting>();                                    jobCommonES.Add(JobCommonEnvSettingOM);                                    unboundJobSchedule.JobSpecification.CommonEnvironmentSettings = jobCommonES;                              }                                // add the job schedule to the service                              unboundJobSchedule.Commit();                          }                            // now we have a jobschedule with jobprep/release...now test the values on the jobschedule                          {                              CloudJobSchedule boundJobSchedule = client.JobScheduleOperations.GetJobSchedule(jsId);                                Assert.NotNull(boundJobSchedule);                              Assert.NotNull(boundJobSchedule.JobSpecification);                              Assert.NotNull(boundJobSchedule.JobSpecification.JobPreparationTask);                              Assert.NotNull(boundJobSchedule.JobSpecification.JobReleaseTask);                              Assert.NotNull(boundJobSchedule.JobSpecification.CommonEnvironmentSettings);                                AssertGoodCommonEnvSettingsOM(boundJobSchedule.JobSpecification.CommonEnvironmentSettings);                              AssertGoodJobPrepTaskOM(boundJobSchedule.JobSpecification.JobPreparationTask);                              AssertGoodJobReleaseTaskOM(boundJobSchedule.JobSpecification.JobReleaseTask);                              AssertGoodResourceFiles(resFiles' boundJobSchedule.JobSpecification.JobPreparationTask.ResourceFiles);                              AssertGoodResourceFiles(resFiles' boundJobSchedule.JobSpecification.JobReleaseTask.ResourceFiles);                                //todo: test mutability                          }                            CloudJobSchedule boundJobScheduleWithJob; // set on job test                            // test the values on the job                          {                              boundJobScheduleWithJob = TestUtilities.WaitForJobOnJobSchedule(client.JobScheduleOperations' jsId);                              CloudJob bndJob = client.JobOperations.GetJob(boundJobScheduleWithJob.ExecutionInformation.RecentJob.Id);                                Assert.NotNull(bndJob);                              Assert.NotNull(bndJob.CommonEnvironmentSettings);                              Assert.NotNull(bndJob.JobPreparationTask);                              Assert.NotNull(bndJob.JobReleaseTask);                                AssertGoodCommonEnvSettingsOM(bndJob.CommonEnvironmentSettings as IList<EnvironmentSetting>                                  /* we know it is our internal IList */);                              AssertGoodJobPrepTaskOM(bndJob.JobPreparationTask);                              AssertGoodJobReleaseTaskOM(bndJob.JobReleaseTask);                              AssertGoodResourceFiles(resFiles' bndJob.JobPreparationTask.ResourceFiles);                              AssertGoodResourceFiles(resFiles' bndJob.JobReleaseTask.ResourceFiles);                                //TODO: test immutability                          }                            // used for on get-status test                          CloudJobSchedule updatedJobSchedule;                            // test update on the WI jobprep/jobrelease                          {                              // change props                              boundJobScheduleWithJob.JobSpecification.JobPreparationTask.WaitForSuccess = JobPrepWaitForSuccessUpdate;                                // commit changes                              boundJobScheduleWithJob.Commit();                                // get new values                              updatedJobSchedule = client.JobScheduleOperations.GetJobSchedule(jsId);                                // confirm values changed                              Assert.Equal(JobPrepWaitForSuccessUpdate' updatedJobSchedule.JobSpecification.JobPreparationTask.WaitForSuccess);                          }                            TestGetPrepReleaseStatusCalls(client' updatedJobSchedule' this.poolFixture.PoolId' resFiles);                      }                      finally                      {                          // cleanup                          TestUtilities.DeleteJobScheduleIfExistsAsync(client' jsId).Wait();                      }                  }                };
Magic Number,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestOMJobSpecAndRelease,The following statement contains a magic number: Action test = () =>              {                  StagingStorageAccount stagingCreds = TestUtilities.GetStorageCredentialsFromEnvironment();                  using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jsId = "JobPrepAndRelease-" + /* "OM-static-c" */ "dynamic-" + CraftTimeString() + "-" + TestUtilities.GetMyName();                        try                      {                          // increase request timeout interceptor                          Protocol.RequestInterceptor increaseTimeoutInterceptor =                              new Protocol.RequestInterceptor((x) =>                              {                                  this.testOutputHelper.WriteLine("TestOMJobSpecAndRelease: setting request timeout.  Request type: " + x.GetType().ToString() + "' ClientRequestID: " + x.Options.ClientRequestId);                                  var timeoutOptions = x.Options as Protocol.Models.ITimeoutOptions;                                  timeoutOptions.Timeout = 5 * 60;                              });                            // lets use a timer too                          CallTimerViaInterceptors timerInterceptor = new CallTimerViaInterceptors();                            // seeing client side timeouts... so increase the durations on every call                          client.CustomBehaviors.Add(increaseTimeoutInterceptor);                          // add a call timer spammer/logger                          client.CustomBehaviors.Add(timerInterceptor.ReqInterceptor);                            // get some resource files to play with                          IList<ResourceFile> resFiles = UploadFilesMakeResFiles(stagingCreds);                            // create job schedule with prep/release                          {                              CloudJobSchedule unboundJobSchedule = client.JobScheduleOperations.CreateJobSchedule(jsId' null' null);                              unboundJobSchedule.JobSpecification = new JobSpecification(new PoolInformation());                              unboundJobSchedule.JobSpecification.PoolInformation.PoolId = this.poolFixture.PoolId;                              unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(3) };                                // add the jobPrep task to the job schedule                              {                                  JobPreparationTask prep = new JobPreparationTask(JobPrepCommandLine);                                  unboundJobSchedule.JobSpecification.JobPreparationTask = prep;                                    List<EnvironmentSetting> prepEnvSettings = new List<EnvironmentSetting>();                                  prepEnvSettings.Add(JobPrepEnvSettingOM);                                  prep.EnvironmentSettings = prepEnvSettings;                                    prep.Id = JobPrepId;                                  prep.RerunOnComputeNodeRebootAfterSuccess = JobPrepRerunOnComputeNodeRebootAfterSuccess;                                    prep.ResourceFiles = resFiles; // bug: incorrect type this should be IList<>                                    /*                                      prep.ResourceFiles = new List<ResourceFile>();  // this is actually read into our concurrent iList thing                                        // why not' merge them in.  exersize the concurent  IList thing                                      foreach (ResourceFile curRF in resFiles)                                      {                                          prep.ResourceFiles.Add(curRF);                                      }                                      */                                    prep.UserIdentity = new UserIdentity(JobPrepUserSpec);                                  prep.Constraints = JobPrepTaskConstraintsOM;                                  prep.WaitForSuccess = JobPrepWaitForSuccessCreate;                              }                                // add a jobRelease task to the job schedule                              {                                  JobReleaseTask relTask = new JobReleaseTask(JobReleaseTaskCommandLine);                                  unboundJobSchedule.JobSpecification.JobReleaseTask = relTask;                                                                    List<EnvironmentSetting> relEnvSettings = new List<EnvironmentSetting>();                                  relEnvSettings.Add(JobRelEnvSettingOM);                                  relTask.EnvironmentSettings = relEnvSettings;                                    relTask.MaxWallClockTime = JobRelMaxWallClockTime;                                    relTask.Id = JobRelId;                                    relTask.ResourceFiles = null;                                    relTask.ResourceFiles = new List<ResourceFile>();                                    // why not' merge them in.  work the concurrent  IList thing                                  foreach (ResourceFile curRF in resFiles)                                  {                                      relTask.ResourceFiles.Add(curRF);                                  }                                    relTask.RetentionTime = JobRelRetentionTime;                                  relTask.UserIdentity = new UserIdentity(JobRelUserSpec);                              }                                // set JobCommonEnvSettings                              {                                  List<EnvironmentSetting> jobCommonES = new List<EnvironmentSetting>();                                    jobCommonES.Add(JobCommonEnvSettingOM);                                    unboundJobSchedule.JobSpecification.CommonEnvironmentSettings = jobCommonES;                              }                                // add the job schedule to the service                              unboundJobSchedule.Commit();                          }                            // now we have a jobschedule with jobprep/release...now test the values on the jobschedule                          {                              CloudJobSchedule boundJobSchedule = client.JobScheduleOperations.GetJobSchedule(jsId);                                Assert.NotNull(boundJobSchedule);                              Assert.NotNull(boundJobSchedule.JobSpecification);                              Assert.NotNull(boundJobSchedule.JobSpecification.JobPreparationTask);                              Assert.NotNull(boundJobSchedule.JobSpecification.JobReleaseTask);                              Assert.NotNull(boundJobSchedule.JobSpecification.CommonEnvironmentSettings);                                AssertGoodCommonEnvSettingsOM(boundJobSchedule.JobSpecification.CommonEnvironmentSettings);                              AssertGoodJobPrepTaskOM(boundJobSchedule.JobSpecification.JobPreparationTask);                              AssertGoodJobReleaseTaskOM(boundJobSchedule.JobSpecification.JobReleaseTask);                              AssertGoodResourceFiles(resFiles' boundJobSchedule.JobSpecification.JobPreparationTask.ResourceFiles);                              AssertGoodResourceFiles(resFiles' boundJobSchedule.JobSpecification.JobReleaseTask.ResourceFiles);                                //todo: test mutability                          }                            CloudJobSchedule boundJobScheduleWithJob; // set on job test                            // test the values on the job                          {                              boundJobScheduleWithJob = TestUtilities.WaitForJobOnJobSchedule(client.JobScheduleOperations' jsId);                              CloudJob bndJob = client.JobOperations.GetJob(boundJobScheduleWithJob.ExecutionInformation.RecentJob.Id);                                Assert.NotNull(bndJob);                              Assert.NotNull(bndJob.CommonEnvironmentSettings);                              Assert.NotNull(bndJob.JobPreparationTask);                              Assert.NotNull(bndJob.JobReleaseTask);                                AssertGoodCommonEnvSettingsOM(bndJob.CommonEnvironmentSettings as IList<EnvironmentSetting>                                  /* we know it is our internal IList */);                              AssertGoodJobPrepTaskOM(bndJob.JobPreparationTask);                              AssertGoodJobReleaseTaskOM(bndJob.JobReleaseTask);                              AssertGoodResourceFiles(resFiles' bndJob.JobPreparationTask.ResourceFiles);                              AssertGoodResourceFiles(resFiles' bndJob.JobReleaseTask.ResourceFiles);                                //TODO: test immutability                          }                            // used for on get-status test                          CloudJobSchedule updatedJobSchedule;                            // test update on the WI jobprep/jobrelease                          {                              // change props                              boundJobScheduleWithJob.JobSpecification.JobPreparationTask.WaitForSuccess = JobPrepWaitForSuccessUpdate;                                // commit changes                              boundJobScheduleWithJob.Commit();                                // get new values                              updatedJobSchedule = client.JobScheduleOperations.GetJobSchedule(jsId);                                // confirm values changed                              Assert.Equal(JobPrepWaitForSuccessUpdate' updatedJobSchedule.JobSpecification.JobPreparationTask.WaitForSuccess);                          }                            TestGetPrepReleaseStatusCalls(client' updatedJobSchedule' this.poolFixture.PoolId' resFiles);                      }                      finally                      {                          // cleanup                          TestUtilities.DeleteJobScheduleIfExistsAsync(client' jsId).Wait();                      }                  }                };
Magic Number,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestOMJobPrepSchedulingError,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      try                      {                          // create job with prep that triggers prep scheduling error                          {                              CloudJob unboundJob = client.JobOperations.CreateJob(jobId' new PoolInformation() {PoolId = this.poolFixture.PoolId});                              // add the jobPrep task to the job                              {                                  JobPreparationTask prep = new JobPreparationTask("cmd /c JobPrep Task");                                  unboundJob.JobPreparationTask = prep;                                    ResourceFile[] badResFiles = { ResourceFile.FromUrl("https://not.a.domain.invalid/file"' "bob.txt")};                                    prep.ResourceFiles = badResFiles;                                    prep.WaitForSuccess = true; // be explicit even though this is the default.  need JP/ to not run                              }                                // add the job to the service                              unboundJob.Commit();                          }                            CloudJob boundJob = client.JobOperations.GetJob(jobId);                            // add a trivial task to force the JP                          client.JobOperations.AddTask(boundJob.Id' new CloudTask("ForceJobPrep"' "cmd /c echo TestOMJobPrepSchedulingError"));                            // the victim compute node.  pool should have size 1.                          List<ComputeNode> nodes = client.PoolOperations.ListComputeNodes(this.poolFixture.PoolId).ToList();                            Assert.Single(nodes);                            // now we have a job that should be trying to run the JP                          // poll for the JP to have been run' and it must have a scheduling error                          bool prepNotCompleted = true;                            // gotta poll to find out when the jp has been run                          while (prepNotCompleted)                          {                              List<JobPreparationAndReleaseTaskExecutionInformation> jpStatsList =                                  client.JobOperations.ListJobPreparationAndReleaseTaskStatus(jobId).ToList();                              JobPreparationAndReleaseTaskExecutionInformation jpStatus = jpStatsList.FirstOrDefault();                                if (jpStatus == null)                              {                                  Thread.Sleep(2000);                              }                              else                              {                                  if (JobPreparationTaskState.Completed == jpStatus.JobPreparationTaskExecutionInformation.State)                                  {                                      prepNotCompleted = false; // we see a JP has completed                                        Assert.NotNull(jpStatus.JobPreparationTaskExecutionInformation.FailureInformation);                                      Assert.Equal(TaskExecutionResult.Failure' jpStatus.JobPreparationTaskExecutionInformation.Result);                                        // spew the failure                                      this.OutputFailureInfo(jpStatus.JobPreparationTaskExecutionInformation.FailureInformation);                                  }                                    this.testOutputHelper.WriteLine("Job Prep is running (waiting for blob dl to timeout)");                              }                          }                      }                      finally                      {                          // cleanup                          client.JobOperations.DeleteJob(jobId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestOMJobReleaseSchedulingError,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      try                      {                          // create job schedule with prep that succeeds and release the triggers scheduling error                          {                              PoolInformation poolInfo = new PoolInformation() {PoolId = this.poolFixture.PoolId};                              CloudJob unboundJob = client.JobOperations.CreateJob(jobId' poolInfo);                                // add the jobPrep task to the job                              {                                  JobPreparationTask prep = new JobPreparationTask("cmd /c echo the quick job prep jumped over the...");                                  unboundJob.JobPreparationTask = prep;                                    prep.WaitForSuccess = false; // we don't really care but why not set this                              }                                // add a jobRelease task to the job                              {                                  JobReleaseTask relTask = new JobReleaseTask("cmd /c echo Job Release Task");                                  unboundJob.JobReleaseTask = relTask;                                    ResourceFile[] badResFiles = { ResourceFile.FromUrl("https://not.a.domain.invalid/file"' "bob.txt")};                                    relTask.ResourceFiles = badResFiles;                                    relTask.Id = "jobRelease";                              }                                // add the job to the service                              unboundJob.Commit();                          }                            // add a trivial task to force the JP                          client.JobOperations.AddTask(jobId' new CloudTask("ForceJobPrep"' "cmd /c echo TestOMJobReleaseSchedulingError"));                            // wait for the task to complete                            TaskStateMonitor tsm = client.Utilities.CreateTaskStateMonitor();                            tsm.WaitAll(                              client.JobOperations.ListTasks(jobId)'                              TaskState.Completed'                              TimeSpan.FromMinutes(10)'                              additionalBehaviors:                                  new[]                                  {                                      // spam/logging interceptor                                      new Protocol.RequestInterceptor((x) =>                                          {                                              this.testOutputHelper.WriteLine("Issuing request type: " + x.GetType().ToString());                                                // print out the compute node states... we are actually waiting on the compute nodes                                              List<ComputeNode> allComputeNodes = client.PoolOperations.ListComputeNodes(this.poolFixture.PoolId).ToList();                                                this.testOutputHelper.WriteLine("    #compute nodes: " + allComputeNodes.Count);                                                allComputeNodes.ForEach((icn) =>                                                  {                                                      this.testOutputHelper.WriteLine("  computeNode.id: " + icn.Id + "' state: " + icn.State);                                                  });                                              this.testOutputHelper.WriteLine("");                                          })                                  }                              );                            // ok terminate job to trigger job release                          client.JobOperations.TerminateJob(jobId' "BUG: Server will throw 500 if I don't provide reason");                            // the victim compute node.  pool should have size 1.                          List<ComputeNode> computeNodes = client.PoolOperations.ListComputeNodes(this.poolFixture.PoolId).ToList();                            Assert.Single(computeNodes);                            // now we have a job that should be trying to run the JP                          // poll for the JP to have been run' and it must have a scheduling error                          bool releaseNotCompleted = true;                            // gotta poll to find out when the jp has been run                          while (releaseNotCompleted)                          {                              List<JobPreparationAndReleaseTaskExecutionInformation> jrStatusList =                                  client.JobOperations.ListJobPreparationAndReleaseTaskStatus(jobId).ToList();                                JobPreparationAndReleaseTaskExecutionInformation prepAndReleaseStatus = jrStatusList.FirstOrDefault();                                if (prepAndReleaseStatus != null && null != prepAndReleaseStatus.JobReleaseTaskExecutionInformation)                              {                                  if (JobReleaseTaskState.Completed == prepAndReleaseStatus.JobReleaseTaskExecutionInformation.State)                                  {                                      releaseNotCompleted = false; // we see a JP has been run                                        // now assert the failure info                                      Assert.NotNull(prepAndReleaseStatus);                                      Assert.NotNull(prepAndReleaseStatus.JobReleaseTaskExecutionInformation.FailureInformation);                                      Assert.Equal(TaskExecutionResult.Failure' prepAndReleaseStatus.JobReleaseTaskExecutionInformation.Result);                                        // spew the failure info                                      this.OutputFailureInfo(prepAndReleaseStatus.JobReleaseTaskExecutionInformation.FailureInformation);                                  }                              }                              Thread.Sleep(2000);                              this.testOutputHelper.WriteLine("Job Release tasks still running (waiting for blob dl to timeout).");                          }                      }                      finally                      {                          client.JobOperations.DeleteJob(jobId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestOMJobReleaseSchedulingError,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient client = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      try                      {                          // create job schedule with prep that succeeds and release the triggers scheduling error                          {                              PoolInformation poolInfo = new PoolInformation() {PoolId = this.poolFixture.PoolId};                              CloudJob unboundJob = client.JobOperations.CreateJob(jobId' poolInfo);                                // add the jobPrep task to the job                              {                                  JobPreparationTask prep = new JobPreparationTask("cmd /c echo the quick job prep jumped over the...");                                  unboundJob.JobPreparationTask = prep;                                    prep.WaitForSuccess = false; // we don't really care but why not set this                              }                                // add a jobRelease task to the job                              {                                  JobReleaseTask relTask = new JobReleaseTask("cmd /c echo Job Release Task");                                  unboundJob.JobReleaseTask = relTask;                                    ResourceFile[] badResFiles = { ResourceFile.FromUrl("https://not.a.domain.invalid/file"' "bob.txt")};                                    relTask.ResourceFiles = badResFiles;                                    relTask.Id = "jobRelease";                              }                                // add the job to the service                              unboundJob.Commit();                          }                            // add a trivial task to force the JP                          client.JobOperations.AddTask(jobId' new CloudTask("ForceJobPrep"' "cmd /c echo TestOMJobReleaseSchedulingError"));                            // wait for the task to complete                            TaskStateMonitor tsm = client.Utilities.CreateTaskStateMonitor();                            tsm.WaitAll(                              client.JobOperations.ListTasks(jobId)'                              TaskState.Completed'                              TimeSpan.FromMinutes(10)'                              additionalBehaviors:                                  new[]                                  {                                      // spam/logging interceptor                                      new Protocol.RequestInterceptor((x) =>                                          {                                              this.testOutputHelper.WriteLine("Issuing request type: " + x.GetType().ToString());                                                // print out the compute node states... we are actually waiting on the compute nodes                                              List<ComputeNode> allComputeNodes = client.PoolOperations.ListComputeNodes(this.poolFixture.PoolId).ToList();                                                this.testOutputHelper.WriteLine("    #compute nodes: " + allComputeNodes.Count);                                                allComputeNodes.ForEach((icn) =>                                                  {                                                      this.testOutputHelper.WriteLine("  computeNode.id: " + icn.Id + "' state: " + icn.State);                                                  });                                              this.testOutputHelper.WriteLine("");                                          })                                  }                              );                            // ok terminate job to trigger job release                          client.JobOperations.TerminateJob(jobId' "BUG: Server will throw 500 if I don't provide reason");                            // the victim compute node.  pool should have size 1.                          List<ComputeNode> computeNodes = client.PoolOperations.ListComputeNodes(this.poolFixture.PoolId).ToList();                            Assert.Single(computeNodes);                            // now we have a job that should be trying to run the JP                          // poll for the JP to have been run' and it must have a scheduling error                          bool releaseNotCompleted = true;                            // gotta poll to find out when the jp has been run                          while (releaseNotCompleted)                          {                              List<JobPreparationAndReleaseTaskExecutionInformation> jrStatusList =                                  client.JobOperations.ListJobPreparationAndReleaseTaskStatus(jobId).ToList();                                JobPreparationAndReleaseTaskExecutionInformation prepAndReleaseStatus = jrStatusList.FirstOrDefault();                                if (prepAndReleaseStatus != null && null != prepAndReleaseStatus.JobReleaseTaskExecutionInformation)                              {                                  if (JobReleaseTaskState.Completed == prepAndReleaseStatus.JobReleaseTaskExecutionInformation.State)                                  {                                      releaseNotCompleted = false; // we see a JP has been run                                        // now assert the failure info                                      Assert.NotNull(prepAndReleaseStatus);                                      Assert.NotNull(prepAndReleaseStatus.JobReleaseTaskExecutionInformation.FailureInformation);                                      Assert.Equal(TaskExecutionResult.Failure' prepAndReleaseStatus.JobReleaseTaskExecutionInformation.Result);                                        // spew the failure info                                      this.OutputFailureInfo(prepAndReleaseStatus.JobReleaseTaskExecutionInformation.FailureInformation);                                  }                              }                              Thread.Sleep(2000);                              this.testOutputHelper.WriteLine("Job Release tasks still running (waiting for blob dl to timeout).");                          }                      }                      finally                      {                          client.JobOperations.DeleteJob(jobId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,The following statement contains a magic number: Thread.Sleep(1000);
Magic Number,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,The following statement contains a magic number: Assert.True(beforeJobPrepRuns < jptei.JobPreparationTaskExecutionInformation.StartTime + TimeSpan.FromSeconds(10));
Magic Number,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,The following statement contains a magic number: Thread.Sleep(2000);
Magic Number,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,The following statement contains a magic number: tsm.WaitAll(                      batchCli.JobOperations.GetJob(jobId).ListTasks(additionalBehaviors: new[] { consoleSpammer })'                      TaskState.Completed'                      TimeSpan.FromSeconds(120)'                      additionalBehaviors: new[] { consoleSpammer });
Magic Number,BatchClientIntegrationTests,JobPrepReleaseIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\JobPrepReleaseIntegrationTests.cs,TestGetPrepReleaseStatusCalls,The following statement contains a magic number: Thread.Sleep(2000);
Magic Number,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug1480489NodeFileMissingIsDirectory,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug1480489Job-" + TestUtilities.GetMyName();                        try                      {                          // here we show how to use an unbound Job + Commit() to run millions of Tasks                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId });                          unboundJob.Commit();                            // Open the new Job as bound.                          CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                            CloudTask myTask = new CloudTask(id: "Bug1480489Task"' commandline: @"md Bug1480489Directory");                            // add the task to the job                          boundJob.AddTask(myTask);                            // wait for the task to complete                          Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                            taskStateMonitor.WaitAll(                              boundJob.ListTasks()'                              Microsoft.Azure.Batch.Common.TaskState.Completed'                              TimeSpan.FromMinutes(3));                            CloudTask myCompletedTask = new List<CloudTask>(boundJob.ListTasks(null))[0];                            string stdOut = myCompletedTask.GetNodeFile(Constants.StandardOutFileName).ReadAsString();                          string stdErr = myCompletedTask.GetNodeFile(Constants.StandardErrorFileName).ReadAsString();                            this.testOutputHelper.WriteLine("TaskId: " + myCompletedTask.Id);                          this.testOutputHelper.WriteLine("StdOut: ");                          this.testOutputHelper.WriteLine(stdOut);                            this.testOutputHelper.WriteLine("StdErr: ");                          this.testOutputHelper.WriteLine(stdErr);                            this.testOutputHelper.WriteLine("Task Files:");                            bool foundAtLeastOneDir = false;                            foreach (NodeFile curFile in myCompletedTask.ListNodeFiles())                          {                              this.testOutputHelper.WriteLine("    Filepath: " + curFile.Path);                              this.testOutputHelper.WriteLine("       IsDirectory: " + curFile.IsDirectory.ToString());                                // turns out wd is created for each task so use it as sentinal                              if (curFile.Path.Equals("wd") && curFile.IsDirectory.HasValue && curFile.IsDirectory.Value)                              {                                  foundAtLeastOneDir = true;                              }                          }                            Assert.True(foundAtLeastOneDir);                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug230385SupportDeleteNodeFileByTask,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug230285Job-" + TestUtilities.GetMyName();                        try                      {                          const string taskId = "hiWorld";                          const string directoryCreationTaskId1 = "dirTask1";                          const string directoryCreationTaskId2 = "dirTask2";                            const string directoryNameOne = "Foo";                          const string directoryNameTwo = "Bar";                                                    const string directory2PathOnNode = "wd/" + directoryNameTwo;                            //                          // Create the job                          //                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          unboundJob.PoolInformation.PoolId = this.poolFixture.PoolId;                          unboundJob.Commit();                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                          CloudTask myTask = new CloudTask(taskId' "cmd /c echo hello world");                          CloudTask directoryCreationTask1 = new CloudTask(directoryCreationTaskId1' string.Format("cmd /c mkdir {0} && echo test > {0}/testfile.txt"' directoryNameOne));                          CloudTask directoryCreationTask2 = new CloudTask(directoryCreationTaskId2' string.Format("cmd /c mkdir {0} && echo test > {0}/testfile.txt"' directoryNameTwo));                            boundJob.AddTask(myTask);                          boundJob.AddTask(directoryCreationTask1);                          boundJob.AddTask(directoryCreationTask2);                            this.testOutputHelper.WriteLine("Initial job commit()");                            //                          // Wait for task to go to completion                          //                          Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                            taskStateMonitor.WaitAll(                                  boundJob.ListTasks()'                                  Microsoft.Azure.Batch.Common.TaskState.Completed'                                  TimeSpan.FromMinutes(3));                                                    //                          // NodeFile delete                          //                                                    //Delete single file                          NodeFile file = batchCli.JobOperations.GetNodeFile(jobId' taskId' Constants.StandardOutFileName);                          file.Delete();                            //Ensure delete succeeded                          TestUtilities.AssertThrows<BatchException>(() => batchCli.JobOperations.GetNodeFile(jobId' taskId' Constants.StandardOutFileName));                            //Delete directory                            NodeFile directory = batchCli.JobOperations.ListNodeFiles(jobId' directoryCreationTaskId1' recursive: true).First(item => item.Path.Contains(directoryNameOne));                          Assert.True(directory.IsDirectory);                          TestUtilities.AssertThrows<BatchException>(() => directory.Delete(recursive: false));                          directory.Delete(recursive: true);                            Assert.Null(batchCli.JobOperations.ListNodeFiles(jobId' directoryCreationTaskId1' recursive: true).FirstOrDefault(item => item.Path.Contains(directoryNameOne)));                            //                          // JobScheduleOperations delete task file                          //                          batchCli.JobOperations.GetNodeFile(jobId' taskId' Constants.StandardErrorFileName);                          batchCli.JobOperations.DeleteNodeFile(jobId' taskId' Constants.StandardErrorFileName);                            //Ensure delete succeeded                          TestUtilities.AssertThrows<BatchException>(() => batchCli.JobOperations.GetNodeFile(jobId' taskId' Constants.StandardErrorFileName));                            //Delete directory                          directory = batchCli.JobOperations.ListNodeFiles(jobId' directoryCreationTaskId2' recursive: true).First(item => item.Path.Contains(directoryNameTwo));                          Assert.True(directory.IsDirectory);                          TestUtilities.AssertThrows<BatchException>(() => batchCli.JobOperations.DeleteNodeFile(jobId' directoryCreationTaskId2' directory2PathOnNode' recursive: false));                          batchCli.JobOperations.DeleteNodeFile(jobId' directoryCreationTaskId2' directory2PathOnNode' recursive: true);                            Assert.Null(batchCli.JobOperations.ListNodeFiles(jobId' directoryCreationTaskId2' recursive: true).FirstOrDefault(item => item.Path.Contains(directoryNameTwo)));                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestNode_GetListDeleteFiles,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "TestNodeGetListDeleteFiles-" + TestUtilities.GetMyName();                        try                      {                          const string taskId = "hiWorld";                            const string directoryCreationTaskId1 = "dirTask1";                          const string directoryCreationTaskId2 = "dirTask2";                            const string directoryNameOne = "Foo";                          const string directoryNameTwo = "Bar";                            //                          // Create the job                          //                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          unboundJob.PoolInformation.PoolId = this.poolFixture.PoolId;                          unboundJob.Commit();                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                          CloudTask myTask = new CloudTask(taskId' "cmd /c echo hello world");                          CloudTask directoryCreationTask1 = new CloudTask(directoryCreationTaskId1' string.Format("cmd /c mkdir {0} && echo test > {0}/testfile.txt"' directoryNameOne));                          CloudTask directoryCreationTask2 = new CloudTask(directoryCreationTaskId2' string.Format("cmd /c mkdir {0} && echo test > {0}/testfile.txt"' directoryNameTwo));                            boundJob.AddTask(myTask);                          boundJob.AddTask(directoryCreationTask1);                          boundJob.AddTask(directoryCreationTask2);                            this.testOutputHelper.WriteLine("Initial job commit()");                            //                          // Wait for task to go to completion                          //                          Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                            taskStateMonitor.WaitAll(                              boundJob.ListTasks()'                              Microsoft.Azure.Batch.Common.TaskState.Completed'                              TimeSpan.FromMinutes(3));                            CloudTask boundTask = boundJob.GetTask(taskId);                          //Since the compute node name comes back as "Node:<computeNodeId>" we need to split on : to get the actual compute node name                          string computeNodeId = boundTask.ComputeNodeInformation.AffinityId.Split(':')[1];                            ComputeNode computeNode = batchCli.PoolOperations.GetComputeNode(this.poolFixture.PoolId' computeNodeId);                            this.testOutputHelper.WriteLine("Task ran on compute node: {0}"' computeNodeId);                            //Ensure that ListFiles done without a recursive option' or with recursive false return the same values                          {                              List<NodeFile> filesByComputeNodeRecursiveOmitted = batchCli.PoolOperations.ListNodeFiles(                                  this.poolFixture.PoolId'                                   computeNodeId).ToList();                                List<NodeFile> filesByComputeNodeRecursiveFalse = batchCli.PoolOperations.ListNodeFiles(                                  this.poolFixture.PoolId'                                   computeNodeId'                                   recursive: false).ToList();                                AssertFileListsMatch(filesByComputeNodeRecursiveOmitted' filesByComputeNodeRecursiveFalse);                          }                            {                              List<NodeFile> filesByTaskRecursiveOmitted = batchCli.JobOperations.ListNodeFiles(                                  jobId'                                  taskId).ToList();                                List<NodeFile> filesByTaskRecursiveFalse = batchCli.JobOperations.ListNodeFiles(                                  jobId'                                  taskId'                                  recursive: false).ToList();                                AssertFileListsMatch(filesByTaskRecursiveOmitted' filesByTaskRecursiveFalse);                          }                            //                          // List all node files from operations -- recursive true                          //                          //TODO: Detail level?                          List<NodeFile> fileListFromComputeNodeOperations = batchCli.PoolOperations.ListNodeFiles(this.poolFixture.PoolId' computeNodeId' recursive: true).ToList();                            foreach (NodeFile f in fileListFromComputeNodeOperations)                          {                              this.testOutputHelper.WriteLine("Found file: {0}"' f.Path);                          }                          //Check to make sure the expected folder named "Shared" exists                          Assert.Contains("shared"' fileListFromComputeNodeOperations.Select(f => f.Path));                            //                          // List all node files from the compute node -- recursive true                          //                          List<NodeFile> fileListFromComputeNode = computeNode.ListNodeFiles(recursive: true).ToList();                          foreach (NodeFile f in fileListFromComputeNodeOperations)                          {                              this.testOutputHelper.WriteLine("Found file: {0}"' f.Path);                          }                          //Check to make sure the expected folder named "Shared" exists                          Assert.Contains("shared"' fileListFromComputeNode.Select(f => f.Path));                            //                          // Get file from operations                          //                          string filePathToGet = fileListFromComputeNode.First(f => !f.IsDirectory.Value && f.Properties.ContentLength > 0).Path;                          this.testOutputHelper.WriteLine("Getting file: {0}"' filePathToGet);                          NodeFile computeNodeFileFromManager = batchCli.PoolOperations.GetNodeFile(this.poolFixture.PoolId' computeNodeId' filePathToGet);                          this.testOutputHelper.WriteLine("Successfully retrieved file: {0}"' filePathToGet);                          this.testOutputHelper.WriteLine("---- File data: ----");                          var computeNodeFileContentFromManager = computeNodeFileFromManager.ReadAsString();                          this.testOutputHelper.WriteLine(computeNodeFileContentFromManager);                          Assert.NotEmpty(computeNodeFileContentFromManager);                            //                          // Get file directly from operations (bypassing the properties call)                          //                          var computeNodeFileContentDirect = batchCli.PoolOperations.CopyNodeFileContentToString(this.poolFixture.PoolId' computeNodeId' filePathToGet);                          this.testOutputHelper.WriteLine("---- File data: ----");                          this.testOutputHelper.WriteLine(computeNodeFileContentDirect);                          Assert.NotEmpty(computeNodeFileContentDirect);                            //                          // Get file from compute node                          //                          this.testOutputHelper.WriteLine("Getting file: {0}"' filePathToGet);                          NodeFile fileFromComputeNode = computeNode.GetNodeFile(filePathToGet);                          this.testOutputHelper.WriteLine("Successfully retrieved file: {0}"' filePathToGet);                          this.testOutputHelper.WriteLine("---- File data: ----");                          var computeNodeFileContentFromNode = fileFromComputeNode.ReadAsString();                          this.testOutputHelper.WriteLine(computeNodeFileContentFromNode);                          Assert.NotEmpty(computeNodeFileContentFromNode);                            //                          // Get file from compute node (bypassing the properties call)                          //                          computeNodeFileContentDirect = computeNode.CopyNodeFileContentToString(filePathToGet);                          this.testOutputHelper.WriteLine("---- File data: ----");                          this.testOutputHelper.WriteLine(computeNodeFileContentDirect);                          Assert.NotEmpty(computeNodeFileContentDirect);                            //                          // NodeFile delete                          //                          string filePath = Path.Combine(@"workitems"' jobId' "job-1"' taskId' Constants.StandardOutFileName);                          NodeFile nodeFile = batchCli.PoolOperations.GetNodeFile(this.poolFixture.PoolId' computeNodeId' filePath);                            nodeFile.Delete();                            //Ensure delete succeeded                            TestUtilities.AssertThrows<BatchException>(() => nodeFile.Refresh());                            //Delete directory                            NodeFile directory = batchCli.PoolOperations.ListNodeFiles(this.poolFixture.PoolId' computeNodeId' recursive: true).First(item => item.Path.Contains(directoryNameOne));                          Assert.True(directory.IsDirectory);                          TestUtilities.AssertThrows<BatchException>(() => directory.Delete(recursive: false));                          directory.Delete(recursive: true);                            Assert.Null(batchCli.PoolOperations.ListNodeFiles(this.poolFixture.PoolId' computeNodeId' recursive: true).FirstOrDefault(item => item.Path.Contains(directoryNameOne)));                            //                          // PoolManager delete node file                          //                          filePath = Path.Combine(@"workitems"' jobId' "job-1"' taskId' Constants.StandardErrorFileName);                            NodeFile file = batchCli.JobOperations.GetNodeFile(jobId' taskId' Constants.StandardErrorFileName);                          batchCli.PoolOperations.DeleteNodeFile(this.poolFixture.PoolId' computeNodeId' filePath);                            //Ensure delete succeeded                          TestUtilities.AssertThrows<BatchException>(() => batchCli.JobOperations.GetNodeFile(jobId' taskId' Constants.StandardErrorFileName));                            //Delete directory                          directory = batchCli.PoolOperations.ListNodeFiles(this.poolFixture.PoolId' computeNodeId' recursive: true).First(item => item.Path.Contains(directoryNameTwo));                          Assert.True(directory.IsDirectory);                          TestUtilities.AssertThrows<BatchException>(() => batchCli.PoolOperations.DeleteNodeFile(this.poolFixture.PoolId' computeNodeId' directory.Path' recursive: false));                          batchCli.PoolOperations.DeleteNodeFile(this.poolFixture.PoolId' computeNodeId' directory.Path' recursive: true);                            Assert.Null(batchCli.PoolOperations.ListNodeFiles(this.poolFixture.PoolId' computeNodeId' recursive: true).FirstOrDefault(item => item.Path.Contains(directoryNameTwo)));                      }                      finally                      {                          batchCli.JobOperations.DeleteJob(jobId);                      }                    }              };
Magic Number,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug2338301_CheckStreamPositionAfterFileRead,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      JobOperations jobOperations = batchCli.JobOperations;                      {                          string jobId = "Bug2338301Job-" + TestUtilities.GetMyName();                            try                          {                              const string taskId = "hiWorld";                                //                              // Create the job                              //                              CloudJob unboundJob = jobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId });                              unboundJob.Commit();                                CloudJob boundJob = jobOperations.GetJob(jobId);                              CloudTask myTask = new CloudTask(taskId' "cmd /c echo hello world");                                boundJob.AddTask(myTask);                                this.testOutputHelper.WriteLine("Initial job commit()");                                //                              // Wait for task to go to completion                              //                              Utilities utilities = batchCli.Utilities;                              TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                              taskStateMonitor.WaitAll(                                  boundJob.ListTasks()'                                  Microsoft.Azure.Batch.Common.TaskState.Completed'                                  TimeSpan.FromMinutes(3));                                CloudTask boundTask = boundJob.GetTask(taskId);                                //Get the task file                              const string fileToGet = "stdout.txt";                              NodeFile file = boundTask.GetNodeFile(fileToGet);                                //Download the file data                              string result = file.ReadAsString();                              Assert.True(result.Length > 0);                          }                          finally                          {                              jobOperations.DeleteJob(jobId);                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug1480491NodeFileFileProperties,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug1480491Job-" + TestUtilities.GetMyName();                        try                      {                          const string taskId = "hiWorld";                            //                          // Create the job                          //                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          unboundJob.PoolInformation.PoolId = this.poolFixture.PoolId;                          unboundJob.Commit();                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                          CloudTask myTask = new CloudTask(taskId' "cmd /c echo hello world");                            boundJob.AddTask(myTask);                            this.testOutputHelper.WriteLine("Initial job commit()");                            //                          // Wait for task to go to completion                          //                          Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                            taskStateMonitor.WaitAll(                              boundJob.ListTasks()'                              Microsoft.Azure.Batch.Common.TaskState.Completed'                              TimeSpan.FromMinutes(3));                            const int expectedFileSize = 13; //Magic number based on output generated by the task                            //                          // NodeFile by task                          //                          NodeFile file = batchCli.JobOperations.GetNodeFile(jobId' taskId' Constants.StandardOutFileName);                            this.testOutputHelper.WriteLine("File {0} has content length: {1}"' Constants.StandardOutFileName' file.Properties.ContentLength);                          this.testOutputHelper.WriteLine("File {0} has content type: {1}"' Constants.StandardOutFileName' file.Properties.ContentType);                            this.testOutputHelper.WriteLine("File {0} has creation time: {1}"' Constants.StandardOutFileName' file.Properties.CreationTime);                          this.testOutputHelper.WriteLine("File {0} has last modified time: {1}"' Constants.StandardOutFileName' file.Properties.LastModified);                            Assert.Equal(expectedFileSize' file.Properties.ContentLength);                          Assert.Equal("text/plain"' file.Properties.ContentType);                            //                          // NodeFile by node                          //                          CloudTask boundTask = boundJob.GetTask(taskId);                          string computeNodeId = boundTask.ComputeNodeInformation.AffinityId.Split(':')[1];                            ComputeNode computeNode = batchCli.PoolOperations.GetComputeNode(this.poolFixture.PoolId' computeNodeId);                            this.testOutputHelper.WriteLine("Task ran on compute node: {0}"' computeNodeId);                            List<NodeFile> files = computeNode.ListNodeFiles(recursive: true).ToList();                          foreach (NodeFile nodeFile in files)                          {                              this.testOutputHelper.WriteLine("Found file: {0}"' nodeFile.Path);                          }                            string filePathToGet = string.Format("workitems/{0}/{1}/{2}/{3}"' jobId' "job-1"' taskId' Constants.StandardOutFileName);                          file = computeNode.GetNodeFile(filePathToGet);                            this.testOutputHelper.WriteLine("File {0} has content length: {1}"' filePathToGet' file.Properties.ContentLength);                          this.testOutputHelper.WriteLine("File {0} has content type: {1}"' filePathToGet' file.Properties.ContentType);                            this.testOutputHelper.WriteLine("File {0} has creation time: {1}"' filePathToGet' file.Properties.CreationTime);                          this.testOutputHelper.WriteLine("File {0} has last modified time: {1}"' filePathToGet' file.Properties.LastModified);                            Assert.Equal(expectedFileSize' file.Properties.ContentLength);                          Assert.Equal("text/plain"' file.Properties.ContentType);                      }                      finally                      {                          batchCli.JobOperations.DeleteJob(jobId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,Bug1480491NodeFileFileProperties,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      string jobId = "Bug1480491Job-" + TestUtilities.GetMyName();                        try                      {                          const string taskId = "hiWorld";                            //                          // Create the job                          //                          CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                          unboundJob.PoolInformation.PoolId = this.poolFixture.PoolId;                          unboundJob.Commit();                            CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                          CloudTask myTask = new CloudTask(taskId' "cmd /c echo hello world");                            boundJob.AddTask(myTask);                            this.testOutputHelper.WriteLine("Initial job commit()");                            //                          // Wait for task to go to completion                          //                          Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                            taskStateMonitor.WaitAll(                              boundJob.ListTasks()'                              Microsoft.Azure.Batch.Common.TaskState.Completed'                              TimeSpan.FromMinutes(3));                            const int expectedFileSize = 13; //Magic number based on output generated by the task                            //                          // NodeFile by task                          //                          NodeFile file = batchCli.JobOperations.GetNodeFile(jobId' taskId' Constants.StandardOutFileName);                            this.testOutputHelper.WriteLine("File {0} has content length: {1}"' Constants.StandardOutFileName' file.Properties.ContentLength);                          this.testOutputHelper.WriteLine("File {0} has content type: {1}"' Constants.StandardOutFileName' file.Properties.ContentType);                            this.testOutputHelper.WriteLine("File {0} has creation time: {1}"' Constants.StandardOutFileName' file.Properties.CreationTime);                          this.testOutputHelper.WriteLine("File {0} has last modified time: {1}"' Constants.StandardOutFileName' file.Properties.LastModified);                            Assert.Equal(expectedFileSize' file.Properties.ContentLength);                          Assert.Equal("text/plain"' file.Properties.ContentType);                            //                          // NodeFile by node                          //                          CloudTask boundTask = boundJob.GetTask(taskId);                          string computeNodeId = boundTask.ComputeNodeInformation.AffinityId.Split(':')[1];                            ComputeNode computeNode = batchCli.PoolOperations.GetComputeNode(this.poolFixture.PoolId' computeNodeId);                            this.testOutputHelper.WriteLine("Task ran on compute node: {0}"' computeNodeId);                            List<NodeFile> files = computeNode.ListNodeFiles(recursive: true).ToList();                          foreach (NodeFile nodeFile in files)                          {                              this.testOutputHelper.WriteLine("Found file: {0}"' nodeFile.Path);                          }                            string filePathToGet = string.Format("workitems/{0}/{1}/{2}/{3}"' jobId' "job-1"' taskId' Constants.StandardOutFileName);                          file = computeNode.GetNodeFile(filePathToGet);                            this.testOutputHelper.WriteLine("File {0} has content length: {1}"' filePathToGet' file.Properties.ContentLength);                          this.testOutputHelper.WriteLine("File {0} has content type: {1}"' filePathToGet' file.Properties.ContentType);                            this.testOutputHelper.WriteLine("File {0} has creation time: {1}"' filePathToGet' file.Properties.CreationTime);                          this.testOutputHelper.WriteLine("File {0} has last modified time: {1}"' filePathToGet' file.Properties.LastModified);                            Assert.Equal(expectedFileSize' file.Properties.ContentLength);                          Assert.Equal("text/plain"' file.Properties.ContentType);                      }                      finally                      {                          batchCli.JobOperations.DeleteJob(jobId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,NodeFileIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\NodeFileIntegrationTests.cs,TestGetNodeFileByTask,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      JobOperations jobOperations = batchCli.JobOperations;                        string jobId = Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-" + nameof(TestGetNodeFileByTask);                      try                      {                          //                          // Create the job                          //                          CloudJob job = jobOperations.CreateJob(jobId' new PoolInformation());                          job.PoolInformation = new PoolInformation()                          {                              PoolId = this.poolFixture.PoolId                          };                            this.testOutputHelper.WriteLine("Initial job schedule commit()");                            job.Commit();                            //                          // Wait for the job                          //                          this.testOutputHelper.WriteLine("Waiting for job");                          CloudJob boundJob = jobOperations.GetJob(jobId);                            //                          // Add task to the job                          //                          const string taskId = "T1";                          const string taskMessage = "This is a test";                            this.testOutputHelper.WriteLine("Adding task: {0}"' taskId);                          CloudTask task = new CloudTask(taskId' string.Format("cmd /c echo {0}"' taskMessage));                          boundJob.AddTask(task);                            //                          // Wait for the task to complete                          //                          this.testOutputHelper.WriteLine("Waiting for the task to complete");                          Utilities utilities = batchCli.Utilities;                          TaskStateMonitor taskStateMonitor = utilities.CreateTaskStateMonitor();                            //Wait for the task state to be running                          taskStateMonitor.WaitAll(                              jobOperations.ListTasks(jobId)'                              TaskState.Completed'                              TimeSpan.FromSeconds(30));                            //Download the data                          this.testOutputHelper.WriteLine("Downloading the stdout for the file");                          NodeFile file = jobOperations.GetNodeFile(jobId' taskId' Constants.StandardOutFileName);                          string data = file.ReadAsString();                          this.testOutputHelper.WriteLine("Data: {0}"' data);                          Assert.Contains(taskMessage' data);                            // Download the data again using the JobOperations read file content helper                          data = batchCli.JobOperations.CopyNodeFileContentToString(jobId' taskId' Constants.StandardOutFileName);                          this.testOutputHelper.WriteLine("Data: {0}"' data);                          Assert.Contains(taskMessage' data);                      }                      finally                      {                          jobOperations.DeleteJob(jobId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug957878SkipTokenSupportMissing,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      int numTasksCreated = 0;                      string jobId = "bug957898Job-" + TestUtilities.GetMyName();                        try                      {                          CloudJob jobCreate = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId });                          jobCreate.Commit();                            CloudJob theJob = batchCli.JobOperations.GetJob(jobId);                            for (int i = 0; i < 50; i++)                          {                              CloudTask curTask = new CloudTask("bug957878-task-" + i.ToString()' "hostname");                                theJob.AddTask(curTask);                                numTasksCreated++;                          }                            int numTasksSeen = 0;                            // test replacement interceptor and forces MaxResults to a low #                          Bug957878ReplacementInterceptorBox box0 = new Bug957878ReplacementInterceptorBox(this.testOutputHelper);                            foreach (CloudTask curTask in theJob.ListTasks(additionalBehaviors: new[] {                              new Microsoft.Azure.Batch.Protocol.RequestReplacementInterceptor(box0.Bug957878RequestReplacementInterceptorOpContextFactory)}))                          {                              numTasksSeen++;                                this.testOutputHelper.WriteLine("    Task_Id: " + curTask.Id);                          }                            // confirm we'v seen the correct # of tasks during enumeration                          Assert.Equal(numTasksCreated' numTasksSeen);                            // confirm we got the correct # of chunks...                          Assert.True(box0.NumTimesCalled >= 10);                            // >= because the server might hickup too and put in extra empty skiptokens                            this.testOutputHelper.WriteLine("total tasks created: " + numTasksCreated.ToString());                          this.testOutputHelper.WriteLine("total tasks enumerated: " + numTasksSeen.ToString());                            Assert.Equal(numTasksCreated' numTasksSeen);                            // tests performed elsewhere                          // list task files                          // list job schedules                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug957878SkipTokenSupportMissing,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      int numTasksCreated = 0;                      string jobId = "bug957898Job-" + TestUtilities.GetMyName();                        try                      {                          CloudJob jobCreate = batchCli.JobOperations.CreateJob(jobId' new PoolInformation() { PoolId = this.poolFixture.PoolId });                          jobCreate.Commit();                            CloudJob theJob = batchCli.JobOperations.GetJob(jobId);                            for (int i = 0; i < 50; i++)                          {                              CloudTask curTask = new CloudTask("bug957878-task-" + i.ToString()' "hostname");                                theJob.AddTask(curTask);                                numTasksCreated++;                          }                            int numTasksSeen = 0;                            // test replacement interceptor and forces MaxResults to a low #                          Bug957878ReplacementInterceptorBox box0 = new Bug957878ReplacementInterceptorBox(this.testOutputHelper);                            foreach (CloudTask curTask in theJob.ListTasks(additionalBehaviors: new[] {                              new Microsoft.Azure.Batch.Protocol.RequestReplacementInterceptor(box0.Bug957878RequestReplacementInterceptorOpContextFactory)}))                          {                              numTasksSeen++;                                this.testOutputHelper.WriteLine("    Task_Id: " + curTask.Id);                          }                            // confirm we'v seen the correct # of tasks during enumeration                          Assert.Equal(numTasksCreated' numTasksSeen);                            // confirm we got the correct # of chunks...                          Assert.True(box0.NumTimesCalled >= 10);                            // >= because the server might hickup too and put in extra empty skiptokens                            this.testOutputHelper.WriteLine("total tasks created: " + numTasksCreated.ToString());                          this.testOutputHelper.WriteLine("total tasks enumerated: " + numTasksSeen.ToString());                            Assert.Equal(numTasksCreated' numTasksSeen);                            // tests performed elsewhere                          // list task files                          // list job schedules                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1719609ODATADetailLevel,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      // pools tested in Bug1770942ExposeBatchRequestProperties                      this.testOutputHelper.WriteLine("job schedule tests");                        // create a bunch of job schedules                      {                          const int numJobSchedulesToCreate = 10;                            List<string> jobScheduleIds = new List<string>();                          for (int i = 0; i < numJobSchedulesToCreate; i++)                          {                              string id;                                if (1 == (i % 2))                              {                                  id = "Odd-Bug1770942-";                              }                              else                              {                                  id = "Even-Bug1770942-";                              }                                // add my name for visibile accounting                              id += i + "-" + TestUtilities.GetMyName();                                jobScheduleIds.Add(id);                          }                            try                          {                              foreach (string jobScheduleId in jobScheduleIds)                              {                                  CloudJobSchedule unboundJobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                                  PoolInformation poolInformation = new PoolInformation();                                    poolInformation.PoolId = this.poolFixture.PoolId;                                    unboundJobSchedule.JobSpecification = new JobSpecification(poolInformation);                                    unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(5) };                                    // create the job schedule                                  unboundJobSchedule.Commit();                              }                                // first get a list of all wi's with all props                              IEnumerable<CloudJobSchedule> ienumJobScheduleAllProps = batchCli.JobScheduleOperations.ListJobSchedules();                              List<CloudJobSchedule> listAllJobScheduleProps = new List<CloudJobSchedule>(ienumJobScheduleAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<CloudJobSchedule> ienumOdd =                                  batchCli.JobScheduleOperations.ListJobSchedules(detailLevel:                                      new ODATADetailLevel() { FilterClause = "startswith(id' 'Odd')"' SelectClause = "id'state" });                              List<CloudJobSchedule> listOdd = new List<CloudJobSchedule>(ienumOdd);                                IEnumerable<CloudJobSchedule> ienumEven =                                  batchCli.JobScheduleOperations.ListJobSchedules(detailLevel:                                      new ODATADetailLevel() { FilterClause = "startswith(id' 'Even')"' SelectClause = "id'state" });                              List<CloudJobSchedule> listEven = new List<CloudJobSchedule>(ienumEven);                                // confirm detail level worked                                // pick one                              CloudJobSchedule lowDetailLevelJobSchedule = listEven[0];                              CloudJobSchedule matchingAllPropJobSchedule = null;                                // find it in the list that has full props                              foreach (CloudJobSchedule currJobSchedule in listAllJobScheduleProps)                              {                                  // found it                                  if (currJobSchedule.Id.Equals(lowDetailLevelJobSchedule.Id' StringComparison.InvariantCultureIgnoreCase))                                  {                                      matchingAllPropJobSchedule = currJobSchedule;                                        Assert.NotEqual(currJobSchedule.CreationTime' lowDetailLevelJobSchedule.CreationTime);                                  }                              }                                // confirm that a match was found                              Assert.NotNull(matchingAllPropJobSchedule);                                // confirm that detail level works on jobScheduleOperations.GetJobSchedule()                              CloudJobSchedule directGetLowDetailLevel = batchCli.JobScheduleOperations.GetJobSchedule(matchingAllPropJobSchedule.Id'                                  new ODATADetailLevel() { SelectClause = "id'state" });                                Assert.NotEqual(matchingAllPropJobSchedule.CreationTime' directGetLowDetailLevel.CreationTime);                                // confirm that detail level can be returned to normal via refresh()                              directGetLowDetailLevel.Refresh(); // no detail level returns to full properties                                Assert.Equal(matchingAllPropJobSchedule.CreationTime' directGetLowDetailLevel.CreationTime);                          }                          finally                          {                              List<Task> jobScheduleDeletions = new List<Task>();                              foreach (string id in jobScheduleIds)                              {                                  Task t = TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' id);                                  jobScheduleDeletions.Add(t);                              }                                Task.WhenAll(jobScheduleDeletions).Wait();                          }                      }                        this.testOutputHelper.WriteLine("job tests");                        // jobs                      string jobId = "Bug1770942Job-" + TestUtilities.GetMyName();                        try                      {                          {                              // create a job                              CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                              unboundJob.PoolInformation.PoolId = this.poolFixture.PoolId;                              unboundJob.Commit();                              CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                                CloudTask unboundTask = new CloudTask("Bug1770942Taskname"' "hostname");                              boundJob.AddTask(unboundTask);                                string filterString = string.Format("startswith(id' '{0}')"' jobId);                                // first get a list with all props                              IEnumerable<CloudJob> ienumAllProps = batchCli.JobOperations.ListJobs(detailLevel: new ODATADetailLevel(){ FilterClause = filterString });                              List<CloudJob> listAllProps = new List<CloudJob>(ienumAllProps);                                // get list using lower Detail Level.  choose a predicate that will return no jobs since there is only the one :(                              IEnumerable<CloudJob> iEnumFewerProps = batchCli.JobOperations.ListJobs(detailLevel: new ODATADetailLevel() { SelectClause = "id'state"' FilterClause = filterString });                              List<CloudJob> listFewerProps = new List<CloudJob>(iEnumFewerProps);                                // the total must equal the sum of the parts                              Assert.Equal(listFewerProps.Count' listAllProps.Count);                                // confirm detail level worked                                // get the low detail level object                              CloudJob lowDetailLevel = listFewerProps.Single();                                // yes its the same and only                              Assert.Equal(listAllProps[0].Id' lowDetailLevel.Id);                                // confirm detail levels different                              Assert.NotEqual(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                                // confirm detail level returned to normal via refresh                              lowDetailLevel.Refresh();                                // now they both have all props                              Assert.Equal(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                                // confirm refresh can lower detail level                              lowDetailLevel = batchCli.JobOperations.GetJob(lowDetailLevel.Id);  // cant refresh 2 times or more because that pesky bug on refresh                              Assert.Equal(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);  // so all props are loaded                                // refresh and lower DL                              lowDetailLevel.Refresh(detailLevel: new ODATADetailLevel() { SelectClause = "id'state" });                                // now they must be different                              Assert.NotEqual(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                          }                            this.testOutputHelper.WriteLine("task tests");                            // tasks                          {                              // push tasks to this job                              CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                                // add a bunch of tasks                              const int numToCreate = 10;                                for (int i = 0; i < numToCreate; i++)                              {                                  string id;                                    if (1 == (i % 2))                                  {                                      id = "Odd-Bug1770942-";                                  }                                  else                                  {                                      id = "Even-Bug1770942-";                                  }                                    // add my name for visibile accounting                                  id += i + "-" + TestUtilities.GetMyName();                                    CloudTask unboundTask = new CloudTask(id' "cmd /c hostname");                                    // add the task                                  boundJob.AddTask(unboundTask);                              }                                // first get a list with all props                              IEnumerable<CloudTask> ienumAllProps = boundJob.ListTasks();                              List<CloudTask> listAllProps = new List<CloudTask>(ienumAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<CloudTask> ienumOdd = boundJob.ListTasks(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(id' 'Odd')"' SelectClause = "id'state" });                              List<CloudTask> listOdd = new List<CloudTask>(ienumOdd);                                IEnumerable<CloudTask> ienumEven = boundJob.ListTasks(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(id' 'Even')"' SelectClause = "id'state" });                              List<CloudTask> listEven = new List<CloudTask>(ienumEven);                                // the total must equal the sum of the parts                              Assert.Equal(listOdd.Count + listEven.Count + 1 /* 1 special task from above */' listAllProps.Count);                                // confirm detail level worked                              // pick one from lower detail level and compare it to the same one from the all-props collection                                CloudTask lowerDetailTask = listOdd[0];                              CloudTask matchingAllPropsTask = null;                                // now find it in the all-props list                              foreach (CloudTask curAllPropsTask in listAllProps)                              {                                  if (curAllPropsTask.Id.Equals(lowerDetailTask.Id))                                  {                                      matchingAllPropsTask = curAllPropsTask;                                  }                              }                                // we have a matching all-props instance... compare them.                              Assert.NotNull(matchingAllPropsTask);                                // see!  detail level works!                              Assert.NotEqual(matchingAllPropsTask.CreationTime' lowerDetailTask.CreationTime);                                // now confirm that refresh will raise detail level                              lowerDetailTask.Refresh();                                // they should be the same now                              Assert.Equal(matchingAllPropsTask.CreationTime' lowerDetailTask.CreationTime);                                // now confirm that refresh + detail level can lower detail level                              matchingAllPropsTask.Refresh(detailLevel: new ODATADetailLevel() { SelectClause = "id'state" });                                // confirm lower detail level                              Assert.NotEqual(lowerDetailTask.CreationTime' matchingAllPropsTask.CreationTime);                          }                            // task files                          this.testOutputHelper.WriteLine("task file tests");                            {                              List<CloudTask> tasks = new List<CloudTask>(batchCli.JobOperations.GetJob(jobId).ListTasks());                              CloudTask task = tasks[0]; // just pick one it doesnt matter which                                //Ensure that the task has run                              TaskStateMonitor tsm = batchCli.Utilities.CreateTaskStateMonitor();                              tsm.WaitAll(new List<CloudTask> { task }' TaskState.Completed' TimeSpan.FromSeconds(20));                                // first get a list with all props                              IEnumerable<NodeFile> ienumAllProps = task.ListNodeFiles();                              List<NodeFile> listAllProps = new List<NodeFile>(ienumAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<NodeFile> ienumStd = task.ListNodeFiles(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(name' 'std')" });                              List<NodeFile> listStd = new List<NodeFile>(ienumStd);                                // assert that filtering works                              Assert.Equal(2' listStd.Count);  // stdout/stderr                              Assert.True(listAllProps.Count > listStd.Count);                                // test nodefile refresh                                NodeFile stdoutFile = null;                                // find stdout                              listStd.ForEach(x => { if (x.Path.IndexOf("stdout"' StringComparison.InvariantCultureIgnoreCase) >= 0) { stdoutFile = x; } });                                // save pre-refresh props                              FileProperties saveFilProps = stdoutFile.Properties;                                // refesh to see if the props come back                              stdoutFile.Refresh();                                NodeFile againViaList = null;                                new List<NodeFile>(task.ListNodeFiles()).ForEach(x => { if (x.Path.IndexOf("stdout"' StringComparison.InvariantCultureIgnoreCase) >= 0) { againViaList = x; } });                                //"Bug1719609ODATADetailLevel: sometimes this can fail.  check out CreateTime"                              //This fails due to different time formats used in the header vs in the body of a request.  Since we expect that this will basically never pass                              //until the bug is fixed' we assert instead on only the upper-order digits of the DateTime                                //Assert.Equal(stdoutFile.Properties.CreationTime' saveFilProps.CreationTime);                              DateTime creationTime = saveFilProps.CreationTime.Value;                              DateTime refreshedCreationTime = stdoutFile.Properties.CreationTime.Value;                                Assert.Equal(DateTimeKind.Utc' refreshedCreationTime.Kind);                                Assert.Equal(creationTime.Year' refreshedCreationTime.Year);                              Assert.Equal(creationTime.Month' refreshedCreationTime.Month);                              Assert.Equal(creationTime.Day' refreshedCreationTime.Day);                              Assert.Equal(creationTime.Hour' refreshedCreationTime.Hour);                              Assert.Equal(creationTime.Minute' refreshedCreationTime.Minute);                              Assert.Equal(creationTime.Second' refreshedCreationTime.Second);                              Assert.Equal(creationTime.Kind' refreshedCreationTime.Kind);                                //Since the low order bits are lost in the GetFile (header based respose) assert that they are 0                              Assert.Equal(0' refreshedCreationTime.Millisecond);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1719609ODATADetailLevel,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      // pools tested in Bug1770942ExposeBatchRequestProperties                      this.testOutputHelper.WriteLine("job schedule tests");                        // create a bunch of job schedules                      {                          const int numJobSchedulesToCreate = 10;                            List<string> jobScheduleIds = new List<string>();                          for (int i = 0; i < numJobSchedulesToCreate; i++)                          {                              string id;                                if (1 == (i % 2))                              {                                  id = "Odd-Bug1770942-";                              }                              else                              {                                  id = "Even-Bug1770942-";                              }                                // add my name for visibile accounting                              id += i + "-" + TestUtilities.GetMyName();                                jobScheduleIds.Add(id);                          }                            try                          {                              foreach (string jobScheduleId in jobScheduleIds)                              {                                  CloudJobSchedule unboundJobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                                  PoolInformation poolInformation = new PoolInformation();                                    poolInformation.PoolId = this.poolFixture.PoolId;                                    unboundJobSchedule.JobSpecification = new JobSpecification(poolInformation);                                    unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(5) };                                    // create the job schedule                                  unboundJobSchedule.Commit();                              }                                // first get a list of all wi's with all props                              IEnumerable<CloudJobSchedule> ienumJobScheduleAllProps = batchCli.JobScheduleOperations.ListJobSchedules();                              List<CloudJobSchedule> listAllJobScheduleProps = new List<CloudJobSchedule>(ienumJobScheduleAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<CloudJobSchedule> ienumOdd =                                  batchCli.JobScheduleOperations.ListJobSchedules(detailLevel:                                      new ODATADetailLevel() { FilterClause = "startswith(id' 'Odd')"' SelectClause = "id'state" });                              List<CloudJobSchedule> listOdd = new List<CloudJobSchedule>(ienumOdd);                                IEnumerable<CloudJobSchedule> ienumEven =                                  batchCli.JobScheduleOperations.ListJobSchedules(detailLevel:                                      new ODATADetailLevel() { FilterClause = "startswith(id' 'Even')"' SelectClause = "id'state" });                              List<CloudJobSchedule> listEven = new List<CloudJobSchedule>(ienumEven);                                // confirm detail level worked                                // pick one                              CloudJobSchedule lowDetailLevelJobSchedule = listEven[0];                              CloudJobSchedule matchingAllPropJobSchedule = null;                                // find it in the list that has full props                              foreach (CloudJobSchedule currJobSchedule in listAllJobScheduleProps)                              {                                  // found it                                  if (currJobSchedule.Id.Equals(lowDetailLevelJobSchedule.Id' StringComparison.InvariantCultureIgnoreCase))                                  {                                      matchingAllPropJobSchedule = currJobSchedule;                                        Assert.NotEqual(currJobSchedule.CreationTime' lowDetailLevelJobSchedule.CreationTime);                                  }                              }                                // confirm that a match was found                              Assert.NotNull(matchingAllPropJobSchedule);                                // confirm that detail level works on jobScheduleOperations.GetJobSchedule()                              CloudJobSchedule directGetLowDetailLevel = batchCli.JobScheduleOperations.GetJobSchedule(matchingAllPropJobSchedule.Id'                                  new ODATADetailLevel() { SelectClause = "id'state" });                                Assert.NotEqual(matchingAllPropJobSchedule.CreationTime' directGetLowDetailLevel.CreationTime);                                // confirm that detail level can be returned to normal via refresh()                              directGetLowDetailLevel.Refresh(); // no detail level returns to full properties                                Assert.Equal(matchingAllPropJobSchedule.CreationTime' directGetLowDetailLevel.CreationTime);                          }                          finally                          {                              List<Task> jobScheduleDeletions = new List<Task>();                              foreach (string id in jobScheduleIds)                              {                                  Task t = TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' id);                                  jobScheduleDeletions.Add(t);                              }                                Task.WhenAll(jobScheduleDeletions).Wait();                          }                      }                        this.testOutputHelper.WriteLine("job tests");                        // jobs                      string jobId = "Bug1770942Job-" + TestUtilities.GetMyName();                        try                      {                          {                              // create a job                              CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                              unboundJob.PoolInformation.PoolId = this.poolFixture.PoolId;                              unboundJob.Commit();                              CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                                CloudTask unboundTask = new CloudTask("Bug1770942Taskname"' "hostname");                              boundJob.AddTask(unboundTask);                                string filterString = string.Format("startswith(id' '{0}')"' jobId);                                // first get a list with all props                              IEnumerable<CloudJob> ienumAllProps = batchCli.JobOperations.ListJobs(detailLevel: new ODATADetailLevel(){ FilterClause = filterString });                              List<CloudJob> listAllProps = new List<CloudJob>(ienumAllProps);                                // get list using lower Detail Level.  choose a predicate that will return no jobs since there is only the one :(                              IEnumerable<CloudJob> iEnumFewerProps = batchCli.JobOperations.ListJobs(detailLevel: new ODATADetailLevel() { SelectClause = "id'state"' FilterClause = filterString });                              List<CloudJob> listFewerProps = new List<CloudJob>(iEnumFewerProps);                                // the total must equal the sum of the parts                              Assert.Equal(listFewerProps.Count' listAllProps.Count);                                // confirm detail level worked                                // get the low detail level object                              CloudJob lowDetailLevel = listFewerProps.Single();                                // yes its the same and only                              Assert.Equal(listAllProps[0].Id' lowDetailLevel.Id);                                // confirm detail levels different                              Assert.NotEqual(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                                // confirm detail level returned to normal via refresh                              lowDetailLevel.Refresh();                                // now they both have all props                              Assert.Equal(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                                // confirm refresh can lower detail level                              lowDetailLevel = batchCli.JobOperations.GetJob(lowDetailLevel.Id);  // cant refresh 2 times or more because that pesky bug on refresh                              Assert.Equal(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);  // so all props are loaded                                // refresh and lower DL                              lowDetailLevel.Refresh(detailLevel: new ODATADetailLevel() { SelectClause = "id'state" });                                // now they must be different                              Assert.NotEqual(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                          }                            this.testOutputHelper.WriteLine("task tests");                            // tasks                          {                              // push tasks to this job                              CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                                // add a bunch of tasks                              const int numToCreate = 10;                                for (int i = 0; i < numToCreate; i++)                              {                                  string id;                                    if (1 == (i % 2))                                  {                                      id = "Odd-Bug1770942-";                                  }                                  else                                  {                                      id = "Even-Bug1770942-";                                  }                                    // add my name for visibile accounting                                  id += i + "-" + TestUtilities.GetMyName();                                    CloudTask unboundTask = new CloudTask(id' "cmd /c hostname");                                    // add the task                                  boundJob.AddTask(unboundTask);                              }                                // first get a list with all props                              IEnumerable<CloudTask> ienumAllProps = boundJob.ListTasks();                              List<CloudTask> listAllProps = new List<CloudTask>(ienumAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<CloudTask> ienumOdd = boundJob.ListTasks(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(id' 'Odd')"' SelectClause = "id'state" });                              List<CloudTask> listOdd = new List<CloudTask>(ienumOdd);                                IEnumerable<CloudTask> ienumEven = boundJob.ListTasks(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(id' 'Even')"' SelectClause = "id'state" });                              List<CloudTask> listEven = new List<CloudTask>(ienumEven);                                // the total must equal the sum of the parts                              Assert.Equal(listOdd.Count + listEven.Count + 1 /* 1 special task from above */' listAllProps.Count);                                // confirm detail level worked                              // pick one from lower detail level and compare it to the same one from the all-props collection                                CloudTask lowerDetailTask = listOdd[0];                              CloudTask matchingAllPropsTask = null;                                // now find it in the all-props list                              foreach (CloudTask curAllPropsTask in listAllProps)                              {                                  if (curAllPropsTask.Id.Equals(lowerDetailTask.Id))                                  {                                      matchingAllPropsTask = curAllPropsTask;                                  }                              }                                // we have a matching all-props instance... compare them.                              Assert.NotNull(matchingAllPropsTask);                                // see!  detail level works!                              Assert.NotEqual(matchingAllPropsTask.CreationTime' lowerDetailTask.CreationTime);                                // now confirm that refresh will raise detail level                              lowerDetailTask.Refresh();                                // they should be the same now                              Assert.Equal(matchingAllPropsTask.CreationTime' lowerDetailTask.CreationTime);                                // now confirm that refresh + detail level can lower detail level                              matchingAllPropsTask.Refresh(detailLevel: new ODATADetailLevel() { SelectClause = "id'state" });                                // confirm lower detail level                              Assert.NotEqual(lowerDetailTask.CreationTime' matchingAllPropsTask.CreationTime);                          }                            // task files                          this.testOutputHelper.WriteLine("task file tests");                            {                              List<CloudTask> tasks = new List<CloudTask>(batchCli.JobOperations.GetJob(jobId).ListTasks());                              CloudTask task = tasks[0]; // just pick one it doesnt matter which                                //Ensure that the task has run                              TaskStateMonitor tsm = batchCli.Utilities.CreateTaskStateMonitor();                              tsm.WaitAll(new List<CloudTask> { task }' TaskState.Completed' TimeSpan.FromSeconds(20));                                // first get a list with all props                              IEnumerable<NodeFile> ienumAllProps = task.ListNodeFiles();                              List<NodeFile> listAllProps = new List<NodeFile>(ienumAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<NodeFile> ienumStd = task.ListNodeFiles(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(name' 'std')" });                              List<NodeFile> listStd = new List<NodeFile>(ienumStd);                                // assert that filtering works                              Assert.Equal(2' listStd.Count);  // stdout/stderr                              Assert.True(listAllProps.Count > listStd.Count);                                // test nodefile refresh                                NodeFile stdoutFile = null;                                // find stdout                              listStd.ForEach(x => { if (x.Path.IndexOf("stdout"' StringComparison.InvariantCultureIgnoreCase) >= 0) { stdoutFile = x; } });                                // save pre-refresh props                              FileProperties saveFilProps = stdoutFile.Properties;                                // refesh to see if the props come back                              stdoutFile.Refresh();                                NodeFile againViaList = null;                                new List<NodeFile>(task.ListNodeFiles()).ForEach(x => { if (x.Path.IndexOf("stdout"' StringComparison.InvariantCultureIgnoreCase) >= 0) { againViaList = x; } });                                //"Bug1719609ODATADetailLevel: sometimes this can fail.  check out CreateTime"                              //This fails due to different time formats used in the header vs in the body of a request.  Since we expect that this will basically never pass                              //until the bug is fixed' we assert instead on only the upper-order digits of the DateTime                                //Assert.Equal(stdoutFile.Properties.CreationTime' saveFilProps.CreationTime);                              DateTime creationTime = saveFilProps.CreationTime.Value;                              DateTime refreshedCreationTime = stdoutFile.Properties.CreationTime.Value;                                Assert.Equal(DateTimeKind.Utc' refreshedCreationTime.Kind);                                Assert.Equal(creationTime.Year' refreshedCreationTime.Year);                              Assert.Equal(creationTime.Month' refreshedCreationTime.Month);                              Assert.Equal(creationTime.Day' refreshedCreationTime.Day);                              Assert.Equal(creationTime.Hour' refreshedCreationTime.Hour);                              Assert.Equal(creationTime.Minute' refreshedCreationTime.Minute);                              Assert.Equal(creationTime.Second' refreshedCreationTime.Second);                              Assert.Equal(creationTime.Kind' refreshedCreationTime.Kind);                                //Since the low order bits are lost in the GetFile (header based respose) assert that they are 0                              Assert.Equal(0' refreshedCreationTime.Millisecond);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1719609ODATADetailLevel,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      // pools tested in Bug1770942ExposeBatchRequestProperties                      this.testOutputHelper.WriteLine("job schedule tests");                        // create a bunch of job schedules                      {                          const int numJobSchedulesToCreate = 10;                            List<string> jobScheduleIds = new List<string>();                          for (int i = 0; i < numJobSchedulesToCreate; i++)                          {                              string id;                                if (1 == (i % 2))                              {                                  id = "Odd-Bug1770942-";                              }                              else                              {                                  id = "Even-Bug1770942-";                              }                                // add my name for visibile accounting                              id += i + "-" + TestUtilities.GetMyName();                                jobScheduleIds.Add(id);                          }                            try                          {                              foreach (string jobScheduleId in jobScheduleIds)                              {                                  CloudJobSchedule unboundJobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                                  PoolInformation poolInformation = new PoolInformation();                                    poolInformation.PoolId = this.poolFixture.PoolId;                                    unboundJobSchedule.JobSpecification = new JobSpecification(poolInformation);                                    unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(5) };                                    // create the job schedule                                  unboundJobSchedule.Commit();                              }                                // first get a list of all wi's with all props                              IEnumerable<CloudJobSchedule> ienumJobScheduleAllProps = batchCli.JobScheduleOperations.ListJobSchedules();                              List<CloudJobSchedule> listAllJobScheduleProps = new List<CloudJobSchedule>(ienumJobScheduleAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<CloudJobSchedule> ienumOdd =                                  batchCli.JobScheduleOperations.ListJobSchedules(detailLevel:                                      new ODATADetailLevel() { FilterClause = "startswith(id' 'Odd')"' SelectClause = "id'state" });                              List<CloudJobSchedule> listOdd = new List<CloudJobSchedule>(ienumOdd);                                IEnumerable<CloudJobSchedule> ienumEven =                                  batchCli.JobScheduleOperations.ListJobSchedules(detailLevel:                                      new ODATADetailLevel() { FilterClause = "startswith(id' 'Even')"' SelectClause = "id'state" });                              List<CloudJobSchedule> listEven = new List<CloudJobSchedule>(ienumEven);                                // confirm detail level worked                                // pick one                              CloudJobSchedule lowDetailLevelJobSchedule = listEven[0];                              CloudJobSchedule matchingAllPropJobSchedule = null;                                // find it in the list that has full props                              foreach (CloudJobSchedule currJobSchedule in listAllJobScheduleProps)                              {                                  // found it                                  if (currJobSchedule.Id.Equals(lowDetailLevelJobSchedule.Id' StringComparison.InvariantCultureIgnoreCase))                                  {                                      matchingAllPropJobSchedule = currJobSchedule;                                        Assert.NotEqual(currJobSchedule.CreationTime' lowDetailLevelJobSchedule.CreationTime);                                  }                              }                                // confirm that a match was found                              Assert.NotNull(matchingAllPropJobSchedule);                                // confirm that detail level works on jobScheduleOperations.GetJobSchedule()                              CloudJobSchedule directGetLowDetailLevel = batchCli.JobScheduleOperations.GetJobSchedule(matchingAllPropJobSchedule.Id'                                  new ODATADetailLevel() { SelectClause = "id'state" });                                Assert.NotEqual(matchingAllPropJobSchedule.CreationTime' directGetLowDetailLevel.CreationTime);                                // confirm that detail level can be returned to normal via refresh()                              directGetLowDetailLevel.Refresh(); // no detail level returns to full properties                                Assert.Equal(matchingAllPropJobSchedule.CreationTime' directGetLowDetailLevel.CreationTime);                          }                          finally                          {                              List<Task> jobScheduleDeletions = new List<Task>();                              foreach (string id in jobScheduleIds)                              {                                  Task t = TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' id);                                  jobScheduleDeletions.Add(t);                              }                                Task.WhenAll(jobScheduleDeletions).Wait();                          }                      }                        this.testOutputHelper.WriteLine("job tests");                        // jobs                      string jobId = "Bug1770942Job-" + TestUtilities.GetMyName();                        try                      {                          {                              // create a job                              CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                              unboundJob.PoolInformation.PoolId = this.poolFixture.PoolId;                              unboundJob.Commit();                              CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                                CloudTask unboundTask = new CloudTask("Bug1770942Taskname"' "hostname");                              boundJob.AddTask(unboundTask);                                string filterString = string.Format("startswith(id' '{0}')"' jobId);                                // first get a list with all props                              IEnumerable<CloudJob> ienumAllProps = batchCli.JobOperations.ListJobs(detailLevel: new ODATADetailLevel(){ FilterClause = filterString });                              List<CloudJob> listAllProps = new List<CloudJob>(ienumAllProps);                                // get list using lower Detail Level.  choose a predicate that will return no jobs since there is only the one :(                              IEnumerable<CloudJob> iEnumFewerProps = batchCli.JobOperations.ListJobs(detailLevel: new ODATADetailLevel() { SelectClause = "id'state"' FilterClause = filterString });                              List<CloudJob> listFewerProps = new List<CloudJob>(iEnumFewerProps);                                // the total must equal the sum of the parts                              Assert.Equal(listFewerProps.Count' listAllProps.Count);                                // confirm detail level worked                                // get the low detail level object                              CloudJob lowDetailLevel = listFewerProps.Single();                                // yes its the same and only                              Assert.Equal(listAllProps[0].Id' lowDetailLevel.Id);                                // confirm detail levels different                              Assert.NotEqual(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                                // confirm detail level returned to normal via refresh                              lowDetailLevel.Refresh();                                // now they both have all props                              Assert.Equal(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                                // confirm refresh can lower detail level                              lowDetailLevel = batchCli.JobOperations.GetJob(lowDetailLevel.Id);  // cant refresh 2 times or more because that pesky bug on refresh                              Assert.Equal(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);  // so all props are loaded                                // refresh and lower DL                              lowDetailLevel.Refresh(detailLevel: new ODATADetailLevel() { SelectClause = "id'state" });                                // now they must be different                              Assert.NotEqual(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                          }                            this.testOutputHelper.WriteLine("task tests");                            // tasks                          {                              // push tasks to this job                              CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                                // add a bunch of tasks                              const int numToCreate = 10;                                for (int i = 0; i < numToCreate; i++)                              {                                  string id;                                    if (1 == (i % 2))                                  {                                      id = "Odd-Bug1770942-";                                  }                                  else                                  {                                      id = "Even-Bug1770942-";                                  }                                    // add my name for visibile accounting                                  id += i + "-" + TestUtilities.GetMyName();                                    CloudTask unboundTask = new CloudTask(id' "cmd /c hostname");                                    // add the task                                  boundJob.AddTask(unboundTask);                              }                                // first get a list with all props                              IEnumerable<CloudTask> ienumAllProps = boundJob.ListTasks();                              List<CloudTask> listAllProps = new List<CloudTask>(ienumAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<CloudTask> ienumOdd = boundJob.ListTasks(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(id' 'Odd')"' SelectClause = "id'state" });                              List<CloudTask> listOdd = new List<CloudTask>(ienumOdd);                                IEnumerable<CloudTask> ienumEven = boundJob.ListTasks(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(id' 'Even')"' SelectClause = "id'state" });                              List<CloudTask> listEven = new List<CloudTask>(ienumEven);                                // the total must equal the sum of the parts                              Assert.Equal(listOdd.Count + listEven.Count + 1 /* 1 special task from above */' listAllProps.Count);                                // confirm detail level worked                              // pick one from lower detail level and compare it to the same one from the all-props collection                                CloudTask lowerDetailTask = listOdd[0];                              CloudTask matchingAllPropsTask = null;                                // now find it in the all-props list                              foreach (CloudTask curAllPropsTask in listAllProps)                              {                                  if (curAllPropsTask.Id.Equals(lowerDetailTask.Id))                                  {                                      matchingAllPropsTask = curAllPropsTask;                                  }                              }                                // we have a matching all-props instance... compare them.                              Assert.NotNull(matchingAllPropsTask);                                // see!  detail level works!                              Assert.NotEqual(matchingAllPropsTask.CreationTime' lowerDetailTask.CreationTime);                                // now confirm that refresh will raise detail level                              lowerDetailTask.Refresh();                                // they should be the same now                              Assert.Equal(matchingAllPropsTask.CreationTime' lowerDetailTask.CreationTime);                                // now confirm that refresh + detail level can lower detail level                              matchingAllPropsTask.Refresh(detailLevel: new ODATADetailLevel() { SelectClause = "id'state" });                                // confirm lower detail level                              Assert.NotEqual(lowerDetailTask.CreationTime' matchingAllPropsTask.CreationTime);                          }                            // task files                          this.testOutputHelper.WriteLine("task file tests");                            {                              List<CloudTask> tasks = new List<CloudTask>(batchCli.JobOperations.GetJob(jobId).ListTasks());                              CloudTask task = tasks[0]; // just pick one it doesnt matter which                                //Ensure that the task has run                              TaskStateMonitor tsm = batchCli.Utilities.CreateTaskStateMonitor();                              tsm.WaitAll(new List<CloudTask> { task }' TaskState.Completed' TimeSpan.FromSeconds(20));                                // first get a list with all props                              IEnumerable<NodeFile> ienumAllProps = task.ListNodeFiles();                              List<NodeFile> listAllProps = new List<NodeFile>(ienumAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<NodeFile> ienumStd = task.ListNodeFiles(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(name' 'std')" });                              List<NodeFile> listStd = new List<NodeFile>(ienumStd);                                // assert that filtering works                              Assert.Equal(2' listStd.Count);  // stdout/stderr                              Assert.True(listAllProps.Count > listStd.Count);                                // test nodefile refresh                                NodeFile stdoutFile = null;                                // find stdout                              listStd.ForEach(x => { if (x.Path.IndexOf("stdout"' StringComparison.InvariantCultureIgnoreCase) >= 0) { stdoutFile = x; } });                                // save pre-refresh props                              FileProperties saveFilProps = stdoutFile.Properties;                                // refesh to see if the props come back                              stdoutFile.Refresh();                                NodeFile againViaList = null;                                new List<NodeFile>(task.ListNodeFiles()).ForEach(x => { if (x.Path.IndexOf("stdout"' StringComparison.InvariantCultureIgnoreCase) >= 0) { againViaList = x; } });                                //"Bug1719609ODATADetailLevel: sometimes this can fail.  check out CreateTime"                              //This fails due to different time formats used in the header vs in the body of a request.  Since we expect that this will basically never pass                              //until the bug is fixed' we assert instead on only the upper-order digits of the DateTime                                //Assert.Equal(stdoutFile.Properties.CreationTime' saveFilProps.CreationTime);                              DateTime creationTime = saveFilProps.CreationTime.Value;                              DateTime refreshedCreationTime = stdoutFile.Properties.CreationTime.Value;                                Assert.Equal(DateTimeKind.Utc' refreshedCreationTime.Kind);                                Assert.Equal(creationTime.Year' refreshedCreationTime.Year);                              Assert.Equal(creationTime.Month' refreshedCreationTime.Month);                              Assert.Equal(creationTime.Day' refreshedCreationTime.Day);                              Assert.Equal(creationTime.Hour' refreshedCreationTime.Hour);                              Assert.Equal(creationTime.Minute' refreshedCreationTime.Minute);                              Assert.Equal(creationTime.Second' refreshedCreationTime.Second);                              Assert.Equal(creationTime.Kind' refreshedCreationTime.Kind);                                //Since the low order bits are lost in the GetFile (header based respose) assert that they are 0                              Assert.Equal(0' refreshedCreationTime.Millisecond);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1719609ODATADetailLevel,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      // pools tested in Bug1770942ExposeBatchRequestProperties                      this.testOutputHelper.WriteLine("job schedule tests");                        // create a bunch of job schedules                      {                          const int numJobSchedulesToCreate = 10;                            List<string> jobScheduleIds = new List<string>();                          for (int i = 0; i < numJobSchedulesToCreate; i++)                          {                              string id;                                if (1 == (i % 2))                              {                                  id = "Odd-Bug1770942-";                              }                              else                              {                                  id = "Even-Bug1770942-";                              }                                // add my name for visibile accounting                              id += i + "-" + TestUtilities.GetMyName();                                jobScheduleIds.Add(id);                          }                            try                          {                              foreach (string jobScheduleId in jobScheduleIds)                              {                                  CloudJobSchedule unboundJobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                                  PoolInformation poolInformation = new PoolInformation();                                    poolInformation.PoolId = this.poolFixture.PoolId;                                    unboundJobSchedule.JobSpecification = new JobSpecification(poolInformation);                                    unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(5) };                                    // create the job schedule                                  unboundJobSchedule.Commit();                              }                                // first get a list of all wi's with all props                              IEnumerable<CloudJobSchedule> ienumJobScheduleAllProps = batchCli.JobScheduleOperations.ListJobSchedules();                              List<CloudJobSchedule> listAllJobScheduleProps = new List<CloudJobSchedule>(ienumJobScheduleAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<CloudJobSchedule> ienumOdd =                                  batchCli.JobScheduleOperations.ListJobSchedules(detailLevel:                                      new ODATADetailLevel() { FilterClause = "startswith(id' 'Odd')"' SelectClause = "id'state" });                              List<CloudJobSchedule> listOdd = new List<CloudJobSchedule>(ienumOdd);                                IEnumerable<CloudJobSchedule> ienumEven =                                  batchCli.JobScheduleOperations.ListJobSchedules(detailLevel:                                      new ODATADetailLevel() { FilterClause = "startswith(id' 'Even')"' SelectClause = "id'state" });                              List<CloudJobSchedule> listEven = new List<CloudJobSchedule>(ienumEven);                                // confirm detail level worked                                // pick one                              CloudJobSchedule lowDetailLevelJobSchedule = listEven[0];                              CloudJobSchedule matchingAllPropJobSchedule = null;                                // find it in the list that has full props                              foreach (CloudJobSchedule currJobSchedule in listAllJobScheduleProps)                              {                                  // found it                                  if (currJobSchedule.Id.Equals(lowDetailLevelJobSchedule.Id' StringComparison.InvariantCultureIgnoreCase))                                  {                                      matchingAllPropJobSchedule = currJobSchedule;                                        Assert.NotEqual(currJobSchedule.CreationTime' lowDetailLevelJobSchedule.CreationTime);                                  }                              }                                // confirm that a match was found                              Assert.NotNull(matchingAllPropJobSchedule);                                // confirm that detail level works on jobScheduleOperations.GetJobSchedule()                              CloudJobSchedule directGetLowDetailLevel = batchCli.JobScheduleOperations.GetJobSchedule(matchingAllPropJobSchedule.Id'                                  new ODATADetailLevel() { SelectClause = "id'state" });                                Assert.NotEqual(matchingAllPropJobSchedule.CreationTime' directGetLowDetailLevel.CreationTime);                                // confirm that detail level can be returned to normal via refresh()                              directGetLowDetailLevel.Refresh(); // no detail level returns to full properties                                Assert.Equal(matchingAllPropJobSchedule.CreationTime' directGetLowDetailLevel.CreationTime);                          }                          finally                          {                              List<Task> jobScheduleDeletions = new List<Task>();                              foreach (string id in jobScheduleIds)                              {                                  Task t = TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' id);                                  jobScheduleDeletions.Add(t);                              }                                Task.WhenAll(jobScheduleDeletions).Wait();                          }                      }                        this.testOutputHelper.WriteLine("job tests");                        // jobs                      string jobId = "Bug1770942Job-" + TestUtilities.GetMyName();                        try                      {                          {                              // create a job                              CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                              unboundJob.PoolInformation.PoolId = this.poolFixture.PoolId;                              unboundJob.Commit();                              CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                                CloudTask unboundTask = new CloudTask("Bug1770942Taskname"' "hostname");                              boundJob.AddTask(unboundTask);                                string filterString = string.Format("startswith(id' '{0}')"' jobId);                                // first get a list with all props                              IEnumerable<CloudJob> ienumAllProps = batchCli.JobOperations.ListJobs(detailLevel: new ODATADetailLevel(){ FilterClause = filterString });                              List<CloudJob> listAllProps = new List<CloudJob>(ienumAllProps);                                // get list using lower Detail Level.  choose a predicate that will return no jobs since there is only the one :(                              IEnumerable<CloudJob> iEnumFewerProps = batchCli.JobOperations.ListJobs(detailLevel: new ODATADetailLevel() { SelectClause = "id'state"' FilterClause = filterString });                              List<CloudJob> listFewerProps = new List<CloudJob>(iEnumFewerProps);                                // the total must equal the sum of the parts                              Assert.Equal(listFewerProps.Count' listAllProps.Count);                                // confirm detail level worked                                // get the low detail level object                              CloudJob lowDetailLevel = listFewerProps.Single();                                // yes its the same and only                              Assert.Equal(listAllProps[0].Id' lowDetailLevel.Id);                                // confirm detail levels different                              Assert.NotEqual(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                                // confirm detail level returned to normal via refresh                              lowDetailLevel.Refresh();                                // now they both have all props                              Assert.Equal(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                                // confirm refresh can lower detail level                              lowDetailLevel = batchCli.JobOperations.GetJob(lowDetailLevel.Id);  // cant refresh 2 times or more because that pesky bug on refresh                              Assert.Equal(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);  // so all props are loaded                                // refresh and lower DL                              lowDetailLevel.Refresh(detailLevel: new ODATADetailLevel() { SelectClause = "id'state" });                                // now they must be different                              Assert.NotEqual(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                          }                            this.testOutputHelper.WriteLine("task tests");                            // tasks                          {                              // push tasks to this job                              CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                                // add a bunch of tasks                              const int numToCreate = 10;                                for (int i = 0; i < numToCreate; i++)                              {                                  string id;                                    if (1 == (i % 2))                                  {                                      id = "Odd-Bug1770942-";                                  }                                  else                                  {                                      id = "Even-Bug1770942-";                                  }                                    // add my name for visibile accounting                                  id += i + "-" + TestUtilities.GetMyName();                                    CloudTask unboundTask = new CloudTask(id' "cmd /c hostname");                                    // add the task                                  boundJob.AddTask(unboundTask);                              }                                // first get a list with all props                              IEnumerable<CloudTask> ienumAllProps = boundJob.ListTasks();                              List<CloudTask> listAllProps = new List<CloudTask>(ienumAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<CloudTask> ienumOdd = boundJob.ListTasks(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(id' 'Odd')"' SelectClause = "id'state" });                              List<CloudTask> listOdd = new List<CloudTask>(ienumOdd);                                IEnumerable<CloudTask> ienumEven = boundJob.ListTasks(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(id' 'Even')"' SelectClause = "id'state" });                              List<CloudTask> listEven = new List<CloudTask>(ienumEven);                                // the total must equal the sum of the parts                              Assert.Equal(listOdd.Count + listEven.Count + 1 /* 1 special task from above */' listAllProps.Count);                                // confirm detail level worked                              // pick one from lower detail level and compare it to the same one from the all-props collection                                CloudTask lowerDetailTask = listOdd[0];                              CloudTask matchingAllPropsTask = null;                                // now find it in the all-props list                              foreach (CloudTask curAllPropsTask in listAllProps)                              {                                  if (curAllPropsTask.Id.Equals(lowerDetailTask.Id))                                  {                                      matchingAllPropsTask = curAllPropsTask;                                  }                              }                                // we have a matching all-props instance... compare them.                              Assert.NotNull(matchingAllPropsTask);                                // see!  detail level works!                              Assert.NotEqual(matchingAllPropsTask.CreationTime' lowerDetailTask.CreationTime);                                // now confirm that refresh will raise detail level                              lowerDetailTask.Refresh();                                // they should be the same now                              Assert.Equal(matchingAllPropsTask.CreationTime' lowerDetailTask.CreationTime);                                // now confirm that refresh + detail level can lower detail level                              matchingAllPropsTask.Refresh(detailLevel: new ODATADetailLevel() { SelectClause = "id'state" });                                // confirm lower detail level                              Assert.NotEqual(lowerDetailTask.CreationTime' matchingAllPropsTask.CreationTime);                          }                            // task files                          this.testOutputHelper.WriteLine("task file tests");                            {                              List<CloudTask> tasks = new List<CloudTask>(batchCli.JobOperations.GetJob(jobId).ListTasks());                              CloudTask task = tasks[0]; // just pick one it doesnt matter which                                //Ensure that the task has run                              TaskStateMonitor tsm = batchCli.Utilities.CreateTaskStateMonitor();                              tsm.WaitAll(new List<CloudTask> { task }' TaskState.Completed' TimeSpan.FromSeconds(20));                                // first get a list with all props                              IEnumerable<NodeFile> ienumAllProps = task.ListNodeFiles();                              List<NodeFile> listAllProps = new List<NodeFile>(ienumAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<NodeFile> ienumStd = task.ListNodeFiles(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(name' 'std')" });                              List<NodeFile> listStd = new List<NodeFile>(ienumStd);                                // assert that filtering works                              Assert.Equal(2' listStd.Count);  // stdout/stderr                              Assert.True(listAllProps.Count > listStd.Count);                                // test nodefile refresh                                NodeFile stdoutFile = null;                                // find stdout                              listStd.ForEach(x => { if (x.Path.IndexOf("stdout"' StringComparison.InvariantCultureIgnoreCase) >= 0) { stdoutFile = x; } });                                // save pre-refresh props                              FileProperties saveFilProps = stdoutFile.Properties;                                // refesh to see if the props come back                              stdoutFile.Refresh();                                NodeFile againViaList = null;                                new List<NodeFile>(task.ListNodeFiles()).ForEach(x => { if (x.Path.IndexOf("stdout"' StringComparison.InvariantCultureIgnoreCase) >= 0) { againViaList = x; } });                                //"Bug1719609ODATADetailLevel: sometimes this can fail.  check out CreateTime"                              //This fails due to different time formats used in the header vs in the body of a request.  Since we expect that this will basically never pass                              //until the bug is fixed' we assert instead on only the upper-order digits of the DateTime                                //Assert.Equal(stdoutFile.Properties.CreationTime' saveFilProps.CreationTime);                              DateTime creationTime = saveFilProps.CreationTime.Value;                              DateTime refreshedCreationTime = stdoutFile.Properties.CreationTime.Value;                                Assert.Equal(DateTimeKind.Utc' refreshedCreationTime.Kind);                                Assert.Equal(creationTime.Year' refreshedCreationTime.Year);                              Assert.Equal(creationTime.Month' refreshedCreationTime.Month);                              Assert.Equal(creationTime.Day' refreshedCreationTime.Day);                              Assert.Equal(creationTime.Hour' refreshedCreationTime.Hour);                              Assert.Equal(creationTime.Minute' refreshedCreationTime.Minute);                              Assert.Equal(creationTime.Second' refreshedCreationTime.Second);                              Assert.Equal(creationTime.Kind' refreshedCreationTime.Kind);                                //Since the low order bits are lost in the GetFile (header based respose) assert that they are 0                              Assert.Equal(0' refreshedCreationTime.Millisecond);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1719609ODATADetailLevel,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      // pools tested in Bug1770942ExposeBatchRequestProperties                      this.testOutputHelper.WriteLine("job schedule tests");                        // create a bunch of job schedules                      {                          const int numJobSchedulesToCreate = 10;                            List<string> jobScheduleIds = new List<string>();                          for (int i = 0; i < numJobSchedulesToCreate; i++)                          {                              string id;                                if (1 == (i % 2))                              {                                  id = "Odd-Bug1770942-";                              }                              else                              {                                  id = "Even-Bug1770942-";                              }                                // add my name for visibile accounting                              id += i + "-" + TestUtilities.GetMyName();                                jobScheduleIds.Add(id);                          }                            try                          {                              foreach (string jobScheduleId in jobScheduleIds)                              {                                  CloudJobSchedule unboundJobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                                  PoolInformation poolInformation = new PoolInformation();                                    poolInformation.PoolId = this.poolFixture.PoolId;                                    unboundJobSchedule.JobSpecification = new JobSpecification(poolInformation);                                    unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(5) };                                    // create the job schedule                                  unboundJobSchedule.Commit();                              }                                // first get a list of all wi's with all props                              IEnumerable<CloudJobSchedule> ienumJobScheduleAllProps = batchCli.JobScheduleOperations.ListJobSchedules();                              List<CloudJobSchedule> listAllJobScheduleProps = new List<CloudJobSchedule>(ienumJobScheduleAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<CloudJobSchedule> ienumOdd =                                  batchCli.JobScheduleOperations.ListJobSchedules(detailLevel:                                      new ODATADetailLevel() { FilterClause = "startswith(id' 'Odd')"' SelectClause = "id'state" });                              List<CloudJobSchedule> listOdd = new List<CloudJobSchedule>(ienumOdd);                                IEnumerable<CloudJobSchedule> ienumEven =                                  batchCli.JobScheduleOperations.ListJobSchedules(detailLevel:                                      new ODATADetailLevel() { FilterClause = "startswith(id' 'Even')"' SelectClause = "id'state" });                              List<CloudJobSchedule> listEven = new List<CloudJobSchedule>(ienumEven);                                // confirm detail level worked                                // pick one                              CloudJobSchedule lowDetailLevelJobSchedule = listEven[0];                              CloudJobSchedule matchingAllPropJobSchedule = null;                                // find it in the list that has full props                              foreach (CloudJobSchedule currJobSchedule in listAllJobScheduleProps)                              {                                  // found it                                  if (currJobSchedule.Id.Equals(lowDetailLevelJobSchedule.Id' StringComparison.InvariantCultureIgnoreCase))                                  {                                      matchingAllPropJobSchedule = currJobSchedule;                                        Assert.NotEqual(currJobSchedule.CreationTime' lowDetailLevelJobSchedule.CreationTime);                                  }                              }                                // confirm that a match was found                              Assert.NotNull(matchingAllPropJobSchedule);                                // confirm that detail level works on jobScheduleOperations.GetJobSchedule()                              CloudJobSchedule directGetLowDetailLevel = batchCli.JobScheduleOperations.GetJobSchedule(matchingAllPropJobSchedule.Id'                                  new ODATADetailLevel() { SelectClause = "id'state" });                                Assert.NotEqual(matchingAllPropJobSchedule.CreationTime' directGetLowDetailLevel.CreationTime);                                // confirm that detail level can be returned to normal via refresh()                              directGetLowDetailLevel.Refresh(); // no detail level returns to full properties                                Assert.Equal(matchingAllPropJobSchedule.CreationTime' directGetLowDetailLevel.CreationTime);                          }                          finally                          {                              List<Task> jobScheduleDeletions = new List<Task>();                              foreach (string id in jobScheduleIds)                              {                                  Task t = TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' id);                                  jobScheduleDeletions.Add(t);                              }                                Task.WhenAll(jobScheduleDeletions).Wait();                          }                      }                        this.testOutputHelper.WriteLine("job tests");                        // jobs                      string jobId = "Bug1770942Job-" + TestUtilities.GetMyName();                        try                      {                          {                              // create a job                              CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                              unboundJob.PoolInformation.PoolId = this.poolFixture.PoolId;                              unboundJob.Commit();                              CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                                CloudTask unboundTask = new CloudTask("Bug1770942Taskname"' "hostname");                              boundJob.AddTask(unboundTask);                                string filterString = string.Format("startswith(id' '{0}')"' jobId);                                // first get a list with all props                              IEnumerable<CloudJob> ienumAllProps = batchCli.JobOperations.ListJobs(detailLevel: new ODATADetailLevel(){ FilterClause = filterString });                              List<CloudJob> listAllProps = new List<CloudJob>(ienumAllProps);                                // get list using lower Detail Level.  choose a predicate that will return no jobs since there is only the one :(                              IEnumerable<CloudJob> iEnumFewerProps = batchCli.JobOperations.ListJobs(detailLevel: new ODATADetailLevel() { SelectClause = "id'state"' FilterClause = filterString });                              List<CloudJob> listFewerProps = new List<CloudJob>(iEnumFewerProps);                                // the total must equal the sum of the parts                              Assert.Equal(listFewerProps.Count' listAllProps.Count);                                // confirm detail level worked                                // get the low detail level object                              CloudJob lowDetailLevel = listFewerProps.Single();                                // yes its the same and only                              Assert.Equal(listAllProps[0].Id' lowDetailLevel.Id);                                // confirm detail levels different                              Assert.NotEqual(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                                // confirm detail level returned to normal via refresh                              lowDetailLevel.Refresh();                                // now they both have all props                              Assert.Equal(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                                // confirm refresh can lower detail level                              lowDetailLevel = batchCli.JobOperations.GetJob(lowDetailLevel.Id);  // cant refresh 2 times or more because that pesky bug on refresh                              Assert.Equal(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);  // so all props are loaded                                // refresh and lower DL                              lowDetailLevel.Refresh(detailLevel: new ODATADetailLevel() { SelectClause = "id'state" });                                // now they must be different                              Assert.NotEqual(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                          }                            this.testOutputHelper.WriteLine("task tests");                            // tasks                          {                              // push tasks to this job                              CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                                // add a bunch of tasks                              const int numToCreate = 10;                                for (int i = 0; i < numToCreate; i++)                              {                                  string id;                                    if (1 == (i % 2))                                  {                                      id = "Odd-Bug1770942-";                                  }                                  else                                  {                                      id = "Even-Bug1770942-";                                  }                                    // add my name for visibile accounting                                  id += i + "-" + TestUtilities.GetMyName();                                    CloudTask unboundTask = new CloudTask(id' "cmd /c hostname");                                    // add the task                                  boundJob.AddTask(unboundTask);                              }                                // first get a list with all props                              IEnumerable<CloudTask> ienumAllProps = boundJob.ListTasks();                              List<CloudTask> listAllProps = new List<CloudTask>(ienumAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<CloudTask> ienumOdd = boundJob.ListTasks(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(id' 'Odd')"' SelectClause = "id'state" });                              List<CloudTask> listOdd = new List<CloudTask>(ienumOdd);                                IEnumerable<CloudTask> ienumEven = boundJob.ListTasks(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(id' 'Even')"' SelectClause = "id'state" });                              List<CloudTask> listEven = new List<CloudTask>(ienumEven);                                // the total must equal the sum of the parts                              Assert.Equal(listOdd.Count + listEven.Count + 1 /* 1 special task from above */' listAllProps.Count);                                // confirm detail level worked                              // pick one from lower detail level and compare it to the same one from the all-props collection                                CloudTask lowerDetailTask = listOdd[0];                              CloudTask matchingAllPropsTask = null;                                // now find it in the all-props list                              foreach (CloudTask curAllPropsTask in listAllProps)                              {                                  if (curAllPropsTask.Id.Equals(lowerDetailTask.Id))                                  {                                      matchingAllPropsTask = curAllPropsTask;                                  }                              }                                // we have a matching all-props instance... compare them.                              Assert.NotNull(matchingAllPropsTask);                                // see!  detail level works!                              Assert.NotEqual(matchingAllPropsTask.CreationTime' lowerDetailTask.CreationTime);                                // now confirm that refresh will raise detail level                              lowerDetailTask.Refresh();                                // they should be the same now                              Assert.Equal(matchingAllPropsTask.CreationTime' lowerDetailTask.CreationTime);                                // now confirm that refresh + detail level can lower detail level                              matchingAllPropsTask.Refresh(detailLevel: new ODATADetailLevel() { SelectClause = "id'state" });                                // confirm lower detail level                              Assert.NotEqual(lowerDetailTask.CreationTime' matchingAllPropsTask.CreationTime);                          }                            // task files                          this.testOutputHelper.WriteLine("task file tests");                            {                              List<CloudTask> tasks = new List<CloudTask>(batchCli.JobOperations.GetJob(jobId).ListTasks());                              CloudTask task = tasks[0]; // just pick one it doesnt matter which                                //Ensure that the task has run                              TaskStateMonitor tsm = batchCli.Utilities.CreateTaskStateMonitor();                              tsm.WaitAll(new List<CloudTask> { task }' TaskState.Completed' TimeSpan.FromSeconds(20));                                // first get a list with all props                              IEnumerable<NodeFile> ienumAllProps = task.ListNodeFiles();                              List<NodeFile> listAllProps = new List<NodeFile>(ienumAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<NodeFile> ienumStd = task.ListNodeFiles(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(name' 'std')" });                              List<NodeFile> listStd = new List<NodeFile>(ienumStd);                                // assert that filtering works                              Assert.Equal(2' listStd.Count);  // stdout/stderr                              Assert.True(listAllProps.Count > listStd.Count);                                // test nodefile refresh                                NodeFile stdoutFile = null;                                // find stdout                              listStd.ForEach(x => { if (x.Path.IndexOf("stdout"' StringComparison.InvariantCultureIgnoreCase) >= 0) { stdoutFile = x; } });                                // save pre-refresh props                              FileProperties saveFilProps = stdoutFile.Properties;                                // refesh to see if the props come back                              stdoutFile.Refresh();                                NodeFile againViaList = null;                                new List<NodeFile>(task.ListNodeFiles()).ForEach(x => { if (x.Path.IndexOf("stdout"' StringComparison.InvariantCultureIgnoreCase) >= 0) { againViaList = x; } });                                //"Bug1719609ODATADetailLevel: sometimes this can fail.  check out CreateTime"                              //This fails due to different time formats used in the header vs in the body of a request.  Since we expect that this will basically never pass                              //until the bug is fixed' we assert instead on only the upper-order digits of the DateTime                                //Assert.Equal(stdoutFile.Properties.CreationTime' saveFilProps.CreationTime);                              DateTime creationTime = saveFilProps.CreationTime.Value;                              DateTime refreshedCreationTime = stdoutFile.Properties.CreationTime.Value;                                Assert.Equal(DateTimeKind.Utc' refreshedCreationTime.Kind);                                Assert.Equal(creationTime.Year' refreshedCreationTime.Year);                              Assert.Equal(creationTime.Month' refreshedCreationTime.Month);                              Assert.Equal(creationTime.Day' refreshedCreationTime.Day);                              Assert.Equal(creationTime.Hour' refreshedCreationTime.Hour);                              Assert.Equal(creationTime.Minute' refreshedCreationTime.Minute);                              Assert.Equal(creationTime.Second' refreshedCreationTime.Second);                              Assert.Equal(creationTime.Kind' refreshedCreationTime.Kind);                                //Since the low order bits are lost in the GetFile (header based respose) assert that they are 0                              Assert.Equal(0' refreshedCreationTime.Millisecond);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1719609ODATADetailLevel,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      // pools tested in Bug1770942ExposeBatchRequestProperties                      this.testOutputHelper.WriteLine("job schedule tests");                        // create a bunch of job schedules                      {                          const int numJobSchedulesToCreate = 10;                            List<string> jobScheduleIds = new List<string>();                          for (int i = 0; i < numJobSchedulesToCreate; i++)                          {                              string id;                                if (1 == (i % 2))                              {                                  id = "Odd-Bug1770942-";                              }                              else                              {                                  id = "Even-Bug1770942-";                              }                                // add my name for visibile accounting                              id += i + "-" + TestUtilities.GetMyName();                                jobScheduleIds.Add(id);                          }                            try                          {                              foreach (string jobScheduleId in jobScheduleIds)                              {                                  CloudJobSchedule unboundJobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                                  PoolInformation poolInformation = new PoolInformation();                                    poolInformation.PoolId = this.poolFixture.PoolId;                                    unboundJobSchedule.JobSpecification = new JobSpecification(poolInformation);                                    unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(5) };                                    // create the job schedule                                  unboundJobSchedule.Commit();                              }                                // first get a list of all wi's with all props                              IEnumerable<CloudJobSchedule> ienumJobScheduleAllProps = batchCli.JobScheduleOperations.ListJobSchedules();                              List<CloudJobSchedule> listAllJobScheduleProps = new List<CloudJobSchedule>(ienumJobScheduleAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<CloudJobSchedule> ienumOdd =                                  batchCli.JobScheduleOperations.ListJobSchedules(detailLevel:                                      new ODATADetailLevel() { FilterClause = "startswith(id' 'Odd')"' SelectClause = "id'state" });                              List<CloudJobSchedule> listOdd = new List<CloudJobSchedule>(ienumOdd);                                IEnumerable<CloudJobSchedule> ienumEven =                                  batchCli.JobScheduleOperations.ListJobSchedules(detailLevel:                                      new ODATADetailLevel() { FilterClause = "startswith(id' 'Even')"' SelectClause = "id'state" });                              List<CloudJobSchedule> listEven = new List<CloudJobSchedule>(ienumEven);                                // confirm detail level worked                                // pick one                              CloudJobSchedule lowDetailLevelJobSchedule = listEven[0];                              CloudJobSchedule matchingAllPropJobSchedule = null;                                // find it in the list that has full props                              foreach (CloudJobSchedule currJobSchedule in listAllJobScheduleProps)                              {                                  // found it                                  if (currJobSchedule.Id.Equals(lowDetailLevelJobSchedule.Id' StringComparison.InvariantCultureIgnoreCase))                                  {                                      matchingAllPropJobSchedule = currJobSchedule;                                        Assert.NotEqual(currJobSchedule.CreationTime' lowDetailLevelJobSchedule.CreationTime);                                  }                              }                                // confirm that a match was found                              Assert.NotNull(matchingAllPropJobSchedule);                                // confirm that detail level works on jobScheduleOperations.GetJobSchedule()                              CloudJobSchedule directGetLowDetailLevel = batchCli.JobScheduleOperations.GetJobSchedule(matchingAllPropJobSchedule.Id'                                  new ODATADetailLevel() { SelectClause = "id'state" });                                Assert.NotEqual(matchingAllPropJobSchedule.CreationTime' directGetLowDetailLevel.CreationTime);                                // confirm that detail level can be returned to normal via refresh()                              directGetLowDetailLevel.Refresh(); // no detail level returns to full properties                                Assert.Equal(matchingAllPropJobSchedule.CreationTime' directGetLowDetailLevel.CreationTime);                          }                          finally                          {                              List<Task> jobScheduleDeletions = new List<Task>();                              foreach (string id in jobScheduleIds)                              {                                  Task t = TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' id);                                  jobScheduleDeletions.Add(t);                              }                                Task.WhenAll(jobScheduleDeletions).Wait();                          }                      }                        this.testOutputHelper.WriteLine("job tests");                        // jobs                      string jobId = "Bug1770942Job-" + TestUtilities.GetMyName();                        try                      {                          {                              // create a job                              CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                              unboundJob.PoolInformation.PoolId = this.poolFixture.PoolId;                              unboundJob.Commit();                              CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                                CloudTask unboundTask = new CloudTask("Bug1770942Taskname"' "hostname");                              boundJob.AddTask(unboundTask);                                string filterString = string.Format("startswith(id' '{0}')"' jobId);                                // first get a list with all props                              IEnumerable<CloudJob> ienumAllProps = batchCli.JobOperations.ListJobs(detailLevel: new ODATADetailLevel(){ FilterClause = filterString });                              List<CloudJob> listAllProps = new List<CloudJob>(ienumAllProps);                                // get list using lower Detail Level.  choose a predicate that will return no jobs since there is only the one :(                              IEnumerable<CloudJob> iEnumFewerProps = batchCli.JobOperations.ListJobs(detailLevel: new ODATADetailLevel() { SelectClause = "id'state"' FilterClause = filterString });                              List<CloudJob> listFewerProps = new List<CloudJob>(iEnumFewerProps);                                // the total must equal the sum of the parts                              Assert.Equal(listFewerProps.Count' listAllProps.Count);                                // confirm detail level worked                                // get the low detail level object                              CloudJob lowDetailLevel = listFewerProps.Single();                                // yes its the same and only                              Assert.Equal(listAllProps[0].Id' lowDetailLevel.Id);                                // confirm detail levels different                              Assert.NotEqual(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                                // confirm detail level returned to normal via refresh                              lowDetailLevel.Refresh();                                // now they both have all props                              Assert.Equal(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                                // confirm refresh can lower detail level                              lowDetailLevel = batchCli.JobOperations.GetJob(lowDetailLevel.Id);  // cant refresh 2 times or more because that pesky bug on refresh                              Assert.Equal(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);  // so all props are loaded                                // refresh and lower DL                              lowDetailLevel.Refresh(detailLevel: new ODATADetailLevel() { SelectClause = "id'state" });                                // now they must be different                              Assert.NotEqual(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                          }                            this.testOutputHelper.WriteLine("task tests");                            // tasks                          {                              // push tasks to this job                              CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                                // add a bunch of tasks                              const int numToCreate = 10;                                for (int i = 0; i < numToCreate; i++)                              {                                  string id;                                    if (1 == (i % 2))                                  {                                      id = "Odd-Bug1770942-";                                  }                                  else                                  {                                      id = "Even-Bug1770942-";                                  }                                    // add my name for visibile accounting                                  id += i + "-" + TestUtilities.GetMyName();                                    CloudTask unboundTask = new CloudTask(id' "cmd /c hostname");                                    // add the task                                  boundJob.AddTask(unboundTask);                              }                                // first get a list with all props                              IEnumerable<CloudTask> ienumAllProps = boundJob.ListTasks();                              List<CloudTask> listAllProps = new List<CloudTask>(ienumAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<CloudTask> ienumOdd = boundJob.ListTasks(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(id' 'Odd')"' SelectClause = "id'state" });                              List<CloudTask> listOdd = new List<CloudTask>(ienumOdd);                                IEnumerable<CloudTask> ienumEven = boundJob.ListTasks(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(id' 'Even')"' SelectClause = "id'state" });                              List<CloudTask> listEven = new List<CloudTask>(ienumEven);                                // the total must equal the sum of the parts                              Assert.Equal(listOdd.Count + listEven.Count + 1 /* 1 special task from above */' listAllProps.Count);                                // confirm detail level worked                              // pick one from lower detail level and compare it to the same one from the all-props collection                                CloudTask lowerDetailTask = listOdd[0];                              CloudTask matchingAllPropsTask = null;                                // now find it in the all-props list                              foreach (CloudTask curAllPropsTask in listAllProps)                              {                                  if (curAllPropsTask.Id.Equals(lowerDetailTask.Id))                                  {                                      matchingAllPropsTask = curAllPropsTask;                                  }                              }                                // we have a matching all-props instance... compare them.                              Assert.NotNull(matchingAllPropsTask);                                // see!  detail level works!                              Assert.NotEqual(matchingAllPropsTask.CreationTime' lowerDetailTask.CreationTime);                                // now confirm that refresh will raise detail level                              lowerDetailTask.Refresh();                                // they should be the same now                              Assert.Equal(matchingAllPropsTask.CreationTime' lowerDetailTask.CreationTime);                                // now confirm that refresh + detail level can lower detail level                              matchingAllPropsTask.Refresh(detailLevel: new ODATADetailLevel() { SelectClause = "id'state" });                                // confirm lower detail level                              Assert.NotEqual(lowerDetailTask.CreationTime' matchingAllPropsTask.CreationTime);                          }                            // task files                          this.testOutputHelper.WriteLine("task file tests");                            {                              List<CloudTask> tasks = new List<CloudTask>(batchCli.JobOperations.GetJob(jobId).ListTasks());                              CloudTask task = tasks[0]; // just pick one it doesnt matter which                                //Ensure that the task has run                              TaskStateMonitor tsm = batchCli.Utilities.CreateTaskStateMonitor();                              tsm.WaitAll(new List<CloudTask> { task }' TaskState.Completed' TimeSpan.FromSeconds(20));                                // first get a list with all props                              IEnumerable<NodeFile> ienumAllProps = task.ListNodeFiles();                              List<NodeFile> listAllProps = new List<NodeFile>(ienumAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<NodeFile> ienumStd = task.ListNodeFiles(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(name' 'std')" });                              List<NodeFile> listStd = new List<NodeFile>(ienumStd);                                // assert that filtering works                              Assert.Equal(2' listStd.Count);  // stdout/stderr                              Assert.True(listAllProps.Count > listStd.Count);                                // test nodefile refresh                                NodeFile stdoutFile = null;                                // find stdout                              listStd.ForEach(x => { if (x.Path.IndexOf("stdout"' StringComparison.InvariantCultureIgnoreCase) >= 0) { stdoutFile = x; } });                                // save pre-refresh props                              FileProperties saveFilProps = stdoutFile.Properties;                                // refesh to see if the props come back                              stdoutFile.Refresh();                                NodeFile againViaList = null;                                new List<NodeFile>(task.ListNodeFiles()).ForEach(x => { if (x.Path.IndexOf("stdout"' StringComparison.InvariantCultureIgnoreCase) >= 0) { againViaList = x; } });                                //"Bug1719609ODATADetailLevel: sometimes this can fail.  check out CreateTime"                              //This fails due to different time formats used in the header vs in the body of a request.  Since we expect that this will basically never pass                              //until the bug is fixed' we assert instead on only the upper-order digits of the DateTime                                //Assert.Equal(stdoutFile.Properties.CreationTime' saveFilProps.CreationTime);                              DateTime creationTime = saveFilProps.CreationTime.Value;                              DateTime refreshedCreationTime = stdoutFile.Properties.CreationTime.Value;                                Assert.Equal(DateTimeKind.Utc' refreshedCreationTime.Kind);                                Assert.Equal(creationTime.Year' refreshedCreationTime.Year);                              Assert.Equal(creationTime.Month' refreshedCreationTime.Month);                              Assert.Equal(creationTime.Day' refreshedCreationTime.Day);                              Assert.Equal(creationTime.Hour' refreshedCreationTime.Hour);                              Assert.Equal(creationTime.Minute' refreshedCreationTime.Minute);                              Assert.Equal(creationTime.Second' refreshedCreationTime.Second);                              Assert.Equal(creationTime.Kind' refreshedCreationTime.Kind);                                //Since the low order bits are lost in the GetFile (header based respose) assert that they are 0                              Assert.Equal(0' refreshedCreationTime.Millisecond);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1719609ODATADetailLevel,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      // pools tested in Bug1770942ExposeBatchRequestProperties                      this.testOutputHelper.WriteLine("job schedule tests");                        // create a bunch of job schedules                      {                          const int numJobSchedulesToCreate = 10;                            List<string> jobScheduleIds = new List<string>();                          for (int i = 0; i < numJobSchedulesToCreate; i++)                          {                              string id;                                if (1 == (i % 2))                              {                                  id = "Odd-Bug1770942-";                              }                              else                              {                                  id = "Even-Bug1770942-";                              }                                // add my name for visibile accounting                              id += i + "-" + TestUtilities.GetMyName();                                jobScheduleIds.Add(id);                          }                            try                          {                              foreach (string jobScheduleId in jobScheduleIds)                              {                                  CloudJobSchedule unboundJobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                                  PoolInformation poolInformation = new PoolInformation();                                    poolInformation.PoolId = this.poolFixture.PoolId;                                    unboundJobSchedule.JobSpecification = new JobSpecification(poolInformation);                                    unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(5) };                                    // create the job schedule                                  unboundJobSchedule.Commit();                              }                                // first get a list of all wi's with all props                              IEnumerable<CloudJobSchedule> ienumJobScheduleAllProps = batchCli.JobScheduleOperations.ListJobSchedules();                              List<CloudJobSchedule> listAllJobScheduleProps = new List<CloudJobSchedule>(ienumJobScheduleAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<CloudJobSchedule> ienumOdd =                                  batchCli.JobScheduleOperations.ListJobSchedules(detailLevel:                                      new ODATADetailLevel() { FilterClause = "startswith(id' 'Odd')"' SelectClause = "id'state" });                              List<CloudJobSchedule> listOdd = new List<CloudJobSchedule>(ienumOdd);                                IEnumerable<CloudJobSchedule> ienumEven =                                  batchCli.JobScheduleOperations.ListJobSchedules(detailLevel:                                      new ODATADetailLevel() { FilterClause = "startswith(id' 'Even')"' SelectClause = "id'state" });                              List<CloudJobSchedule> listEven = new List<CloudJobSchedule>(ienumEven);                                // confirm detail level worked                                // pick one                              CloudJobSchedule lowDetailLevelJobSchedule = listEven[0];                              CloudJobSchedule matchingAllPropJobSchedule = null;                                // find it in the list that has full props                              foreach (CloudJobSchedule currJobSchedule in listAllJobScheduleProps)                              {                                  // found it                                  if (currJobSchedule.Id.Equals(lowDetailLevelJobSchedule.Id' StringComparison.InvariantCultureIgnoreCase))                                  {                                      matchingAllPropJobSchedule = currJobSchedule;                                        Assert.NotEqual(currJobSchedule.CreationTime' lowDetailLevelJobSchedule.CreationTime);                                  }                              }                                // confirm that a match was found                              Assert.NotNull(matchingAllPropJobSchedule);                                // confirm that detail level works on jobScheduleOperations.GetJobSchedule()                              CloudJobSchedule directGetLowDetailLevel = batchCli.JobScheduleOperations.GetJobSchedule(matchingAllPropJobSchedule.Id'                                  new ODATADetailLevel() { SelectClause = "id'state" });                                Assert.NotEqual(matchingAllPropJobSchedule.CreationTime' directGetLowDetailLevel.CreationTime);                                // confirm that detail level can be returned to normal via refresh()                              directGetLowDetailLevel.Refresh(); // no detail level returns to full properties                                Assert.Equal(matchingAllPropJobSchedule.CreationTime' directGetLowDetailLevel.CreationTime);                          }                          finally                          {                              List<Task> jobScheduleDeletions = new List<Task>();                              foreach (string id in jobScheduleIds)                              {                                  Task t = TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' id);                                  jobScheduleDeletions.Add(t);                              }                                Task.WhenAll(jobScheduleDeletions).Wait();                          }                      }                        this.testOutputHelper.WriteLine("job tests");                        // jobs                      string jobId = "Bug1770942Job-" + TestUtilities.GetMyName();                        try                      {                          {                              // create a job                              CloudJob unboundJob = batchCli.JobOperations.CreateJob(jobId' new PoolInformation());                              unboundJob.PoolInformation.PoolId = this.poolFixture.PoolId;                              unboundJob.Commit();                              CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                                CloudTask unboundTask = new CloudTask("Bug1770942Taskname"' "hostname");                              boundJob.AddTask(unboundTask);                                string filterString = string.Format("startswith(id' '{0}')"' jobId);                                // first get a list with all props                              IEnumerable<CloudJob> ienumAllProps = batchCli.JobOperations.ListJobs(detailLevel: new ODATADetailLevel(){ FilterClause = filterString });                              List<CloudJob> listAllProps = new List<CloudJob>(ienumAllProps);                                // get list using lower Detail Level.  choose a predicate that will return no jobs since there is only the one :(                              IEnumerable<CloudJob> iEnumFewerProps = batchCli.JobOperations.ListJobs(detailLevel: new ODATADetailLevel() { SelectClause = "id'state"' FilterClause = filterString });                              List<CloudJob> listFewerProps = new List<CloudJob>(iEnumFewerProps);                                // the total must equal the sum of the parts                              Assert.Equal(listFewerProps.Count' listAllProps.Count);                                // confirm detail level worked                                // get the low detail level object                              CloudJob lowDetailLevel = listFewerProps.Single();                                // yes its the same and only                              Assert.Equal(listAllProps[0].Id' lowDetailLevel.Id);                                // confirm detail levels different                              Assert.NotEqual(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                                // confirm detail level returned to normal via refresh                              lowDetailLevel.Refresh();                                // now they both have all props                              Assert.Equal(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                                // confirm refresh can lower detail level                              lowDetailLevel = batchCli.JobOperations.GetJob(lowDetailLevel.Id);  // cant refresh 2 times or more because that pesky bug on refresh                              Assert.Equal(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);  // so all props are loaded                                // refresh and lower DL                              lowDetailLevel.Refresh(detailLevel: new ODATADetailLevel() { SelectClause = "id'state" });                                // now they must be different                              Assert.NotEqual(listAllProps[0].CreationTime' lowDetailLevel.CreationTime);                          }                            this.testOutputHelper.WriteLine("task tests");                            // tasks                          {                              // push tasks to this job                              CloudJob boundJob = batchCli.JobOperations.GetJob(jobId);                                // add a bunch of tasks                              const int numToCreate = 10;                                for (int i = 0; i < numToCreate; i++)                              {                                  string id;                                    if (1 == (i % 2))                                  {                                      id = "Odd-Bug1770942-";                                  }                                  else                                  {                                      id = "Even-Bug1770942-";                                  }                                    // add my name for visibile accounting                                  id += i + "-" + TestUtilities.GetMyName();                                    CloudTask unboundTask = new CloudTask(id' "cmd /c hostname");                                    // add the task                                  boundJob.AddTask(unboundTask);                              }                                // first get a list with all props                              IEnumerable<CloudTask> ienumAllProps = boundJob.ListTasks();                              List<CloudTask> listAllProps = new List<CloudTask>(ienumAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<CloudTask> ienumOdd = boundJob.ListTasks(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(id' 'Odd')"' SelectClause = "id'state" });                              List<CloudTask> listOdd = new List<CloudTask>(ienumOdd);                                IEnumerable<CloudTask> ienumEven = boundJob.ListTasks(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(id' 'Even')"' SelectClause = "id'state" });                              List<CloudTask> listEven = new List<CloudTask>(ienumEven);                                // the total must equal the sum of the parts                              Assert.Equal(listOdd.Count + listEven.Count + 1 /* 1 special task from above */' listAllProps.Count);                                // confirm detail level worked                              // pick one from lower detail level and compare it to the same one from the all-props collection                                CloudTask lowerDetailTask = listOdd[0];                              CloudTask matchingAllPropsTask = null;                                // now find it in the all-props list                              foreach (CloudTask curAllPropsTask in listAllProps)                              {                                  if (curAllPropsTask.Id.Equals(lowerDetailTask.Id))                                  {                                      matchingAllPropsTask = curAllPropsTask;                                  }                              }                                // we have a matching all-props instance... compare them.                              Assert.NotNull(matchingAllPropsTask);                                // see!  detail level works!                              Assert.NotEqual(matchingAllPropsTask.CreationTime' lowerDetailTask.CreationTime);                                // now confirm that refresh will raise detail level                              lowerDetailTask.Refresh();                                // they should be the same now                              Assert.Equal(matchingAllPropsTask.CreationTime' lowerDetailTask.CreationTime);                                // now confirm that refresh + detail level can lower detail level                              matchingAllPropsTask.Refresh(detailLevel: new ODATADetailLevel() { SelectClause = "id'state" });                                // confirm lower detail level                              Assert.NotEqual(lowerDetailTask.CreationTime' matchingAllPropsTask.CreationTime);                          }                            // task files                          this.testOutputHelper.WriteLine("task file tests");                            {                              List<CloudTask> tasks = new List<CloudTask>(batchCli.JobOperations.GetJob(jobId).ListTasks());                              CloudTask task = tasks[0]; // just pick one it doesnt matter which                                //Ensure that the task has run                              TaskStateMonitor tsm = batchCli.Utilities.CreateTaskStateMonitor();                              tsm.WaitAll(new List<CloudTask> { task }' TaskState.Completed' TimeSpan.FromSeconds(20));                                // first get a list with all props                              IEnumerable<NodeFile> ienumAllProps = task.ListNodeFiles();                              List<NodeFile> listAllProps = new List<NodeFile>(ienumAllProps);                                // get filtered lists using lower Detail Level                              IEnumerable<NodeFile> ienumStd = task.ListNodeFiles(detailLevel: new ODATADetailLevel() { FilterClause = "startswith(name' 'std')" });                              List<NodeFile> listStd = new List<NodeFile>(ienumStd);                                // assert that filtering works                              Assert.Equal(2' listStd.Count);  // stdout/stderr                              Assert.True(listAllProps.Count > listStd.Count);                                // test nodefile refresh                                NodeFile stdoutFile = null;                                // find stdout                              listStd.ForEach(x => { if (x.Path.IndexOf("stdout"' StringComparison.InvariantCultureIgnoreCase) >= 0) { stdoutFile = x; } });                                // save pre-refresh props                              FileProperties saveFilProps = stdoutFile.Properties;                                // refesh to see if the props come back                              stdoutFile.Refresh();                                NodeFile againViaList = null;                                new List<NodeFile>(task.ListNodeFiles()).ForEach(x => { if (x.Path.IndexOf("stdout"' StringComparison.InvariantCultureIgnoreCase) >= 0) { againViaList = x; } });                                //"Bug1719609ODATADetailLevel: sometimes this can fail.  check out CreateTime"                              //This fails due to different time formats used in the header vs in the body of a request.  Since we expect that this will basically never pass                              //until the bug is fixed' we assert instead on only the upper-order digits of the DateTime                                //Assert.Equal(stdoutFile.Properties.CreationTime' saveFilProps.CreationTime);                              DateTime creationTime = saveFilProps.CreationTime.Value;                              DateTime refreshedCreationTime = stdoutFile.Properties.CreationTime.Value;                                Assert.Equal(DateTimeKind.Utc' refreshedCreationTime.Kind);                                Assert.Equal(creationTime.Year' refreshedCreationTime.Year);                              Assert.Equal(creationTime.Month' refreshedCreationTime.Month);                              Assert.Equal(creationTime.Day' refreshedCreationTime.Day);                              Assert.Equal(creationTime.Hour' refreshedCreationTime.Hour);                              Assert.Equal(creationTime.Minute' refreshedCreationTime.Minute);                              Assert.Equal(creationTime.Second' refreshedCreationTime.Second);                              Assert.Equal(creationTime.Kind' refreshedCreationTime.Kind);                                //Since the low order bits are lost in the GetFile (header based respose) assert that they are 0                              Assert.Equal(0' refreshedCreationTime.Millisecond);                          }                      }                      finally                      {                          TestUtilities.DeleteJobIfExistsAsync(batchCli' jobId).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1996130_ResourceDoubleRefreshDoesntWork,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      const string testName = "Bug1996130_ResourceDoubleRefreshDoesntWork";                      const string taskId = "Bug1996130_ResourceDoubleRefreshDoesntWork_Task1";                        string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-" + testName;                      try                      {                          //                          // Create the job schedule                          //                          CloudJobSchedule jobSchedule = batchCli.JobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                          jobSchedule.JobSpecification = new JobSpecification(new PoolInformation()                              {                                  PoolId = this.poolFixture.PoolId                              });                          jobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(1) };                            this.testOutputHelper.WriteLine("Initial job schedule commit()");                          jobSchedule.Commit();                            //Get the bound job schedule                          CloudJobSchedule boundJobSchedule = TestUtilities.WaitForJobOnJobSchedule(batchCli.JobScheduleOperations' jobScheduleId);                            //Get the job                          CloudJob boundJob = batchCli.JobOperations.GetJob(boundJobSchedule.ExecutionInformation.RecentJob.Id);                          string jobId = boundJob.Id; //We have to store this because after we commit we can't access the name anymore...                            CloudTask myTask = new CloudTask(taskId' "cmd /c echo hello world");                            //Add the task                          this.testOutputHelper.WriteLine("Adding task: {0}"' taskId);                          boundJob.AddTask(myTask);                            //Get the task                          CloudTask boundTask = batchCli.JobOperations.GetTask(jobId' taskId);                            //Wait for the task to complete                            TaskStateMonitor stateMonitor = batchCli.Utilities.CreateTaskStateMonitor();                          stateMonitor.WaitAll(new List<CloudTask> { boundTask }' TaskState.Completed' TimeSpan.FromMinutes(2));                                                    //Try to refresh the job schedule multiple times                          this.testOutputHelper.WriteLine("Refreshing job schedule");                          boundJobSchedule.Refresh();                          this.testOutputHelper.WriteLine("Refreshing job schedule");                          boundJobSchedule.Refresh();                            //Try to refresh the job multiple times                          this.testOutputHelper.WriteLine("Refreshing job");                          boundJob.Refresh();                          this.testOutputHelper.WriteLine("Refreshing job");                          boundJob.Refresh();                            //Try to refresh the task multiple times                          this.testOutputHelper.WriteLine("Refreshing task");                          boundTask.Refresh();                          this.testOutputHelper.WriteLine("Refreshing task");                          boundTask.Refresh();                            //Try to refresh a file multiple times                          NodeFile nodeFile = boundTask.GetNodeFile("stdout.txt");                            this.testOutputHelper.WriteLine("Refreshing task file");                          nodeFile.Refresh();                          this.testOutputHelper.WriteLine("Refreshing task file");                          nodeFile.Refresh();                            //Try to refresh the pool multiple times                          CloudPool boundPool = batchCli.PoolOperations.GetPool(this.poolFixture.PoolId);                            this.testOutputHelper.WriteLine("Refreshing pool");                          boundPool.Refresh();                          this.testOutputHelper.WriteLine("Refreshing pool");                          boundPool.Refresh();                          //Try to refresh a compute node multiple times                          ComputeNode computeNode = boundPool.ListComputeNodes().First();                            this.testOutputHelper.WriteLine("Refreshing compute node");                          computeNode.Refresh();                          this.testOutputHelper.WriteLine("Refreshing compute node");                          computeNode.Refresh();                            //Try to refresh a node file multiple times                          //NodeFile nodeFile = computeNode.GetNodeFile("startup/stdout.txt");                            //this.testOutputHelper.WriteLine("Refreshing vm file");                          //nodeFile.Refresh();                          //this.testOutputHelper.WriteLine("Refreshing vm file");                          //nodeFile.Refresh();                            //TODO: Add certificate refreshes here                        }                      finally                      {                          batchCli.JobScheduleOperations.DeleteJobSchedule(jobScheduleId);                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,CommitFollowedByRefreshTest,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      const string testName = "PostCommitInvalidPropRouterTests";                        JobScheduleOperations jobScheduleOperations = batchCli.JobScheduleOperations;                      JobOperations jobOperations = batchCli.JobOperations;                        // test bound job commit followed by refresh                      string jobScheduleId = testName + "-" + TestUtilities.GetMyName();                        try                      {                          CloudJobSchedule unboundJobSchedule = jobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                          PoolInformation poolInformation = new PoolInformation();                          poolInformation.PoolId = this.poolFixture.PoolId;                          unboundJobSchedule.JobSpecification = new JobSpecification(poolInformation);                          unboundJobSchedule.Schedule = new Schedule() { DoNotRunAfter = DateTime.UtcNow.AddDays(1) };                          unboundJobSchedule.Commit();                            CloudJobSchedule boundJobSchedule = TestUtilities.WaitForJobOnJobSchedule(jobScheduleOperations' jobScheduleId);                          CloudJob boundJob = jobOperations.GetJob(boundJobSchedule.ExecutionInformation.RecentJob.Id);                            boundJob.Constraints = new JobConstraints(TimeSpan.FromDays(1)' 99);                            // we have a bound job' we made an unimportant change' now commit it to mark the object as read only                          boundJob.Commit();                            // this used to throw                          boundJob.Refresh();                      }                      finally                      {                          TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jobScheduleId).Wait();                      }                    }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      const string testName = "Bug1910530_ConcurrentChangeTrackedList";                        PoolOperations poolOperations = batchCli.PoolOperations;                      JobScheduleOperations jobScheduleOperations = batchCli.JobScheduleOperations;                      JobOperations jobOperations = batchCli.JobOperations;                        CloudJobSchedule boundJobSchedule = null;                        {                          string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-" + testName;                          try                          {                              //                              //Test bound pool properties                              //                              CloudPool pool = poolOperations.GetPool(this.poolFixture.PoolId);                              pool.Metadata = new List<MetadataItem>();                              pool.Metadata.Add(new MetadataItem("test"' "test"));                                //Note: We rely on the certificate specific tests to validate certificate references work for us                                pool.Commit();                                pool = poolOperations.GetPool(this.poolFixture.PoolId);                                Assert.Equal(1' pool.Metadata.Count);                                //                              //Unbound job schedule properties                              //                              this.testOutputHelper.WriteLine("Creating job schedule {0}"' jobScheduleId);                              CloudJobSchedule unboundJobSchedule = jobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                                Assert.Null(unboundJobSchedule.Metadata);                                unboundJobSchedule.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                //JobManagerTask                              JobManagerTask jm = new JobManagerTask(id: "JobManagerTask"' commandLine: "cmd /c dir");                                Assert.Null(jm.ResourceFiles);                              Assert.Null(jm.EnvironmentSettings);                                jm.ResourceFiles = new List<ResourceFile> { ResourceFile.FromUrl("http://test"' "test") };                              jm.EnvironmentSettings = new List<EnvironmentSetting> { new EnvironmentSetting("test"' "Test") };                                //StartTask                              StartTask startTask = new StartTask("cmd /c dir");                                Assert.Null(startTask.ResourceFiles);                              Assert.Null(startTask.EnvironmentSettings);                                startTask.EnvironmentSettings = new List<EnvironmentSetting>() { new EnvironmentSetting("test"' "test") };                              startTask.ResourceFiles = new List<ResourceFile>() { ResourceFile.FromUrl("http://test"' "Test") };                                //Pool Specification                              PoolSpecification poolSpecification = new PoolSpecification()                              {                                  TargetDedicatedComputeNodes = 0'                                  VirtualMachineSize = PoolFixture.VMSize'                                  CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily)'                                  StartTask = startTask                              };                                Assert.Null(poolSpecification.Metadata);                              //Note: We rely on the certificate specific tests to validate certificate references work for us                                poolSpecification.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                PoolInformation poolInformation = new PoolInformation()                              {                                  AutoPoolSpecification = new AutoPoolSpecification()                                  {                                      KeepAlive = false'                                      PoolSpecification = poolSpecification'                                      PoolLifetimeOption = PoolLifetimeOption.JobSchedule                                  }                              };                                unboundJobSchedule.JobSpecification = new JobSpecification(poolInformation)                              {                                  JobManagerTask = jm'                              };                                unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(6) };                                unboundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Equal(1' boundJobSchedule.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //                              // Bound job schedule properties                              //                                //Testing addition to existing lists now                              boundJobSchedule.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with more IList stuff added");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                  Assert.Equal(2' boundJobSchedule.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to set to null and ensure that works.                                boundJobSchedule.Metadata = null;                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles = null;                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings = null;                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with some IList stuff removed");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to remove an item from' and ensure that works                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.RemoveAt(0);                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.RemoveAt(1);                                boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = TestUtilities.WaitForJobOnJobSchedule(jobScheduleOperations' jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              //Extra check to ensure we removed the right one                              Assert.Equal("abc"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.First().Name);                              Assert.Equal("test"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.First().Name);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Now take a snapshot and ensure it isn't modified by editing the list after the fact                              IList<ResourceFile> resourceFiles = boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles;                                IEnumerator<ResourceFile> enumerator = resourceFiles.GetEnumerator();                              int resourceFileCountBeforeListModification = 0;                              int resourceFileCountAfterListModification = 0;                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountBeforeListModification;                              }                                //Remove a file                              ResourceFile resourceFile = resourceFiles[0];                              resourceFiles.Remove(resourceFile);                                enumerator.Reset();                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountAfterListModification;                              }                                Assert.Equal(resourceFileCountBeforeListModification' resourceFileCountAfterListModification);                                //                              // Get the job and add a task                              //                              const string taskId = "test";                                CloudJob job = jobOperations.GetJob(boundJobSchedule.ExecutionInformation.RecentJob.Id);                                CloudTask unboundTask = new CloudTask("test"' "cmd /c dir");                              unboundTask.EnvironmentSettings = new List<EnvironmentSetting>();                              unboundTask.EnvironmentSettings.Add(new EnvironmentSetting("foo"' "baz"));                                unboundTask.ResourceFiles = new List<ResourceFile>();                              unboundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://foo"' "baz"));                                job.AddTask(unboundTask);                                //Get the bound task                              CloudTask boundTask = job.GetTask(taskId);                                Assert.NotNull(boundTask.ResourceFiles);                              Assert.NotNull(boundTask.EnvironmentSettings);                                //Ensure the task has the correct settings                              Assert.Equal(1' boundTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundTask.ResourceFiles.Count);                                TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.EnvironmentSettings.Add(new EnvironmentSetting("test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => { IList<IFileStagingProvider> filesToStage = boundTask.FilesToStage; });                          }                          finally                          {                              TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jobScheduleId).Wait();                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      const string testName = "Bug1910530_ConcurrentChangeTrackedList";                        PoolOperations poolOperations = batchCli.PoolOperations;                      JobScheduleOperations jobScheduleOperations = batchCli.JobScheduleOperations;                      JobOperations jobOperations = batchCli.JobOperations;                        CloudJobSchedule boundJobSchedule = null;                        {                          string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-" + testName;                          try                          {                              //                              //Test bound pool properties                              //                              CloudPool pool = poolOperations.GetPool(this.poolFixture.PoolId);                              pool.Metadata = new List<MetadataItem>();                              pool.Metadata.Add(new MetadataItem("test"' "test"));                                //Note: We rely on the certificate specific tests to validate certificate references work for us                                pool.Commit();                                pool = poolOperations.GetPool(this.poolFixture.PoolId);                                Assert.Equal(1' pool.Metadata.Count);                                //                              //Unbound job schedule properties                              //                              this.testOutputHelper.WriteLine("Creating job schedule {0}"' jobScheduleId);                              CloudJobSchedule unboundJobSchedule = jobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                                Assert.Null(unboundJobSchedule.Metadata);                                unboundJobSchedule.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                //JobManagerTask                              JobManagerTask jm = new JobManagerTask(id: "JobManagerTask"' commandLine: "cmd /c dir");                                Assert.Null(jm.ResourceFiles);                              Assert.Null(jm.EnvironmentSettings);                                jm.ResourceFiles = new List<ResourceFile> { ResourceFile.FromUrl("http://test"' "test") };                              jm.EnvironmentSettings = new List<EnvironmentSetting> { new EnvironmentSetting("test"' "Test") };                                //StartTask                              StartTask startTask = new StartTask("cmd /c dir");                                Assert.Null(startTask.ResourceFiles);                              Assert.Null(startTask.EnvironmentSettings);                                startTask.EnvironmentSettings = new List<EnvironmentSetting>() { new EnvironmentSetting("test"' "test") };                              startTask.ResourceFiles = new List<ResourceFile>() { ResourceFile.FromUrl("http://test"' "Test") };                                //Pool Specification                              PoolSpecification poolSpecification = new PoolSpecification()                              {                                  TargetDedicatedComputeNodes = 0'                                  VirtualMachineSize = PoolFixture.VMSize'                                  CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily)'                                  StartTask = startTask                              };                                Assert.Null(poolSpecification.Metadata);                              //Note: We rely on the certificate specific tests to validate certificate references work for us                                poolSpecification.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                PoolInformation poolInformation = new PoolInformation()                              {                                  AutoPoolSpecification = new AutoPoolSpecification()                                  {                                      KeepAlive = false'                                      PoolSpecification = poolSpecification'                                      PoolLifetimeOption = PoolLifetimeOption.JobSchedule                                  }                              };                                unboundJobSchedule.JobSpecification = new JobSpecification(poolInformation)                              {                                  JobManagerTask = jm'                              };                                unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(6) };                                unboundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Equal(1' boundJobSchedule.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //                              // Bound job schedule properties                              //                                //Testing addition to existing lists now                              boundJobSchedule.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with more IList stuff added");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                  Assert.Equal(2' boundJobSchedule.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to set to null and ensure that works.                                boundJobSchedule.Metadata = null;                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles = null;                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings = null;                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with some IList stuff removed");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to remove an item from' and ensure that works                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.RemoveAt(0);                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.RemoveAt(1);                                boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = TestUtilities.WaitForJobOnJobSchedule(jobScheduleOperations' jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              //Extra check to ensure we removed the right one                              Assert.Equal("abc"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.First().Name);                              Assert.Equal("test"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.First().Name);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Now take a snapshot and ensure it isn't modified by editing the list after the fact                              IList<ResourceFile> resourceFiles = boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles;                                IEnumerator<ResourceFile> enumerator = resourceFiles.GetEnumerator();                              int resourceFileCountBeforeListModification = 0;                              int resourceFileCountAfterListModification = 0;                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountBeforeListModification;                              }                                //Remove a file                              ResourceFile resourceFile = resourceFiles[0];                              resourceFiles.Remove(resourceFile);                                enumerator.Reset();                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountAfterListModification;                              }                                Assert.Equal(resourceFileCountBeforeListModification' resourceFileCountAfterListModification);                                //                              // Get the job and add a task                              //                              const string taskId = "test";                                CloudJob job = jobOperations.GetJob(boundJobSchedule.ExecutionInformation.RecentJob.Id);                                CloudTask unboundTask = new CloudTask("test"' "cmd /c dir");                              unboundTask.EnvironmentSettings = new List<EnvironmentSetting>();                              unboundTask.EnvironmentSettings.Add(new EnvironmentSetting("foo"' "baz"));                                unboundTask.ResourceFiles = new List<ResourceFile>();                              unboundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://foo"' "baz"));                                job.AddTask(unboundTask);                                //Get the bound task                              CloudTask boundTask = job.GetTask(taskId);                                Assert.NotNull(boundTask.ResourceFiles);                              Assert.NotNull(boundTask.EnvironmentSettings);                                //Ensure the task has the correct settings                              Assert.Equal(1' boundTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundTask.ResourceFiles.Count);                                TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.EnvironmentSettings.Add(new EnvironmentSetting("test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => { IList<IFileStagingProvider> filesToStage = boundTask.FilesToStage; });                          }                          finally                          {                              TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jobScheduleId).Wait();                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      const string testName = "Bug1910530_ConcurrentChangeTrackedList";                        PoolOperations poolOperations = batchCli.PoolOperations;                      JobScheduleOperations jobScheduleOperations = batchCli.JobScheduleOperations;                      JobOperations jobOperations = batchCli.JobOperations;                        CloudJobSchedule boundJobSchedule = null;                        {                          string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-" + testName;                          try                          {                              //                              //Test bound pool properties                              //                              CloudPool pool = poolOperations.GetPool(this.poolFixture.PoolId);                              pool.Metadata = new List<MetadataItem>();                              pool.Metadata.Add(new MetadataItem("test"' "test"));                                //Note: We rely on the certificate specific tests to validate certificate references work for us                                pool.Commit();                                pool = poolOperations.GetPool(this.poolFixture.PoolId);                                Assert.Equal(1' pool.Metadata.Count);                                //                              //Unbound job schedule properties                              //                              this.testOutputHelper.WriteLine("Creating job schedule {0}"' jobScheduleId);                              CloudJobSchedule unboundJobSchedule = jobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                                Assert.Null(unboundJobSchedule.Metadata);                                unboundJobSchedule.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                //JobManagerTask                              JobManagerTask jm = new JobManagerTask(id: "JobManagerTask"' commandLine: "cmd /c dir");                                Assert.Null(jm.ResourceFiles);                              Assert.Null(jm.EnvironmentSettings);                                jm.ResourceFiles = new List<ResourceFile> { ResourceFile.FromUrl("http://test"' "test") };                              jm.EnvironmentSettings = new List<EnvironmentSetting> { new EnvironmentSetting("test"' "Test") };                                //StartTask                              StartTask startTask = new StartTask("cmd /c dir");                                Assert.Null(startTask.ResourceFiles);                              Assert.Null(startTask.EnvironmentSettings);                                startTask.EnvironmentSettings = new List<EnvironmentSetting>() { new EnvironmentSetting("test"' "test") };                              startTask.ResourceFiles = new List<ResourceFile>() { ResourceFile.FromUrl("http://test"' "Test") };                                //Pool Specification                              PoolSpecification poolSpecification = new PoolSpecification()                              {                                  TargetDedicatedComputeNodes = 0'                                  VirtualMachineSize = PoolFixture.VMSize'                                  CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily)'                                  StartTask = startTask                              };                                Assert.Null(poolSpecification.Metadata);                              //Note: We rely on the certificate specific tests to validate certificate references work for us                                poolSpecification.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                PoolInformation poolInformation = new PoolInformation()                              {                                  AutoPoolSpecification = new AutoPoolSpecification()                                  {                                      KeepAlive = false'                                      PoolSpecification = poolSpecification'                                      PoolLifetimeOption = PoolLifetimeOption.JobSchedule                                  }                              };                                unboundJobSchedule.JobSpecification = new JobSpecification(poolInformation)                              {                                  JobManagerTask = jm'                              };                                unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(6) };                                unboundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Equal(1' boundJobSchedule.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //                              // Bound job schedule properties                              //                                //Testing addition to existing lists now                              boundJobSchedule.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with more IList stuff added");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                  Assert.Equal(2' boundJobSchedule.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to set to null and ensure that works.                                boundJobSchedule.Metadata = null;                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles = null;                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings = null;                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with some IList stuff removed");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to remove an item from' and ensure that works                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.RemoveAt(0);                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.RemoveAt(1);                                boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = TestUtilities.WaitForJobOnJobSchedule(jobScheduleOperations' jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              //Extra check to ensure we removed the right one                              Assert.Equal("abc"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.First().Name);                              Assert.Equal("test"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.First().Name);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Now take a snapshot and ensure it isn't modified by editing the list after the fact                              IList<ResourceFile> resourceFiles = boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles;                                IEnumerator<ResourceFile> enumerator = resourceFiles.GetEnumerator();                              int resourceFileCountBeforeListModification = 0;                              int resourceFileCountAfterListModification = 0;                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountBeforeListModification;                              }                                //Remove a file                              ResourceFile resourceFile = resourceFiles[0];                              resourceFiles.Remove(resourceFile);                                enumerator.Reset();                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountAfterListModification;                              }                                Assert.Equal(resourceFileCountBeforeListModification' resourceFileCountAfterListModification);                                //                              // Get the job and add a task                              //                              const string taskId = "test";                                CloudJob job = jobOperations.GetJob(boundJobSchedule.ExecutionInformation.RecentJob.Id);                                CloudTask unboundTask = new CloudTask("test"' "cmd /c dir");                              unboundTask.EnvironmentSettings = new List<EnvironmentSetting>();                              unboundTask.EnvironmentSettings.Add(new EnvironmentSetting("foo"' "baz"));                                unboundTask.ResourceFiles = new List<ResourceFile>();                              unboundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://foo"' "baz"));                                job.AddTask(unboundTask);                                //Get the bound task                              CloudTask boundTask = job.GetTask(taskId);                                Assert.NotNull(boundTask.ResourceFiles);                              Assert.NotNull(boundTask.EnvironmentSettings);                                //Ensure the task has the correct settings                              Assert.Equal(1' boundTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundTask.ResourceFiles.Count);                                TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.EnvironmentSettings.Add(new EnvironmentSetting("test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => { IList<IFileStagingProvider> filesToStage = boundTask.FilesToStage; });                          }                          finally                          {                              TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jobScheduleId).Wait();                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      const string testName = "Bug1910530_ConcurrentChangeTrackedList";                        PoolOperations poolOperations = batchCli.PoolOperations;                      JobScheduleOperations jobScheduleOperations = batchCli.JobScheduleOperations;                      JobOperations jobOperations = batchCli.JobOperations;                        CloudJobSchedule boundJobSchedule = null;                        {                          string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-" + testName;                          try                          {                              //                              //Test bound pool properties                              //                              CloudPool pool = poolOperations.GetPool(this.poolFixture.PoolId);                              pool.Metadata = new List<MetadataItem>();                              pool.Metadata.Add(new MetadataItem("test"' "test"));                                //Note: We rely on the certificate specific tests to validate certificate references work for us                                pool.Commit();                                pool = poolOperations.GetPool(this.poolFixture.PoolId);                                Assert.Equal(1' pool.Metadata.Count);                                //                              //Unbound job schedule properties                              //                              this.testOutputHelper.WriteLine("Creating job schedule {0}"' jobScheduleId);                              CloudJobSchedule unboundJobSchedule = jobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                                Assert.Null(unboundJobSchedule.Metadata);                                unboundJobSchedule.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                //JobManagerTask                              JobManagerTask jm = new JobManagerTask(id: "JobManagerTask"' commandLine: "cmd /c dir");                                Assert.Null(jm.ResourceFiles);                              Assert.Null(jm.EnvironmentSettings);                                jm.ResourceFiles = new List<ResourceFile> { ResourceFile.FromUrl("http://test"' "test") };                              jm.EnvironmentSettings = new List<EnvironmentSetting> { new EnvironmentSetting("test"' "Test") };                                //StartTask                              StartTask startTask = new StartTask("cmd /c dir");                                Assert.Null(startTask.ResourceFiles);                              Assert.Null(startTask.EnvironmentSettings);                                startTask.EnvironmentSettings = new List<EnvironmentSetting>() { new EnvironmentSetting("test"' "test") };                              startTask.ResourceFiles = new List<ResourceFile>() { ResourceFile.FromUrl("http://test"' "Test") };                                //Pool Specification                              PoolSpecification poolSpecification = new PoolSpecification()                              {                                  TargetDedicatedComputeNodes = 0'                                  VirtualMachineSize = PoolFixture.VMSize'                                  CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily)'                                  StartTask = startTask                              };                                Assert.Null(poolSpecification.Metadata);                              //Note: We rely on the certificate specific tests to validate certificate references work for us                                poolSpecification.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                PoolInformation poolInformation = new PoolInformation()                              {                                  AutoPoolSpecification = new AutoPoolSpecification()                                  {                                      KeepAlive = false'                                      PoolSpecification = poolSpecification'                                      PoolLifetimeOption = PoolLifetimeOption.JobSchedule                                  }                              };                                unboundJobSchedule.JobSpecification = new JobSpecification(poolInformation)                              {                                  JobManagerTask = jm'                              };                                unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(6) };                                unboundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Equal(1' boundJobSchedule.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //                              // Bound job schedule properties                              //                                //Testing addition to existing lists now                              boundJobSchedule.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with more IList stuff added");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                  Assert.Equal(2' boundJobSchedule.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to set to null and ensure that works.                                boundJobSchedule.Metadata = null;                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles = null;                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings = null;                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with some IList stuff removed");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to remove an item from' and ensure that works                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.RemoveAt(0);                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.RemoveAt(1);                                boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = TestUtilities.WaitForJobOnJobSchedule(jobScheduleOperations' jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              //Extra check to ensure we removed the right one                              Assert.Equal("abc"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.First().Name);                              Assert.Equal("test"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.First().Name);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Now take a snapshot and ensure it isn't modified by editing the list after the fact                              IList<ResourceFile> resourceFiles = boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles;                                IEnumerator<ResourceFile> enumerator = resourceFiles.GetEnumerator();                              int resourceFileCountBeforeListModification = 0;                              int resourceFileCountAfterListModification = 0;                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountBeforeListModification;                              }                                //Remove a file                              ResourceFile resourceFile = resourceFiles[0];                              resourceFiles.Remove(resourceFile);                                enumerator.Reset();                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountAfterListModification;                              }                                Assert.Equal(resourceFileCountBeforeListModification' resourceFileCountAfterListModification);                                //                              // Get the job and add a task                              //                              const string taskId = "test";                                CloudJob job = jobOperations.GetJob(boundJobSchedule.ExecutionInformation.RecentJob.Id);                                CloudTask unboundTask = new CloudTask("test"' "cmd /c dir");                              unboundTask.EnvironmentSettings = new List<EnvironmentSetting>();                              unboundTask.EnvironmentSettings.Add(new EnvironmentSetting("foo"' "baz"));                                unboundTask.ResourceFiles = new List<ResourceFile>();                              unboundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://foo"' "baz"));                                job.AddTask(unboundTask);                                //Get the bound task                              CloudTask boundTask = job.GetTask(taskId);                                Assert.NotNull(boundTask.ResourceFiles);                              Assert.NotNull(boundTask.EnvironmentSettings);                                //Ensure the task has the correct settings                              Assert.Equal(1' boundTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundTask.ResourceFiles.Count);                                TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.EnvironmentSettings.Add(new EnvironmentSetting("test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => { IList<IFileStagingProvider> filesToStage = boundTask.FilesToStage; });                          }                          finally                          {                              TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jobScheduleId).Wait();                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      const string testName = "Bug1910530_ConcurrentChangeTrackedList";                        PoolOperations poolOperations = batchCli.PoolOperations;                      JobScheduleOperations jobScheduleOperations = batchCli.JobScheduleOperations;                      JobOperations jobOperations = batchCli.JobOperations;                        CloudJobSchedule boundJobSchedule = null;                        {                          string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-" + testName;                          try                          {                              //                              //Test bound pool properties                              //                              CloudPool pool = poolOperations.GetPool(this.poolFixture.PoolId);                              pool.Metadata = new List<MetadataItem>();                              pool.Metadata.Add(new MetadataItem("test"' "test"));                                //Note: We rely on the certificate specific tests to validate certificate references work for us                                pool.Commit();                                pool = poolOperations.GetPool(this.poolFixture.PoolId);                                Assert.Equal(1' pool.Metadata.Count);                                //                              //Unbound job schedule properties                              //                              this.testOutputHelper.WriteLine("Creating job schedule {0}"' jobScheduleId);                              CloudJobSchedule unboundJobSchedule = jobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                                Assert.Null(unboundJobSchedule.Metadata);                                unboundJobSchedule.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                //JobManagerTask                              JobManagerTask jm = new JobManagerTask(id: "JobManagerTask"' commandLine: "cmd /c dir");                                Assert.Null(jm.ResourceFiles);                              Assert.Null(jm.EnvironmentSettings);                                jm.ResourceFiles = new List<ResourceFile> { ResourceFile.FromUrl("http://test"' "test") };                              jm.EnvironmentSettings = new List<EnvironmentSetting> { new EnvironmentSetting("test"' "Test") };                                //StartTask                              StartTask startTask = new StartTask("cmd /c dir");                                Assert.Null(startTask.ResourceFiles);                              Assert.Null(startTask.EnvironmentSettings);                                startTask.EnvironmentSettings = new List<EnvironmentSetting>() { new EnvironmentSetting("test"' "test") };                              startTask.ResourceFiles = new List<ResourceFile>() { ResourceFile.FromUrl("http://test"' "Test") };                                //Pool Specification                              PoolSpecification poolSpecification = new PoolSpecification()                              {                                  TargetDedicatedComputeNodes = 0'                                  VirtualMachineSize = PoolFixture.VMSize'                                  CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily)'                                  StartTask = startTask                              };                                Assert.Null(poolSpecification.Metadata);                              //Note: We rely on the certificate specific tests to validate certificate references work for us                                poolSpecification.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                PoolInformation poolInformation = new PoolInformation()                              {                                  AutoPoolSpecification = new AutoPoolSpecification()                                  {                                      KeepAlive = false'                                      PoolSpecification = poolSpecification'                                      PoolLifetimeOption = PoolLifetimeOption.JobSchedule                                  }                              };                                unboundJobSchedule.JobSpecification = new JobSpecification(poolInformation)                              {                                  JobManagerTask = jm'                              };                                unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(6) };                                unboundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Equal(1' boundJobSchedule.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //                              // Bound job schedule properties                              //                                //Testing addition to existing lists now                              boundJobSchedule.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with more IList stuff added");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                  Assert.Equal(2' boundJobSchedule.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to set to null and ensure that works.                                boundJobSchedule.Metadata = null;                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles = null;                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings = null;                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with some IList stuff removed");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to remove an item from' and ensure that works                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.RemoveAt(0);                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.RemoveAt(1);                                boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = TestUtilities.WaitForJobOnJobSchedule(jobScheduleOperations' jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              //Extra check to ensure we removed the right one                              Assert.Equal("abc"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.First().Name);                              Assert.Equal("test"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.First().Name);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Now take a snapshot and ensure it isn't modified by editing the list after the fact                              IList<ResourceFile> resourceFiles = boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles;                                IEnumerator<ResourceFile> enumerator = resourceFiles.GetEnumerator();                              int resourceFileCountBeforeListModification = 0;                              int resourceFileCountAfterListModification = 0;                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountBeforeListModification;                              }                                //Remove a file                              ResourceFile resourceFile = resourceFiles[0];                              resourceFiles.Remove(resourceFile);                                enumerator.Reset();                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountAfterListModification;                              }                                Assert.Equal(resourceFileCountBeforeListModification' resourceFileCountAfterListModification);                                //                              // Get the job and add a task                              //                              const string taskId = "test";                                CloudJob job = jobOperations.GetJob(boundJobSchedule.ExecutionInformation.RecentJob.Id);                                CloudTask unboundTask = new CloudTask("test"' "cmd /c dir");                              unboundTask.EnvironmentSettings = new List<EnvironmentSetting>();                              unboundTask.EnvironmentSettings.Add(new EnvironmentSetting("foo"' "baz"));                                unboundTask.ResourceFiles = new List<ResourceFile>();                              unboundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://foo"' "baz"));                                job.AddTask(unboundTask);                                //Get the bound task                              CloudTask boundTask = job.GetTask(taskId);                                Assert.NotNull(boundTask.ResourceFiles);                              Assert.NotNull(boundTask.EnvironmentSettings);                                //Ensure the task has the correct settings                              Assert.Equal(1' boundTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundTask.ResourceFiles.Count);                                TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.EnvironmentSettings.Add(new EnvironmentSetting("test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => { IList<IFileStagingProvider> filesToStage = boundTask.FilesToStage; });                          }                          finally                          {                              TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jobScheduleId).Wait();                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      const string testName = "Bug1910530_ConcurrentChangeTrackedList";                        PoolOperations poolOperations = batchCli.PoolOperations;                      JobScheduleOperations jobScheduleOperations = batchCli.JobScheduleOperations;                      JobOperations jobOperations = batchCli.JobOperations;                        CloudJobSchedule boundJobSchedule = null;                        {                          string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-" + testName;                          try                          {                              //                              //Test bound pool properties                              //                              CloudPool pool = poolOperations.GetPool(this.poolFixture.PoolId);                              pool.Metadata = new List<MetadataItem>();                              pool.Metadata.Add(new MetadataItem("test"' "test"));                                //Note: We rely on the certificate specific tests to validate certificate references work for us                                pool.Commit();                                pool = poolOperations.GetPool(this.poolFixture.PoolId);                                Assert.Equal(1' pool.Metadata.Count);                                //                              //Unbound job schedule properties                              //                              this.testOutputHelper.WriteLine("Creating job schedule {0}"' jobScheduleId);                              CloudJobSchedule unboundJobSchedule = jobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                                Assert.Null(unboundJobSchedule.Metadata);                                unboundJobSchedule.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                //JobManagerTask                              JobManagerTask jm = new JobManagerTask(id: "JobManagerTask"' commandLine: "cmd /c dir");                                Assert.Null(jm.ResourceFiles);                              Assert.Null(jm.EnvironmentSettings);                                jm.ResourceFiles = new List<ResourceFile> { ResourceFile.FromUrl("http://test"' "test") };                              jm.EnvironmentSettings = new List<EnvironmentSetting> { new EnvironmentSetting("test"' "Test") };                                //StartTask                              StartTask startTask = new StartTask("cmd /c dir");                                Assert.Null(startTask.ResourceFiles);                              Assert.Null(startTask.EnvironmentSettings);                                startTask.EnvironmentSettings = new List<EnvironmentSetting>() { new EnvironmentSetting("test"' "test") };                              startTask.ResourceFiles = new List<ResourceFile>() { ResourceFile.FromUrl("http://test"' "Test") };                                //Pool Specification                              PoolSpecification poolSpecification = new PoolSpecification()                              {                                  TargetDedicatedComputeNodes = 0'                                  VirtualMachineSize = PoolFixture.VMSize'                                  CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily)'                                  StartTask = startTask                              };                                Assert.Null(poolSpecification.Metadata);                              //Note: We rely on the certificate specific tests to validate certificate references work for us                                poolSpecification.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                PoolInformation poolInformation = new PoolInformation()                              {                                  AutoPoolSpecification = new AutoPoolSpecification()                                  {                                      KeepAlive = false'                                      PoolSpecification = poolSpecification'                                      PoolLifetimeOption = PoolLifetimeOption.JobSchedule                                  }                              };                                unboundJobSchedule.JobSpecification = new JobSpecification(poolInformation)                              {                                  JobManagerTask = jm'                              };                                unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(6) };                                unboundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Equal(1' boundJobSchedule.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //                              // Bound job schedule properties                              //                                //Testing addition to existing lists now                              boundJobSchedule.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with more IList stuff added");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                  Assert.Equal(2' boundJobSchedule.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to set to null and ensure that works.                                boundJobSchedule.Metadata = null;                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles = null;                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings = null;                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with some IList stuff removed");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to remove an item from' and ensure that works                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.RemoveAt(0);                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.RemoveAt(1);                                boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = TestUtilities.WaitForJobOnJobSchedule(jobScheduleOperations' jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              //Extra check to ensure we removed the right one                              Assert.Equal("abc"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.First().Name);                              Assert.Equal("test"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.First().Name);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Now take a snapshot and ensure it isn't modified by editing the list after the fact                              IList<ResourceFile> resourceFiles = boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles;                                IEnumerator<ResourceFile> enumerator = resourceFiles.GetEnumerator();                              int resourceFileCountBeforeListModification = 0;                              int resourceFileCountAfterListModification = 0;                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountBeforeListModification;                              }                                //Remove a file                              ResourceFile resourceFile = resourceFiles[0];                              resourceFiles.Remove(resourceFile);                                enumerator.Reset();                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountAfterListModification;                              }                                Assert.Equal(resourceFileCountBeforeListModification' resourceFileCountAfterListModification);                                //                              // Get the job and add a task                              //                              const string taskId = "test";                                CloudJob job = jobOperations.GetJob(boundJobSchedule.ExecutionInformation.RecentJob.Id);                                CloudTask unboundTask = new CloudTask("test"' "cmd /c dir");                              unboundTask.EnvironmentSettings = new List<EnvironmentSetting>();                              unboundTask.EnvironmentSettings.Add(new EnvironmentSetting("foo"' "baz"));                                unboundTask.ResourceFiles = new List<ResourceFile>();                              unboundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://foo"' "baz"));                                job.AddTask(unboundTask);                                //Get the bound task                              CloudTask boundTask = job.GetTask(taskId);                                Assert.NotNull(boundTask.ResourceFiles);                              Assert.NotNull(boundTask.EnvironmentSettings);                                //Ensure the task has the correct settings                              Assert.Equal(1' boundTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundTask.ResourceFiles.Count);                                TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.EnvironmentSettings.Add(new EnvironmentSetting("test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => { IList<IFileStagingProvider> filesToStage = boundTask.FilesToStage; });                          }                          finally                          {                              TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jobScheduleId).Wait();                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      const string testName = "Bug1910530_ConcurrentChangeTrackedList";                        PoolOperations poolOperations = batchCli.PoolOperations;                      JobScheduleOperations jobScheduleOperations = batchCli.JobScheduleOperations;                      JobOperations jobOperations = batchCli.JobOperations;                        CloudJobSchedule boundJobSchedule = null;                        {                          string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-" + testName;                          try                          {                              //                              //Test bound pool properties                              //                              CloudPool pool = poolOperations.GetPool(this.poolFixture.PoolId);                              pool.Metadata = new List<MetadataItem>();                              pool.Metadata.Add(new MetadataItem("test"' "test"));                                //Note: We rely on the certificate specific tests to validate certificate references work for us                                pool.Commit();                                pool = poolOperations.GetPool(this.poolFixture.PoolId);                                Assert.Equal(1' pool.Metadata.Count);                                //                              //Unbound job schedule properties                              //                              this.testOutputHelper.WriteLine("Creating job schedule {0}"' jobScheduleId);                              CloudJobSchedule unboundJobSchedule = jobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                                Assert.Null(unboundJobSchedule.Metadata);                                unboundJobSchedule.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                //JobManagerTask                              JobManagerTask jm = new JobManagerTask(id: "JobManagerTask"' commandLine: "cmd /c dir");                                Assert.Null(jm.ResourceFiles);                              Assert.Null(jm.EnvironmentSettings);                                jm.ResourceFiles = new List<ResourceFile> { ResourceFile.FromUrl("http://test"' "test") };                              jm.EnvironmentSettings = new List<EnvironmentSetting> { new EnvironmentSetting("test"' "Test") };                                //StartTask                              StartTask startTask = new StartTask("cmd /c dir");                                Assert.Null(startTask.ResourceFiles);                              Assert.Null(startTask.EnvironmentSettings);                                startTask.EnvironmentSettings = new List<EnvironmentSetting>() { new EnvironmentSetting("test"' "test") };                              startTask.ResourceFiles = new List<ResourceFile>() { ResourceFile.FromUrl("http://test"' "Test") };                                //Pool Specification                              PoolSpecification poolSpecification = new PoolSpecification()                              {                                  TargetDedicatedComputeNodes = 0'                                  VirtualMachineSize = PoolFixture.VMSize'                                  CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily)'                                  StartTask = startTask                              };                                Assert.Null(poolSpecification.Metadata);                              //Note: We rely on the certificate specific tests to validate certificate references work for us                                poolSpecification.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                PoolInformation poolInformation = new PoolInformation()                              {                                  AutoPoolSpecification = new AutoPoolSpecification()                                  {                                      KeepAlive = false'                                      PoolSpecification = poolSpecification'                                      PoolLifetimeOption = PoolLifetimeOption.JobSchedule                                  }                              };                                unboundJobSchedule.JobSpecification = new JobSpecification(poolInformation)                              {                                  JobManagerTask = jm'                              };                                unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(6) };                                unboundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Equal(1' boundJobSchedule.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //                              // Bound job schedule properties                              //                                //Testing addition to existing lists now                              boundJobSchedule.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with more IList stuff added");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                  Assert.Equal(2' boundJobSchedule.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to set to null and ensure that works.                                boundJobSchedule.Metadata = null;                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles = null;                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings = null;                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with some IList stuff removed");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to remove an item from' and ensure that works                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.RemoveAt(0);                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.RemoveAt(1);                                boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = TestUtilities.WaitForJobOnJobSchedule(jobScheduleOperations' jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              //Extra check to ensure we removed the right one                              Assert.Equal("abc"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.First().Name);                              Assert.Equal("test"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.First().Name);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Now take a snapshot and ensure it isn't modified by editing the list after the fact                              IList<ResourceFile> resourceFiles = boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles;                                IEnumerator<ResourceFile> enumerator = resourceFiles.GetEnumerator();                              int resourceFileCountBeforeListModification = 0;                              int resourceFileCountAfterListModification = 0;                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountBeforeListModification;                              }                                //Remove a file                              ResourceFile resourceFile = resourceFiles[0];                              resourceFiles.Remove(resourceFile);                                enumerator.Reset();                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountAfterListModification;                              }                                Assert.Equal(resourceFileCountBeforeListModification' resourceFileCountAfterListModification);                                //                              // Get the job and add a task                              //                              const string taskId = "test";                                CloudJob job = jobOperations.GetJob(boundJobSchedule.ExecutionInformation.RecentJob.Id);                                CloudTask unboundTask = new CloudTask("test"' "cmd /c dir");                              unboundTask.EnvironmentSettings = new List<EnvironmentSetting>();                              unboundTask.EnvironmentSettings.Add(new EnvironmentSetting("foo"' "baz"));                                unboundTask.ResourceFiles = new List<ResourceFile>();                              unboundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://foo"' "baz"));                                job.AddTask(unboundTask);                                //Get the bound task                              CloudTask boundTask = job.GetTask(taskId);                                Assert.NotNull(boundTask.ResourceFiles);                              Assert.NotNull(boundTask.EnvironmentSettings);                                //Ensure the task has the correct settings                              Assert.Equal(1' boundTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundTask.ResourceFiles.Count);                                TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.EnvironmentSettings.Add(new EnvironmentSetting("test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => { IList<IFileStagingProvider> filesToStage = boundTask.FilesToStage; });                          }                          finally                          {                              TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jobScheduleId).Wait();                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      const string testName = "Bug1910530_ConcurrentChangeTrackedList";                        PoolOperations poolOperations = batchCli.PoolOperations;                      JobScheduleOperations jobScheduleOperations = batchCli.JobScheduleOperations;                      JobOperations jobOperations = batchCli.JobOperations;                        CloudJobSchedule boundJobSchedule = null;                        {                          string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-" + testName;                          try                          {                              //                              //Test bound pool properties                              //                              CloudPool pool = poolOperations.GetPool(this.poolFixture.PoolId);                              pool.Metadata = new List<MetadataItem>();                              pool.Metadata.Add(new MetadataItem("test"' "test"));                                //Note: We rely on the certificate specific tests to validate certificate references work for us                                pool.Commit();                                pool = poolOperations.GetPool(this.poolFixture.PoolId);                                Assert.Equal(1' pool.Metadata.Count);                                //                              //Unbound job schedule properties                              //                              this.testOutputHelper.WriteLine("Creating job schedule {0}"' jobScheduleId);                              CloudJobSchedule unboundJobSchedule = jobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                                Assert.Null(unboundJobSchedule.Metadata);                                unboundJobSchedule.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                //JobManagerTask                              JobManagerTask jm = new JobManagerTask(id: "JobManagerTask"' commandLine: "cmd /c dir");                                Assert.Null(jm.ResourceFiles);                              Assert.Null(jm.EnvironmentSettings);                                jm.ResourceFiles = new List<ResourceFile> { ResourceFile.FromUrl("http://test"' "test") };                              jm.EnvironmentSettings = new List<EnvironmentSetting> { new EnvironmentSetting("test"' "Test") };                                //StartTask                              StartTask startTask = new StartTask("cmd /c dir");                                Assert.Null(startTask.ResourceFiles);                              Assert.Null(startTask.EnvironmentSettings);                                startTask.EnvironmentSettings = new List<EnvironmentSetting>() { new EnvironmentSetting("test"' "test") };                              startTask.ResourceFiles = new List<ResourceFile>() { ResourceFile.FromUrl("http://test"' "Test") };                                //Pool Specification                              PoolSpecification poolSpecification = new PoolSpecification()                              {                                  TargetDedicatedComputeNodes = 0'                                  VirtualMachineSize = PoolFixture.VMSize'                                  CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily)'                                  StartTask = startTask                              };                                Assert.Null(poolSpecification.Metadata);                              //Note: We rely on the certificate specific tests to validate certificate references work for us                                poolSpecification.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                PoolInformation poolInformation = new PoolInformation()                              {                                  AutoPoolSpecification = new AutoPoolSpecification()                                  {                                      KeepAlive = false'                                      PoolSpecification = poolSpecification'                                      PoolLifetimeOption = PoolLifetimeOption.JobSchedule                                  }                              };                                unboundJobSchedule.JobSpecification = new JobSpecification(poolInformation)                              {                                  JobManagerTask = jm'                              };                                unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(6) };                                unboundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Equal(1' boundJobSchedule.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //                              // Bound job schedule properties                              //                                //Testing addition to existing lists now                              boundJobSchedule.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with more IList stuff added");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                  Assert.Equal(2' boundJobSchedule.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to set to null and ensure that works.                                boundJobSchedule.Metadata = null;                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles = null;                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings = null;                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with some IList stuff removed");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to remove an item from' and ensure that works                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.RemoveAt(0);                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.RemoveAt(1);                                boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = TestUtilities.WaitForJobOnJobSchedule(jobScheduleOperations' jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              //Extra check to ensure we removed the right one                              Assert.Equal("abc"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.First().Name);                              Assert.Equal("test"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.First().Name);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Now take a snapshot and ensure it isn't modified by editing the list after the fact                              IList<ResourceFile> resourceFiles = boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles;                                IEnumerator<ResourceFile> enumerator = resourceFiles.GetEnumerator();                              int resourceFileCountBeforeListModification = 0;                              int resourceFileCountAfterListModification = 0;                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountBeforeListModification;                              }                                //Remove a file                              ResourceFile resourceFile = resourceFiles[0];                              resourceFiles.Remove(resourceFile);                                enumerator.Reset();                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountAfterListModification;                              }                                Assert.Equal(resourceFileCountBeforeListModification' resourceFileCountAfterListModification);                                //                              // Get the job and add a task                              //                              const string taskId = "test";                                CloudJob job = jobOperations.GetJob(boundJobSchedule.ExecutionInformation.RecentJob.Id);                                CloudTask unboundTask = new CloudTask("test"' "cmd /c dir");                              unboundTask.EnvironmentSettings = new List<EnvironmentSetting>();                              unboundTask.EnvironmentSettings.Add(new EnvironmentSetting("foo"' "baz"));                                unboundTask.ResourceFiles = new List<ResourceFile>();                              unboundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://foo"' "baz"));                                job.AddTask(unboundTask);                                //Get the bound task                              CloudTask boundTask = job.GetTask(taskId);                                Assert.NotNull(boundTask.ResourceFiles);                              Assert.NotNull(boundTask.EnvironmentSettings);                                //Ensure the task has the correct settings                              Assert.Equal(1' boundTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundTask.ResourceFiles.Count);                                TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.EnvironmentSettings.Add(new EnvironmentSetting("test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => { IList<IFileStagingProvider> filesToStage = boundTask.FilesToStage; });                          }                          finally                          {                              TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jobScheduleId).Wait();                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      const string testName = "Bug1910530_ConcurrentChangeTrackedList";                        PoolOperations poolOperations = batchCli.PoolOperations;                      JobScheduleOperations jobScheduleOperations = batchCli.JobScheduleOperations;                      JobOperations jobOperations = batchCli.JobOperations;                        CloudJobSchedule boundJobSchedule = null;                        {                          string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-" + testName;                          try                          {                              //                              //Test bound pool properties                              //                              CloudPool pool = poolOperations.GetPool(this.poolFixture.PoolId);                              pool.Metadata = new List<MetadataItem>();                              pool.Metadata.Add(new MetadataItem("test"' "test"));                                //Note: We rely on the certificate specific tests to validate certificate references work for us                                pool.Commit();                                pool = poolOperations.GetPool(this.poolFixture.PoolId);                                Assert.Equal(1' pool.Metadata.Count);                                //                              //Unbound job schedule properties                              //                              this.testOutputHelper.WriteLine("Creating job schedule {0}"' jobScheduleId);                              CloudJobSchedule unboundJobSchedule = jobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                                Assert.Null(unboundJobSchedule.Metadata);                                unboundJobSchedule.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                //JobManagerTask                              JobManagerTask jm = new JobManagerTask(id: "JobManagerTask"' commandLine: "cmd /c dir");                                Assert.Null(jm.ResourceFiles);                              Assert.Null(jm.EnvironmentSettings);                                jm.ResourceFiles = new List<ResourceFile> { ResourceFile.FromUrl("http://test"' "test") };                              jm.EnvironmentSettings = new List<EnvironmentSetting> { new EnvironmentSetting("test"' "Test") };                                //StartTask                              StartTask startTask = new StartTask("cmd /c dir");                                Assert.Null(startTask.ResourceFiles);                              Assert.Null(startTask.EnvironmentSettings);                                startTask.EnvironmentSettings = new List<EnvironmentSetting>() { new EnvironmentSetting("test"' "test") };                              startTask.ResourceFiles = new List<ResourceFile>() { ResourceFile.FromUrl("http://test"' "Test") };                                //Pool Specification                              PoolSpecification poolSpecification = new PoolSpecification()                              {                                  TargetDedicatedComputeNodes = 0'                                  VirtualMachineSize = PoolFixture.VMSize'                                  CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily)'                                  StartTask = startTask                              };                                Assert.Null(poolSpecification.Metadata);                              //Note: We rely on the certificate specific tests to validate certificate references work for us                                poolSpecification.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                PoolInformation poolInformation = new PoolInformation()                              {                                  AutoPoolSpecification = new AutoPoolSpecification()                                  {                                      KeepAlive = false'                                      PoolSpecification = poolSpecification'                                      PoolLifetimeOption = PoolLifetimeOption.JobSchedule                                  }                              };                                unboundJobSchedule.JobSpecification = new JobSpecification(poolInformation)                              {                                  JobManagerTask = jm'                              };                                unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(6) };                                unboundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Equal(1' boundJobSchedule.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //                              // Bound job schedule properties                              //                                //Testing addition to existing lists now                              boundJobSchedule.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with more IList stuff added");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                  Assert.Equal(2' boundJobSchedule.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to set to null and ensure that works.                                boundJobSchedule.Metadata = null;                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles = null;                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings = null;                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with some IList stuff removed");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to remove an item from' and ensure that works                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.RemoveAt(0);                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.RemoveAt(1);                                boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = TestUtilities.WaitForJobOnJobSchedule(jobScheduleOperations' jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              //Extra check to ensure we removed the right one                              Assert.Equal("abc"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.First().Name);                              Assert.Equal("test"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.First().Name);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Now take a snapshot and ensure it isn't modified by editing the list after the fact                              IList<ResourceFile> resourceFiles = boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles;                                IEnumerator<ResourceFile> enumerator = resourceFiles.GetEnumerator();                              int resourceFileCountBeforeListModification = 0;                              int resourceFileCountAfterListModification = 0;                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountBeforeListModification;                              }                                //Remove a file                              ResourceFile resourceFile = resourceFiles[0];                              resourceFiles.Remove(resourceFile);                                enumerator.Reset();                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountAfterListModification;                              }                                Assert.Equal(resourceFileCountBeforeListModification' resourceFileCountAfterListModification);                                //                              // Get the job and add a task                              //                              const string taskId = "test";                                CloudJob job = jobOperations.GetJob(boundJobSchedule.ExecutionInformation.RecentJob.Id);                                CloudTask unboundTask = new CloudTask("test"' "cmd /c dir");                              unboundTask.EnvironmentSettings = new List<EnvironmentSetting>();                              unboundTask.EnvironmentSettings.Add(new EnvironmentSetting("foo"' "baz"));                                unboundTask.ResourceFiles = new List<ResourceFile>();                              unboundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://foo"' "baz"));                                job.AddTask(unboundTask);                                //Get the bound task                              CloudTask boundTask = job.GetTask(taskId);                                Assert.NotNull(boundTask.ResourceFiles);                              Assert.NotNull(boundTask.EnvironmentSettings);                                //Ensure the task has the correct settings                              Assert.Equal(1' boundTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundTask.ResourceFiles.Count);                                TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.EnvironmentSettings.Add(new EnvironmentSetting("test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => { IList<IFileStagingProvider> filesToStage = boundTask.FilesToStage; });                          }                          finally                          {                              TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jobScheduleId).Wait();                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      const string testName = "Bug1910530_ConcurrentChangeTrackedList";                        PoolOperations poolOperations = batchCli.PoolOperations;                      JobScheduleOperations jobScheduleOperations = batchCli.JobScheduleOperations;                      JobOperations jobOperations = batchCli.JobOperations;                        CloudJobSchedule boundJobSchedule = null;                        {                          string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-" + testName;                          try                          {                              //                              //Test bound pool properties                              //                              CloudPool pool = poolOperations.GetPool(this.poolFixture.PoolId);                              pool.Metadata = new List<MetadataItem>();                              pool.Metadata.Add(new MetadataItem("test"' "test"));                                //Note: We rely on the certificate specific tests to validate certificate references work for us                                pool.Commit();                                pool = poolOperations.GetPool(this.poolFixture.PoolId);                                Assert.Equal(1' pool.Metadata.Count);                                //                              //Unbound job schedule properties                              //                              this.testOutputHelper.WriteLine("Creating job schedule {0}"' jobScheduleId);                              CloudJobSchedule unboundJobSchedule = jobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                                Assert.Null(unboundJobSchedule.Metadata);                                unboundJobSchedule.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                //JobManagerTask                              JobManagerTask jm = new JobManagerTask(id: "JobManagerTask"' commandLine: "cmd /c dir");                                Assert.Null(jm.ResourceFiles);                              Assert.Null(jm.EnvironmentSettings);                                jm.ResourceFiles = new List<ResourceFile> { ResourceFile.FromUrl("http://test"' "test") };                              jm.EnvironmentSettings = new List<EnvironmentSetting> { new EnvironmentSetting("test"' "Test") };                                //StartTask                              StartTask startTask = new StartTask("cmd /c dir");                                Assert.Null(startTask.ResourceFiles);                              Assert.Null(startTask.EnvironmentSettings);                                startTask.EnvironmentSettings = new List<EnvironmentSetting>() { new EnvironmentSetting("test"' "test") };                              startTask.ResourceFiles = new List<ResourceFile>() { ResourceFile.FromUrl("http://test"' "Test") };                                //Pool Specification                              PoolSpecification poolSpecification = new PoolSpecification()                              {                                  TargetDedicatedComputeNodes = 0'                                  VirtualMachineSize = PoolFixture.VMSize'                                  CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily)'                                  StartTask = startTask                              };                                Assert.Null(poolSpecification.Metadata);                              //Note: We rely on the certificate specific tests to validate certificate references work for us                                poolSpecification.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                PoolInformation poolInformation = new PoolInformation()                              {                                  AutoPoolSpecification = new AutoPoolSpecification()                                  {                                      KeepAlive = false'                                      PoolSpecification = poolSpecification'                                      PoolLifetimeOption = PoolLifetimeOption.JobSchedule                                  }                              };                                unboundJobSchedule.JobSpecification = new JobSpecification(poolInformation)                              {                                  JobManagerTask = jm'                              };                                unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(6) };                                unboundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Equal(1' boundJobSchedule.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //                              // Bound job schedule properties                              //                                //Testing addition to existing lists now                              boundJobSchedule.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with more IList stuff added");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                  Assert.Equal(2' boundJobSchedule.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to set to null and ensure that works.                                boundJobSchedule.Metadata = null;                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles = null;                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings = null;                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with some IList stuff removed");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to remove an item from' and ensure that works                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.RemoveAt(0);                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.RemoveAt(1);                                boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = TestUtilities.WaitForJobOnJobSchedule(jobScheduleOperations' jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              //Extra check to ensure we removed the right one                              Assert.Equal("abc"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.First().Name);                              Assert.Equal("test"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.First().Name);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Now take a snapshot and ensure it isn't modified by editing the list after the fact                              IList<ResourceFile> resourceFiles = boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles;                                IEnumerator<ResourceFile> enumerator = resourceFiles.GetEnumerator();                              int resourceFileCountBeforeListModification = 0;                              int resourceFileCountAfterListModification = 0;                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountBeforeListModification;                              }                                //Remove a file                              ResourceFile resourceFile = resourceFiles[0];                              resourceFiles.Remove(resourceFile);                                enumerator.Reset();                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountAfterListModification;                              }                                Assert.Equal(resourceFileCountBeforeListModification' resourceFileCountAfterListModification);                                //                              // Get the job and add a task                              //                              const string taskId = "test";                                CloudJob job = jobOperations.GetJob(boundJobSchedule.ExecutionInformation.RecentJob.Id);                                CloudTask unboundTask = new CloudTask("test"' "cmd /c dir");                              unboundTask.EnvironmentSettings = new List<EnvironmentSetting>();                              unboundTask.EnvironmentSettings.Add(new EnvironmentSetting("foo"' "baz"));                                unboundTask.ResourceFiles = new List<ResourceFile>();                              unboundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://foo"' "baz"));                                job.AddTask(unboundTask);                                //Get the bound task                              CloudTask boundTask = job.GetTask(taskId);                                Assert.NotNull(boundTask.ResourceFiles);                              Assert.NotNull(boundTask.EnvironmentSettings);                                //Ensure the task has the correct settings                              Assert.Equal(1' boundTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundTask.ResourceFiles.Count);                                TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.EnvironmentSettings.Add(new EnvironmentSetting("test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => { IList<IFileStagingProvider> filesToStage = boundTask.FilesToStage; });                          }                          finally                          {                              TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jobScheduleId).Wait();                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,ObjectModelFeatureIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1910530_ConcurrentChangeTrackedList,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      const string testName = "Bug1910530_ConcurrentChangeTrackedList";                        PoolOperations poolOperations = batchCli.PoolOperations;                      JobScheduleOperations jobScheduleOperations = batchCli.JobScheduleOperations;                      JobOperations jobOperations = batchCli.JobOperations;                        CloudJobSchedule boundJobSchedule = null;                        {                          string jobScheduleId = Microsoft.Azure.Batch.Constants.DefaultConveniencePrefix + TestUtilities.GetMyName() + "-" + testName;                          try                          {                              //                              //Test bound pool properties                              //                              CloudPool pool = poolOperations.GetPool(this.poolFixture.PoolId);                              pool.Metadata = new List<MetadataItem>();                              pool.Metadata.Add(new MetadataItem("test"' "test"));                                //Note: We rely on the certificate specific tests to validate certificate references work for us                                pool.Commit();                                pool = poolOperations.GetPool(this.poolFixture.PoolId);                                Assert.Equal(1' pool.Metadata.Count);                                //                              //Unbound job schedule properties                              //                              this.testOutputHelper.WriteLine("Creating job schedule {0}"' jobScheduleId);                              CloudJobSchedule unboundJobSchedule = jobScheduleOperations.CreateJobSchedule(jobScheduleId' null' null);                                Assert.Null(unboundJobSchedule.Metadata);                                unboundJobSchedule.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                //JobManagerTask                              JobManagerTask jm = new JobManagerTask(id: "JobManagerTask"' commandLine: "cmd /c dir");                                Assert.Null(jm.ResourceFiles);                              Assert.Null(jm.EnvironmentSettings);                                jm.ResourceFiles = new List<ResourceFile> { ResourceFile.FromUrl("http://test"' "test") };                              jm.EnvironmentSettings = new List<EnvironmentSetting> { new EnvironmentSetting("test"' "Test") };                                //StartTask                              StartTask startTask = new StartTask("cmd /c dir");                                Assert.Null(startTask.ResourceFiles);                              Assert.Null(startTask.EnvironmentSettings);                                startTask.EnvironmentSettings = new List<EnvironmentSetting>() { new EnvironmentSetting("test"' "test") };                              startTask.ResourceFiles = new List<ResourceFile>() { ResourceFile.FromUrl("http://test"' "Test") };                                //Pool Specification                              PoolSpecification poolSpecification = new PoolSpecification()                              {                                  TargetDedicatedComputeNodes = 0'                                  VirtualMachineSize = PoolFixture.VMSize'                                  CloudServiceConfiguration = new CloudServiceConfiguration(PoolFixture.OSFamily)'                                  StartTask = startTask                              };                                Assert.Null(poolSpecification.Metadata);                              //Note: We rely on the certificate specific tests to validate certificate references work for us                                poolSpecification.Metadata = new List<MetadataItem>() { new MetadataItem("test"' "test") };                                PoolInformation poolInformation = new PoolInformation()                              {                                  AutoPoolSpecification = new AutoPoolSpecification()                                  {                                      KeepAlive = false'                                      PoolSpecification = poolSpecification'                                      PoolLifetimeOption = PoolLifetimeOption.JobSchedule                                  }                              };                                unboundJobSchedule.JobSpecification = new JobSpecification(poolInformation)                              {                                  JobManagerTask = jm'                              };                                unboundJobSchedule.Schedule = new Schedule() { RecurrenceInterval = TimeSpan.FromMinutes(6) };                                unboundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Equal(1' boundJobSchedule.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //                              // Bound job schedule properties                              //                                //Testing addition to existing lists now                              boundJobSchedule.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Add(new MetadataItem("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Add(new EnvironmentSetting("abc"' "abc"));                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Add(ResourceFile.FromUrl("http://abc"' "abc"));                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with more IList stuff added");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were set correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                  Assert.Equal(2' boundJobSchedule.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to set to null and ensure that works.                                boundJobSchedule.Metadata = null;                              boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles = null;                              boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings = null;                                this.testOutputHelper.WriteLine("Commiting updated Job Schedule with some IList stuff removed");                              boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = jobScheduleOperations.GetJobSchedule(jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Choose some properties on the job schedule to remove an item from' and ensure that works                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.RemoveAt(0);                              boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.RemoveAt(1);                                boundJobSchedule.Commit();                                this.testOutputHelper.WriteLine("Getting job schedule to ensure that IList properties were removed correctly on server");                              boundJobSchedule = TestUtilities.WaitForJobOnJobSchedule(jobScheduleOperations' jobScheduleId);                                Assert.Null(boundJobSchedule.Metadata);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.EnvironmentSettings);                              Assert.Null(boundJobSchedule.JobSpecification.JobManagerTask.ResourceFiles);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.Count);                              Assert.Equal(1' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.Count);                              //Extra check to ensure we removed the right one                              Assert.Equal("abc"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.Metadata.First().Name);                              Assert.Equal("test"' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.EnvironmentSettings.First().Name);                              Assert.Equal(2' boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles.Count);                                //Now take a snapshot and ensure it isn't modified by editing the list after the fact                              IList<ResourceFile> resourceFiles = boundJobSchedule.JobSpecification.PoolInformation.AutoPoolSpecification.PoolSpecification.StartTask.ResourceFiles;                                IEnumerator<ResourceFile> enumerator = resourceFiles.GetEnumerator();                              int resourceFileCountBeforeListModification = 0;                              int resourceFileCountAfterListModification = 0;                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountBeforeListModification;                              }                                //Remove a file                              ResourceFile resourceFile = resourceFiles[0];                              resourceFiles.Remove(resourceFile);                                enumerator.Reset();                              while (enumerator.MoveNext())                              {                                  ++resourceFileCountAfterListModification;                              }                                Assert.Equal(resourceFileCountBeforeListModification' resourceFileCountAfterListModification);                                //                              // Get the job and add a task                              //                              const string taskId = "test";                                CloudJob job = jobOperations.GetJob(boundJobSchedule.ExecutionInformation.RecentJob.Id);                                CloudTask unboundTask = new CloudTask("test"' "cmd /c dir");                              unboundTask.EnvironmentSettings = new List<EnvironmentSetting>();                              unboundTask.EnvironmentSettings.Add(new EnvironmentSetting("foo"' "baz"));                                unboundTask.ResourceFiles = new List<ResourceFile>();                              unboundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://foo"' "baz"));                                job.AddTask(unboundTask);                                //Get the bound task                              CloudTask boundTask = job.GetTask(taskId);                                Assert.NotNull(boundTask.ResourceFiles);                              Assert.NotNull(boundTask.EnvironmentSettings);                                //Ensure the task has the correct settings                              Assert.Equal(1' boundTask.EnvironmentSettings.Count);                              Assert.Equal(1' boundTask.ResourceFiles.Count);                                TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.EnvironmentSettings.Add(new EnvironmentSetting("test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => boundTask.ResourceFiles.Add(ResourceFile.FromUrl("http://test"' "test")));                              TestUtilities.AssertThrows<InvalidOperationException>(() => { IList<IFileStagingProvider> filesToStage = boundTask.FilesToStage; });                          }                          finally                          {                              TestUtilities.DeleteJobScheduleIfExistsAsync(batchCli' jobScheduleId).Wait();                          }                      }                  }              };
Magic Number,BatchClientIntegrationTests,Bug957878ReplacementInterceptorBox,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug957878RequestReplacementInterceptorOpContextFactory,The following statement contains a magic number: strongTypedBatchRequest.Options.MaxResults = 5;
Magic Number,BatchClientIntegrationTests,IntegrationObjectModelFeatureTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1770942ExposeBatchRequestProperties,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      List<string> poolIdsToCreate = new List<string>();                      const int numPoolsToCreate = 10;                        // create some pools that can be listed and filtered                      for (int i = 0; i < numPoolsToCreate; i++)                      {                          string name;                            if (1 == (i % 2))                          {                              name = "Odd-Bug1770942-";                          }                          else                          {                              name = "Even-Bug1770942-";                          }                            // add my name for visibile accounting                          name += i + "-" + TestUtilities.GetMyName();                            poolIdsToCreate.Add(name);                      }                        try                      {                          // Pool tests                            // test custom retry policy per-call                          {                              CloudPool unboundPool = batchCli.PoolOperations.CreatePool(                                  @"really/\bad+&*pool_^#name" + TestUtilities.GetMyName()'                                  PoolFixture.VMSize'                                  new CloudServiceConfiguration(PoolFixture.OSFamily)'                                  targetDedicatedComputeNodes: 0);                              Bug1770942RetryPolicy retryPolicy = new Bug1770942RetryPolicy(this.testOutputHelper);                                // confirm there is a default retry policy                              // EnforceThereIsOnlyOneRetry(unboundPool.CustomBehaviors);                                // test perCall RetryPolicy                              TestUtilities.AssertThrows<BatchException>(() => unboundPool.Commit(new[] { new RetryPolicyProvider(retryPolicy) }));                                // confirm retry policy was used                              Assert.Equal(3' retryPolicy.NumTimesCalled);                          }                            // test ListPools ODATA predicate                          {                              // create some pools that can be listed and filtered                              foreach (string poolId in poolIdsToCreate)                              {                                  // no compute nodes because this is only a list/predicate test                                  CloudPool unboundPool = batchCli.PoolOperations.CreatePool(                                      poolId'                                      PoolFixture.VMSize'                                      new CloudServiceConfiguration(PoolFixture.OSFamily)'                                      targetDedicatedComputeNodes: 0);                                    unboundPool.Commit();                              }                                this.testOutputHelper.WriteLine("All pools: ");                                var allPools = batchCli.PoolOperations.ListPools();                                TestUtilities.DisplayPools(this.testOutputHelper' allPools);                                // get odd list' also test select                              var oddIEnum =                                  batchCli.PoolOperations.ListPools(new ODATADetailLevel()                                  {                                      FilterClause = "startswith(id' 'Odd')"'                                      SelectClause = "id'state"                                  });                              List<CloudPool> oddList = new List<CloudPool>(oddIEnum);                                this.testOutputHelper.WriteLine("Odd Pools:");                                TestUtilities.DisplayPools(this.testOutputHelper' oddIEnum);                                // get even list' also test select                              var evenIEnum =                                  batchCli.PoolOperations.ListPools(new ODATADetailLevel()                                  {                                      FilterClause = "startswith(id' 'Even')"'                                      SelectClause = "id'state"                                  });                              List<CloudPool> evenList = new List<CloudPool>(evenIEnum);                                this.testOutputHelper.WriteLine("Even Pools:");                                TestUtilities.DisplayPools(this.testOutputHelper' evenIEnum);                                Assert.Equal(numPoolsToCreate' (oddList.Count + evenList.Count));                                // test that select worked                                // pick one                              CloudPool fewerDetails = oddList[0];                              CloudPool matchingPoolWithFullDetailLevel = null;                                // find in complete (which has no DetailLevel set and should have all props) list and compare detail level                              foreach (CloudPool curPool in allPools)                              {                                  if (curPool.Id.Equals(fewerDetails.Id' StringComparison.InvariantCultureIgnoreCase))                                  {                                      matchingPoolWithFullDetailLevel = curPool;                                        // confirm detail level is different between instances                                      Assert.NotEqual(curPool.AllocationState' fewerDetails.AllocationState);                                      break;                                  }                              }                                // confirm that a match was actually found.                              Assert.NotNull(matchingPoolWithFullDetailLevel);                                /////////////////////////////////////////////////////////////                                // test select works on poolMgr.GetPool                              // we have the matching instance with full props from list-all' and selected props from list+DetailLevel                              // now test poolMgr.GetPool + detailLevel                                CloudPool lowerDetailLevel = batchCli.PoolOperations.GetPool(matchingPoolWithFullDetailLevel.Id' new ODATADetailLevel() { SelectClause = "id'state" });                                // confirm that allocation state was not read in                              Assert.Null(lowerDetailLevel.AllocationState);                                matchingPoolWithFullDetailLevel.Refresh();                                // confirm full props have good prop value                              Assert.Equal(AllocationState.Steady' matchingPoolWithFullDetailLevel.AllocationState);                                //////////////////////////////////////////////////////                              //                              // test that pool.Refresh() can change the detail level                              // use "matching..." which has all props and "lowerDetailLevel" which has restricted props                                matchingPoolWithFullDetailLevel.Refresh(detailLevel: new ODATADetailLevel() { SelectClause = "id'state" });                                // confirm detail level is lower now                              Assert.Null(matchingPoolWithFullDetailLevel.AllocationState);                                // return to full props via refresh()                                matchingPoolWithFullDetailLevel.Refresh();                                Assert.Equal(AllocationState.Steady' matchingPoolWithFullDetailLevel.AllocationState);                            }                      }                      finally                      {                          // clean up                          List<Task> deletePoolTasks = new List<Task>();                          foreach (string poolId in poolIdsToCreate)                          {                              Task t = TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId);                              deletePoolTasks.Add(t);                          }                            Task.WhenAll(deletePoolTasks).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationObjectModelFeatureTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1770942ExposeBatchRequestProperties,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      List<string> poolIdsToCreate = new List<string>();                      const int numPoolsToCreate = 10;                        // create some pools that can be listed and filtered                      for (int i = 0; i < numPoolsToCreate; i++)                      {                          string name;                            if (1 == (i % 2))                          {                              name = "Odd-Bug1770942-";                          }                          else                          {                              name = "Even-Bug1770942-";                          }                            // add my name for visibile accounting                          name += i + "-" + TestUtilities.GetMyName();                            poolIdsToCreate.Add(name);                      }                        try                      {                          // Pool tests                            // test custom retry policy per-call                          {                              CloudPool unboundPool = batchCli.PoolOperations.CreatePool(                                  @"really/\bad+&*pool_^#name" + TestUtilities.GetMyName()'                                  PoolFixture.VMSize'                                  new CloudServiceConfiguration(PoolFixture.OSFamily)'                                  targetDedicatedComputeNodes: 0);                              Bug1770942RetryPolicy retryPolicy = new Bug1770942RetryPolicy(this.testOutputHelper);                                // confirm there is a default retry policy                              // EnforceThereIsOnlyOneRetry(unboundPool.CustomBehaviors);                                // test perCall RetryPolicy                              TestUtilities.AssertThrows<BatchException>(() => unboundPool.Commit(new[] { new RetryPolicyProvider(retryPolicy) }));                                // confirm retry policy was used                              Assert.Equal(3' retryPolicy.NumTimesCalled);                          }                            // test ListPools ODATA predicate                          {                              // create some pools that can be listed and filtered                              foreach (string poolId in poolIdsToCreate)                              {                                  // no compute nodes because this is only a list/predicate test                                  CloudPool unboundPool = batchCli.PoolOperations.CreatePool(                                      poolId'                                      PoolFixture.VMSize'                                      new CloudServiceConfiguration(PoolFixture.OSFamily)'                                      targetDedicatedComputeNodes: 0);                                    unboundPool.Commit();                              }                                this.testOutputHelper.WriteLine("All pools: ");                                var allPools = batchCli.PoolOperations.ListPools();                                TestUtilities.DisplayPools(this.testOutputHelper' allPools);                                // get odd list' also test select                              var oddIEnum =                                  batchCli.PoolOperations.ListPools(new ODATADetailLevel()                                  {                                      FilterClause = "startswith(id' 'Odd')"'                                      SelectClause = "id'state"                                  });                              List<CloudPool> oddList = new List<CloudPool>(oddIEnum);                                this.testOutputHelper.WriteLine("Odd Pools:");                                TestUtilities.DisplayPools(this.testOutputHelper' oddIEnum);                                // get even list' also test select                              var evenIEnum =                                  batchCli.PoolOperations.ListPools(new ODATADetailLevel()                                  {                                      FilterClause = "startswith(id' 'Even')"'                                      SelectClause = "id'state"                                  });                              List<CloudPool> evenList = new List<CloudPool>(evenIEnum);                                this.testOutputHelper.WriteLine("Even Pools:");                                TestUtilities.DisplayPools(this.testOutputHelper' evenIEnum);                                Assert.Equal(numPoolsToCreate' (oddList.Count + evenList.Count));                                // test that select worked                                // pick one                              CloudPool fewerDetails = oddList[0];                              CloudPool matchingPoolWithFullDetailLevel = null;                                // find in complete (which has no DetailLevel set and should have all props) list and compare detail level                              foreach (CloudPool curPool in allPools)                              {                                  if (curPool.Id.Equals(fewerDetails.Id' StringComparison.InvariantCultureIgnoreCase))                                  {                                      matchingPoolWithFullDetailLevel = curPool;                                        // confirm detail level is different between instances                                      Assert.NotEqual(curPool.AllocationState' fewerDetails.AllocationState);                                      break;                                  }                              }                                // confirm that a match was actually found.                              Assert.NotNull(matchingPoolWithFullDetailLevel);                                /////////////////////////////////////////////////////////////                                // test select works on poolMgr.GetPool                              // we have the matching instance with full props from list-all' and selected props from list+DetailLevel                              // now test poolMgr.GetPool + detailLevel                                CloudPool lowerDetailLevel = batchCli.PoolOperations.GetPool(matchingPoolWithFullDetailLevel.Id' new ODATADetailLevel() { SelectClause = "id'state" });                                // confirm that allocation state was not read in                              Assert.Null(lowerDetailLevel.AllocationState);                                matchingPoolWithFullDetailLevel.Refresh();                                // confirm full props have good prop value                              Assert.Equal(AllocationState.Steady' matchingPoolWithFullDetailLevel.AllocationState);                                //////////////////////////////////////////////////////                              //                              // test that pool.Refresh() can change the detail level                              // use "matching..." which has all props and "lowerDetailLevel" which has restricted props                                matchingPoolWithFullDetailLevel.Refresh(detailLevel: new ODATADetailLevel() { SelectClause = "id'state" });                                // confirm detail level is lower now                              Assert.Null(matchingPoolWithFullDetailLevel.AllocationState);                                // return to full props via refresh()                                matchingPoolWithFullDetailLevel.Refresh();                                Assert.Equal(AllocationState.Steady' matchingPoolWithFullDetailLevel.AllocationState);                            }                      }                      finally                      {                          // clean up                          List<Task> deletePoolTasks = new List<Task>();                          foreach (string poolId in poolIdsToCreate)                          {                              Task t = TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId);                              deletePoolTasks.Add(t);                          }                            Task.WhenAll(deletePoolTasks).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,IntegrationObjectModelFeatureTestsWithoutSharedPool,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,Bug1770942ExposeBatchRequestProperties,The following statement contains a magic number: Action test = () =>              {                  using (BatchClient batchCli = TestUtilities.OpenBatchClient(TestUtilities.GetCredentialsFromEnvironment()))                  {                      List<string> poolIdsToCreate = new List<string>();                      const int numPoolsToCreate = 10;                        // create some pools that can be listed and filtered                      for (int i = 0; i < numPoolsToCreate; i++)                      {                          string name;                            if (1 == (i % 2))                          {                              name = "Odd-Bug1770942-";                          }                          else                          {                              name = "Even-Bug1770942-";                          }                            // add my name for visibile accounting                          name += i + "-" + TestUtilities.GetMyName();                            poolIdsToCreate.Add(name);                      }                        try                      {                          // Pool tests                            // test custom retry policy per-call                          {                              CloudPool unboundPool = batchCli.PoolOperations.CreatePool(                                  @"really/\bad+&*pool_^#name" + TestUtilities.GetMyName()'                                  PoolFixture.VMSize'                                  new CloudServiceConfiguration(PoolFixture.OSFamily)'                                  targetDedicatedComputeNodes: 0);                              Bug1770942RetryPolicy retryPolicy = new Bug1770942RetryPolicy(this.testOutputHelper);                                // confirm there is a default retry policy                              // EnforceThereIsOnlyOneRetry(unboundPool.CustomBehaviors);                                // test perCall RetryPolicy                              TestUtilities.AssertThrows<BatchException>(() => unboundPool.Commit(new[] { new RetryPolicyProvider(retryPolicy) }));                                // confirm retry policy was used                              Assert.Equal(3' retryPolicy.NumTimesCalled);                          }                            // test ListPools ODATA predicate                          {                              // create some pools that can be listed and filtered                              foreach (string poolId in poolIdsToCreate)                              {                                  // no compute nodes because this is only a list/predicate test                                  CloudPool unboundPool = batchCli.PoolOperations.CreatePool(                                      poolId'                                      PoolFixture.VMSize'                                      new CloudServiceConfiguration(PoolFixture.OSFamily)'                                      targetDedicatedComputeNodes: 0);                                    unboundPool.Commit();                              }                                this.testOutputHelper.WriteLine("All pools: ");                                var allPools = batchCli.PoolOperations.ListPools();                                TestUtilities.DisplayPools(this.testOutputHelper' allPools);                                // get odd list' also test select                              var oddIEnum =                                  batchCli.PoolOperations.ListPools(new ODATADetailLevel()                                  {                                      FilterClause = "startswith(id' 'Odd')"'                                      SelectClause = "id'state"                                  });                              List<CloudPool> oddList = new List<CloudPool>(oddIEnum);                                this.testOutputHelper.WriteLine("Odd Pools:");                                TestUtilities.DisplayPools(this.testOutputHelper' oddIEnum);                                // get even list' also test select                              var evenIEnum =                                  batchCli.PoolOperations.ListPools(new ODATADetailLevel()                                  {                                      FilterClause = "startswith(id' 'Even')"'                                      SelectClause = "id'state"                                  });                              List<CloudPool> evenList = new List<CloudPool>(evenIEnum);                                this.testOutputHelper.WriteLine("Even Pools:");                                TestUtilities.DisplayPools(this.testOutputHelper' evenIEnum);                                Assert.Equal(numPoolsToCreate' (oddList.Count + evenList.Count));                                // test that select worked                                // pick one                              CloudPool fewerDetails = oddList[0];                              CloudPool matchingPoolWithFullDetailLevel = null;                                // find in complete (which has no DetailLevel set and should have all props) list and compare detail level                              foreach (CloudPool curPool in allPools)                              {                                  if (curPool.Id.Equals(fewerDetails.Id' StringComparison.InvariantCultureIgnoreCase))                                  {                                      matchingPoolWithFullDetailLevel = curPool;                                        // confirm detail level is different between instances                                      Assert.NotEqual(curPool.AllocationState' fewerDetails.AllocationState);                                      break;                                  }                              }                                // confirm that a match was actually found.                              Assert.NotNull(matchingPoolWithFullDetailLevel);                                /////////////////////////////////////////////////////////////                                // test select works on poolMgr.GetPool                              // we have the matching instance with full props from list-all' and selected props from list+DetailLevel                              // now test poolMgr.GetPool + detailLevel                                CloudPool lowerDetailLevel = batchCli.PoolOperations.GetPool(matchingPoolWithFullDetailLevel.Id' new ODATADetailLevel() { SelectClause = "id'state" });                                // confirm that allocation state was not read in                              Assert.Null(lowerDetailLevel.AllocationState);                                matchingPoolWithFullDetailLevel.Refresh();                                // confirm full props have good prop value                              Assert.Equal(AllocationState.Steady' matchingPoolWithFullDetailLevel.AllocationState);                                //////////////////////////////////////////////////////                              //                              // test that pool.Refresh() can change the detail level                              // use "matching..." which has all props and "lowerDetailLevel" which has restricted props                                matchingPoolWithFullDetailLevel.Refresh(detailLevel: new ODATADetailLevel() { SelectClause = "id'state" });                                // confirm detail level is lower now                              Assert.Null(matchingPoolWithFullDetailLevel.AllocationState);                                // return to full props via refresh()                                matchingPoolWithFullDetailLevel.Refresh();                                Assert.Equal(AllocationState.Steady' matchingPoolWithFullDetailLevel.AllocationState);                            }                      }                      finally                      {                          // clean up                          List<Task> deletePoolTasks = new List<Task>();                          foreach (string poolId in poolIdsToCreate)                          {                              Task t = TestUtilities.DeletePoolIfExistsAsync(batchCli' poolId);                              deletePoolTasks.Add(t);                          }                            Task.WhenAll(deletePoolTasks).Wait();                      }                  }              };
Magic Number,BatchClientIntegrationTests,Bug1770942RetryPolicy,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\ObjectModelFeatureIntegrationTests.cs,ShouldRetryAsync,The following statement contains a magic number: operationContext.RequestResults.Count < 3
Magic Number,BatchClientIntegrationTests,TaskDependencyIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\TaskDependencyIntegrationTests.cs,CanSpecifyTaskDependencyIds,The following statement contains a magic number: IList<TaskIdRange> taskIdRanges = new List<TaskIdRange>                      {                          new TaskIdRange(1' 5)'                          new TaskIdRange(8' 8)                      };
Magic Number,BatchClientIntegrationTests,TaskDependencyIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\TaskDependencyIntegrationTests.cs,CanSpecifyTaskDependencyIds,The following statement contains a magic number: IList<TaskIdRange> taskIdRanges = new List<TaskIdRange>                      {                          new TaskIdRange(1' 5)'                          new TaskIdRange(8' 8)                      };
Magic Number,BatchClientIntegrationTests,TaskDependencyIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\TaskDependencyIntegrationTests.cs,CanSpecifyTaskDependencyIds,The following statement contains a magic number: IList<TaskIdRange> taskIdRanges = new List<TaskIdRange>                      {                          new TaskIdRange(1' 5)'                          new TaskIdRange(8' 8)                      };
Magic Number,BatchClientIntegrationTests,TaskDependencyIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\TaskDependencyIntegrationTests.cs,CanSpecifyTaskDependencyIds,The following statement contains a magic number: Assert.Equal(5' dependedOnRange.End);
Magic Number,BatchClientIntegrationTests.Application,ApplicationPackagesReferencesIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationPackagesReferencesIntegrationTests.cs,CanCreateAndUpdateJobScheduleWithApplicationReferences,The following statement contains a magic number: Schedule schedule = new Schedule { DoNotRunAfter = DateTime.UtcNow.AddMinutes(5)' RecurrenceInterval = TimeSpan.FromMinutes(2) };
Magic Number,BatchClientIntegrationTests.Application,ApplicationPackagesReferencesIntegrationTests,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Application\ApplicationPackagesReferencesIntegrationTests.cs,CanCreateAndUpdateJobScheduleWithApplicationReferences,The following statement contains a magic number: Schedule schedule = new Schedule { DoNotRunAfter = DateTime.UtcNow.AddMinutes(5)' RecurrenceInterval = TimeSpan.FromMinutes(2) };
Magic Number,BatchClientIntegrationTests.Fixtures,PoolFixture,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Fixtures\PoolFixture.cs,WaitForPoolAllocation,The following statement contains a magic number: TimeSpan computeNodeAllocationTimeout = TimeSpan.FromMinutes(10);
Magic Number,BatchClientIntegrationTests.Fixtures,PoolFixture,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Fixtures\PoolFixture.cs,WaitForPoolAllocation,The following statement contains a magic number: TimeSpan computeNodeSteadyTimeout = TimeSpan.FromMinutes(25);
Magic Number,BatchClientIntegrationTests.Fixtures,PoolFixture,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\Fixtures\PoolFixture.cs,WaitForPoolAllocation,The following statement contains a magic number: Thread.Sleep(TimeSpan.FromSeconds(10));
Magic Number,BatchClientIntegrationTests.IntegrationTestUtilities,FileToStage,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\FileUploadUtilities.cs,CreateDefaultBlobContainerAndSASIfNeededReturnAsync,The following statement contains a magic number: DateTime expiredAtTime = startTime + new TimeSpan(24 /* hrs*/' 0' 0);
Magic Number,BatchClientIntegrationTests.IntegrationTestUtilities,FileStagingLinkedSources,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\FileUploadUtilities.cs,ConstructDefaultName,The following statement contains a magic number: Thread.Sleep(30);
Magic Number,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,GenerateResourceId,The following statement contains a magic number: int actualMaxLength = maxLength ?? 50;
Magic Number,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,WaitForJobStateAsync,The following statement contains a magic number: await Task.Delay(TimeSpan.FromSeconds(5)).ConfigureAwait(false);
Magic Number,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,RefreshBasedPollingWithTimeoutAsync,The following statement contains a magic number: await Task.Delay(TimeSpan.FromSeconds(10)).ConfigureAwait(continueOnCapturedContext: false);
Magic Number,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,DeleteCertMonitor,The following statement contains a magic number: System.Threading.Thread.Sleep(5000);
Magic Number,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,HelloWorld,The following statement contains a magic number: taskStateMonitor.WaitAll(                      boundJob.ListTasks()'                      TaskState.Completed'                      TimeSpan.FromMinutes(3));
Magic Number,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,WaitForJobOnJobSchedule,The following statement contains a magic number: TimeSpan jobCreationTimeout = timeout ?? TimeSpan.FromSeconds(30);
Magic Number,BatchClientIntegrationTests.IntegrationTestUtilities,TestUtilities,D:\research\architectureSmells\repos\Azure_azure-sdk-for-net\sdk\batch\Microsoft.Azure.Batch\tests\IntegrationTests\IntegrationTestUtilities\TestUtilities.cs,WaitForJobOnJobSchedule,The following statement contains a magic number: Thread.Sleep(TimeSpan.FromSeconds(10));
