Implementation smell,Namespace,Class,File,Method,Description
Long Method,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findMdlMaterials,The method has 106 lines of code.
Long Method,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findBspUtilityFiles,The method has 151 lines of code.
Complex Method,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findMdlMaterials,Cyclomatic complexity of the method is 17
Complex Method,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,Cyclomatic complexity of the method is 8
Complex Method,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findBspUtilityFiles,Cyclomatic complexity of the method is 30
Complex Method,CompilePalX.Compilers.BSPPack,BSP,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\BSP.cs,buildEntTextureList,Cyclomatic complexity of the method is 11
Complex Method,CompilePalX.Compilers.BSPPack,BSP,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\BSP.cs,buildModelList,Cyclomatic complexity of the method is 9
Complex Method,CompilePalX.Compilers.BSPPack,PakFile,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\PakFile.cs,PakFile,Cyclomatic complexity of the method is 27
Complex Method,CompilePalX.Compilers.BSPPack,BSPPack,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\Pack.cs,GetSourceDirectories,Cyclomatic complexity of the method is 9
Complex Method,CompilePalX,LaunchWindow,C:\repos\ruarai_CompilePal\CompilePalX\GameConfiguration\LaunchWindow.xaml.cs,LaunchWindow,Cyclomatic complexity of the method is 10
Complex Method,CompilePalX,ConfigurationManager,C:\repos\ruarai_CompilePal\CompilePalX\Configuration\ConfigurationManager.cs,AssemblePresets,Cyclomatic complexity of the method is 8
Long Statement,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,vmtPathParser,The length of the statement  "            vmtline = vmtline.Split(new string[] { "materials/" }' StringSplitOptions.RemoveEmptyEntries)[0];// removes materials/ for consistency " is 134.
Long Statement,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findBspUtilityFiles,The length of the statement  "            Dictionary<string' string>  pd_ent = bsp.entityList.FirstOrDefault(item => item["classname"] == "tf_logic_player_destruction"); " is 127.
Long Statement,CompilePalX.Compilers,NavProcess,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\NavProcess.cs,Run,The length of the statement  "            string args = "-game \"" + context.Configuration.GameFolder + "\" -windowed -novid -nosound +log 0 +sv_logflush 1 +sv_cheats 1 +map " + mapname; " is 144.
Long Statement,CompilePalX.Compilers,NavProcess,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\NavProcess.cs,Run,The length of the statement  "            using (TextReader tr = new StreamReader(File.Open(mapLogPath' FileMode.OpenOrCreate' FileAccess.Read' FileShare.ReadWrite))) " is 124.
Long Statement,CompilePalX.Compilers,CubemapProcess,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\CubemapProcess.cs,Run,The length of the statement  "                string args = "-game \"" + context.Configuration.GameFolder + "\" -windowed -novid -nosound +mat_specular 0 %HDRevel% +map " + mapname + " -buildcubemaps"; " is 155.
Long Statement,CompilePalX,CompilingManager,C:\repos\ruarai_CompilePal\CompilePalX\Compiling\CompilingManager.cs,CompileThreaded,The length of the statement  "                    foreach (var compileProcess in ConfigurationManager.CompileProcesses.Where(c => c.Metadata.DoRun && c.PresetDictionary.ContainsKey(ConfigurationManager.CurrentPreset))) " is 168.
Long Statement,CompilePalX,CompilingManager,C:\repos\ruarai_CompilePal\CompilePalX\Compiling\CompilingManager.cs,postCompile,The length of the statement  "            CompilePalLogger.LogLineColor(string.Format("'{0}' compile finished in {1}"' ConfigurationManager.CurrentPreset' compileTimeStopwatch.Elapsed.ToString(@"hh\:mm\:ss"))' Brushes.ForestGreen); " is 189.
Long Statement,CompilePalX,CompilingManager,C:\repos\ruarai_CompilePal\CompilePalX\Compiling\CompilingManager.cs,postCompile,The length of the statement  "                    CompilePalLogger.LogLineColor("{0} errors/warnings logged for {1}:"' Error.GetSeverityBrush(mapMaxSeverity)' map.Errors.Count' map.MapName); " is 140.
Long Statement,CompilePalX,ProgressManager,C:\repos\ruarai_CompilePal\CompilePalX\Compiling\ProgressManager.cs,Init,The length of the statement  "            TitleChange(string.Format("{0} {1}X {2}"' defaultTitle' UpdateManager.CurrentVersion' GameConfigurationManager.GameConfiguration.Name)); " is 136.
Long Statement,CompilePalX,ProgressManager,C:\repos\ruarai_CompilePal\CompilePalX\Compiling\ProgressManager.cs,SetProgress,The length of the statement  "                        TitleChange(string.Format("{0} {1}X {2}"' defaultTitle' UpdateManager.CurrentVersion' GameConfigurationManager.GameConfiguration.Name)); " is 136.
Long Statement,CompilePalX,ConfigItem,C:\repos\ruarai_CompilePal\CompilePalX\Configuration\ConfigItem.cs,Clone,The length of the statement  "            return new ConfigItem() {Name=Name'Parameter=Parameter'Description = Description'Value=Value'CanHaveValue = CanHaveValue'Warning = Warning}; " is 140.
Long Statement,CompilePalX,GameConfigurationManager,C:\repos\ruarai_CompilePal\CompilePalX\GameConfiguration\GameConfigurationManager.cs,SubstituteValues,The length of the statement  "            text = text.Replace("$mapCopyLocation$"' string.Format("\"{0}\""' Path.Combine(GameConfiguration.MapFolder' Path.ChangeExtension(Path.GetFileName(mapFile)' "bsp")))); " is 166.
Long Statement,CompilePalX,MainWindow,C:\repos\ruarai_CompilePal\CompilePalX\MainWindow.xaml.cs,UpdateManager_OnUpdateFound,The length of the statement  "            UpdateHyperLink.Inlines.Add(string.Format("An update is available. Current version is {0}' latest version is {1}."' UpdateManager.CurrentVersion' UpdateManager.LatestVersion)); " is 176.
Long Statement,CompilePalX,MainWindow,C:\repos\ruarai_CompilePal\CompilePalX\MainWindow.xaml.cs,CompilingManager_OnFinish,The length of the statement  "            string textLog = new TextRange(CompileOutputTextbox.Document.ContentStart' CompileOutputTextbox.Document.ContentEnd).Text; " is 122.
Long Statement,CompilePalX,MainWindow,C:\repos\ruarai_CompilePal\CompilePalX\MainWindow.xaml.cs,AddParameterButton_Click,The length of the statement  "                if (c.ChosenItem != null && !selectedProcess.PresetDictionary[ConfigurationManager.CurrentPreset].Contains(c.ChosenItem)) " is 121.
Long Statement,CompilePalX,MainWindow,C:\repos\ruarai_CompilePal\CompilePalX\MainWindow.xaml.cs,UpdateConfigGrid,The length of the statement  "            if (selectedProcess != null && ConfigurationManager.CurrentPreset != null && selectedProcess.PresetDictionary.ContainsKey(ConfigurationManager.CurrentPreset)) " is 158.
Long Statement,CompilePalX,MainWindow,C:\repos\ruarai_CompilePal\CompilePalX\MainWindow.xaml.cs,UpdateProcessList,The length of the statement  "            CompileProcessesListBox.BeginAnimation(OpacityProperty' new DoubleAnimation(0' 1' new Duration(TimeSpan.FromMilliseconds(50)))); " is 128.
Long Statement,System.Collections.ObjectModel,ObservableDictionary<TKey;TValue>,C:\repos\ruarai_CompilePal\CompilePalX\ObservableDictionary.cs,Insert,The length of the statement  "                OnCollectionChanged(NotifyCollectionChangedAction.Replace' new KeyValuePair<TKey' TValue>(key' value)' new KeyValuePair<TKey' TValue>(key' item)); " is 146.
Long Statement,System.Collections.ObjectModel,ObservableDictionary<TKey;TValue>,C:\repos\ruarai_CompilePal\CompilePalX\ObservableDictionary.cs,OnCollectionChanged,The length of the statement  "            if (CollectionChanged != null) CollectionChanged(this' new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset)); " is 130.
Complex Conditional,CompilePalX.Compilers.BSPPack,BSP,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\BSP.cs,buildEntModelList,The conditional expression  "!ent["classname"].StartsWith("func") &&                          !ent["classname"].StartsWith("trigger") &&                          !ent["classname"].Contains("sprite") &&                          Keys.vmfModelKeys.Contains(prop.Key)"  is complex.
Empty Catch Block,CompilePalX.Compilers,NavProcess,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\NavProcess.cs,exitClient,The method has an empty catch block.
Empty Catch Block,CompilePalX.Compiling,CompilePalLogger,C:\repos\ruarai_CompilePal\CompilePalX\Compiling\Logger.cs,LogColor,The method has an empty catch block.
Empty Catch Block,CompilePalX,LaunchWindow,C:\repos\ruarai_CompilePal\CompilePalX\GameConfiguration\LaunchWindow.xaml.cs,LaunchWindow,The method has an empty catch block.
Empty Catch Block,CompilePalX,AnalyticsManager,C:\repos\ruarai_CompilePal\CompilePalX\Analytics\Analytics.cs,getUniqueComputerID,The method has an empty catch block.
Empty Catch Block,CompilePalX,AnalyticsManager,C:\repos\ruarai_CompilePal\CompilePalX\Analytics\Analytics.cs,getUniqueComputerID,The method has an empty catch block.
Empty Catch Block,CompilePalX,CompilingManager,C:\repos\ruarai_CompilePal\CompilePalX\Compiling\CompilingManager.cs,CancelCompile,The method has an empty catch block.
Empty Catch Block,CompilePalX,CompilingManager,C:\repos\ruarai_CompilePal\CompilePalX\Compiling\CompilingManager.cs,CancelCompile,The method has an empty catch block.
Empty Catch Block,CompilePalX,MainWindow,C:\repos\ruarai_CompilePal\CompilePalX\MainWindow.xaml.cs,HandleArgs,The method has an empty catch block.
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findMdlMaterials,The following statement contains a magic number: if (File.Exists(path))              {                    FileStream mdl = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(mdl);                    mdl.Seek(4' SeekOrigin.Begin);                  int ver = reader.ReadInt32();                    List<string> modelVmts = new List<string>();                  List<string> modelDirs = new List<string>();                    mdl.Seek(76' SeekOrigin.Begin);                  int datalength = reader.ReadInt32();                  mdl.Seek(124' SeekOrigin.Current);                    int textureCount = reader.ReadInt32();                  int textureOffset = reader.ReadInt32();                    int textureDirCount = reader.ReadInt32();                  int textureDirOffset = reader.ReadInt32();                    int skinreferenceCount = reader.ReadInt32();                  int skinrfamilyCount = reader.ReadInt32();                  int skinreferenceIndex = reader.ReadInt32();                    int bodypart_count = reader.ReadInt32();                  int bodypart_index = reader.ReadInt32();                    // find model names                  for (int i = 0; i < textureCount; i++)                  {                      mdl.Seek(textureOffset + (i * 64)' SeekOrigin.Begin);                      int textureNameOffset = reader.ReadInt32();                        mdl.Seek(textureOffset + (i * 64) + textureNameOffset' SeekOrigin.Begin);                      modelVmts.Add(readNullTerminatedString(mdl' reader));                  }                    // find model dirs                  List<int> textureDirOffsets = new List<int>();                  for (int i = 0; i < textureDirCount; i++)                  {                      mdl.Seek(textureDirOffset + (4 * i)' SeekOrigin.Begin);                      int offset = reader.ReadInt32();                      mdl.Seek(offset' SeekOrigin.Begin);                        string model = readNullTerminatedString(mdl' reader);                      model = model.TrimStart(new char[] { '/'' '\\' });                      modelDirs.Add(model);                  }                    if (skins != null)                  {                      // load specific skins                      List<int> material_ids = new List<int>();                        for (int i = 0; i < bodypart_count; i++)                      // we are reading an array of mstudiobodyparts_t                      {                          mdl.Seek(bodypart_index + i * 32' SeekOrigin.Begin);                            mdl.Seek(4' SeekOrigin.Current);                          int nummodels = reader.ReadInt32();                          mdl.Seek(4' SeekOrigin.Current);                          int modelindex = reader.ReadInt32();                            for (int j = 0; j < nummodels; j++)                          // we are reading an array of mstudiomodel_t                          {                              mdl.Seek(bodypart_index + modelindex + j * 140' SeekOrigin.Begin);                                mdl.Seek(72' SeekOrigin.Current);                              int nummeshes = reader.ReadInt32();                              int meshindex = reader.ReadInt32();                                for (int k = 0; k < nummeshes; k++)                              // we are reading an array of mstudiomesh_t                              {                                  mdl.Seek(bodypart_index + modelindex + meshindex + (k * 116)' SeekOrigin.Begin);                                  int mat_index = reader.ReadInt32();                                    if (!material_ids.Contains(mat_index))                                      material_ids.Add(mat_index);                              }                          }                      }                        // read the skintable                      mdl.Seek(skinreferenceIndex' SeekOrigin.Begin);                      short['] skintable = new short[skinrfamilyCount' skinreferenceCount];                      for (int i = 0; i < skinrfamilyCount; i++)                      {                          for (int j = 0; j < skinreferenceCount; j++)                          {                              skintable[i' j] = reader.ReadInt16();                          }                      }                        // trim the larger than required skintable                      short['] trimmedtable = new short[skinrfamilyCount' material_ids.Count];                      for (int i = 0; i < skinrfamilyCount; i++)                          for (int j = 0; j < material_ids.Count; j++)                              trimmedtable[i' j] = skintable[i' material_ids[j]];                        // add default skin 0 in case of non-existing skin indexes                      if (skins.IndexOf(0) == -1 && skins.Where(s => s >= trimmedtable.GetLength(0)).Count() != 0)                          skins.Add(0);                        // use the trimmed table to fetch used vmts                      foreach (int skin in skins.Where(skin => skin < trimmedtable.GetLength(0)))                          for (int j = 0; j < material_ids.Count; j++)                              for (int k = 0; k < modelDirs.Count; k++)                              {                                  short id = trimmedtable[skin' j];                                  materials.Add("materials/" + modelDirs[k] + modelVmts[id] + ".vmt");                              }                  }                  else                      // load all vmts                      for (int i = 0; i < modelVmts.Count; i++)                          for (int j = 0; j < modelDirs.Count; j++)                              materials.Add("materials/" + modelDirs[j] + modelVmts[i] + ".vmt");                  mdl.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findMdlMaterials,The following statement contains a magic number: if (File.Exists(path))              {                    FileStream mdl = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(mdl);                    mdl.Seek(4' SeekOrigin.Begin);                  int ver = reader.ReadInt32();                    List<string> modelVmts = new List<string>();                  List<string> modelDirs = new List<string>();                    mdl.Seek(76' SeekOrigin.Begin);                  int datalength = reader.ReadInt32();                  mdl.Seek(124' SeekOrigin.Current);                    int textureCount = reader.ReadInt32();                  int textureOffset = reader.ReadInt32();                    int textureDirCount = reader.ReadInt32();                  int textureDirOffset = reader.ReadInt32();                    int skinreferenceCount = reader.ReadInt32();                  int skinrfamilyCount = reader.ReadInt32();                  int skinreferenceIndex = reader.ReadInt32();                    int bodypart_count = reader.ReadInt32();                  int bodypart_index = reader.ReadInt32();                    // find model names                  for (int i = 0; i < textureCount; i++)                  {                      mdl.Seek(textureOffset + (i * 64)' SeekOrigin.Begin);                      int textureNameOffset = reader.ReadInt32();                        mdl.Seek(textureOffset + (i * 64) + textureNameOffset' SeekOrigin.Begin);                      modelVmts.Add(readNullTerminatedString(mdl' reader));                  }                    // find model dirs                  List<int> textureDirOffsets = new List<int>();                  for (int i = 0; i < textureDirCount; i++)                  {                      mdl.Seek(textureDirOffset + (4 * i)' SeekOrigin.Begin);                      int offset = reader.ReadInt32();                      mdl.Seek(offset' SeekOrigin.Begin);                        string model = readNullTerminatedString(mdl' reader);                      model = model.TrimStart(new char[] { '/'' '\\' });                      modelDirs.Add(model);                  }                    if (skins != null)                  {                      // load specific skins                      List<int> material_ids = new List<int>();                        for (int i = 0; i < bodypart_count; i++)                      // we are reading an array of mstudiobodyparts_t                      {                          mdl.Seek(bodypart_index + i * 32' SeekOrigin.Begin);                            mdl.Seek(4' SeekOrigin.Current);                          int nummodels = reader.ReadInt32();                          mdl.Seek(4' SeekOrigin.Current);                          int modelindex = reader.ReadInt32();                            for (int j = 0; j < nummodels; j++)                          // we are reading an array of mstudiomodel_t                          {                              mdl.Seek(bodypart_index + modelindex + j * 140' SeekOrigin.Begin);                                mdl.Seek(72' SeekOrigin.Current);                              int nummeshes = reader.ReadInt32();                              int meshindex = reader.ReadInt32();                                for (int k = 0; k < nummeshes; k++)                              // we are reading an array of mstudiomesh_t                              {                                  mdl.Seek(bodypart_index + modelindex + meshindex + (k * 116)' SeekOrigin.Begin);                                  int mat_index = reader.ReadInt32();                                    if (!material_ids.Contains(mat_index))                                      material_ids.Add(mat_index);                              }                          }                      }                        // read the skintable                      mdl.Seek(skinreferenceIndex' SeekOrigin.Begin);                      short['] skintable = new short[skinrfamilyCount' skinreferenceCount];                      for (int i = 0; i < skinrfamilyCount; i++)                      {                          for (int j = 0; j < skinreferenceCount; j++)                          {                              skintable[i' j] = reader.ReadInt16();                          }                      }                        // trim the larger than required skintable                      short['] trimmedtable = new short[skinrfamilyCount' material_ids.Count];                      for (int i = 0; i < skinrfamilyCount; i++)                          for (int j = 0; j < material_ids.Count; j++)                              trimmedtable[i' j] = skintable[i' material_ids[j]];                        // add default skin 0 in case of non-existing skin indexes                      if (skins.IndexOf(0) == -1 && skins.Where(s => s >= trimmedtable.GetLength(0)).Count() != 0)                          skins.Add(0);                        // use the trimmed table to fetch used vmts                      foreach (int skin in skins.Where(skin => skin < trimmedtable.GetLength(0)))                          for (int j = 0; j < material_ids.Count; j++)                              for (int k = 0; k < modelDirs.Count; k++)                              {                                  short id = trimmedtable[skin' j];                                  materials.Add("materials/" + modelDirs[k] + modelVmts[id] + ".vmt");                              }                  }                  else                      // load all vmts                      for (int i = 0; i < modelVmts.Count; i++)                          for (int j = 0; j < modelDirs.Count; j++)                              materials.Add("materials/" + modelDirs[j] + modelVmts[i] + ".vmt");                  mdl.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findMdlMaterials,The following statement contains a magic number: if (File.Exists(path))              {                    FileStream mdl = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(mdl);                    mdl.Seek(4' SeekOrigin.Begin);                  int ver = reader.ReadInt32();                    List<string> modelVmts = new List<string>();                  List<string> modelDirs = new List<string>();                    mdl.Seek(76' SeekOrigin.Begin);                  int datalength = reader.ReadInt32();                  mdl.Seek(124' SeekOrigin.Current);                    int textureCount = reader.ReadInt32();                  int textureOffset = reader.ReadInt32();                    int textureDirCount = reader.ReadInt32();                  int textureDirOffset = reader.ReadInt32();                    int skinreferenceCount = reader.ReadInt32();                  int skinrfamilyCount = reader.ReadInt32();                  int skinreferenceIndex = reader.ReadInt32();                    int bodypart_count = reader.ReadInt32();                  int bodypart_index = reader.ReadInt32();                    // find model names                  for (int i = 0; i < textureCount; i++)                  {                      mdl.Seek(textureOffset + (i * 64)' SeekOrigin.Begin);                      int textureNameOffset = reader.ReadInt32();                        mdl.Seek(textureOffset + (i * 64) + textureNameOffset' SeekOrigin.Begin);                      modelVmts.Add(readNullTerminatedString(mdl' reader));                  }                    // find model dirs                  List<int> textureDirOffsets = new List<int>();                  for (int i = 0; i < textureDirCount; i++)                  {                      mdl.Seek(textureDirOffset + (4 * i)' SeekOrigin.Begin);                      int offset = reader.ReadInt32();                      mdl.Seek(offset' SeekOrigin.Begin);                        string model = readNullTerminatedString(mdl' reader);                      model = model.TrimStart(new char[] { '/'' '\\' });                      modelDirs.Add(model);                  }                    if (skins != null)                  {                      // load specific skins                      List<int> material_ids = new List<int>();                        for (int i = 0; i < bodypart_count; i++)                      // we are reading an array of mstudiobodyparts_t                      {                          mdl.Seek(bodypart_index + i * 32' SeekOrigin.Begin);                            mdl.Seek(4' SeekOrigin.Current);                          int nummodels = reader.ReadInt32();                          mdl.Seek(4' SeekOrigin.Current);                          int modelindex = reader.ReadInt32();                            for (int j = 0; j < nummodels; j++)                          // we are reading an array of mstudiomodel_t                          {                              mdl.Seek(bodypart_index + modelindex + j * 140' SeekOrigin.Begin);                                mdl.Seek(72' SeekOrigin.Current);                              int nummeshes = reader.ReadInt32();                              int meshindex = reader.ReadInt32();                                for (int k = 0; k < nummeshes; k++)                              // we are reading an array of mstudiomesh_t                              {                                  mdl.Seek(bodypart_index + modelindex + meshindex + (k * 116)' SeekOrigin.Begin);                                  int mat_index = reader.ReadInt32();                                    if (!material_ids.Contains(mat_index))                                      material_ids.Add(mat_index);                              }                          }                      }                        // read the skintable                      mdl.Seek(skinreferenceIndex' SeekOrigin.Begin);                      short['] skintable = new short[skinrfamilyCount' skinreferenceCount];                      for (int i = 0; i < skinrfamilyCount; i++)                      {                          for (int j = 0; j < skinreferenceCount; j++)                          {                              skintable[i' j] = reader.ReadInt16();                          }                      }                        // trim the larger than required skintable                      short['] trimmedtable = new short[skinrfamilyCount' material_ids.Count];                      for (int i = 0; i < skinrfamilyCount; i++)                          for (int j = 0; j < material_ids.Count; j++)                              trimmedtable[i' j] = skintable[i' material_ids[j]];                        // add default skin 0 in case of non-existing skin indexes                      if (skins.IndexOf(0) == -1 && skins.Where(s => s >= trimmedtable.GetLength(0)).Count() != 0)                          skins.Add(0);                        // use the trimmed table to fetch used vmts                      foreach (int skin in skins.Where(skin => skin < trimmedtable.GetLength(0)))                          for (int j = 0; j < material_ids.Count; j++)                              for (int k = 0; k < modelDirs.Count; k++)                              {                                  short id = trimmedtable[skin' j];                                  materials.Add("materials/" + modelDirs[k] + modelVmts[id] + ".vmt");                              }                  }                  else                      // load all vmts                      for (int i = 0; i < modelVmts.Count; i++)                          for (int j = 0; j < modelDirs.Count; j++)                              materials.Add("materials/" + modelDirs[j] + modelVmts[i] + ".vmt");                  mdl.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findMdlMaterials,The following statement contains a magic number: if (File.Exists(path))              {                    FileStream mdl = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(mdl);                    mdl.Seek(4' SeekOrigin.Begin);                  int ver = reader.ReadInt32();                    List<string> modelVmts = new List<string>();                  List<string> modelDirs = new List<string>();                    mdl.Seek(76' SeekOrigin.Begin);                  int datalength = reader.ReadInt32();                  mdl.Seek(124' SeekOrigin.Current);                    int textureCount = reader.ReadInt32();                  int textureOffset = reader.ReadInt32();                    int textureDirCount = reader.ReadInt32();                  int textureDirOffset = reader.ReadInt32();                    int skinreferenceCount = reader.ReadInt32();                  int skinrfamilyCount = reader.ReadInt32();                  int skinreferenceIndex = reader.ReadInt32();                    int bodypart_count = reader.ReadInt32();                  int bodypart_index = reader.ReadInt32();                    // find model names                  for (int i = 0; i < textureCount; i++)                  {                      mdl.Seek(textureOffset + (i * 64)' SeekOrigin.Begin);                      int textureNameOffset = reader.ReadInt32();                        mdl.Seek(textureOffset + (i * 64) + textureNameOffset' SeekOrigin.Begin);                      modelVmts.Add(readNullTerminatedString(mdl' reader));                  }                    // find model dirs                  List<int> textureDirOffsets = new List<int>();                  for (int i = 0; i < textureDirCount; i++)                  {                      mdl.Seek(textureDirOffset + (4 * i)' SeekOrigin.Begin);                      int offset = reader.ReadInt32();                      mdl.Seek(offset' SeekOrigin.Begin);                        string model = readNullTerminatedString(mdl' reader);                      model = model.TrimStart(new char[] { '/'' '\\' });                      modelDirs.Add(model);                  }                    if (skins != null)                  {                      // load specific skins                      List<int> material_ids = new List<int>();                        for (int i = 0; i < bodypart_count; i++)                      // we are reading an array of mstudiobodyparts_t                      {                          mdl.Seek(bodypart_index + i * 32' SeekOrigin.Begin);                            mdl.Seek(4' SeekOrigin.Current);                          int nummodels = reader.ReadInt32();                          mdl.Seek(4' SeekOrigin.Current);                          int modelindex = reader.ReadInt32();                            for (int j = 0; j < nummodels; j++)                          // we are reading an array of mstudiomodel_t                          {                              mdl.Seek(bodypart_index + modelindex + j * 140' SeekOrigin.Begin);                                mdl.Seek(72' SeekOrigin.Current);                              int nummeshes = reader.ReadInt32();                              int meshindex = reader.ReadInt32();                                for (int k = 0; k < nummeshes; k++)                              // we are reading an array of mstudiomesh_t                              {                                  mdl.Seek(bodypart_index + modelindex + meshindex + (k * 116)' SeekOrigin.Begin);                                  int mat_index = reader.ReadInt32();                                    if (!material_ids.Contains(mat_index))                                      material_ids.Add(mat_index);                              }                          }                      }                        // read the skintable                      mdl.Seek(skinreferenceIndex' SeekOrigin.Begin);                      short['] skintable = new short[skinrfamilyCount' skinreferenceCount];                      for (int i = 0; i < skinrfamilyCount; i++)                      {                          for (int j = 0; j < skinreferenceCount; j++)                          {                              skintable[i' j] = reader.ReadInt16();                          }                      }                        // trim the larger than required skintable                      short['] trimmedtable = new short[skinrfamilyCount' material_ids.Count];                      for (int i = 0; i < skinrfamilyCount; i++)                          for (int j = 0; j < material_ids.Count; j++)                              trimmedtable[i' j] = skintable[i' material_ids[j]];                        // add default skin 0 in case of non-existing skin indexes                      if (skins.IndexOf(0) == -1 && skins.Where(s => s >= trimmedtable.GetLength(0)).Count() != 0)                          skins.Add(0);                        // use the trimmed table to fetch used vmts                      foreach (int skin in skins.Where(skin => skin < trimmedtable.GetLength(0)))                          for (int j = 0; j < material_ids.Count; j++)                              for (int k = 0; k < modelDirs.Count; k++)                              {                                  short id = trimmedtable[skin' j];                                  materials.Add("materials/" + modelDirs[k] + modelVmts[id] + ".vmt");                              }                  }                  else                      // load all vmts                      for (int i = 0; i < modelVmts.Count; i++)                          for (int j = 0; j < modelDirs.Count; j++)                              materials.Add("materials/" + modelDirs[j] + modelVmts[i] + ".vmt");                  mdl.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findMdlMaterials,The following statement contains a magic number: if (File.Exists(path))              {                    FileStream mdl = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(mdl);                    mdl.Seek(4' SeekOrigin.Begin);                  int ver = reader.ReadInt32();                    List<string> modelVmts = new List<string>();                  List<string> modelDirs = new List<string>();                    mdl.Seek(76' SeekOrigin.Begin);                  int datalength = reader.ReadInt32();                  mdl.Seek(124' SeekOrigin.Current);                    int textureCount = reader.ReadInt32();                  int textureOffset = reader.ReadInt32();                    int textureDirCount = reader.ReadInt32();                  int textureDirOffset = reader.ReadInt32();                    int skinreferenceCount = reader.ReadInt32();                  int skinrfamilyCount = reader.ReadInt32();                  int skinreferenceIndex = reader.ReadInt32();                    int bodypart_count = reader.ReadInt32();                  int bodypart_index = reader.ReadInt32();                    // find model names                  for (int i = 0; i < textureCount; i++)                  {                      mdl.Seek(textureOffset + (i * 64)' SeekOrigin.Begin);                      int textureNameOffset = reader.ReadInt32();                        mdl.Seek(textureOffset + (i * 64) + textureNameOffset' SeekOrigin.Begin);                      modelVmts.Add(readNullTerminatedString(mdl' reader));                  }                    // find model dirs                  List<int> textureDirOffsets = new List<int>();                  for (int i = 0; i < textureDirCount; i++)                  {                      mdl.Seek(textureDirOffset + (4 * i)' SeekOrigin.Begin);                      int offset = reader.ReadInt32();                      mdl.Seek(offset' SeekOrigin.Begin);                        string model = readNullTerminatedString(mdl' reader);                      model = model.TrimStart(new char[] { '/'' '\\' });                      modelDirs.Add(model);                  }                    if (skins != null)                  {                      // load specific skins                      List<int> material_ids = new List<int>();                        for (int i = 0; i < bodypart_count; i++)                      // we are reading an array of mstudiobodyparts_t                      {                          mdl.Seek(bodypart_index + i * 32' SeekOrigin.Begin);                            mdl.Seek(4' SeekOrigin.Current);                          int nummodels = reader.ReadInt32();                          mdl.Seek(4' SeekOrigin.Current);                          int modelindex = reader.ReadInt32();                            for (int j = 0; j < nummodels; j++)                          // we are reading an array of mstudiomodel_t                          {                              mdl.Seek(bodypart_index + modelindex + j * 140' SeekOrigin.Begin);                                mdl.Seek(72' SeekOrigin.Current);                              int nummeshes = reader.ReadInt32();                              int meshindex = reader.ReadInt32();                                for (int k = 0; k < nummeshes; k++)                              // we are reading an array of mstudiomesh_t                              {                                  mdl.Seek(bodypart_index + modelindex + meshindex + (k * 116)' SeekOrigin.Begin);                                  int mat_index = reader.ReadInt32();                                    if (!material_ids.Contains(mat_index))                                      material_ids.Add(mat_index);                              }                          }                      }                        // read the skintable                      mdl.Seek(skinreferenceIndex' SeekOrigin.Begin);                      short['] skintable = new short[skinrfamilyCount' skinreferenceCount];                      for (int i = 0; i < skinrfamilyCount; i++)                      {                          for (int j = 0; j < skinreferenceCount; j++)                          {                              skintable[i' j] = reader.ReadInt16();                          }                      }                        // trim the larger than required skintable                      short['] trimmedtable = new short[skinrfamilyCount' material_ids.Count];                      for (int i = 0; i < skinrfamilyCount; i++)                          for (int j = 0; j < material_ids.Count; j++)                              trimmedtable[i' j] = skintable[i' material_ids[j]];                        // add default skin 0 in case of non-existing skin indexes                      if (skins.IndexOf(0) == -1 && skins.Where(s => s >= trimmedtable.GetLength(0)).Count() != 0)                          skins.Add(0);                        // use the trimmed table to fetch used vmts                      foreach (int skin in skins.Where(skin => skin < trimmedtable.GetLength(0)))                          for (int j = 0; j < material_ids.Count; j++)                              for (int k = 0; k < modelDirs.Count; k++)                              {                                  short id = trimmedtable[skin' j];                                  materials.Add("materials/" + modelDirs[k] + modelVmts[id] + ".vmt");                              }                  }                  else                      // load all vmts                      for (int i = 0; i < modelVmts.Count; i++)                          for (int j = 0; j < modelDirs.Count; j++)                              materials.Add("materials/" + modelDirs[j] + modelVmts[i] + ".vmt");                  mdl.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findMdlMaterials,The following statement contains a magic number: if (File.Exists(path))              {                    FileStream mdl = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(mdl);                    mdl.Seek(4' SeekOrigin.Begin);                  int ver = reader.ReadInt32();                    List<string> modelVmts = new List<string>();                  List<string> modelDirs = new List<string>();                    mdl.Seek(76' SeekOrigin.Begin);                  int datalength = reader.ReadInt32();                  mdl.Seek(124' SeekOrigin.Current);                    int textureCount = reader.ReadInt32();                  int textureOffset = reader.ReadInt32();                    int textureDirCount = reader.ReadInt32();                  int textureDirOffset = reader.ReadInt32();                    int skinreferenceCount = reader.ReadInt32();                  int skinrfamilyCount = reader.ReadInt32();                  int skinreferenceIndex = reader.ReadInt32();                    int bodypart_count = reader.ReadInt32();                  int bodypart_index = reader.ReadInt32();                    // find model names                  for (int i = 0; i < textureCount; i++)                  {                      mdl.Seek(textureOffset + (i * 64)' SeekOrigin.Begin);                      int textureNameOffset = reader.ReadInt32();                        mdl.Seek(textureOffset + (i * 64) + textureNameOffset' SeekOrigin.Begin);                      modelVmts.Add(readNullTerminatedString(mdl' reader));                  }                    // find model dirs                  List<int> textureDirOffsets = new List<int>();                  for (int i = 0; i < textureDirCount; i++)                  {                      mdl.Seek(textureDirOffset + (4 * i)' SeekOrigin.Begin);                      int offset = reader.ReadInt32();                      mdl.Seek(offset' SeekOrigin.Begin);                        string model = readNullTerminatedString(mdl' reader);                      model = model.TrimStart(new char[] { '/'' '\\' });                      modelDirs.Add(model);                  }                    if (skins != null)                  {                      // load specific skins                      List<int> material_ids = new List<int>();                        for (int i = 0; i < bodypart_count; i++)                      // we are reading an array of mstudiobodyparts_t                      {                          mdl.Seek(bodypart_index + i * 32' SeekOrigin.Begin);                            mdl.Seek(4' SeekOrigin.Current);                          int nummodels = reader.ReadInt32();                          mdl.Seek(4' SeekOrigin.Current);                          int modelindex = reader.ReadInt32();                            for (int j = 0; j < nummodels; j++)                          // we are reading an array of mstudiomodel_t                          {                              mdl.Seek(bodypart_index + modelindex + j * 140' SeekOrigin.Begin);                                mdl.Seek(72' SeekOrigin.Current);                              int nummeshes = reader.ReadInt32();                              int meshindex = reader.ReadInt32();                                for (int k = 0; k < nummeshes; k++)                              // we are reading an array of mstudiomesh_t                              {                                  mdl.Seek(bodypart_index + modelindex + meshindex + (k * 116)' SeekOrigin.Begin);                                  int mat_index = reader.ReadInt32();                                    if (!material_ids.Contains(mat_index))                                      material_ids.Add(mat_index);                              }                          }                      }                        // read the skintable                      mdl.Seek(skinreferenceIndex' SeekOrigin.Begin);                      short['] skintable = new short[skinrfamilyCount' skinreferenceCount];                      for (int i = 0; i < skinrfamilyCount; i++)                      {                          for (int j = 0; j < skinreferenceCount; j++)                          {                              skintable[i' j] = reader.ReadInt16();                          }                      }                        // trim the larger than required skintable                      short['] trimmedtable = new short[skinrfamilyCount' material_ids.Count];                      for (int i = 0; i < skinrfamilyCount; i++)                          for (int j = 0; j < material_ids.Count; j++)                              trimmedtable[i' j] = skintable[i' material_ids[j]];                        // add default skin 0 in case of non-existing skin indexes                      if (skins.IndexOf(0) == -1 && skins.Where(s => s >= trimmedtable.GetLength(0)).Count() != 0)                          skins.Add(0);                        // use the trimmed table to fetch used vmts                      foreach (int skin in skins.Where(skin => skin < trimmedtable.GetLength(0)))                          for (int j = 0; j < material_ids.Count; j++)                              for (int k = 0; k < modelDirs.Count; k++)                              {                                  short id = trimmedtable[skin' j];                                  materials.Add("materials/" + modelDirs[k] + modelVmts[id] + ".vmt");                              }                  }                  else                      // load all vmts                      for (int i = 0; i < modelVmts.Count; i++)                          for (int j = 0; j < modelDirs.Count; j++)                              materials.Add("materials/" + modelDirs[j] + modelVmts[i] + ".vmt");                  mdl.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findMdlMaterials,The following statement contains a magic number: if (File.Exists(path))              {                    FileStream mdl = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(mdl);                    mdl.Seek(4' SeekOrigin.Begin);                  int ver = reader.ReadInt32();                    List<string> modelVmts = new List<string>();                  List<string> modelDirs = new List<string>();                    mdl.Seek(76' SeekOrigin.Begin);                  int datalength = reader.ReadInt32();                  mdl.Seek(124' SeekOrigin.Current);                    int textureCount = reader.ReadInt32();                  int textureOffset = reader.ReadInt32();                    int textureDirCount = reader.ReadInt32();                  int textureDirOffset = reader.ReadInt32();                    int skinreferenceCount = reader.ReadInt32();                  int skinrfamilyCount = reader.ReadInt32();                  int skinreferenceIndex = reader.ReadInt32();                    int bodypart_count = reader.ReadInt32();                  int bodypart_index = reader.ReadInt32();                    // find model names                  for (int i = 0; i < textureCount; i++)                  {                      mdl.Seek(textureOffset + (i * 64)' SeekOrigin.Begin);                      int textureNameOffset = reader.ReadInt32();                        mdl.Seek(textureOffset + (i * 64) + textureNameOffset' SeekOrigin.Begin);                      modelVmts.Add(readNullTerminatedString(mdl' reader));                  }                    // find model dirs                  List<int> textureDirOffsets = new List<int>();                  for (int i = 0; i < textureDirCount; i++)                  {                      mdl.Seek(textureDirOffset + (4 * i)' SeekOrigin.Begin);                      int offset = reader.ReadInt32();                      mdl.Seek(offset' SeekOrigin.Begin);                        string model = readNullTerminatedString(mdl' reader);                      model = model.TrimStart(new char[] { '/'' '\\' });                      modelDirs.Add(model);                  }                    if (skins != null)                  {                      // load specific skins                      List<int> material_ids = new List<int>();                        for (int i = 0; i < bodypart_count; i++)                      // we are reading an array of mstudiobodyparts_t                      {                          mdl.Seek(bodypart_index + i * 32' SeekOrigin.Begin);                            mdl.Seek(4' SeekOrigin.Current);                          int nummodels = reader.ReadInt32();                          mdl.Seek(4' SeekOrigin.Current);                          int modelindex = reader.ReadInt32();                            for (int j = 0; j < nummodels; j++)                          // we are reading an array of mstudiomodel_t                          {                              mdl.Seek(bodypart_index + modelindex + j * 140' SeekOrigin.Begin);                                mdl.Seek(72' SeekOrigin.Current);                              int nummeshes = reader.ReadInt32();                              int meshindex = reader.ReadInt32();                                for (int k = 0; k < nummeshes; k++)                              // we are reading an array of mstudiomesh_t                              {                                  mdl.Seek(bodypart_index + modelindex + meshindex + (k * 116)' SeekOrigin.Begin);                                  int mat_index = reader.ReadInt32();                                    if (!material_ids.Contains(mat_index))                                      material_ids.Add(mat_index);                              }                          }                      }                        // read the skintable                      mdl.Seek(skinreferenceIndex' SeekOrigin.Begin);                      short['] skintable = new short[skinrfamilyCount' skinreferenceCount];                      for (int i = 0; i < skinrfamilyCount; i++)                      {                          for (int j = 0; j < skinreferenceCount; j++)                          {                              skintable[i' j] = reader.ReadInt16();                          }                      }                        // trim the larger than required skintable                      short['] trimmedtable = new short[skinrfamilyCount' material_ids.Count];                      for (int i = 0; i < skinrfamilyCount; i++)                          for (int j = 0; j < material_ids.Count; j++)                              trimmedtable[i' j] = skintable[i' material_ids[j]];                        // add default skin 0 in case of non-existing skin indexes                      if (skins.IndexOf(0) == -1 && skins.Where(s => s >= trimmedtable.GetLength(0)).Count() != 0)                          skins.Add(0);                        // use the trimmed table to fetch used vmts                      foreach (int skin in skins.Where(skin => skin < trimmedtable.GetLength(0)))                          for (int j = 0; j < material_ids.Count; j++)                              for (int k = 0; k < modelDirs.Count; k++)                              {                                  short id = trimmedtable[skin' j];                                  materials.Add("materials/" + modelDirs[k] + modelVmts[id] + ".vmt");                              }                  }                  else                      // load all vmts                      for (int i = 0; i < modelVmts.Count; i++)                          for (int j = 0; j < modelDirs.Count; j++)                              materials.Add("materials/" + modelDirs[j] + modelVmts[i] + ".vmt");                  mdl.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findMdlMaterials,The following statement contains a magic number: if (File.Exists(path))              {                    FileStream mdl = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(mdl);                    mdl.Seek(4' SeekOrigin.Begin);                  int ver = reader.ReadInt32();                    List<string> modelVmts = new List<string>();                  List<string> modelDirs = new List<string>();                    mdl.Seek(76' SeekOrigin.Begin);                  int datalength = reader.ReadInt32();                  mdl.Seek(124' SeekOrigin.Current);                    int textureCount = reader.ReadInt32();                  int textureOffset = reader.ReadInt32();                    int textureDirCount = reader.ReadInt32();                  int textureDirOffset = reader.ReadInt32();                    int skinreferenceCount = reader.ReadInt32();                  int skinrfamilyCount = reader.ReadInt32();                  int skinreferenceIndex = reader.ReadInt32();                    int bodypart_count = reader.ReadInt32();                  int bodypart_index = reader.ReadInt32();                    // find model names                  for (int i = 0; i < textureCount; i++)                  {                      mdl.Seek(textureOffset + (i * 64)' SeekOrigin.Begin);                      int textureNameOffset = reader.ReadInt32();                        mdl.Seek(textureOffset + (i * 64) + textureNameOffset' SeekOrigin.Begin);                      modelVmts.Add(readNullTerminatedString(mdl' reader));                  }                    // find model dirs                  List<int> textureDirOffsets = new List<int>();                  for (int i = 0; i < textureDirCount; i++)                  {                      mdl.Seek(textureDirOffset + (4 * i)' SeekOrigin.Begin);                      int offset = reader.ReadInt32();                      mdl.Seek(offset' SeekOrigin.Begin);                        string model = readNullTerminatedString(mdl' reader);                      model = model.TrimStart(new char[] { '/'' '\\' });                      modelDirs.Add(model);                  }                    if (skins != null)                  {                      // load specific skins                      List<int> material_ids = new List<int>();                        for (int i = 0; i < bodypart_count; i++)                      // we are reading an array of mstudiobodyparts_t                      {                          mdl.Seek(bodypart_index + i * 32' SeekOrigin.Begin);                            mdl.Seek(4' SeekOrigin.Current);                          int nummodels = reader.ReadInt32();                          mdl.Seek(4' SeekOrigin.Current);                          int modelindex = reader.ReadInt32();                            for (int j = 0; j < nummodels; j++)                          // we are reading an array of mstudiomodel_t                          {                              mdl.Seek(bodypart_index + modelindex + j * 140' SeekOrigin.Begin);                                mdl.Seek(72' SeekOrigin.Current);                              int nummeshes = reader.ReadInt32();                              int meshindex = reader.ReadInt32();                                for (int k = 0; k < nummeshes; k++)                              // we are reading an array of mstudiomesh_t                              {                                  mdl.Seek(bodypart_index + modelindex + meshindex + (k * 116)' SeekOrigin.Begin);                                  int mat_index = reader.ReadInt32();                                    if (!material_ids.Contains(mat_index))                                      material_ids.Add(mat_index);                              }                          }                      }                        // read the skintable                      mdl.Seek(skinreferenceIndex' SeekOrigin.Begin);                      short['] skintable = new short[skinrfamilyCount' skinreferenceCount];                      for (int i = 0; i < skinrfamilyCount; i++)                      {                          for (int j = 0; j < skinreferenceCount; j++)                          {                              skintable[i' j] = reader.ReadInt16();                          }                      }                        // trim the larger than required skintable                      short['] trimmedtable = new short[skinrfamilyCount' material_ids.Count];                      for (int i = 0; i < skinrfamilyCount; i++)                          for (int j = 0; j < material_ids.Count; j++)                              trimmedtable[i' j] = skintable[i' material_ids[j]];                        // add default skin 0 in case of non-existing skin indexes                      if (skins.IndexOf(0) == -1 && skins.Where(s => s >= trimmedtable.GetLength(0)).Count() != 0)                          skins.Add(0);                        // use the trimmed table to fetch used vmts                      foreach (int skin in skins.Where(skin => skin < trimmedtable.GetLength(0)))                          for (int j = 0; j < material_ids.Count; j++)                              for (int k = 0; k < modelDirs.Count; k++)                              {                                  short id = trimmedtable[skin' j];                                  materials.Add("materials/" + modelDirs[k] + modelVmts[id] + ".vmt");                              }                  }                  else                      // load all vmts                      for (int i = 0; i < modelVmts.Count; i++)                          for (int j = 0; j < modelDirs.Count; j++)                              materials.Add("materials/" + modelDirs[j] + modelVmts[i] + ".vmt");                  mdl.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findMdlMaterials,The following statement contains a magic number: if (File.Exists(path))              {                    FileStream mdl = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(mdl);                    mdl.Seek(4' SeekOrigin.Begin);                  int ver = reader.ReadInt32();                    List<string> modelVmts = new List<string>();                  List<string> modelDirs = new List<string>();                    mdl.Seek(76' SeekOrigin.Begin);                  int datalength = reader.ReadInt32();                  mdl.Seek(124' SeekOrigin.Current);                    int textureCount = reader.ReadInt32();                  int textureOffset = reader.ReadInt32();                    int textureDirCount = reader.ReadInt32();                  int textureDirOffset = reader.ReadInt32();                    int skinreferenceCount = reader.ReadInt32();                  int skinrfamilyCount = reader.ReadInt32();                  int skinreferenceIndex = reader.ReadInt32();                    int bodypart_count = reader.ReadInt32();                  int bodypart_index = reader.ReadInt32();                    // find model names                  for (int i = 0; i < textureCount; i++)                  {                      mdl.Seek(textureOffset + (i * 64)' SeekOrigin.Begin);                      int textureNameOffset = reader.ReadInt32();                        mdl.Seek(textureOffset + (i * 64) + textureNameOffset' SeekOrigin.Begin);                      modelVmts.Add(readNullTerminatedString(mdl' reader));                  }                    // find model dirs                  List<int> textureDirOffsets = new List<int>();                  for (int i = 0; i < textureDirCount; i++)                  {                      mdl.Seek(textureDirOffset + (4 * i)' SeekOrigin.Begin);                      int offset = reader.ReadInt32();                      mdl.Seek(offset' SeekOrigin.Begin);                        string model = readNullTerminatedString(mdl' reader);                      model = model.TrimStart(new char[] { '/'' '\\' });                      modelDirs.Add(model);                  }                    if (skins != null)                  {                      // load specific skins                      List<int> material_ids = new List<int>();                        for (int i = 0; i < bodypart_count; i++)                      // we are reading an array of mstudiobodyparts_t                      {                          mdl.Seek(bodypart_index + i * 32' SeekOrigin.Begin);                            mdl.Seek(4' SeekOrigin.Current);                          int nummodels = reader.ReadInt32();                          mdl.Seek(4' SeekOrigin.Current);                          int modelindex = reader.ReadInt32();                            for (int j = 0; j < nummodels; j++)                          // we are reading an array of mstudiomodel_t                          {                              mdl.Seek(bodypart_index + modelindex + j * 140' SeekOrigin.Begin);                                mdl.Seek(72' SeekOrigin.Current);                              int nummeshes = reader.ReadInt32();                              int meshindex = reader.ReadInt32();                                for (int k = 0; k < nummeshes; k++)                              // we are reading an array of mstudiomesh_t                              {                                  mdl.Seek(bodypart_index + modelindex + meshindex + (k * 116)' SeekOrigin.Begin);                                  int mat_index = reader.ReadInt32();                                    if (!material_ids.Contains(mat_index))                                      material_ids.Add(mat_index);                              }                          }                      }                        // read the skintable                      mdl.Seek(skinreferenceIndex' SeekOrigin.Begin);                      short['] skintable = new short[skinrfamilyCount' skinreferenceCount];                      for (int i = 0; i < skinrfamilyCount; i++)                      {                          for (int j = 0; j < skinreferenceCount; j++)                          {                              skintable[i' j] = reader.ReadInt16();                          }                      }                        // trim the larger than required skintable                      short['] trimmedtable = new short[skinrfamilyCount' material_ids.Count];                      for (int i = 0; i < skinrfamilyCount; i++)                          for (int j = 0; j < material_ids.Count; j++)                              trimmedtable[i' j] = skintable[i' material_ids[j]];                        // add default skin 0 in case of non-existing skin indexes                      if (skins.IndexOf(0) == -1 && skins.Where(s => s >= trimmedtable.GetLength(0)).Count() != 0)                          skins.Add(0);                        // use the trimmed table to fetch used vmts                      foreach (int skin in skins.Where(skin => skin < trimmedtable.GetLength(0)))                          for (int j = 0; j < material_ids.Count; j++)                              for (int k = 0; k < modelDirs.Count; k++)                              {                                  short id = trimmedtable[skin' j];                                  materials.Add("materials/" + modelDirs[k] + modelVmts[id] + ".vmt");                              }                  }                  else                      // load all vmts                      for (int i = 0; i < modelVmts.Count; i++)                          for (int j = 0; j < modelDirs.Count; j++)                              materials.Add("materials/" + modelDirs[j] + modelVmts[i] + ".vmt");                  mdl.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findMdlMaterials,The following statement contains a magic number: if (File.Exists(path))              {                    FileStream mdl = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(mdl);                    mdl.Seek(4' SeekOrigin.Begin);                  int ver = reader.ReadInt32();                    List<string> modelVmts = new List<string>();                  List<string> modelDirs = new List<string>();                    mdl.Seek(76' SeekOrigin.Begin);                  int datalength = reader.ReadInt32();                  mdl.Seek(124' SeekOrigin.Current);                    int textureCount = reader.ReadInt32();                  int textureOffset = reader.ReadInt32();                    int textureDirCount = reader.ReadInt32();                  int textureDirOffset = reader.ReadInt32();                    int skinreferenceCount = reader.ReadInt32();                  int skinrfamilyCount = reader.ReadInt32();                  int skinreferenceIndex = reader.ReadInt32();                    int bodypart_count = reader.ReadInt32();                  int bodypart_index = reader.ReadInt32();                    // find model names                  for (int i = 0; i < textureCount; i++)                  {                      mdl.Seek(textureOffset + (i * 64)' SeekOrigin.Begin);                      int textureNameOffset = reader.ReadInt32();                        mdl.Seek(textureOffset + (i * 64) + textureNameOffset' SeekOrigin.Begin);                      modelVmts.Add(readNullTerminatedString(mdl' reader));                  }                    // find model dirs                  List<int> textureDirOffsets = new List<int>();                  for (int i = 0; i < textureDirCount; i++)                  {                      mdl.Seek(textureDirOffset + (4 * i)' SeekOrigin.Begin);                      int offset = reader.ReadInt32();                      mdl.Seek(offset' SeekOrigin.Begin);                        string model = readNullTerminatedString(mdl' reader);                      model = model.TrimStart(new char[] { '/'' '\\' });                      modelDirs.Add(model);                  }                    if (skins != null)                  {                      // load specific skins                      List<int> material_ids = new List<int>();                        for (int i = 0; i < bodypart_count; i++)                      // we are reading an array of mstudiobodyparts_t                      {                          mdl.Seek(bodypart_index + i * 32' SeekOrigin.Begin);                            mdl.Seek(4' SeekOrigin.Current);                          int nummodels = reader.ReadInt32();                          mdl.Seek(4' SeekOrigin.Current);                          int modelindex = reader.ReadInt32();                            for (int j = 0; j < nummodels; j++)                          // we are reading an array of mstudiomodel_t                          {                              mdl.Seek(bodypart_index + modelindex + j * 140' SeekOrigin.Begin);                                mdl.Seek(72' SeekOrigin.Current);                              int nummeshes = reader.ReadInt32();                              int meshindex = reader.ReadInt32();                                for (int k = 0; k < nummeshes; k++)                              // we are reading an array of mstudiomesh_t                              {                                  mdl.Seek(bodypart_index + modelindex + meshindex + (k * 116)' SeekOrigin.Begin);                                  int mat_index = reader.ReadInt32();                                    if (!material_ids.Contains(mat_index))                                      material_ids.Add(mat_index);                              }                          }                      }                        // read the skintable                      mdl.Seek(skinreferenceIndex' SeekOrigin.Begin);                      short['] skintable = new short[skinrfamilyCount' skinreferenceCount];                      for (int i = 0; i < skinrfamilyCount; i++)                      {                          for (int j = 0; j < skinreferenceCount; j++)                          {                              skintable[i' j] = reader.ReadInt16();                          }                      }                        // trim the larger than required skintable                      short['] trimmedtable = new short[skinrfamilyCount' material_ids.Count];                      for (int i = 0; i < skinrfamilyCount; i++)                          for (int j = 0; j < material_ids.Count; j++)                              trimmedtable[i' j] = skintable[i' material_ids[j]];                        // add default skin 0 in case of non-existing skin indexes                      if (skins.IndexOf(0) == -1 && skins.Where(s => s >= trimmedtable.GetLength(0)).Count() != 0)                          skins.Add(0);                        // use the trimmed table to fetch used vmts                      foreach (int skin in skins.Where(skin => skin < trimmedtable.GetLength(0)))                          for (int j = 0; j < material_ids.Count; j++)                              for (int k = 0; k < modelDirs.Count; k++)                              {                                  short id = trimmedtable[skin' j];                                  materials.Add("materials/" + modelDirs[k] + modelVmts[id] + ".vmt");                              }                  }                  else                      // load all vmts                      for (int i = 0; i < modelVmts.Count; i++)                          for (int j = 0; j < modelDirs.Count; j++)                              materials.Add("materials/" + modelDirs[j] + modelVmts[i] + ".vmt");                  mdl.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findMdlMaterials,The following statement contains a magic number: if (File.Exists(path))              {                    FileStream mdl = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(mdl);                    mdl.Seek(4' SeekOrigin.Begin);                  int ver = reader.ReadInt32();                    List<string> modelVmts = new List<string>();                  List<string> modelDirs = new List<string>();                    mdl.Seek(76' SeekOrigin.Begin);                  int datalength = reader.ReadInt32();                  mdl.Seek(124' SeekOrigin.Current);                    int textureCount = reader.ReadInt32();                  int textureOffset = reader.ReadInt32();                    int textureDirCount = reader.ReadInt32();                  int textureDirOffset = reader.ReadInt32();                    int skinreferenceCount = reader.ReadInt32();                  int skinrfamilyCount = reader.ReadInt32();                  int skinreferenceIndex = reader.ReadInt32();                    int bodypart_count = reader.ReadInt32();                  int bodypart_index = reader.ReadInt32();                    // find model names                  for (int i = 0; i < textureCount; i++)                  {                      mdl.Seek(textureOffset + (i * 64)' SeekOrigin.Begin);                      int textureNameOffset = reader.ReadInt32();                        mdl.Seek(textureOffset + (i * 64) + textureNameOffset' SeekOrigin.Begin);                      modelVmts.Add(readNullTerminatedString(mdl' reader));                  }                    // find model dirs                  List<int> textureDirOffsets = new List<int>();                  for (int i = 0; i < textureDirCount; i++)                  {                      mdl.Seek(textureDirOffset + (4 * i)' SeekOrigin.Begin);                      int offset = reader.ReadInt32();                      mdl.Seek(offset' SeekOrigin.Begin);                        string model = readNullTerminatedString(mdl' reader);                      model = model.TrimStart(new char[] { '/'' '\\' });                      modelDirs.Add(model);                  }                    if (skins != null)                  {                      // load specific skins                      List<int> material_ids = new List<int>();                        for (int i = 0; i < bodypart_count; i++)                      // we are reading an array of mstudiobodyparts_t                      {                          mdl.Seek(bodypart_index + i * 32' SeekOrigin.Begin);                            mdl.Seek(4' SeekOrigin.Current);                          int nummodels = reader.ReadInt32();                          mdl.Seek(4' SeekOrigin.Current);                          int modelindex = reader.ReadInt32();                            for (int j = 0; j < nummodels; j++)                          // we are reading an array of mstudiomodel_t                          {                              mdl.Seek(bodypart_index + modelindex + j * 140' SeekOrigin.Begin);                                mdl.Seek(72' SeekOrigin.Current);                              int nummeshes = reader.ReadInt32();                              int meshindex = reader.ReadInt32();                                for (int k = 0; k < nummeshes; k++)                              // we are reading an array of mstudiomesh_t                              {                                  mdl.Seek(bodypart_index + modelindex + meshindex + (k * 116)' SeekOrigin.Begin);                                  int mat_index = reader.ReadInt32();                                    if (!material_ids.Contains(mat_index))                                      material_ids.Add(mat_index);                              }                          }                      }                        // read the skintable                      mdl.Seek(skinreferenceIndex' SeekOrigin.Begin);                      short['] skintable = new short[skinrfamilyCount' skinreferenceCount];                      for (int i = 0; i < skinrfamilyCount; i++)                      {                          for (int j = 0; j < skinreferenceCount; j++)                          {                              skintable[i' j] = reader.ReadInt16();                          }                      }                        // trim the larger than required skintable                      short['] trimmedtable = new short[skinrfamilyCount' material_ids.Count];                      for (int i = 0; i < skinrfamilyCount; i++)                          for (int j = 0; j < material_ids.Count; j++)                              trimmedtable[i' j] = skintable[i' material_ids[j]];                        // add default skin 0 in case of non-existing skin indexes                      if (skins.IndexOf(0) == -1 && skins.Where(s => s >= trimmedtable.GetLength(0)).Count() != 0)                          skins.Add(0);                        // use the trimmed table to fetch used vmts                      foreach (int skin in skins.Where(skin => skin < trimmedtable.GetLength(0)))                          for (int j = 0; j < material_ids.Count; j++)                              for (int k = 0; k < modelDirs.Count; k++)                              {                                  short id = trimmedtable[skin' j];                                  materials.Add("materials/" + modelDirs[k] + modelVmts[id] + ".vmt");                              }                  }                  else                      // load all vmts                      for (int i = 0; i < modelVmts.Count; i++)                          for (int j = 0; j < modelDirs.Count; j++)                              materials.Add("materials/" + modelDirs[j] + modelVmts[i] + ".vmt");                  mdl.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findMdlMaterials,The following statement contains a magic number: if (File.Exists(path))              {                    FileStream mdl = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(mdl);                    mdl.Seek(4' SeekOrigin.Begin);                  int ver = reader.ReadInt32();                    List<string> modelVmts = new List<string>();                  List<string> modelDirs = new List<string>();                    mdl.Seek(76' SeekOrigin.Begin);                  int datalength = reader.ReadInt32();                  mdl.Seek(124' SeekOrigin.Current);                    int textureCount = reader.ReadInt32();                  int textureOffset = reader.ReadInt32();                    int textureDirCount = reader.ReadInt32();                  int textureDirOffset = reader.ReadInt32();                    int skinreferenceCount = reader.ReadInt32();                  int skinrfamilyCount = reader.ReadInt32();                  int skinreferenceIndex = reader.ReadInt32();                    int bodypart_count = reader.ReadInt32();                  int bodypart_index = reader.ReadInt32();                    // find model names                  for (int i = 0; i < textureCount; i++)                  {                      mdl.Seek(textureOffset + (i * 64)' SeekOrigin.Begin);                      int textureNameOffset = reader.ReadInt32();                        mdl.Seek(textureOffset + (i * 64) + textureNameOffset' SeekOrigin.Begin);                      modelVmts.Add(readNullTerminatedString(mdl' reader));                  }                    // find model dirs                  List<int> textureDirOffsets = new List<int>();                  for (int i = 0; i < textureDirCount; i++)                  {                      mdl.Seek(textureDirOffset + (4 * i)' SeekOrigin.Begin);                      int offset = reader.ReadInt32();                      mdl.Seek(offset' SeekOrigin.Begin);                        string model = readNullTerminatedString(mdl' reader);                      model = model.TrimStart(new char[] { '/'' '\\' });                      modelDirs.Add(model);                  }                    if (skins != null)                  {                      // load specific skins                      List<int> material_ids = new List<int>();                        for (int i = 0; i < bodypart_count; i++)                      // we are reading an array of mstudiobodyparts_t                      {                          mdl.Seek(bodypart_index + i * 32' SeekOrigin.Begin);                            mdl.Seek(4' SeekOrigin.Current);                          int nummodels = reader.ReadInt32();                          mdl.Seek(4' SeekOrigin.Current);                          int modelindex = reader.ReadInt32();                            for (int j = 0; j < nummodels; j++)                          // we are reading an array of mstudiomodel_t                          {                              mdl.Seek(bodypart_index + modelindex + j * 140' SeekOrigin.Begin);                                mdl.Seek(72' SeekOrigin.Current);                              int nummeshes = reader.ReadInt32();                              int meshindex = reader.ReadInt32();                                for (int k = 0; k < nummeshes; k++)                              // we are reading an array of mstudiomesh_t                              {                                  mdl.Seek(bodypart_index + modelindex + meshindex + (k * 116)' SeekOrigin.Begin);                                  int mat_index = reader.ReadInt32();                                    if (!material_ids.Contains(mat_index))                                      material_ids.Add(mat_index);                              }                          }                      }                        // read the skintable                      mdl.Seek(skinreferenceIndex' SeekOrigin.Begin);                      short['] skintable = new short[skinrfamilyCount' skinreferenceCount];                      for (int i = 0; i < skinrfamilyCount; i++)                      {                          for (int j = 0; j < skinreferenceCount; j++)                          {                              skintable[i' j] = reader.ReadInt16();                          }                      }                        // trim the larger than required skintable                      short['] trimmedtable = new short[skinrfamilyCount' material_ids.Count];                      for (int i = 0; i < skinrfamilyCount; i++)                          for (int j = 0; j < material_ids.Count; j++)                              trimmedtable[i' j] = skintable[i' material_ids[j]];                        // add default skin 0 in case of non-existing skin indexes                      if (skins.IndexOf(0) == -1 && skins.Where(s => s >= trimmedtable.GetLength(0)).Count() != 0)                          skins.Add(0);                        // use the trimmed table to fetch used vmts                      foreach (int skin in skins.Where(skin => skin < trimmedtable.GetLength(0)))                          for (int j = 0; j < material_ids.Count; j++)                              for (int k = 0; k < modelDirs.Count; k++)                              {                                  short id = trimmedtable[skin' j];                                  materials.Add("materials/" + modelDirs[k] + modelVmts[id] + ".vmt");                              }                  }                  else                      // load all vmts                      for (int i = 0; i < modelVmts.Count; i++)                          for (int j = 0; j < modelDirs.Count; j++)                              materials.Add("materials/" + modelDirs[j] + modelVmts[i] + ".vmt");                  mdl.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPhyGibs,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream phy = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(phy);                  int header_size = reader.ReadInt32();                  phy.Seek(4' SeekOrigin.Current);                  int solidCount = reader.ReadInt32();                    phy.Seek(header_size' SeekOrigin.Begin);                  int solid_size = reader.ReadInt32();                                    phy.Seek(solid_size' SeekOrigin.Current);                  string something = readNullTerminatedString(phy' reader);                                    string[] entries = something.Split(new char [] { '{'''}' });                  for (int i = 0; i < entries.Count(); i++ )                  {                      if (entries[i].Trim().Equals("break")){                          string[] entry = entries[i + 1].Split(new char[]{' '}' StringSplitOptions.RemoveEmptyEntries);                            for (int j = 0; j < entry.Count(); j++)                              if (entry[j].Equals("\"model\"") || entry[j].Equals("\"ragdoll\""))                                  models.Add("models\\" + entry[j + 1].Trim('"')+".mdl");                      }                  }              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,vmtPathParser,The following statement contains a magic number: vmtline = vmtline.Split(new char[] { ' ' }' 2)[1];
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,vmtPathParser,The following statement contains a magic number: if (vmtline.EndsWith(".vmt") || vmtline.EndsWith(".vtf")) // removes extentions if present for consistency                  vmtline = vmtline.Substring(0' vmtline.Length - 4);
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findSoundscapeSounds,The following statement contains a magic number: foreach (string line in File.ReadAllLines(fullpath))              {                  string param = Regex.Replace(line' "[\t|\"]"' " ").Trim();                  if (param.ToLower().StartsWith("wave"))                  {                      string clip = param.Split(new char[] { ' ' }' 2)[1].Trim(' '' ')'' '(');                      audioFiles.Add("sound/" + clip);                  }              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findPcfMaterials,The following statement contains a magic number: if (File.Exists(path))              {                  FileStream pcf = new FileStream(path' FileMode.Open);                  BinaryReader reader = new BinaryReader(pcf);                    string ver = readNullTerminatedString(pcf' reader);                    if (!ver.Equals("<!-- dmx encoding binary 2 format pcf 1 -->\n"))                  {                      Console.WriteLine("Warning: Pcf File not supported'\n" +                      "\t custom materials will not be added if used");                      return materials;                  }                    // read pcf strings                  pcf.Seek(45' SeekOrigin.Begin);                    uint nbstring = reader.ReadUInt16();                  string[] pcfStrings = new string[nbstring];                  for (int i = 0; i < nbstring; i++)                      pcfStrings[i] = readNullTerminatedString(pcf' reader);                    // skipping over pcf elements                  int nbElements = reader.ReadInt32();                  for (int i = 0; i < nbElements; i++)                  {                      pcf.Seek(2' SeekOrigin.Current);                      readNullTerminatedString(pcf' reader);                      pcf.Seek(16' SeekOrigin.Current);                  }                    // read element data                  for (int e = 0; e < nbElements; e++)                  {                      int nbElemAtribs = reader.ReadInt32();                      for (int p = 0; p < nbElemAtribs; p++)                      {                          int typeid = reader.ReadInt16();                          int attributeType = reader.ReadByte();                          int count = (attributeType > 14) ? reader.ReadInt32() : 1;                          attributeType = (attributeType > 14) ? attributeType - 14 : attributeType;                            int[] typelength = { 0' 4' 4' 4' 1' 1' 4' 4' 4' 8' 12' 16' 12' 16' 64 };                            switch (attributeType)                          {                              case 5:                                  string attributeValue = readNullTerminatedString(pcf' reader);                                  if (pcfStrings[typeid] == "material")                                      materials.Add("materials/" + attributeValue);                                  break;                                case 6:                                  for (int i = 0; i < count; i++)                                  {                                      uint len = reader.ReadUInt32();                                      pcf.Seek(len' SeekOrigin.Current);                                  }                                  break;                                default:                                  pcf.Seek(typelength[attributeType] * count' SeekOrigin.Current);                                  break;                          }                        }                    }                  pcf.Close();              }
Magic Number,CompilePalX.Compilers.BSPPack,AssetUtils,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\AssetUtils.cs,findManifestPcfs,The following statement contains a magic number: foreach (string line in File.ReadAllLines(fullpath))              {                  if (line.ToLower().Contains("file"))                  {                      string[] l = line.Split('"');                      pcfs.Add(l[l.Count() - 2].TrimStart('!'));                  }              }
Magic Number,CompilePalX.Compilers.BSPPack,BSP,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\BSP.cs,BSP,The following statement contains a magic number: offsets = new KeyValuePair<int' int>[64];
Magic Number,CompilePalX.Compilers.BSPPack,BSP,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\BSP.cs,BSP,The following statement contains a magic number: for (int i = 0; i < offsets.GetLength(0); i++)              {                  bsp.Seek(8' SeekOrigin.Current); //skip id and version                  offsets[i] = new KeyValuePair<int' int>(reader.ReadInt32()' reader.ReadInt32());              }
Magic Number,CompilePalX.Compilers.BSPPack,BSP,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\BSP.cs,buildEntityList,The following statement contains a magic number: for (int i = 0; i < ent.Length; i++)              {                  if (ent[i] != 123 && ent[i] != 125)                      ents.Add(ent[i]);                    else if (ent[i] == 125)                  {                      string rawent = Encoding.ASCII.GetString(ents.ToArray());                      Dictionary<string' string> entity = new Dictionary<string' string>();                      foreach (string s in rawent.Split('\n'))                      {                          if (s.Count() != 0)                          {                              string[] c = s.Split('"');                              if (!entity.ContainsKey(c[1]))                                  entity.Add(c[1]' c[3]);                                //everything after the hammerid is input/outputs                              if (c[1] == "hammerid")                                  break;                          }                      }                      entityList.Add(entity);                      ents = new List<byte>();                  }              }
Magic Number,CompilePalX.Compilers.BSPPack,BSP,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\BSP.cs,buildEntityList,The following statement contains a magic number: for (int i = 0; i < ent.Length; i++)              {                  if (ent[i] != 123 && ent[i] != 125)                      ents.Add(ent[i]);                    else if (ent[i] == 125)                  {                      string rawent = Encoding.ASCII.GetString(ents.ToArray());                      Dictionary<string' string> entity = new Dictionary<string' string>();                      foreach (string s in rawent.Split('\n'))                      {                          if (s.Count() != 0)                          {                              string[] c = s.Split('"');                              if (!entity.ContainsKey(c[1]))                                  entity.Add(c[1]' c[3]);                                //everything after the hammerid is input/outputs                              if (c[1] == "hammerid")                                  break;                          }                      }                      entityList.Add(entity);                      ents = new List<byte>();                  }              }
Magic Number,CompilePalX.Compilers.BSPPack,BSP,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\BSP.cs,buildEntityList,The following statement contains a magic number: for (int i = 0; i < ent.Length; i++)              {                  if (ent[i] != 123 && ent[i] != 125)                      ents.Add(ent[i]);                    else if (ent[i] == 125)                  {                      string rawent = Encoding.ASCII.GetString(ents.ToArray());                      Dictionary<string' string> entity = new Dictionary<string' string>();                      foreach (string s in rawent.Split('\n'))                      {                          if (s.Count() != 0)                          {                              string[] c = s.Split('"');                              if (!entity.ContainsKey(c[1]))                                  entity.Add(c[1]' c[3]);                                //everything after the hammerid is input/outputs                              if (c[1] == "hammerid")                                  break;                          }                      }                      entityList.Add(entity);                      ents = new List<byte>();                  }              }
Magic Number,CompilePalX.Compilers.BSPPack,BSP,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\BSP.cs,buildEntityList,The following statement contains a magic number: for (int i = 0; i < ent.Length; i++)              {                  if (ent[i] != 123 && ent[i] != 125)                      ents.Add(ent[i]);                    else if (ent[i] == 125)                  {                      string rawent = Encoding.ASCII.GetString(ents.ToArray());                      Dictionary<string' string> entity = new Dictionary<string' string>();                      foreach (string s in rawent.Split('\n'))                      {                          if (s.Count() != 0)                          {                              string[] c = s.Split('"');                              if (!entity.ContainsKey(c[1]))                                  entity.Add(c[1]' c[3]);                                //everything after the hammerid is input/outputs                              if (c[1] == "hammerid")                                  break;                          }                      }                      entityList.Add(entity);                      ents = new List<byte>();                  }              }
Magic Number,CompilePalX.Compilers.BSPPack,BSP,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\BSP.cs,buildTextureList,The following statement contains a magic number: bsp.Seek(offsets[43].Key' SeekOrigin.Begin);
Magic Number,CompilePalX.Compilers.BSPPack,BSP,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\BSP.cs,buildTextureList,The following statement contains a magic number: TextureList = new List<string>(Encoding.ASCII.GetString(reader.ReadBytes(offsets[43].Value)).Split('\0'));
Magic Number,CompilePalX.Compilers.BSPPack,BSP,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\BSP.cs,buildModelList,The following statement contains a magic number: bsp.Seek(offsets[35].Key' SeekOrigin.Begin);
Magic Number,CompilePalX.Compilers.BSPPack,BSP,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\BSP.cs,buildModelList,The following statement contains a magic number: for (int i = 0; i < GameLumpOffsets.Length; i++)              {                  if (reader.ReadInt32() == 1936749168)                      propStaticId = i;                  bsp.Seek(4' SeekOrigin.Current); //skip flags and version                  GameLumpOffsets[i] = new KeyValuePair<int' int>(reader.ReadInt32()' reader.ReadInt32());              }
Magic Number,CompilePalX.Compilers.BSPPack,BSP,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\BSP.cs,buildModelList,The following statement contains a magic number: for (int i = 0; i < GameLumpOffsets.Length; i++)              {                  if (reader.ReadInt32() == 1936749168)                      propStaticId = i;                  bsp.Seek(4' SeekOrigin.Current); //skip flags and version                  GameLumpOffsets[i] = new KeyValuePair<int' int>(reader.ReadInt32()' reader.ReadInt32());              }
Magic Number,CompilePalX.Compilers.BSPPack,BSP,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\BSP.cs,buildModelList,The following statement contains a magic number: for (int i = 0; i < modelCount; i++)              {                  string model = Encoding.ASCII.GetString(reader.ReadBytes(128)).Trim('\0');                  if (model.Length != 0)                      ModelList.Add(model);              }
Magic Number,CompilePalX.Compilers.BSPPack,BSP,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\BSP.cs,buildModelList,The following statement contains a magic number: bsp.Seek(leafCount * 2' SeekOrigin.Current);
Magic Number,CompilePalX.Compilers.BSPPack,BSP,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\BSP.cs,buildModelList,The following statement contains a magic number: for (int i = 0; i < propCount; i++)              {                  bsp.Seek(i * propLength + propOffset + 24' SeekOrigin.Begin); // 24 skips origin and angles                  int modelId = reader.ReadUInt16();                  bsp.Seek(6' SeekOrigin.Current);                  int skin = reader.ReadInt32();                    if (modelSkinList[modelId].IndexOf(skin) == -1)                      modelSkinList[modelId].Add(skin);              }
Magic Number,CompilePalX.Compilers.BSPPack,BSP,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\BSPPack\BSP.cs,buildModelList,The following statement contains a magic number: for (int i = 0; i < propCount; i++)              {                  bsp.Seek(i * propLength + propOffset + 24' SeekOrigin.Begin); // 24 skips origin and angles                  int modelId = reader.ReadUInt16();                  bsp.Seek(6' SeekOrigin.Current);                  int skin = reader.ReadInt32();                    if (modelSkinList[modelId].IndexOf(skin) == -1)                      modelSkinList[modelId].Add(skin);              }
Magic Number,CompilePalX.Compilers,CompileExecutable,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\CompileExecutable.cs,readOutput,The following statement contains a magic number: char[] buffer = new char[256];
Magic Number,CompilePalX.Compilers,CompileExecutable,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\CompileExecutable.cs,readOutput,The following statement contains a magic number: while (true)              {                  if (read == null)                      read = Process.StandardOutput.ReadAsync(buffer' 0' buffer.Length);                    read.Wait(100); // an arbitray timeout                    if (read.IsCompleted)                  {                      if (read.Result > 0)                      {                          string text = new string(buffer' 0' read.Result);                            CompilePalLogger.ProgressiveLog(text);                            read = null; // ok' this task completed so we need to create a new one                          continue;                      }                        // got -1' process ended                      break;                  }              }
Magic Number,CompilePalX.Compilers,NavProcess,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\NavProcess.cs,Run,The following statement contains a magic number: try              {                CompilePalLogger.LogLine("\nCompilePal - Nav Generator");                    if (!File.Exists(context.CopyLocation))                  {                      throw new FileNotFoundException();                  }                    mapname = System.IO.Path.GetFileName(context.CopyLocation).Replace(".bsp"' "");              mapnav = context.CopyLocation.Replace(".bsp"' ".nav");              mapcfg = context.Configuration.GameFolder + "/cfg/" + mapname + ".cfg";              mapCFGBackup = context.Configuration.GameFolder + "/cfg/" + mapname + "_cpalbackup.cfg";                  string mapLog = mapname + "_nav.log";                  mapLogPath = Path.Combine(context.Configuration.GameFolder' mapLog);                    deleteNav(mapname' context.Configuration.GameFolder);                hidden = GetParameterString().Contains("-hidden");              bool textmode = GetParameterString().Contains("-textmode");                string args = "-game \"" + context.Configuration.GameFolder + "\" -windowed -novid -nosound +log 0 +sv_logflush 1 +sv_cheats 1 +map " + mapname;                if (hidden)                  args += " -noborder -x 4000 -y 2000";                if (textmode)                  args += " -textmode";                var startInfo = new ProcessStartInfo(context.Configuration.GameEXE' args);              startInfo.UseShellExecute = false;              startInfo.CreateNoWindow = false;                CompilePalLogger.LogLine("Generating...");              if (File.Exists(mapcfg))              {                  if (File.Exists(mapCFGBackup))                      System.IO.File.Delete(mapCFGBackup);                  System.IO.File.Move(mapcfg' mapCFGBackup);              }                if (File.Exists(mapLogPath))                  File.Delete(mapLogPath);                System.IO.File.Create(mapcfg).Dispose();              TextWriter tw = new StreamWriter(mapcfg);              tw.WriteLine("con_logfile " + mapLog);              tw.WriteLine("nav_generate");              tw.Close();                using (TextReader tr = new StreamReader(File.Open(mapLogPath' FileMode.OpenOrCreate' FileAccess.Read' FileShare.ReadWrite)))              {                  Process = new Process { StartInfo = startInfo };                  Process.Exited += new EventHandler(Process_Exited);                  Process.EnableRaisingEvents = true;                  Process.Start();                                    string line;                  do                  {                      Thread.Sleep(100);                      line = tr.ReadLine();                  } while (line == null || !line.Contains(".nav' saved."));                                    exitClient();              }                    CompilePalLogger.LogLine("nav file complete!");              }              catch (FileNotFoundException)              {                  CompilePalLogger.LogLine("FAILED - Could not find " + context.CopyLocation);              }              catch (Exception exception)              {                  CompilePalLogger.LogLine("Something broke:");                  CompilePalLogger.LogLine(exception.ToString());              }
Magic Number,CompilePalX.Compiling,CompilePalLogger,C:\repos\ruarai_CompilePal\CompilePalX\Compiling\Logger.cs,ProgressiveLog,The following statement contains a magic number: if (s.Contains("\n"))              {                  List<string> lines = lineBuffer.ToString().Split('\n').ToList();                    string suffixText = lines.Last();                    lineBuffer = new StringBuilder(suffixText);                                    OnBacktrack(tempText);                    for (var i = 0; i < lines.Count - 1; i++)                  {                      var line = lines[i];                      var error = ErrorFinder.GetError(line);                        if (error == null)                          Log(line);                      else                      {                          if (errorsFound.ContainsKey(error))                              errorsFound[error]++;                          else                              errorsFound.Add(error' 1);                            if (errorsFound[error] < 128)                              LogCompileError(line' error);                          else                              Log(line);//Stop hyperlinking errors if we see over 128 of them                                                    OnErrorFound(error);                      }                  }                    if (suffixText.Length > 0)                  {                      tempText = new List<Run>();                      tempText.Add(Log(suffixText));                  }              }              else              {                  tempText.Add(Log(s));              }
Magic Number,CompilePalX,ExceptionHandler,C:\repos\ruarai_CompilePal\CompilePalX\ExceptionHandler.cs,LogException,The following statement contains a magic number: if (crash)              {                  string crashLogName = DateTime.Now.ToString("s").Replace(":"' "-");                    File.WriteAllText(Path.Combine("CrashLogs"' crashLogName + ".txt")' e.ToString() + e.InnerException ?? "");                    Thread.Sleep(2000);                  Environment.Exit(0);              }
Magic Number,CompilePalX,GameConfigurationParser,C:\repos\ruarai_CompilePal\CompilePalX\GameConfiguration\GameConfigurationParser.cs,Parse,The following statement contains a magic number: for (int i = 4; i < lines.Length; i++)              {                  string line = lines[i];                    if (line == "	}" || line == "        }")                      break;                    var game = new GameConfiguration { Name = GetKey(line) };                    game.BinFolder = Path.GetDirectoryName(filename);                    CompilePalLogger.LogLine("Loading new game configuration:");                  CompilePalLogger.LogLine(GetKey(line));                    i++;                  for (; i < lines.Length; i++)                  {                      line = lines[i];                      if (IsValid(line))                      {                          switch (GetKey(line))                          {                              case "GameDir":                                  game.GameFolder = GetValue(line);                                  CompilePalLogger.LogLine(GetKey(line) + ":" + GetValue(line));                                  break;                              case "GameExe":                                  game.GameEXE = GetValue(line);                                  CompilePalLogger.LogLine(GetKey(line) + ":" + GetValue(line));                                  break;                              case "MapDir":                                  game.SDKMapFolder = GetValue(line);                                  CompilePalLogger.LogLine(GetKey(line) + ":" + GetValue(line));                                  break;                              case "BSP":                                  game.VBSP = GetValue(line);                                  CompilePalLogger.LogLine(GetKey(line) + ":" + GetValue(line));                                  break;                              case "Vis":                                  game.VVIS = GetValue(line);                                  CompilePalLogger.LogLine(GetKey(line) + ":" + GetValue(line));                                  break;                              case "Light":                                  game.VRAD = GetValue(line);                                  CompilePalLogger.LogLine(GetKey(line) + ":" + GetValue(line));                                  break;                              case "BSPDir":                                  game.MapFolder = GetValue(line);                                  CompilePalLogger.LogLine(GetKey(line) + ":" + GetValue(line));                                  break;                          }                      }                        if (line == "		}" || line == "                }")                      {                          gameInfos.Add(game);                          break;                      }                  }              }
Magic Number,CompilePalX,GameConfigurationParser,C:\repos\ruarai_CompilePal\CompilePalX\GameConfiguration\GameConfigurationParser.cs,GetValue,The following statement contains a magic number: return line.Split('"')[3];
Magic Number,CompilePalX,LaunchWindow,C:\repos\ruarai_CompilePal\CompilePalX\GameConfiguration\LaunchWindow.xaml.cs,LaunchWindow,The following statement contains a magic number: foreach (string arg in commandLineArgs)              {                  try                  {                      //If arg type is a game' continue                      if (arg.Substring(0' 6).ToLower() == "-game:")                      {                          //Make everything lowercase' remove arg type' and remove spaces                          string argGameConfig = arg.ToLower().Remove(0' 6).Replace(" "' "");                            //Search all configs to see if arg is a match                          foreach (GameConfiguration config in configs)                          {                              //Remove spaces and make everything lowercase                              string configName = config.Name.ToLower().Replace(" "' "");                                //If arg matches' launch that configuration                              if (argGameConfig == configName)                              {                                  Launch(config);                              }                          }                      }                  }                  catch (ArgumentOutOfRangeException e)                  {                      //Ignore error                  }              }
Magic Number,CompilePalX,LaunchWindow,C:\repos\ruarai_CompilePal\CompilePalX\GameConfiguration\LaunchWindow.xaml.cs,LaunchWindow,The following statement contains a magic number: foreach (string arg in commandLineArgs)              {                  try                  {                      //If arg type is a game' continue                      if (arg.Substring(0' 6).ToLower() == "-game:")                      {                          //Make everything lowercase' remove arg type' and remove spaces                          string argGameConfig = arg.ToLower().Remove(0' 6).Replace(" "' "");                            //Search all configs to see if arg is a match                          foreach (GameConfiguration config in configs)                          {                              //Remove spaces and make everything lowercase                              string configName = config.Name.ToLower().Replace(" "' "");                                //If arg matches' launch that configuration                              if (argGameConfig == configName)                              {                                  Launch(config);                              }                          }                      }                  }                  catch (ArgumentOutOfRangeException e)                  {                      //Ignore error                  }              }
Magic Number,CompilePalX,CompileProcess,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\CompileProcess.cs,LoadLegacyData,The following statement contains a magic number: metadata.BasisString = lines[3];
Magic Number,CompilePalX,CompileProcess,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\CompileProcess.cs,LoadLegacyData,The following statement contains a magic number: metadata.Order = float.Parse(lines[4]' CultureInfo.InvariantCulture);
Magic Number,CompilePalX,CompileProcess,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\CompileProcess.cs,LoadLegacyData,The following statement contains a magic number: metadata.DoRun = bool.Parse(lines[5]);
Magic Number,CompilePalX,CompileProcess,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\CompileProcess.cs,LoadLegacyData,The following statement contains a magic number: metadata.ReadOutput = bool.Parse(lines[6]);
Magic Number,CompilePalX,CompileProcess,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\CompileProcess.cs,LoadLegacyData,The following statement contains a magic number: if (lines.Count() > 7)                  metadata.Warning = lines[7];
Magic Number,CompilePalX,CompileProcess,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\CompileProcess.cs,LoadLegacyData,The following statement contains a magic number: if (lines.Count() > 7)                  metadata.Warning = lines[7];
Magic Number,CompilePalX,CompileProcess,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\CompileProcess.cs,LoadLegacyData,The following statement contains a magic number: if (lines.Count() > 8)                  metadata.Description = lines[8];
Magic Number,CompilePalX,CompileProcess,C:\repos\ruarai_CompilePal\CompilePalX\Compilers\CompileProcess.cs,LoadLegacyData,The following statement contains a magic number: if (lines.Count() > 8)                  metadata.Description = lines[8];
Magic Number,CompilePalX,CompilingManager,C:\repos\ruarai_CompilePal\CompilePalX\Compiling\CompilingManager.cs,CompilePalLogger_OnErrorFound,The following statement contains a magic number: if (e.Severity == 5 && IsCompiling)              {                  //We're currently in the thread we would like to kill' so make sure we invoke from the window thread to do this.                  MainWindow.ActiveDispatcher.Invoke(() =>                  {                      CompilePalLogger.LogLineColor("An error cancelled the compile."' Error.GetSeverityBrush(5));                      CancelCompile();                      ProgressManager.ErrorProgress();                  });              }
Magic Number,CompilePalX,CompilingManager,C:\repos\ruarai_CompilePal\CompilePalX\Compiling\CompilingManager.cs,CompilePalLogger_OnErrorFound,The following statement contains a magic number: if (e.Severity == 5 && IsCompiling)              {                  //We're currently in the thread we would like to kill' so make sure we invoke from the window thread to do this.                  MainWindow.ActiveDispatcher.Invoke(() =>                  {                      CompilePalLogger.LogLineColor("An error cancelled the compile."' Error.GetSeverityBrush(5));                      CancelCompile();                      ProgressManager.ErrorProgress();                  });              }
Magic Number,CompilePalX,CompilingManager,C:\repos\ruarai_CompilePal\CompilePalX\Compiling\CompilingManager.cs,postCompile,The following statement contains a magic number: if (errors != null && errors.Any())              {                  int numErrors = errors.Sum(e => e.Errors.Count);                  int maxSeverity = errors.Max(e => e.Errors.Any() ? e.Errors.Max(e2 => e2.Severity) : 0);                  CompilePalLogger.LogLineColor("{0} errors/warnings logged:"' Error.GetSeverityBrush(maxSeverity)' numErrors);                    foreach (var map in errors)                  {                      CompilePalLogger.Log("  ");                        if (!map.Errors.Any())                      {                          CompilePalLogger.LogLineColor("No errors/warnings logged for {0}"' Error.GetSeverityBrush(0)' map.MapName);                          continue;                      }                        int mapMaxSeverity = map.Errors.Max(e => e.Severity);                      CompilePalLogger.LogLineColor("{0} errors/warnings logged for {1}:"' Error.GetSeverityBrush(mapMaxSeverity)' map.Errors.Count' map.MapName);                        var distinctErrors = map.Errors.GroupBy(e => e.ID);                      foreach (var errorList in distinctErrors)                      {                          var error = errorList.First();                            string errorText = $"{errorList.Count()}x: {error.SeverityText}: {error.ShortDescription}";                            CompilePalLogger.Log("     ");                          CompilePalLogger.LogCompileError(errorText' error);                          CompilePalLogger.LogLine();                            if (error.Severity >= 3)                              AnalyticsManager.CompileError();                      }                  }              }
Magic Number,CompilePalX,ErrorFinder,C:\repos\ruarai_CompilePal\CompilePalX\Compiling\ErrorFinder.cs,AsyncInit,The following statement contains a magic number: try              {                  if (File.Exists(errorCache) && (DateTime.Now.Subtract(File.GetLastWriteTime(errorCache)).TotalDays < 7))                  {                      LoadErrorData(File.ReadAllText(errorCache));                  }                  else                  {                      WebClient c = new WebClient();                        string result = c.DownloadString(new Uri(errorURL));                        LoadErrorData(result);                        File.WriteAllText(errorCache' result);                  }              }              catch (Exception x)              {                  //nonvital part' record but dont quit                  ExceptionHandler.LogException(x' false);              }
Magic Number,CompilePalX,ErrorFinder,C:\repos\ruarai_CompilePal\CompilePalX\Compiling\ErrorFinder.cs,LoadErrorData,The following statement contains a magic number: for (int i = 1; i < (count * 2) + 1; i++)              {                  Error error = new Error();                    var data = lines[i].Split('|');                    error.Severity = int.Parse(data[0]);                  error.RegexTrigger = new Regex(data[1]);                  i++;                    var shortDesc = errorDescriptionPattern.Match(lines[i]);                  error.ShortDescription = shortDesc.Success ? shortDesc.Groups[1].Value : "unknown error";                    error.Message = style.Replace("%content%"' lines[i]);                    //CompilePalLogger.LogLineColor("Loaded trigger regex: {0}"'error.ErrorColor'data[1]);                      error.ID = id;                  errorList.Add(error);                  id++;              }
Magic Number,CompilePalX,Error,C:\repos\ruarai_CompilePal\CompilePalX\Compiling\ErrorFinder.cs,GetSeverityBrush,The following statement contains a magic number: switch (severity)              {                  default:                      return Brushes.Black;                  case 2:                      return Brushes.Orange;                  case 3:                      return Brushes.OrangeRed;                  case 4:                      return Brushes.DarkRed;                  case 5:                      return Brushes.Red;              }
Magic Number,CompilePalX,Error,C:\repos\ruarai_CompilePal\CompilePalX\Compiling\ErrorFinder.cs,GetSeverityBrush,The following statement contains a magic number: switch (severity)              {                  default:                      return Brushes.Black;                  case 2:                      return Brushes.Orange;                  case 3:                      return Brushes.OrangeRed;                  case 4:                      return Brushes.DarkRed;                  case 5:                      return Brushes.Red;              }
Magic Number,CompilePalX,Error,C:\repos\ruarai_CompilePal\CompilePalX\Compiling\ErrorFinder.cs,GetSeverityBrush,The following statement contains a magic number: switch (severity)              {                  default:                      return Brushes.Black;                  case 2:                      return Brushes.Orange;                  case 3:                      return Brushes.OrangeRed;                  case 4:                      return Brushes.DarkRed;                  case 5:                      return Brushes.Red;              }
Magic Number,CompilePalX,Error,C:\repos\ruarai_CompilePal\CompilePalX\Compiling\ErrorFinder.cs,GetSeverityBrush,The following statement contains a magic number: switch (severity)              {                  default:                      return Brushes.Black;                  case 2:                      return Brushes.Orange;                  case 3:                      return Brushes.OrangeRed;                  case 4:                      return Brushes.DarkRed;                  case 5:                      return Brushes.Red;              }
Magic Number,CompilePalX,ProgressManager,C:\repos\ruarai_CompilePal\CompilePalX\Compiling\ProgressManager.cs,SetProgress,The following statement contains a magic number: if (ready)              {                  taskbarInfo.Dispatcher.Invoke(() =>                  {                      taskbarInfo.ProgressState = TaskbarItemProgressState.Normal;                        taskbarInfo.ProgressValue = progress;                      ProgressChange(progress * 100);                        if (progress >= 1)                      {                          TitleChange(string.Format("{0}% - {1} {2}X"' Math.Floor(progress * 100d)' defaultTitle' UpdateManager.CurrentVersion));                            System.Media.SystemSounds.Exclamation.Play();                      }                      else if (progress <= 0)                      {                          taskbarInfo.ProgressState = TaskbarItemProgressState.None;                          TitleChange(string.Format("{0} {1}X {2}"' defaultTitle' UpdateManager.CurrentVersion' GameConfigurationManager.GameConfiguration.Name));                      }                      else                      {                          TitleChange(string.Format("{0}% - {1} {2}X"' Math.Floor(progress * 100d)' defaultTitle' UpdateManager.CurrentVersion));                      }                  });                }
Magic Number,CompilePalX,ConfigurationManager,C:\repos\ruarai_CompilePal\CompilePalX\Configuration\ConfigurationManager.cs,GetParameters,The following statement contains a magic number: if (File.Exists(jsonParameters))              {                  ConfigItem[] items = JsonConvert.DeserializeObject<ConfigItem[]>(File.ReadAllText(jsonParameters));                  foreach (var configItem in items)                  {                      list.Add(configItem);                  }              }              else              {                  string csvParameters = Path.Combine(ParametersFolder' processName + ".csv");                    if (File.Exists(csvParameters))                  {                      var baselines = File.ReadAllLines(csvParameters);                        for (int i = 2; i < baselines.Length; i++)                      {                          string baseline = baselines[i];                            var item = ParseBaseLine(baseline);                            list.Add(item);                      }                        ConfigItem[] items = list.ToArray();                        File.WriteAllText(jsonParameters' JsonConvert.SerializeObject(items' Formatting.Indented));                  }                  else                  {                      throw new FileNotFoundException("Parameter files could not be found for " + processName);                  }              }
Magic Number,CompilePalX,ConfigurationManager,C:\repos\ruarai_CompilePal\CompilePalX\Configuration\ConfigurationManager.cs,ParsePresetLine,The following statement contains a magic number: if (pieces.Any())              {                  item.Parameter = pieces[0];                  if (pieces.Count() >= 2)                      item.Value = pieces[1];              }
Magic Number,CompilePalX,ConfigurationManager,C:\repos\ruarai_CompilePal\CompilePalX\Configuration\ConfigurationManager.cs,ParseBaseLine,The following statement contains a magic number: if (pieces.Any())              {                  item.Name = pieces[0];                  if (pieces.Count() >= 2)                      item.Parameter = pieces[1];                  if (pieces.Count() >= 3)                      item.CanHaveValue = bool.Parse(pieces[2]);                  if (pieces.Count() >= 4)                      item.Description = pieces[3];                  if (pieces.Count() >= 5)                      item.Warning = pieces[4];              }
Magic Number,CompilePalX,ConfigurationManager,C:\repos\ruarai_CompilePal\CompilePalX\Configuration\ConfigurationManager.cs,ParseBaseLine,The following statement contains a magic number: if (pieces.Any())              {                  item.Name = pieces[0];                  if (pieces.Count() >= 2)                      item.Parameter = pieces[1];                  if (pieces.Count() >= 3)                      item.CanHaveValue = bool.Parse(pieces[2]);                  if (pieces.Count() >= 4)                      item.Description = pieces[3];                  if (pieces.Count() >= 5)                      item.Warning = pieces[4];              }
Magic Number,CompilePalX,ConfigurationManager,C:\repos\ruarai_CompilePal\CompilePalX\Configuration\ConfigurationManager.cs,ParseBaseLine,The following statement contains a magic number: if (pieces.Any())              {                  item.Name = pieces[0];                  if (pieces.Count() >= 2)                      item.Parameter = pieces[1];                  if (pieces.Count() >= 3)                      item.CanHaveValue = bool.Parse(pieces[2]);                  if (pieces.Count() >= 4)                      item.Description = pieces[3];                  if (pieces.Count() >= 5)                      item.Warning = pieces[4];              }
Magic Number,CompilePalX,ConfigurationManager,C:\repos\ruarai_CompilePal\CompilePalX\Configuration\ConfigurationManager.cs,ParseBaseLine,The following statement contains a magic number: if (pieces.Any())              {                  item.Name = pieces[0];                  if (pieces.Count() >= 2)                      item.Parameter = pieces[1];                  if (pieces.Count() >= 3)                      item.CanHaveValue = bool.Parse(pieces[2]);                  if (pieces.Count() >= 4)                      item.Description = pieces[3];                  if (pieces.Count() >= 5)                      item.Warning = pieces[4];              }
Magic Number,CompilePalX,ConfigurationManager,C:\repos\ruarai_CompilePal\CompilePalX\Configuration\ConfigurationManager.cs,ParseBaseLine,The following statement contains a magic number: if (pieces.Any())              {                  item.Name = pieces[0];                  if (pieces.Count() >= 2)                      item.Parameter = pieces[1];                  if (pieces.Count() >= 3)                      item.CanHaveValue = bool.Parse(pieces[2]);                  if (pieces.Count() >= 4)                      item.Description = pieces[3];                  if (pieces.Count() >= 5)                      item.Warning = pieces[4];              }
Magic Number,CompilePalX,ConfigurationManager,C:\repos\ruarai_CompilePal\CompilePalX\Configuration\ConfigurationManager.cs,ParseBaseLine,The following statement contains a magic number: if (pieces.Any())              {                  item.Name = pieces[0];                  if (pieces.Count() >= 2)                      item.Parameter = pieces[1];                  if (pieces.Count() >= 3)                      item.CanHaveValue = bool.Parse(pieces[2]);                  if (pieces.Count() >= 4)                      item.Description = pieces[3];                  if (pieces.Count() >= 5)                      item.Warning = pieces[4];              }
Magic Number,CompilePalX,ConfigurationManager,C:\repos\ruarai_CompilePal\CompilePalX\Configuration\ConfigurationManager.cs,ParseBaseLine,The following statement contains a magic number: if (pieces.Any())              {                  item.Name = pieces[0];                  if (pieces.Count() >= 2)                      item.Parameter = pieces[1];                  if (pieces.Count() >= 3)                      item.CanHaveValue = bool.Parse(pieces[2]);                  if (pieces.Count() >= 4)                      item.Description = pieces[3];                  if (pieces.Count() >= 5)                      item.Warning = pieces[4];              }
Magic Number,CompilePalX,MainWindow,C:\repos\ruarai_CompilePal\CompilePalX\MainWindow.xaml.cs,HandleArgs,The following statement contains a magic number: foreach (string arg in commandLineArgs)              {                  try                  {                      if (!ignoreWipeArg)                      {                          //Wipes the map list                          if (arg.Substring(0' 5).ToLower() == "-wipe")                          {                              CompilingManager.MapFiles.Clear();                              //Recursive so if the wipe arg comes after a arg path' it will readd it                              HandleArgs(true);                              break;                          }                      }                      else                      {                          //If arg type is a path' continue                          if (arg.Substring(0' 6).ToLower() == "-path:")                          {                              //Remove arg type                              string argPath = arg.Remove(0' 6);                                if (File.Exists(argPath))                              {                                  if (argPath.EndsWith(".vmf") || argPath.EndsWith(".vmm") || argPath.EndsWith(".vmx"))                                      CompilingManager.MapFiles.Add(argPath);                              }                          }                      }                  }                  catch (ArgumentOutOfRangeException e)                  {                      //Ignore error                  }              }
Magic Number,CompilePalX,MainWindow,C:\repos\ruarai_CompilePal\CompilePalX\MainWindow.xaml.cs,HandleArgs,The following statement contains a magic number: foreach (string arg in commandLineArgs)              {                  try                  {                      if (!ignoreWipeArg)                      {                          //Wipes the map list                          if (arg.Substring(0' 5).ToLower() == "-wipe")                          {                              CompilingManager.MapFiles.Clear();                              //Recursive so if the wipe arg comes after a arg path' it will readd it                              HandleArgs(true);                              break;                          }                      }                      else                      {                          //If arg type is a path' continue                          if (arg.Substring(0' 6).ToLower() == "-path:")                          {                              //Remove arg type                              string argPath = arg.Remove(0' 6);                                if (File.Exists(argPath))                              {                                  if (argPath.EndsWith(".vmf") || argPath.EndsWith(".vmm") || argPath.EndsWith(".vmx"))                                      CompilingManager.MapFiles.Add(argPath);                              }                          }                      }                  }                  catch (ArgumentOutOfRangeException e)                  {                      //Ignore error                  }              }
Magic Number,CompilePalX,MainWindow,C:\repos\ruarai_CompilePal\CompilePalX\MainWindow.xaml.cs,HandleArgs,The following statement contains a magic number: foreach (string arg in commandLineArgs)              {                  try                  {                      if (!ignoreWipeArg)                      {                          //Wipes the map list                          if (arg.Substring(0' 5).ToLower() == "-wipe")                          {                              CompilingManager.MapFiles.Clear();                              //Recursive so if the wipe arg comes after a arg path' it will readd it                              HandleArgs(true);                              break;                          }                      }                      else                      {                          //If arg type is a path' continue                          if (arg.Substring(0' 6).ToLower() == "-path:")                          {                              //Remove arg type                              string argPath = arg.Remove(0' 6);                                if (File.Exists(argPath))                              {                                  if (argPath.EndsWith(".vmf") || argPath.EndsWith(".vmm") || argPath.EndsWith(".vmx"))                                      CompilingManager.MapFiles.Add(argPath);                              }                          }                      }                  }                  catch (ArgumentOutOfRangeException e)                  {                      //Ignore error                  }              }
Magic Number,CompilePalX,MainWindow,C:\repos\ruarai_CompilePal\CompilePalX\MainWindow.xaml.cs,ProgressManager_ProgressChange,The following statement contains a magic number: if (progress < 0 || progress >= 100)                  CompileStartStopButton.Content = "Compile";
Magic Number,CompilePalX,MainWindow,C:\repos\ruarai_CompilePal\CompilePalX\MainWindow.xaml.cs,UpdateConfigGrid,The following statement contains a magic number: ConfigDataGrid.BeginAnimation(OpacityProperty' new DoubleAnimation(0' 1' new Duration(TimeSpan.FromMilliseconds(50))));
Magic Number,CompilePalX,MainWindow,C:\repos\ruarai_CompilePal\CompilePalX\MainWindow.xaml.cs,UpdateProcessList,The following statement contains a magic number: CompileProcessesListBox.BeginAnimation(OpacityProperty' new DoubleAnimation(0' 1' new Duration(TimeSpan.FromMilliseconds(50))));
Missing Default,CompilePalX,GameConfigurationParser,C:\repos\ruarai_CompilePal\CompilePalX\GameConfiguration\GameConfigurationParser.cs,Parse,The following switch statement is missing a default case: switch (GetKey(line))                          {                              case "GameDir":                                  game.GameFolder = GetValue(line);                                  CompilePalLogger.LogLine(GetKey(line) + ":" + GetValue(line));                                  break;                              case "GameExe":                                  game.GameEXE = GetValue(line);                                  CompilePalLogger.LogLine(GetKey(line) + ":" + GetValue(line));                                  break;                              case "MapDir":                                  game.SDKMapFolder = GetValue(line);                                  CompilePalLogger.LogLine(GetKey(line) + ":" + GetValue(line));                                  break;                              case "BSP":                                  game.VBSP = GetValue(line);                                  CompilePalLogger.LogLine(GetKey(line) + ":" + GetValue(line));                                  break;                              case "Vis":                                  game.VVIS = GetValue(line);                                  CompilePalLogger.LogLine(GetKey(line) + ":" + GetValue(line));                                  break;                              case "Light":                                  game.VRAD = GetValue(line);                                  CompilePalLogger.LogLine(GetKey(line) + ":" + GetValue(line));                                  break;                              case "BSPDir":                                  game.MapFolder = GetValue(line);                                  CompilePalLogger.LogLine(GetKey(line) + ":" + GetValue(line));                                  break;                          }
