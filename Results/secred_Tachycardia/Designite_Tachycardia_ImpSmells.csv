Implementation smell,Namespace,Class,File,Method,Description
Long Method,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,pagein,The method has 111 lines of code.
Long Method,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The method has 107 lines of code.
Long Method,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The method has 283 lines of code.
Long Method,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The method has 299 lines of code.
Long Method,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,synthesis_blockin,The method has 101 lines of code.
Long Method,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The method has 119 lines of code.
Long Method,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,inverse,The method has 124 lines of code.
Long Method,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The method has 113 lines of code.
Long Method,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The method has 123 lines of code.
Long Method,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,process_packet,The method has 117 lines of code.
Long Method,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,pcm_seek,The method has 103 lines of code.
Long Method,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The method has 119 lines of code.
Long Method,Tachycardia.Tools.Commands,SkyX,C:\repos\secred_Tachycardia\src\Tools\Commands\SkyX.cs,OnAtmosphere,The method has 103 lines of code.
Complex Method,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,Cyclomatic complexity of the method is 30
Complex Method,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,KeyPressedHandler,Cyclomatic complexity of the method is 12
Complex Method,Tachycardia,Character,C:\repos\secred_Tachycardia\src\Player\Character.cs,Update,Cyclomatic complexity of the method is 22
Complex Method,Tachycardia,GameState,C:\repos\secred_Tachycardia\src\States\GameState.cs,KeyPressed,Cyclomatic complexity of the method is 39
Complex Method,Tachycardia,GameState,C:\repos\secred_Tachycardia\src\States\GameState.cs,KeyReleased,Cyclomatic complexity of the method is 15
Complex Method,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,UserProcess,Cyclomatic complexity of the method is 9
Complex Method,OpenTK.Audio,AudioContext,C:\repos\secred_Tachycardia\src\Sound\AudioContext.cs,CreateContext,Cyclomatic complexity of the method is 24
Complex Method,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,Cyclomatic complexity of the method is 21
Complex Method,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,ErrorMessage,Cyclomatic complexity of the method is 9
Complex Method,OpenTK.Audio,AudioDeviceEnumerator,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioDeviceEnumerator.cs,AudioDeviceEnumerator,Cyclomatic complexity of the method is 13
Complex Method,OpenTK.Audio,AudioDeviceErrorChecker,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioDeviceErrorChecker.cs,Dispose,Cyclomatic complexity of the method is 11
Complex Method,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,init,Cyclomatic complexity of the method is 8
Complex Method,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,pagein,Cyclomatic complexity of the method is 21
Complex Method,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,Cyclomatic complexity of the method is 16
Complex Method,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,Cyclomatic complexity of the method is 9
Complex Method,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,decode,Cyclomatic complexity of the method is 11
Complex Method,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,decodevs,Cyclomatic complexity of the method is 17
Complex Method,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,best,Cyclomatic complexity of the method is 15
Complex Method,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,besterror,Cyclomatic complexity of the method is 10
Complex Method,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,make_words,Cyclomatic complexity of the method is 12
Complex Method,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,make_decode_tree,Cyclomatic complexity of the method is 12
Complex Method,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drfti1,Cyclomatic complexity of the method is 10
Complex Method,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,Cyclomatic complexity of the method is 46
Complex Method,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drftf1,Cyclomatic complexity of the method is 10
Complex Method,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,Cyclomatic complexity of the method is 44
Complex Method,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drftb1,Cyclomatic complexity of the method is 12
Complex Method,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,synthesis_blockin,Cyclomatic complexity of the method is 22
Complex Method,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,inverse1,Cyclomatic complexity of the method is 12
Complex Method,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,pack,Cyclomatic complexity of the method is 8
Complex Method,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,unpack,Cyclomatic complexity of the method is 12
Complex Method,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,look,Cyclomatic complexity of the method is 27
Complex Method,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,Cyclomatic complexity of the method is 17
Complex Method,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,clear,Cyclomatic complexity of the method is 9
Complex Method,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,Cyclomatic complexity of the method is 28
Complex Method,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,synthesis_headerin,Cyclomatic complexity of the method is 16
Complex Method,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,Cyclomatic complexity of the method is 8
Complex Method,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_from_data,Cyclomatic complexity of the method is 12
Complex Method,csvorbis,Lsp,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lsp.cs,lsp_to_curve,Cyclomatic complexity of the method is 9
Complex Method,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,pack,Cyclomatic complexity of the method is 8
Complex Method,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,unpack,Cyclomatic complexity of the method is 13
Complex Method,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,Cyclomatic complexity of the method is 8
Complex Method,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,Cyclomatic complexity of the method is 8
Complex Method,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,mdct_kernel,Cyclomatic complexity of the method is 8
Complex Method,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,look,Cyclomatic complexity of the method is 8
Complex Method,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,_01inverse,Cyclomatic complexity of the method is 21
Complex Method,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,_2inverse,Cyclomatic complexity of the method is 10
Complex Method,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,Cyclomatic complexity of the method is 32
Complex Method,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,Cyclomatic complexity of the method is 37
Complex Method,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unquantize,Cyclomatic complexity of the method is 16
Complex Method,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,fetch_headers,Cyclomatic complexity of the method is 10
Complex Method,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,process_packet,Cyclomatic complexity of the method is 14
Complex Method,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,raw_seek,Cyclomatic complexity of the method is 14
Complex Method,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,pcm_seek,Cyclomatic complexity of the method is 16
Complex Method,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,Cyclomatic complexity of the method is 34
Complex Method,Tachycardia.Sound.BGM,OggPlayer,C:\repos\secred_Tachycardia\src\Sound\Audio\OggPlayer.cs,PlayThread,Cyclomatic complexity of the method is 14
Complex Method,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,Find,Cyclomatic complexity of the method is 13
Complex Method,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,RFind,Cyclomatic complexity of the method is 12
Complex Method,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,StringTypeToEncoding,Cyclomatic complexity of the method is 8
Complex Method,TagLib,File,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\File.cs,Find,Cyclomatic complexity of the method is 10
Complex Method,TagLib.Ogg,File,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\File.cs,Save,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,Cyclomatic complexity of the method is 12
Complex Method,TagLib.Ogg,PageHeader,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\PageHeader.cs,PageHeader,Cyclomatic complexity of the method is 8
Complex Method,TagLib.Ogg,Paginator,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Paginator.cs,Paginate,Cyclomatic complexity of the method is 10
Complex Method,Tachycardia.Sound,SoundDict,C:\repos\secred_Tachycardia\src\Sound\SoundDict.cs,Update,Cyclomatic complexity of the method is 11
Complex Method,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,OnTab,Cyclomatic complexity of the method is 12
Complex Method,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,OnInvokeParseArg,Cyclomatic complexity of the method is 9
Complex Method,Tachycardia.Tools.Commands,SkyX,C:\repos\secred_Tachycardia\src\Tools\Commands\SkyX.cs,OnAtmosphere,Cyclomatic complexity of the method is 35
Complex Method,Tachycardia.Tools.Commands,SkyX,C:\repos\secred_Tachycardia\src\Tools\Commands\SkyX.cs,OnMode,Cyclomatic complexity of the method is 12
Complex Method,Tachycardia.Tools.Commands,SkyX,C:\repos\secred_Tachycardia\src\Tools\Commands\SkyX.cs,OnMoon,Cyclomatic complexity of the method is 16
Complex Method,Tachycardia.Tools,ConsoleParser,C:\repos\secred_Tachycardia\src\Tools\ConsoleParser.cs,OnTab,Cyclomatic complexity of the method is 14
Complex Method,Tachycardia.Tools,ConsoleParser,C:\repos\secred_Tachycardia\src\Tools\ConsoleParser.cs,ParseInputKey,Cyclomatic complexity of the method is 33
Complex Method,Helper,DotSceneLoader,C:\repos\secred_Tachycardia\src\Tools\DotSceneLoader.cs,processLight,Cyclomatic complexity of the method is 12
Complex Method,Helper,DotSceneLoader,C:\repos\secred_Tachycardia\src\Tools\DotSceneLoader.cs,processNode,Cyclomatic complexity of the method is 15
Long Parameter List,Tachycardia,PhysicsManager,C:\repos\secred_Tachycardia\src\Core\Physics\PhysicsManager.cs,addRope,The method has 5 parameters.
Long Parameter List,OpenTK.Audio,AudioContext,C:\repos\secred_Tachycardia\src\Sound\AudioContext.cs,AudioContext,The method has 5 parameters.
Long Parameter List,OpenTK.Audio,AudioContext,C:\repos\secred_Tachycardia\src\Sound\AudioContext.cs,AudioContext,The method has 6 parameters.
Long Parameter List,OpenTK.Audio,AudioContext,C:\repos\secred_Tachycardia\src\Sound\AudioContext.cs,CreateContext,The method has 6 parameters.
Long Parameter List,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,decodevv_add,The method has 5 parameters.
Long Parameter List,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,decodevs,The method has 5 parameters.
Long Parameter List,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,dist,The method has 5 parameters.
Long Parameter List,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The method has 6 parameters.
Long Parameter List,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The method has 10 parameters.
Long Parameter List,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The method has 11 parameters.
Long Parameter List,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drftf1,The method has 5 parameters.
Long Parameter List,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The method has 6 parameters.
Long Parameter List,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The method has 8 parameters.
Long Parameter List,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The method has 10 parameters.
Long Parameter List,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The method has 11 parameters.
Long Parameter List,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drftb1,The method has 6 parameters.
Long Parameter List,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,forward,The method has 5 parameters.
Long Parameter List,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,lpc_to_curve,The method has 6 parameters.
Long Parameter List,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,forward,The method has 5 parameters.
Long Parameter List,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,render_point,The method has 5 parameters.
Long Parameter List,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,render_line,The method has 5 parameters.
Long Parameter List,csvorbis,FuncFloor,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\FuncFloor.cs,forward,The method has 5 parameters.
Long Parameter List,csvorbis,FuncResidue,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\FuncResidue.cs,inverse,The method has 5 parameters.
Long Parameter List,csvorbis,Lsp,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lsp.cs,lsp_to_curve,The method has 8 parameters.
Long Parameter List,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,mdct_kernel,The method has 6 parameters.
Long Parameter List,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,_01inverse,The method has 5 parameters.
Long Parameter List,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,inverse,The method has 5 parameters.
Long Parameter List,csvorbis,Residue1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue1.cs,inverse,The method has 5 parameters.
Long Parameter List,csvorbis,Residue2,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue2.cs,inverse,The method has 5 parameters.
Long Parameter List,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,StaticCodeBook,The method has 11 parameters.
Long Parameter List,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,bisect_forward_serialno,The method has 5 parameters.
Long Parameter List,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The method has 6 parameters.
Long Parameter List,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,Source,The method has 5 parameters.
Long Parameter List,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,Source,The method has 5 parameters.
Long Parameter List,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,Source,The method has 5 parameters.
Long Parameter List,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,Source,The method has 5 parameters.
Long Parameter List,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,GetSource,The method has 5 parameters.
Long Parameter List,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,GetSource,The method has 5 parameters.
Long Parameter List,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,BufferData,The method has 5 parameters.
Long Parameter List,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,BufferData,The method has 5 parameters.
Long Parameter List,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,BufferData,The method has 5 parameters.
Long Parameter List,Helper,DotSceneLoader,C:\repos\secred_Tachycardia\src\Tools\DotSceneLoader.cs,ParseDotScene,The method has 5 parameters.
Long Statement,Tachycardia,PhysicsManager,C:\repos\secred_Tachycardia\src\Core\Physics\PhysicsManager.cs,addMaterialPair,The length of the statement  "	m_MaterialsPair.Add (mat_name0 + mat_name1' new MogreNewt.MaterialPair (Core.Singleton.NewtonWorld' m_Materials [mat_name0]' m_Materials [mat_name1])); " is 151.
Long Statement,Tachycardia,PhysicsManager,C:\repos\secred_Tachycardia\src\Core\Physics\PhysicsManager.cs,addRope,The length of the statement  "	m_Joints.Add ("j" + m_Joints.Count' new MogreNewt.BasicJoints.BallAndSocket (Core.Singleton.NewtonWorld' body [v - 1].m_Body' null' body [v - 1].m_Node.Position += new Vector3 (0' 1f' 0))); " is 189.
Long Statement,Tachycardia,PhysicsManager,C:\repos\secred_Tachycardia\src\Core\Physics\PhysicsManager.cs,addRope,The length of the statement  "		m_Joints.Add ("j" + m_Joints.Count' new MogreNewt.BasicJoints.BallAndSocket (Core.Singleton.NewtonWorld' body [i + 1].m_Body' body [i].m_Body' body [i].m_Node.Position)); " is 170.
Long Statement,Tachycardia,PhysicsManager,C:\repos\secred_Tachycardia\src\Core\Physics\PhysicsManager.cs,addRope,The length of the statement  "	//m_Joints.Add("j" + m_Joints.Count' new MogreNewt.BasicJoints.BallAndSocket(Core.Singleton.NewtonWorld' c.m_Node.'body[v - 1].m_Body ' )); " is 139.
Long Statement,Tachycardia,PhysicsManager,C:\repos\secred_Tachycardia\src\Core\Physics\PhysicsManager.cs,addElevator,The length of the statement  "	m_Joints.Add ("j" + m_Joints.Count' new MogreNewt.BasicJoints.Slider (Core.Singleton.NewtonWorld' body.m_Body' null' body.m_Node.Position' new Vector3 (0f' 1f' 0f))); " is 166.
Long Statement,Tachycardia,LogicState,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,willTurnLeft,The length of the statement  "		m_Control.m_GoTo = m_Control.m_PlayerNode.Orientation * new Mogre.Quaternion (new Mogre.Degree (getSpdTurn ())' Mogre.Vector3.UNIT_Y); " is 134.
Long Statement,Tachycardia,LogicState,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,willTurnLeft,The length of the statement  "		m_Control.m_PlayerNode.Orientation *= Mogre.Vector3.UNIT_Z.GetRotationTo (new Mogre.Vector3 (3 * Core.m_FixedTime' 0' 1.0f).NormalisedCopy); " is 140.
Long Statement,Tachycardia,LogicState,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,willTurnRight,The length of the statement  "		m_Control.m_GoTo = m_Control.m_PlayerNode.Orientation * new Mogre.Quaternion (new Mogre.Degree (-getSpdTurn ())' Mogre.Vector3.UNIT_Y); " is 135.
Long Statement,Tachycardia,LogicState,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,willTurnRight,The length of the statement  "		m_Control.m_PlayerNode.Orientation *= Mogre.Vector3.UNIT_Z.GetRotationTo (new Mogre.Vector3 (-3 * Core.m_FixedTime' 0' 1.0f).NormalisedCopy); " is 141.
Long Statement,Tachycardia,LogicState,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,willForward,The length of the statement  "	m_Control.m_MainBody.AddForce (-m_Control.m_MainBody.Velocity * new Mogre.Vector3 (1' 0' 1) * 4 * m_Control.m_MainBody.Mass); " is 125.
Long Statement,Tachycardia,LogicState,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,willBackward,The length of the statement  "	m_Control.m_MainBody.AddForce (-m_Control.m_MainBody.Velocity * new Mogre.Vector3 (1' 0' 1) * 4 * m_Control.m_MainBody.Mass); " is 125.
Long Statement,Tachycardia,Normal,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,willJump,The length of the statement  "	m_Control.m_MainBody.AddImpulse (new Mogre.Vector3 (0' m_Control.m_jumpForce * m_Control.m_adrenaline' 0)' m_Control.m_MainBody.Position); " is 138.
Long Statement,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,AttachHydrax,The length of the statement  "	MHydrax.MProjectedGrid grid = new MHydrax.MProjectedGrid (m_Hydrax' new MHydrax.MPerlin ()' new Plane (new Vector3 (0' 1' 0)' new Vector3 ())' MHydrax.MMaterialManager.MNormalMode.NM_VERTEX); " is 191.
Long Statement,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateOgitorScene,The length of the statement  "			m_Log.LogMessage("Player created.");*///z pominieciem profilu' jezeli mi ktos przedstawi jaki byl glebszy sens tego to wrocimy " is 126.
Long Statement,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,KeyPressedHandler,The length of the statement  "		tus.SetAlphaOperation (Mogre.LayerBlendOperationEx.LBX_MODULATE' Mogre.LayerBlendSource.LBS_MANUAL' Mogre.LayerBlendSource.LBS_TEXTURE' alphaLevel); " is 148.
Long Statement,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,KeyPressedHandler,The length of the statement  "		tus.SetAlphaOperation (Mogre.LayerBlendOperationEx.LBX_MODULATE' Mogre.LayerBlendSource.LBS_MANUAL' Mogre.LayerBlendSource.LBS_TEXTURE' alphaLevel); " is 148.
Long Statement,Tachycardia,Map,C:\repos\secred_Tachycardia\src\Core\Map\Map.cs,SetCollisionMesh,The length of the statement  "	MogreNewt.CollisionPrimitives.TreeCollisionSceneParser collision = new MogreNewt.CollisionPrimitives.TreeCollisionSceneParser (Core.Singleton.NewtonWorld); " is 155.
Long Statement,Tachycardia,GameCamera,C:\repos\secred_Tachycardia\src\GameCamera.cs,Update,The length of the statement  "	Vector3 offset = /*Character.m_Node.Orientation*/orientation * (-Vector3.UNIT_Z + (Vector3.UNIT_Y * (float)System.Math.Tan (Angle.ValueRadians))).NormalisedCopy * Distance; " is 172.
Long Statement,Tachycardia,GameCamera,C:\repos\secred_Tachycardia\src\GameCamera.cs,Update,The length of the statement  "	PredicateRaycast raycast = new PredicateRaycast ((b => !(b.UserData is Tachycardia.Objects.Trigger || b.UserData is Character))); " is 129.
Long Statement,Tachycardia,GameCamera,C:\repos\secred_Tachycardia\src\GameCamera.cs,Update,The length of the statement  "		Core.Singleton.Camera.Position = head + (InterPosition - head) * raycast.Contacts [0].Distance + raycast.Contacts [0].Normal * 0.15f; " is 133.
Long Statement,Tachycardia,Character,C:\repos\secred_Tachycardia\src\Player\Character.cs,Update,The length of the statement  "		if (walkAnimation.TimePosition / walkAnimation.Length > 0.5f && (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.5f || (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.0f) { " is 349.
Long Statement,Tachycardia,Character,C:\repos\secred_Tachycardia\src\Player\Character.cs,Update,The length of the statement  "			Core.Singleton.SoundDict.Play ("player/step_gravel_0" + new Random ().Next (1' 4) + ".wav"' m_Control.m_MainBody.Position); " is 123.
Long Statement,Tachycardia,Character,C:\repos\secred_Tachycardia\src\Player\Character.cs,Update,The length of the statement  "		if (walkAnimation.TimePosition / walkAnimation.Length > 0.5f && (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.5f || (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.0f) { " is 349.
Long Statement,Tachycardia,Character,C:\repos\secred_Tachycardia\src\Player\Character.cs,Update,The length of the statement  "			Core.Singleton.SoundDict.Play ("player/step_gravel_0" + new Random ().Next (1' 4) + ".wav"' m_Control.m_MainBody.Position); " is 123.
Long Statement,Tachycardia,GameState,C:\repos\secred_Tachycardia\src\States\GameState.cs,KeyPressed,The length of the statement  "		Console.WriteLine ("Pozycja X = " + Core.Singleton.Camera.Position.x + " Y = " + Core.Singleton.Camera.Position.y + " Z  = " + Core.Singleton.Camera.Position.z); " is 161.
Long Statement,Tachycardia,GameState,C:\repos\secred_Tachycardia\src\States\GameState.cs,MouseMoved,The length of the statement  "	Core.Singleton.m_GameCamera.orientation *= Mogre.Vector3.UNIT_Z.GetRotationTo (new Vector3 ((float)evt.state.X.rel / -5 * Core.m_FixedTime' 0' 1.0f).NormalisedCopy); " is 165.
Long Statement,Tachycardia.Objects.Actions,Teleport,C:\repos\secred_Tachycardia\src\Objects\Actions\Teleport.cs,Go,The length of the statement  "	_Player.m_Control.m_SecondBody.SetPositionOrientation (m_TeleportTo + new Mogre.Vector3 (0' 1' 0)' Mogre.Quaternion.IDENTITY); " is 126.
Long Statement,Tachycardia.Objects,Barrel,C:\repos\secred_Tachycardia\src\Objects\Logic\Barrel.cs,SetPhysics,The length of the statement  "	MogreNewt.ConvexCollision collision = new MogreNewt.CollisionPrimitives.Cylinder (Core.Singleton.NewtonWorld' Core.Singleton.PhysicsManager.getCollisionCylinderRadius (entity' node)' Core.Singleton.PhysicsManager.getCollisionCylinderHeight (entity' node)' new Mogre.Quaternion (new Mogre.Radian (1.57f)' new Mogre.Vector3 (0f' 0f' 1f))' Core.Singleton.GetUniqueBodyId ()); " is 372.
Long Statement,Tachycardia.Objects,Elevator,C:\repos\secred_Tachycardia\src\Objects\Logic\Elevator.cs,SetPhysics,The length of the statement  "	MogreNewt.ConvexCollision collision = new MogreNewt.CollisionPrimitives.Box (Core.Singleton.NewtonWorld' Core.Singleton.PhysicsManager.getCollisionBoxSize (entity' node)' // Core.Singleton.PhysicsManager.getCollisionCylinderRadius(entity' node)' " is 245.
Long Statement,Tachycardia.Objects,Elevator,C:\repos\secred_Tachycardia\src\Objects\Logic\Elevator.cs,SetPhysics,The length of the statement  "	MogreNewt.ConvexCollision collision = new MogreNewt.CollisionPrimitives.Cylinder (Core.Singleton.NewtonWorld' Core.Singleton.PhysicsManager.getCollisionCylinderRadius (entity' node)' Core.Singleton.PhysicsManager.getCollisionCylinderHeight (entity' node)' new Mogre.Quaternion (new Mogre.Radian (1.57f)' new Mogre.Vector3 (0f' 0f' 1f))' Core.Singleton.GetUniqueBodyId ()); " is 372.
Long Statement,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,killtest,The length of the statement  "	tus.SetAlphaOperation (Mogre.LayerBlendOperationEx.LBX_MODULATE' Mogre.LayerBlendSource.LBS_MANUAL' Mogre.LayerBlendSource.LBS_TEXTURE' 1); " is 139.
Long Statement,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,UserProcess,The length of the statement  "	if (contact.Body0.Type == (int)PhysicsManager.BodyTypes.PLAYER || contact.Body0.Type == (int)PhysicsManager.BodyTypes.NPC) { " is 124.
Long Statement,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,UserProcess,The length of the statement  "	else if (contact.Body1.Type == (int)PhysicsManager.BodyTypes.PLAYER || contact.Body1.Type == (int)PhysicsManager.BodyTypes.NPC) { " is 129.
Long Statement,OpenTK.Audio,AudioContext,C:\repos\secred_Tachycardia\src\Sound\AudioContext.cs,CreateContext,The length of the statement  "	if (AudioDeviceEnumerator.Version == AudioDeviceEnumerator.AlcVersion.Alc1_1 && AudioDeviceEnumerator.AvailablePlaybackDevices.Count == 0) " is 138.
Long Statement,OpenTK.Audio,AudioContext,C:\repos\secred_Tachycardia\src\Sound\AudioContext.cs,CreateContext,The length of the statement  "		throw new AudioDeviceException (String.Format ("Audio device '{0}' does not exist or is tied up by another application."' String.IsNullOrEmpty (device) ? "default" : device)); " is 175.
Long Statement,OpenTK.Audio,AudioContext,C:\repos\secred_Tachycardia\src\Sound\AudioContext.cs,MakeCurrent,The length of the statement  "			throw new AudioContextException (String.Format ("ALC {0} error detected at {1}."' Alc.GetError (context != null ? (IntPtr)context.context_handle : IntPtr.Zero).ToString ()' context != null ? context.ToString () : "null")); " is 222.
Long Statement,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,ErrorMessage,The length of the statement  "	return "The handle returned by Alc.CaptureOpenDevice is null." + "\nAlc Error: " + alcerrmsg + "\nDevice Name: " + devicename + "\nCapture frequency: " + frequency + "\nBuffer format: " + bufferformat + "\nBuffer Size: " + buffersize; " is 234.
Long Statement,OpenTK,BlittableValueType,C:\repos\secred_Tachycardia\src\Sound\Audio\BlittableValueType.cs,Check,The length of the statement  "		Debug.Print ("Warning: type {0} does not specify a StructLayoutAttribute with Pack=1. The memory layout of the struct may change between platforms."' type.Name); " is 161.
Long Statement,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,serialno,The length of the statement  "	return (header_base [header + 14] & 0xff) | ((header_base [header + 15] & 0xff) << 8) | ((header_base [header + 16] & 0xff) << 16) | ((header_base [header + 17] & 0xff) << 24); " is 176.
Long Statement,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,pageno,The length of the statement  "	return (header_base [header + 18] & 0xff) | ((header_base [header + 19] & 0xff) << 8) | ((header_base [header + 20] & 0xff) << 16) | ((header_base [header + 21] & 0xff) << 24); " is 176.
Long Statement,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The length of the statement  "	/* construct a page *//* decide how many segments to include *//* If this is the initial header case' the first page must only include" is 134.
Long Statement,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The length of the statement  "				     plausible uses *//* zero for computation; filled in later *//* segment table *//* set pointers in the ogg_page struct *//* advance the lacing data and set the body_returned pointer *//* calculate the checksum *//* done */} " is 222.
Long Statement,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,pageout,The length of the statement  "	if ((e_o_s != 0 && lacing_fill != 0) || /* 'were done' now flush' case */body_fill - body_returned > 4096 || /* 'page nominal size' case */lacing_fill >= 255 || /* 'segment table full' case */(lacing_fill != 0 && b_o_s == 0)) { " is 227.
Long Statement,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The length of the statement  "		if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) { " is 139.
Long Statement,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The length of the statement  "			int predicted = render_point (info.postlist [look.loneighbor [i - 2]]' info.postlist [look.hineighbor [i - 2]]' fit_value [look.loneighbor [i - 2]]' fit_value [look.hineighbor [i - 2]]' info.postlist [i]); " is 205.
Long Statement,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The length of the statement  "		if ((mode_param [i].windowtype >= VI_WINDOWB) || (mode_param [i].transformtype >= VI_WINDOWB) || (mode_param [i].mapping >= maps)) { " is 132.
Long Statement,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,synthesis_headerin,The length of the statement  "			if (buffer [0] != 'v' || buffer [1] != 'o' || buffer [2] != 'r' || buffer [3] != 'b' || buffer [4] != 'i' || buffer [5] != 's') { " is 129.
Long Statement,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,toString,The length of the statement  "	return "version:" + version.ToString () + "' channels:" + channels.ToString () + "' rate:" + rate.ToString () + "' bitrate:" + bitrate_upper.ToString () + "'" + bitrate_nominal.ToString () + "'" + bitrate_lower.ToString (); " is 223.
Long Statement,csvorbis,Lookup,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lookup.cs,fromdBlook,The length of the statement  "	return (i < 0) ? 1.0f : ((i >= (FROMdB_LOOKUP_SZ << FROMdB_SHIFT)) ? 0.0f : FROMdB_LOOKUP [(uint)i >> FROMdB_SHIFT] * FROMdB2_LOOKUP [i & FROMdB2_MASK]); " is 153.
Long Statement,Tachycardia.Sound.BGM,OggFile,C:\repos\secred_Tachycardia\src\Sound\Audio\OggFile.cs,GetBufferSegment,The length of the statement  "	retVal.ReturnValue = m_CSVorbisFile.read (retVal.Buffer' retVal.BufferLength' _BIGENDIANREADMODE' _WORDREADMODE' _SGNEDREADMODE' null); " is 135.
Long Statement,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,ContainsAt,The length of the statement  "	if (patternLength > this.data.Count || offset >= this.data.Count || patternOffset >= pattern.Count || patternLength <= 0 || offset < 0) " is 135.
Long Statement,TagLib,ByteVectorCollection,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVectorList.cs,Split,The length of the statement  "	for (int offset = vector.Find (pattern' 0' byteAlign); offset != -1 && (max < 1 || max > list.Count + 1); offset = vector.Find (pattern' offset + pattern.Count' byteAlign)) { " is 174.
Long Statement,TagLib,File,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\File.cs,Insert,The length of the statement  "		int bytes_read = file_stream.Read (about_to_overwrite' 0' buffer_length < about_to_overwrite.Length ? buffer_length : about_to_overwrite.Length); " is 145.
Long Statement,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The length of the statement  "			ByteVector new_data = ByteVector.FromUInt ((uint)(header.PageSequenceNumber + shiftTable [header.StreamSerialNumber])' false); " is 126.
Long Statement,TagLib.Ogg,PageHeader,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\PageHeader.cs,GetHashCode,The length of the statement  "		return (int)(LacingValues.GetHashCode () ^ version ^ (int)flags ^ (int)absolute_granular_position ^ stream_serial_number ^ page_sequence_number ^ size ^ data_size); " is 164.
Long Statement,TagLib.Ogg,PageHeader,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\PageHeader.cs,Equals,The length of the statement  "	return packet_sizes == other.packet_sizes && version == other.version && flags == other.flags && absolute_granular_position == other.absolute_granular_position && stream_serial_number == other.stream_serial_number && page_sequence_number == other.page_sequence_number && size == other.size && data_size == other.data_size; " is 322.
Long Statement,TagLib.Ogg,Paginator,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Paginator.cs,Paginate,The length of the statement  "			pages.Add (new Page (page_packets' new PageHeader (first_header' index' first_packet_continued ? PageFlags.FirstPacketContinued : PageFlags.None))); " is 148.
Long Statement,TagLib.Ogg,Paginator,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Paginator.cs,Paginate,The length of the statement  "		pages.Add (new Page (page_packets' new PageHeader (first_header.StreamSerialNumber' index' first_packet_continued ? PageFlags.FirstPacketContinued : PageFlags.None))); " is 167.
Long Statement,TagLib.Ogg.Codecs,Vorbis,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Codecs\Vorbis.cs,GetDuration,The length of the statement  "	return header.sample_rate == 0 ? TimeSpan.Zero : TimeSpan.FromSeconds ((double)(lastGranularPosition - firstGranularPosition) / (double)header.sample_rate); " is 156.
Long Statement,Tachycardia.Sound,SoundDict,C:\repos\secred_Tachycardia\src\Sound\SoundDict.cs,Initialize,The length of the statement  "	AL.BufferData (m_HeartBeatBuff' GetSoundFormat (channels' bits_per_sample)' sound_data' sound_data.Length' sample_rate); " is 120.
Long Statement,Helper,DotSceneLoader,C:\repos\secred_Tachycardia\src\Tools\DotSceneLoader.cs,parseColour,The length of the statement  "	return new ColourValue (ParseFloat (XMLNode.GetAttribute ("r"))' ParseFloat (XMLNode.GetAttribute ("g"))' ParseFloat (XMLNode.GetAttribute ("b"))' string.IsNullOrEmpty (XMLNode.GetAttribute ("a")) == false ? ParseFloat (XMLNode.GetAttribute ("a")) : 1); " is 253.
Long Statement,Helper,DotSceneLoader,C:\repos\secred_Tachycardia\src\Tools\DotSceneLoader.cs,parseVector3,The length of the statement  "	return new Vector3 (ParseFloat (XMLNode.GetAttribute ("x"))' ParseFloat (XMLNode.GetAttribute ("y"))' ParseFloat (XMLNode.GetAttribute ("z"))); " is 143.
Long Statement,Helper,DotSceneLoader,C:\repos\secred_Tachycardia\src\Tools\DotSceneLoader.cs,processNode,The length of the statement  "	/** Póki co kolizję ładujemy bezpośrednio z plików z obiektami' zwłaszcza' że ze względu na wygenerowane .scene przez grafików" is 126.
Long Statement,Helper,DotSceneLoader,C:\repos\secred_Tachycardia\src\Tools\DotSceneLoader.cs,processNode,The length of the statement  "             *  w aktualnej planszy mamy niecałe 300 meshy' więc jak się znajdzie ktoś' komu chce się przerabiać je na Col to zapraszam.;) MSZ" is 129.
Long Statement,Helper,DotSceneLoader,C:\repos\secred_Tachycardia\src\Tools\DotSceneLoader.cs,processNode,The length of the statement  "		MogreNewt.CollisionPrimitives.TreeCollisionSceneParser collision = new MogreNewt.CollisionPrimitives.TreeCollisionSceneParser (Tachycardia.Core.Singleton.NewtonWorld); " is 167.
Long Statement,Helper,DotSceneLoader,C:\repos\secred_Tachycardia\src\Tools\DotSceneLoader.cs,processPlane,The length of the statement  "		MeshPtr ptr = MeshManager.Singleton.CreatePlane (name' m_sGroupName' pPlane' width' height' xSegments' ySegments' normals' (ushort)numTexCoordSets' uTile' vTile' upVector); " is 172.
Complex Conditional,Tachycardia,PlayerController,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,BodyForceCallback,The conditional expression  "!m_bBackward && !m_bForward && !m_bLeft && !m_bRight"  is complex.
Complex Conditional,Tachycardia,PlayerController,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,Update,The conditional expression  "m_bForward || (m_State != CharacterState.IDLE && (m_bRight == true || m_bLeft == true))"  is complex.
Complex Conditional,Tachycardia,PlayerController,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,Update,The conditional expression  "!m_bLeft && !m_bRight && !m_bForward && !m_bBackward"  is complex.
Complex Conditional,OpenTK,BlittableValueType,C:\repos\secred_Tachycardia\src\Sound\Audio\BlittableValueType.cs,CheckStructLayoutAttribute,The conditional expression  "(attr == null) || (attr != null && attr.Length > 0 && attr [0].Value != LayoutKind.Explicit && attr [0].Pack != 1)"  is complex.
Complex Conditional,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,pageout,The conditional expression  "(e_o_s != 0 && lacing_fill != 0) || /* 'were done' now flush' case */body_fill - body_returned > 4096 || /* 'page nominal size' case */lacing_fill >= 255 || /* 'segment table full' case */(lacing_fill != 0 && b_o_s == 0)"  is complex.
Complex Conditional,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The conditional expression  "data [page] != 'O' || data [page + 1] != 'g' || data [page + 2] != 'g' || data [page + 3] != 'S'"  is complex.
Complex Conditional,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The conditional expression  "chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]"  is complex.
Complex Conditional,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,unpack,The conditional expression  "(info.order < 1) || (info.rate < 1) || (info.barkmap < 1) || (info.numbooks < 1)"  is complex.
Complex Conditional,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_info,The conditional expression  "(rate < 1) || (channels < 1) || (blocksizes [0] < 8) || (blocksizes [1] < blocksizes [0]) || (opb.read (1) != 1)"  is complex.
Complex Conditional,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,synthesis_headerin,The conditional expression  "buffer [0] != 'v' || buffer [1] != 'o' || buffer [2] != 'r' || buffer [3] != 'b' || buffer [4] != 'i' || buffer [5] != 's'"  is complex.
Complex Conditional,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,unpack,The conditional expression  "testM < 0 || testA < 0 || testM == testA || testM >= vi.channels || testA >= vi.channels"  is complex.
Complex Conditional,OpenTK.Audio.OpenAL,XRamExtension,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\XRamExtension.cs,XRamExtension,The conditional expression  "AL_EAX_RAM_SIZE == 0 || AL_EAX_RAM_FREE == 0 || AL_STORAGE_AUTOMATIC == 0 || AL_STORAGE_HARDWARE == 0 || AL_STORAGE_ACCESSIBLE == 0"  is complex.
Complex Conditional,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,ContainsAt,The conditional expression  "patternLength > this.data.Count || offset >= this.data.Count || patternOffset >= pattern.Count || patternLength <= 0 || offset < 0"  is complex.
Complex Conditional,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,FromStream,The conditional expression  "(bytes_read == stream.Length && stream.Length > 0) || (n < read_size && stream.Length <= 0)"  is complex.
Virtual Method Call from Constructor,Tachycardia,PlayerController,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,PlayerController,The constructor "PlayerController" calls a virtual method "initLogicStates".
Virtual Method Call from Constructor,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,Command,The constructor "Command" calls a virtual method "RegisterArgs".
Magic Number,Tachycardia,PhysicsManager,C:\repos\secred_Tachycardia\src\Core\Physics\PhysicsManager.cs,getCollisionEllipsoidSize,The following statement contains a magic number: return Node.GetScale () * entity.BoundingBox.Size / 2;  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (m_MissionSteps <= 0) {  	/*if ((m_MissionType & RUN) > 0)                     m_Pose.m_MaxSpd /= 1.5f;*/switch (Core.Singleton.Rand.Next () % 10) {  	case 0:  	case 1:  	case 2:  		m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType = GO_LEFT;  		else  			m_MissionType = GO_RIGHT;  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType += GO_AHEAD;  		break;  	case 3:  	case 4:  	case 5:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = GO_AHEAD;  		break;  	case 6:  		m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  		m_MissionType = RUN;  		//m_Pose.m_MaxSpd *= 1.5f;  		break;  	default:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = 0;  		break;  	}  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (m_MissionSteps <= 0) {  	/*if ((m_MissionType & RUN) > 0)                     m_Pose.m_MaxSpd /= 1.5f;*/switch (Core.Singleton.Rand.Next () % 10) {  	case 0:  	case 1:  	case 2:  		m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType = GO_LEFT;  		else  			m_MissionType = GO_RIGHT;  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType += GO_AHEAD;  		break;  	case 3:  	case 4:  	case 5:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = GO_AHEAD;  		break;  	case 6:  		m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  		m_MissionType = RUN;  		//m_Pose.m_MaxSpd *= 1.5f;  		break;  	default:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = 0;  		break;  	}  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (m_MissionSteps <= 0) {  	/*if ((m_MissionType & RUN) > 0)                     m_Pose.m_MaxSpd /= 1.5f;*/switch (Core.Singleton.Rand.Next () % 10) {  	case 0:  	case 1:  	case 2:  		m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType = GO_LEFT;  		else  			m_MissionType = GO_RIGHT;  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType += GO_AHEAD;  		break;  	case 3:  	case 4:  	case 5:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = GO_AHEAD;  		break;  	case 6:  		m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  		m_MissionType = RUN;  		//m_Pose.m_MaxSpd *= 1.5f;  		break;  	default:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = 0;  		break;  	}  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (m_MissionSteps <= 0) {  	/*if ((m_MissionType & RUN) > 0)                     m_Pose.m_MaxSpd /= 1.5f;*/switch (Core.Singleton.Rand.Next () % 10) {  	case 0:  	case 1:  	case 2:  		m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType = GO_LEFT;  		else  			m_MissionType = GO_RIGHT;  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType += GO_AHEAD;  		break;  	case 3:  	case 4:  	case 5:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = GO_AHEAD;  		break;  	case 6:  		m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  		m_MissionType = RUN;  		//m_Pose.m_MaxSpd *= 1.5f;  		break;  	default:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = 0;  		break;  	}  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (m_MissionSteps <= 0) {  	/*if ((m_MissionType & RUN) > 0)                     m_Pose.m_MaxSpd /= 1.5f;*/switch (Core.Singleton.Rand.Next () % 10) {  	case 0:  	case 1:  	case 2:  		m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType = GO_LEFT;  		else  			m_MissionType = GO_RIGHT;  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType += GO_AHEAD;  		break;  	case 3:  	case 4:  	case 5:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = GO_AHEAD;  		break;  	case 6:  		m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  		m_MissionType = RUN;  		//m_Pose.m_MaxSpd *= 1.5f;  		break;  	default:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = 0;  		break;  	}  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (m_MissionSteps <= 0) {  	/*if ((m_MissionType & RUN) > 0)                     m_Pose.m_MaxSpd /= 1.5f;*/switch (Core.Singleton.Rand.Next () % 10) {  	case 0:  	case 1:  	case 2:  		m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType = GO_LEFT;  		else  			m_MissionType = GO_RIGHT;  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType += GO_AHEAD;  		break;  	case 3:  	case 4:  	case 5:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = GO_AHEAD;  		break;  	case 6:  		m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  		m_MissionType = RUN;  		//m_Pose.m_MaxSpd *= 1.5f;  		break;  	default:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = 0;  		break;  	}  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (m_MissionSteps <= 0) {  	/*if ((m_MissionType & RUN) > 0)                     m_Pose.m_MaxSpd /= 1.5f;*/switch (Core.Singleton.Rand.Next () % 10) {  	case 0:  	case 1:  	case 2:  		m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType = GO_LEFT;  		else  			m_MissionType = GO_RIGHT;  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType += GO_AHEAD;  		break;  	case 3:  	case 4:  	case 5:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = GO_AHEAD;  		break;  	case 6:  		m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  		m_MissionType = RUN;  		//m_Pose.m_MaxSpd *= 1.5f;  		break;  	default:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = 0;  		break;  	}  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (m_MissionSteps <= 0) {  	/*if ((m_MissionType & RUN) > 0)                     m_Pose.m_MaxSpd /= 1.5f;*/switch (Core.Singleton.Rand.Next () % 10) {  	case 0:  	case 1:  	case 2:  		m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType = GO_LEFT;  		else  			m_MissionType = GO_RIGHT;  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType += GO_AHEAD;  		break;  	case 3:  	case 4:  	case 5:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = GO_AHEAD;  		break;  	case 6:  		m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  		m_MissionType = RUN;  		//m_Pose.m_MaxSpd *= 1.5f;  		break;  	default:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = 0;  		break;  	}  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (m_MissionSteps <= 0) {  	/*if ((m_MissionType & RUN) > 0)                     m_Pose.m_MaxSpd /= 1.5f;*/switch (Core.Singleton.Rand.Next () % 10) {  	case 0:  	case 1:  	case 2:  		m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType = GO_LEFT;  		else  			m_MissionType = GO_RIGHT;  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType += GO_AHEAD;  		break;  	case 3:  	case 4:  	case 5:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = GO_AHEAD;  		break;  	case 6:  		m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  		m_MissionType = RUN;  		//m_Pose.m_MaxSpd *= 1.5f;  		break;  	default:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = 0;  		break;  	}  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (m_MissionSteps <= 0) {  	/*if ((m_MissionType & RUN) > 0)                     m_Pose.m_MaxSpd /= 1.5f;*/switch (Core.Singleton.Rand.Next () % 10) {  	case 0:  	case 1:  	case 2:  		m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType = GO_LEFT;  		else  			m_MissionType = GO_RIGHT;  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType += GO_AHEAD;  		break;  	case 3:  	case 4:  	case 5:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = GO_AHEAD;  		break;  	case 6:  		m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  		m_MissionType = RUN;  		//m_Pose.m_MaxSpd *= 1.5f;  		break;  	default:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = 0;  		break;  	}  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (m_MissionSteps <= 0) {  	/*if ((m_MissionType & RUN) > 0)                     m_Pose.m_MaxSpd /= 1.5f;*/switch (Core.Singleton.Rand.Next () % 10) {  	case 0:  	case 1:  	case 2:  		m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType = GO_LEFT;  		else  			m_MissionType = GO_RIGHT;  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType += GO_AHEAD;  		break;  	case 3:  	case 4:  	case 5:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = GO_AHEAD;  		break;  	case 6:  		m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  		m_MissionType = RUN;  		//m_Pose.m_MaxSpd *= 1.5f;  		break;  	default:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = 0;  		break;  	}  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (m_MissionSteps <= 0) {  	/*if ((m_MissionType & RUN) > 0)                     m_Pose.m_MaxSpd /= 1.5f;*/switch (Core.Singleton.Rand.Next () % 10) {  	case 0:  	case 1:  	case 2:  		m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType = GO_LEFT;  		else  			m_MissionType = GO_RIGHT;  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType += GO_AHEAD;  		break;  	case 3:  	case 4:  	case 5:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = GO_AHEAD;  		break;  	case 6:  		m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  		m_MissionType = RUN;  		//m_Pose.m_MaxSpd *= 1.5f;  		break;  	default:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = 0;  		break;  	}  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (m_MissionSteps <= 0) {  	/*if ((m_MissionType & RUN) > 0)                     m_Pose.m_MaxSpd /= 1.5f;*/switch (Core.Singleton.Rand.Next () % 10) {  	case 0:  	case 1:  	case 2:  		m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType = GO_LEFT;  		else  			m_MissionType = GO_RIGHT;  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType += GO_AHEAD;  		break;  	case 3:  	case 4:  	case 5:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = GO_AHEAD;  		break;  	case 6:  		m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  		m_MissionType = RUN;  		//m_Pose.m_MaxSpd *= 1.5f;  		break;  	default:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = 0;  		break;  	}  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (m_MissionSteps <= 0) {  	/*if ((m_MissionType & RUN) > 0)                     m_Pose.m_MaxSpd /= 1.5f;*/switch (Core.Singleton.Rand.Next () % 10) {  	case 0:  	case 1:  	case 2:  		m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType = GO_LEFT;  		else  			m_MissionType = GO_RIGHT;  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType += GO_AHEAD;  		break;  	case 3:  	case 4:  	case 5:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = GO_AHEAD;  		break;  	case 6:  		m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  		m_MissionType = RUN;  		//m_Pose.m_MaxSpd *= 1.5f;  		break;  	default:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = 0;  		break;  	}  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (m_MissionSteps <= 0) {  	/*if ((m_MissionType & RUN) > 0)                     m_Pose.m_MaxSpd /= 1.5f;*/switch (Core.Singleton.Rand.Next () % 10) {  	case 0:  	case 1:  	case 2:  		m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType = GO_LEFT;  		else  			m_MissionType = GO_RIGHT;  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType += GO_AHEAD;  		break;  	case 3:  	case 4:  	case 5:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = GO_AHEAD;  		break;  	case 6:  		m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  		m_MissionType = RUN;  		//m_Pose.m_MaxSpd *= 1.5f;  		break;  	default:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = 0;  		break;  	}  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (m_MissionSteps <= 0) {  	/*if ((m_MissionType & RUN) > 0)                     m_Pose.m_MaxSpd /= 1.5f;*/switch (Core.Singleton.Rand.Next () % 10) {  	case 0:  	case 1:  	case 2:  		m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType = GO_LEFT;  		else  			m_MissionType = GO_RIGHT;  		if (Core.Singleton.Rand.Next () % 2 == 0)  			m_MissionType += GO_AHEAD;  		break;  	case 3:  	case 4:  	case 5:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = GO_AHEAD;  		break;  	case 6:  		m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  		m_MissionType = RUN;  		//m_Pose.m_MaxSpd *= 1.5f;  		break;  	default:  		m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  		m_MissionType = 0;  		break;  	}  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: switch (Core.Singleton.Rand.Next () % 10) {  case 0:  case 1:  case 2:  	m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType = GO_LEFT;  	else  		m_MissionType = GO_RIGHT;  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType += GO_AHEAD;  	break;  case 3:  case 4:  case 5:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = GO_AHEAD;  	break;  case 6:  	m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  	m_MissionType = RUN;  	//m_Pose.m_MaxSpd *= 1.5f;  	break;  default:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = 0;  	break;  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: switch (Core.Singleton.Rand.Next () % 10) {  case 0:  case 1:  case 2:  	m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType = GO_LEFT;  	else  		m_MissionType = GO_RIGHT;  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType += GO_AHEAD;  	break;  case 3:  case 4:  case 5:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = GO_AHEAD;  	break;  case 6:  	m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  	m_MissionType = RUN;  	//m_Pose.m_MaxSpd *= 1.5f;  	break;  default:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = 0;  	break;  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: switch (Core.Singleton.Rand.Next () % 10) {  case 0:  case 1:  case 2:  	m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType = GO_LEFT;  	else  		m_MissionType = GO_RIGHT;  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType += GO_AHEAD;  	break;  case 3:  case 4:  case 5:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = GO_AHEAD;  	break;  case 6:  	m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  	m_MissionType = RUN;  	//m_Pose.m_MaxSpd *= 1.5f;  	break;  default:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = 0;  	break;  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: switch (Core.Singleton.Rand.Next () % 10) {  case 0:  case 1:  case 2:  	m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType = GO_LEFT;  	else  		m_MissionType = GO_RIGHT;  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType += GO_AHEAD;  	break;  case 3:  case 4:  case 5:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = GO_AHEAD;  	break;  case 6:  	m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  	m_MissionType = RUN;  	//m_Pose.m_MaxSpd *= 1.5f;  	break;  default:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = 0;  	break;  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: switch (Core.Singleton.Rand.Next () % 10) {  case 0:  case 1:  case 2:  	m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType = GO_LEFT;  	else  		m_MissionType = GO_RIGHT;  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType += GO_AHEAD;  	break;  case 3:  case 4:  case 5:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = GO_AHEAD;  	break;  case 6:  	m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  	m_MissionType = RUN;  	//m_Pose.m_MaxSpd *= 1.5f;  	break;  default:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = 0;  	break;  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: switch (Core.Singleton.Rand.Next () % 10) {  case 0:  case 1:  case 2:  	m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType = GO_LEFT;  	else  		m_MissionType = GO_RIGHT;  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType += GO_AHEAD;  	break;  case 3:  case 4:  case 5:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = GO_AHEAD;  	break;  case 6:  	m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  	m_MissionType = RUN;  	//m_Pose.m_MaxSpd *= 1.5f;  	break;  default:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = 0;  	break;  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: switch (Core.Singleton.Rand.Next () % 10) {  case 0:  case 1:  case 2:  	m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType = GO_LEFT;  	else  		m_MissionType = GO_RIGHT;  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType += GO_AHEAD;  	break;  case 3:  case 4:  case 5:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = GO_AHEAD;  	break;  case 6:  	m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  	m_MissionType = RUN;  	//m_Pose.m_MaxSpd *= 1.5f;  	break;  default:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = 0;  	break;  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: switch (Core.Singleton.Rand.Next () % 10) {  case 0:  case 1:  case 2:  	m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType = GO_LEFT;  	else  		m_MissionType = GO_RIGHT;  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType += GO_AHEAD;  	break;  case 3:  case 4:  case 5:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = GO_AHEAD;  	break;  case 6:  	m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  	m_MissionType = RUN;  	//m_Pose.m_MaxSpd *= 1.5f;  	break;  default:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = 0;  	break;  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: switch (Core.Singleton.Rand.Next () % 10) {  case 0:  case 1:  case 2:  	m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType = GO_LEFT;  	else  		m_MissionType = GO_RIGHT;  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType += GO_AHEAD;  	break;  case 3:  case 4:  case 5:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = GO_AHEAD;  	break;  case 6:  	m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  	m_MissionType = RUN;  	//m_Pose.m_MaxSpd *= 1.5f;  	break;  default:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = 0;  	break;  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: switch (Core.Singleton.Rand.Next () % 10) {  case 0:  case 1:  case 2:  	m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType = GO_LEFT;  	else  		m_MissionType = GO_RIGHT;  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType += GO_AHEAD;  	break;  case 3:  case 4:  case 5:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = GO_AHEAD;  	break;  case 6:  	m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  	m_MissionType = RUN;  	//m_Pose.m_MaxSpd *= 1.5f;  	break;  default:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = 0;  	break;  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: switch (Core.Singleton.Rand.Next () % 10) {  case 0:  case 1:  case 2:  	m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType = GO_LEFT;  	else  		m_MissionType = GO_RIGHT;  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType += GO_AHEAD;  	break;  case 3:  case 4:  case 5:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = GO_AHEAD;  	break;  case 6:  	m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  	m_MissionType = RUN;  	//m_Pose.m_MaxSpd *= 1.5f;  	break;  default:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = 0;  	break;  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: switch (Core.Singleton.Rand.Next () % 10) {  case 0:  case 1:  case 2:  	m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType = GO_LEFT;  	else  		m_MissionType = GO_RIGHT;  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType += GO_AHEAD;  	break;  case 3:  case 4:  case 5:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = GO_AHEAD;  	break;  case 6:  	m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  	m_MissionType = RUN;  	//m_Pose.m_MaxSpd *= 1.5f;  	break;  default:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = 0;  	break;  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: switch (Core.Singleton.Rand.Next () % 10) {  case 0:  case 1:  case 2:  	m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType = GO_LEFT;  	else  		m_MissionType = GO_RIGHT;  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType += GO_AHEAD;  	break;  case 3:  case 4:  case 5:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = GO_AHEAD;  	break;  case 6:  	m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  	m_MissionType = RUN;  	//m_Pose.m_MaxSpd *= 1.5f;  	break;  default:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = 0;  	break;  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: switch (Core.Singleton.Rand.Next () % 10) {  case 0:  case 1:  case 2:  	m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType = GO_LEFT;  	else  		m_MissionType = GO_RIGHT;  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType += GO_AHEAD;  	break;  case 3:  case 4:  case 5:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = GO_AHEAD;  	break;  case 6:  	m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  	m_MissionType = RUN;  	//m_Pose.m_MaxSpd *= 1.5f;  	break;  default:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = 0;  	break;  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: switch (Core.Singleton.Rand.Next () % 10) {  case 0:  case 1:  case 2:  	m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType = GO_LEFT;  	else  		m_MissionType = GO_RIGHT;  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType += GO_AHEAD;  	break;  case 3:  case 4:  case 5:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = GO_AHEAD;  	break;  case 6:  	m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  	m_MissionType = RUN;  	//m_Pose.m_MaxSpd *= 1.5f;  	break;  default:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = 0;  	break;  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: switch (Core.Singleton.Rand.Next () % 10) {  case 0:  case 1:  case 2:  	m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType = GO_LEFT;  	else  		m_MissionType = GO_RIGHT;  	if (Core.Singleton.Rand.Next () % 2 == 0)  		m_MissionType += GO_AHEAD;  	break;  case 3:  case 4:  case 5:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = GO_AHEAD;  	break;  case 6:  	m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  	m_MissionType = RUN;  	//m_Pose.m_MaxSpd *= 1.5f;  	break;  default:  	m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  	m_MissionType = 0;  	break;  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: m_MissionSteps = Core.Singleton.Rand.Next (5' 10);  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (Core.Singleton.Rand.Next () % 2 == 0)  	m_MissionType = GO_LEFT;  else  	m_MissionType = GO_RIGHT;  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (Core.Singleton.Rand.Next () % 2 == 0)  	m_MissionType += GO_AHEAD;  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: m_MissionSteps = Core.Singleton.Rand.Next (30' 120);  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: m_MissionSteps = Core.Singleton.Rand.Next (20' 60);  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (activateidle == true && m_Pose == m_myPoses ["normal"]) {  	if (!m_MainBody.Velocity.IsZeroLength) {  		//nie zatrzymal sie jeszcze to go zatrzymujemy  		Mogre.Vector3 xyVector = new Mogre.Vector3 (0' 0' 1);  		Mogre.Vector3 velocityxy = m_MainBody.Velocity * new Mogre.Vector3 (1' 0' 1);  		Mogre.Quaternion ForceDirection = xyVector.GetRotationTo (velocityxy);  		Mogre.Vector3 StoppingForce = -ForceDirection * Mogre.Vector3.UNIT_Z * m_MainBody.Mass * 6;  		m_MainBody.AddForce (-StoppingForce);  	}  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,Update,The following statement contains a magic number: if (!m_MainBody.Velocity.IsZeroLength) {  	//nie zatrzymal sie jeszcze to go zatrzymujemy  	Mogre.Vector3 xyVector = new Mogre.Vector3 (0' 0' 1);  	Mogre.Vector3 velocityxy = m_MainBody.Velocity * new Mogre.Vector3 (1' 0' 1);  	Mogre.Quaternion ForceDirection = xyVector.GetRotationTo (velocityxy);  	Mogre.Vector3 StoppingForce = -ForceDirection * Mogre.Vector3.UNIT_Z * m_MainBody.Mass * 6;  	m_MainBody.AddForce (-StoppingForce);  }  
Magic Number,Tachycardia,NpcController,C:\repos\secred_Tachycardia\src\Player\NpcController.cs,initLogicStates,The following statement contains a magic number: m_jumpForce = 6;  
Magic Number,Tachycardia,LogicState,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,LogicState,The following statement contains a magic number: m_ForwardForce = 20;  
Magic Number,Tachycardia,LogicState,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,LogicState,The following statement contains a magic number: m_ForwardForceBoost = 40;  
Magic Number,Tachycardia,LogicState,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,LogicState,The following statement contains a magic number: m_BackwardForce = 10;  
Magic Number,Tachycardia,LogicState,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,LogicState,The following statement contains a magic number: m_BackwardForceBoost = 20;  
Magic Number,Tachycardia,LogicState,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,LogicState,The following statement contains a magic number: m_spdTurn = 25;  
Magic Number,Tachycardia,LogicState,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,LogicState,The following statement contains a magic number: m_spdTurnBoost = 15;  
Magic Number,Tachycardia,LogicState,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,LogicState,The following statement contains a magic number: m_ForceStop = 6;  
Magic Number,Tachycardia,LogicState,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,willTurnLeft,The following statement contains a magic number: if (m_Control.m_MainBody.Velocity.Length > 0.1f) {  	m_Control.m_GoTo = m_Control.m_PlayerNode.Orientation * new Mogre.Quaternion (new Mogre.Degree (getSpdTurn ())' Mogre.Vector3.UNIT_Y);  }  else {  	//  	m_Control.m_PlayerNode.Orientation *= Mogre.Vector3.UNIT_Z.GetRotationTo (new Mogre.Vector3 (3 * Core.m_FixedTime' 0' 1.0f).NormalisedCopy);  }  
Magic Number,Tachycardia,LogicState,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,willTurnLeft,The following statement contains a magic number: m_Control.m_PlayerNode.Orientation *= Mogre.Vector3.UNIT_Z.GetRotationTo (new Mogre.Vector3 (3 * Core.m_FixedTime' 0' 1.0f).NormalisedCopy);  
Magic Number,Tachycardia,LogicState,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,willTurnRight,The following statement contains a magic number: if (m_Control.m_MainBody.Velocity.Length > 0.1f) {  	//  	m_Control.m_GoTo = m_Control.m_PlayerNode.Orientation * new Mogre.Quaternion (new Mogre.Degree (-getSpdTurn ())' Mogre.Vector3.UNIT_Y);  }  else {  	//  	m_Control.m_PlayerNode.Orientation *= Mogre.Vector3.UNIT_Z.GetRotationTo (new Mogre.Vector3 (-3 * Core.m_FixedTime' 0' 1.0f).NormalisedCopy);  }  
Magic Number,Tachycardia,LogicState,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,willTurnRight,The following statement contains a magic number: m_Control.m_PlayerNode.Orientation *= Mogre.Vector3.UNIT_Z.GetRotationTo (new Mogre.Vector3 (-3 * Core.m_FixedTime' 0' 1.0f).NormalisedCopy);  
Magic Number,Tachycardia,LogicState,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,willForward,The following statement contains a magic number: m_Control.m_MainBody.AddForce (-m_Control.m_MainBody.Velocity * new Mogre.Vector3 (1' 0' 1) * 4 * m_Control.m_MainBody.Mass);  
Magic Number,Tachycardia,LogicState,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,willBackward,The following statement contains a magic number: m_Control.m_MainBody.AddForce (-m_Control.m_MainBody.Velocity * new Mogre.Vector3 (1' 0' 1) * 4 * m_Control.m_MainBody.Mass);  
Magic Number,Tachycardia,Normal,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,Normal,The following statement contains a magic number: m_ForwardForce = 20;  
Magic Number,Tachycardia,Normal,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,Normal,The following statement contains a magic number: m_ForwardForceBoost = 40;  
Magic Number,Tachycardia,Crouch,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,Crouch,The following statement contains a magic number: m_ForwardForce = 12;  
Magic Number,Tachycardia,Crouch,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,Crouch,The following statement contains a magic number: m_ForwardForceBoost = 16;  
Magic Number,Tachycardia,PlayerController,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,BodyTransformCallback,The following statement contains a magic number: if (m_MainBody.Velocity.Length < 0.1f) {  	m_State = CharacterState.IDLE;  }  else {  	if (m_Pose.m_name == "normal") {  		if (m_MainBody.Velocity.Length > 3.5)  			m_State = CharacterState.RUN;  		else  			m_State = CharacterState.WALK;  	}  	else if (m_Pose.m_name == "fly") {  		m_State = CharacterState.JUMP;  	}  	if (!m_bBackward) {  		//dla wstecznego  		Mogre.Vector3 velocityxy = m_MainBody.Velocity * new Mogre.Vector3 (1' 0' 1);  		m_PlayerNode.Orientation = Mogre.Vector3.UNIT_Z.GetRotationTo (velocityxy);  	}  }  
Magic Number,Tachycardia,PlayerController,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,BodyTransformCallback,The following statement contains a magic number: if (m_Pose.m_name == "normal") {  	if (m_MainBody.Velocity.Length > 3.5)  		m_State = CharacterState.RUN;  	else  		m_State = CharacterState.WALK;  }  else if (m_Pose.m_name == "fly") {  	m_State = CharacterState.JUMP;  }  
Magic Number,Tachycardia,PlayerController,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,BodyTransformCallback,The following statement contains a magic number: if (m_MainBody.Velocity.Length > 3.5)  	m_State = CharacterState.RUN;  else  	m_State = CharacterState.WALK;  
Magic Number,Tachycardia,PlayerController,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,BodyForceCallback,The following statement contains a magic number: if (m_Onground < 10)  	m_Onground++;  else  	//jest w locie - zmieniamy mu stan   	ChangePoseTo ("fly");  
Magic Number,Tachycardia,PlayerController,C:\repos\secred_Tachycardia\src\Player\PlayerController.cs,initLogicStates,The following statement contains a magic number: m_jumpForce = 6;  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,Initialise,The following statement contains a magic number: m_NewtonWorld.SetWorldSize (new AxisAlignedBox (-500' -500' -500' 500' 500' 500));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,Initialise,The following statement contains a magic number: m_NewtonWorld.SetWorldSize (new AxisAlignedBox (-500' -500' -500' 500' 500' 500));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,Initialise,The following statement contains a magic number: m_NewtonWorld.SetWorldSize (new AxisAlignedBox (-500' -500' -500' 500' 500' 500));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,Initialise,The following statement contains a magic number: m_NewtonWorld.SetWorldSize (new AxisAlignedBox (-500' -500' -500' 500' 500' 500));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,Initialise,The following statement contains a magic number: m_NewtonWorld.SetWorldSize (new AxisAlignedBox (-500' -500' -500' 500' 500' 500));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,Initialise,The following statement contains a magic number: m_NewtonWorld.SetWorldSize (new AxisAlignedBox (-500' -500' -500' 500' 500' 500));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateOgitorScene,The following statement contains a magic number: player.SetPosition (new Vector3 (-148' -25' 15));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateOgitorScene,The following statement contains a magic number: player.SetPosition (new Vector3 (-148' -25' 15));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateOgitorScene,The following statement contains a magic number: player.SetPosition (new Vector3 (-148' -25' 15));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateOgitorScene,The following statement contains a magic number: for (int i = 0; i < 50; i++) {  	player = new Character ("Man.mesh"' 70' true);  	player.SetPosition (new Vector3 (-50 + Rand.Next () % 100' 0' -50 + Rand.Next () % 100));  	m_ObjectManager.Add ("bot" + i.ToString ()' player);  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateOgitorScene,The following statement contains a magic number: for (int i = 0; i < 50; i++) {  	player = new Character ("Man.mesh"' 70' true);  	player.SetPosition (new Vector3 (-50 + Rand.Next () % 100' 0' -50 + Rand.Next () % 100));  	m_ObjectManager.Add ("bot" + i.ToString ()' player);  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateOgitorScene,The following statement contains a magic number: for (int i = 0; i < 50; i++) {  	player = new Character ("Man.mesh"' 70' true);  	player.SetPosition (new Vector3 (-50 + Rand.Next () % 100' 0' -50 + Rand.Next () % 100));  	m_ObjectManager.Add ("bot" + i.ToString ()' player);  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateOgitorScene,The following statement contains a magic number: for (int i = 0; i < 50; i++) {  	player = new Character ("Man.mesh"' 70' true);  	player.SetPosition (new Vector3 (-50 + Rand.Next () % 100' 0' -50 + Rand.Next () % 100));  	m_ObjectManager.Add ("bot" + i.ToString ()' player);  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateOgitorScene,The following statement contains a magic number: for (int i = 0; i < 50; i++) {  	player = new Character ("Man.mesh"' 70' true);  	player.SetPosition (new Vector3 (-50 + Rand.Next () % 100' 0' -50 + Rand.Next () % 100));  	m_ObjectManager.Add ("bot" + i.ToString ()' player);  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateOgitorScene,The following statement contains a magic number: for (int i = 0; i < 50; i++) {  	player = new Character ("Man.mesh"' 70' true);  	player.SetPosition (new Vector3 (-50 + Rand.Next () % 100' 0' -50 + Rand.Next () % 100));  	m_ObjectManager.Add ("bot" + i.ToString ()' player);  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateOgitorScene,The following statement contains a magic number: player = new Character ("Man.mesh"' 70' true);  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateOgitorScene,The following statement contains a magic number: player.SetPosition (new Vector3 (-50 + Rand.Next () % 100' 0' -50 + Rand.Next () % 100));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateOgitorScene,The following statement contains a magic number: player.SetPosition (new Vector3 (-50 + Rand.Next () % 100' 0' -50 + Rand.Next () % 100));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateOgitorScene,The following statement contains a magic number: player.SetPosition (new Vector3 (-50 + Rand.Next () % 100' 0' -50 + Rand.Next () % 100));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateOgitorScene,The following statement contains a magic number: player.SetPosition (new Vector3 (-50 + Rand.Next () % 100' 0' -50 + Rand.Next () % 100));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateOgitorScene,The following statement contains a magic number: light.Direction = new Vector3 (1' -3' 1).NormalisedCopy;  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,KeyPressedHandler,The following statement contains a magic number: if (keyEventRef.key == MOIS.KeyCode.KC_RETURN) {  	var messageBox = OverlayManager.Singleton.GetOverlayElement ("HelloWorldOverlay/MessageBox");  	messageBox.Left = (m_RenderWindow.Width - messageBox.Width) / 2;  	messageBox.Top = (m_RenderWindow.Height - messageBox.Height) / 2;  	var messageBody = OverlayManager.Singleton.GetOverlayElement ("HelloWorldOverlay/MessageBox/Body");  	//messageBody.Caption = "Ssij palke :*";  	OverlayManager.Singleton.GetByName ("HelloWorldOverlay").Show ();  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,KeyPressedHandler,The following statement contains a magic number: if (keyEventRef.key == MOIS.KeyCode.KC_RETURN) {  	var messageBox = OverlayManager.Singleton.GetOverlayElement ("HelloWorldOverlay/MessageBox");  	messageBox.Left = (m_RenderWindow.Width - messageBox.Width) / 2;  	messageBox.Top = (m_RenderWindow.Height - messageBox.Height) / 2;  	var messageBody = OverlayManager.Singleton.GetOverlayElement ("HelloWorldOverlay/MessageBox/Body");  	//messageBody.Caption = "Ssij palke :*";  	OverlayManager.Singleton.GetByName ("HelloWorldOverlay").Show ();  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,KeyPressedHandler,The following statement contains a magic number: messageBox.Left = (m_RenderWindow.Width - messageBox.Width) / 2;  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,KeyPressedHandler,The following statement contains a magic number: messageBox.Top = (m_RenderWindow.Height - messageBox.Height) / 2;  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,KeyPressedHandler,The following statement contains a magic number: if (keyEventRef.key == MOIS.KeyCode.KC_P) {  	Character player = (Character)m_ObjectManager.Find ("player");  	player.SetPosition (new Vector3 (-148' -25' 15));  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,KeyPressedHandler,The following statement contains a magic number: if (keyEventRef.key == MOIS.KeyCode.KC_P) {  	Character player = (Character)m_ObjectManager.Find ("player");  	player.SetPosition (new Vector3 (-148' -25' 15));  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,KeyPressedHandler,The following statement contains a magic number: if (keyEventRef.key == MOIS.KeyCode.KC_P) {  	Character player = (Character)m_ObjectManager.Find ("player");  	player.SetPosition (new Vector3 (-148' -25' 15));  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,KeyPressedHandler,The following statement contains a magic number: player.SetPosition (new Vector3 (-148' -25' 15));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,KeyPressedHandler,The following statement contains a magic number: player.SetPosition (new Vector3 (-148' -25' 15));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,KeyPressedHandler,The following statement contains a magic number: player.SetPosition (new Vector3 (-148' -25' 15));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateElevator,The following statement contains a magic number: for (int i = dlugoscMostu - 1; i >= 0; i--) {  	m_Barrel [i] = new Barrel ("Barrel.mesh"' vec1 + new Vector3 (98' -25 + i * 0.2f' 68)' 15);  	m_ObjectManager.Add ("b" + i' m_Barrel [i]);  	//101 -19 66  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateElevator,The following statement contains a magic number: for (int i = dlugoscMostu - 1; i >= 0; i--) {  	m_Barrel [i] = new Barrel ("Barrel.mesh"' vec1 + new Vector3 (98' -25 + i * 0.2f' 68)' 15);  	m_ObjectManager.Add ("b" + i' m_Barrel [i]);  	//101 -19 66  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateElevator,The following statement contains a magic number: for (int i = dlugoscMostu - 1; i >= 0; i--) {  	m_Barrel [i] = new Barrel ("Barrel.mesh"' vec1 + new Vector3 (98' -25 + i * 0.2f' 68)' 15);  	m_ObjectManager.Add ("b" + i' m_Barrel [i]);  	//101 -19 66  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateElevator,The following statement contains a magic number: for (int i = dlugoscMostu - 1; i >= 0; i--) {  	m_Barrel [i] = new Barrel ("Barrel.mesh"' vec1 + new Vector3 (98' -25 + i * 0.2f' 68)' 15);  	m_ObjectManager.Add ("b" + i' m_Barrel [i]);  	//101 -19 66  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateElevator,The following statement contains a magic number: m_Barrel [i] = new Barrel ("Barrel.mesh"' vec1 + new Vector3 (98' -25 + i * 0.2f' 68)' 15);  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateElevator,The following statement contains a magic number: m_Barrel [i] = new Barrel ("Barrel.mesh"' vec1 + new Vector3 (98' -25 + i * 0.2f' 68)' 15);  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateElevator,The following statement contains a magic number: m_Barrel [i] = new Barrel ("Barrel.mesh"' vec1 + new Vector3 (98' -25 + i * 0.2f' 68)' 15);  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateElevator,The following statement contains a magic number: m_Barrel [i] = new Barrel ("Barrel.mesh"' vec1 + new Vector3 (98' -25 + i * 0.2f' 68)' 15);  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateElevator,The following statement contains a magic number: for (int i = dlugoscMostu2 - 1; i >= 0; i--) {  	m_Barrel2 [i] = new Barrel ("Barrel.mesh"' 5' vec1 + new Vector3 (109' -27 + i * 0.5f' 18 + i * 2));  	m_ObjectManager.Add ("bb" + i' m_Barrel2 [i]);  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateElevator,The following statement contains a magic number: for (int i = dlugoscMostu2 - 1; i >= 0; i--) {  	m_Barrel2 [i] = new Barrel ("Barrel.mesh"' 5' vec1 + new Vector3 (109' -27 + i * 0.5f' 18 + i * 2));  	m_ObjectManager.Add ("bb" + i' m_Barrel2 [i]);  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateElevator,The following statement contains a magic number: for (int i = dlugoscMostu2 - 1; i >= 0; i--) {  	m_Barrel2 [i] = new Barrel ("Barrel.mesh"' 5' vec1 + new Vector3 (109' -27 + i * 0.5f' 18 + i * 2));  	m_ObjectManager.Add ("bb" + i' m_Barrel2 [i]);  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateElevator,The following statement contains a magic number: for (int i = dlugoscMostu2 - 1; i >= 0; i--) {  	m_Barrel2 [i] = new Barrel ("Barrel.mesh"' 5' vec1 + new Vector3 (109' -27 + i * 0.5f' 18 + i * 2));  	m_ObjectManager.Add ("bb" + i' m_Barrel2 [i]);  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateElevator,The following statement contains a magic number: for (int i = dlugoscMostu2 - 1; i >= 0; i--) {  	m_Barrel2 [i] = new Barrel ("Barrel.mesh"' 5' vec1 + new Vector3 (109' -27 + i * 0.5f' 18 + i * 2));  	m_ObjectManager.Add ("bb" + i' m_Barrel2 [i]);  }  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateElevator,The following statement contains a magic number: m_Barrel2 [i] = new Barrel ("Barrel.mesh"' 5' vec1 + new Vector3 (109' -27 + i * 0.5f' 18 + i * 2));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateElevator,The following statement contains a magic number: m_Barrel2 [i] = new Barrel ("Barrel.mesh"' 5' vec1 + new Vector3 (109' -27 + i * 0.5f' 18 + i * 2));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateElevator,The following statement contains a magic number: m_Barrel2 [i] = new Barrel ("Barrel.mesh"' 5' vec1 + new Vector3 (109' -27 + i * 0.5f' 18 + i * 2));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateElevator,The following statement contains a magic number: m_Barrel2 [i] = new Barrel ("Barrel.mesh"' 5' vec1 + new Vector3 (109' -27 + i * 0.5f' 18 + i * 2));  
Magic Number,Tachycardia,Core,C:\repos\secred_Tachycardia\src\Core\Core.cs,CreateElevator,The following statement contains a magic number: m_Barrel2 [i] = new Barrel ("Barrel.mesh"' 5' vec1 + new Vector3 (109' -27 + i * 0.5f' 18 + i * 2));  
Magic Number,Tachycardia,GameCamera,C:\repos\secred_Tachycardia\src\GameCamera.cs,Cam3,The following statement contains a magic number: m_Type = 2;  
Magic Number,Tachycardia,GameCamera,C:\repos\secred_Tachycardia\src\GameCamera.cs,Cam4,The following statement contains a magic number: m_Type = 3;  
Magic Number,Tachycardia,Character,C:\repos\secred_Tachycardia\src\Player\Character.cs,Update,The following statement contains a magic number: switch (m_Control.m_State) {  case PlayerController.CharacterState.IDLE:  	walkAnimation.Enabled = false;  	idleAnimation.Enabled = true;  	idleAnimation.Loop = true;  	idleAnimation.AddTime (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector);  	break;  case PlayerController.CharacterState.WALK:  	idleAnimation.Enabled = false;  	walkAnimation.Enabled = true;  	walkAnimation.Loop = true;  	walkAnimation.AddTime (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector);  	if (walkAnimation.TimePosition / walkAnimation.Length > 0.5f && (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.5f || (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.0f) {  		Core.Singleton.SoundDict.Play ("player/step_gravel_0" + new Random ().Next (1' 4) + ".wav"' m_Control.m_MainBody.Position);  	}  	break;  case PlayerController.CharacterState.RUN:  	idleAnimation.Enabled = false;  	walkAnimation.Enabled = true;  	walkAnimation.Loop = true;  	walkAnimation.AddTime (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector);  	if (walkAnimation.TimePosition / walkAnimation.Length > 0.5f && (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.5f || (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.0f) {  		Core.Singleton.SoundDict.Play ("player/step_gravel_0" + new Random ().Next (1' 4) + ".wav"' m_Control.m_MainBody.Position);  	}  	break;  }  
Magic Number,Tachycardia,Character,C:\repos\secred_Tachycardia\src\Player\Character.cs,Update,The following statement contains a magic number: switch (m_Control.m_State) {  case PlayerController.CharacterState.IDLE:  	walkAnimation.Enabled = false;  	idleAnimation.Enabled = true;  	idleAnimation.Loop = true;  	idleAnimation.AddTime (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector);  	break;  case PlayerController.CharacterState.WALK:  	idleAnimation.Enabled = false;  	walkAnimation.Enabled = true;  	walkAnimation.Loop = true;  	walkAnimation.AddTime (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector);  	if (walkAnimation.TimePosition / walkAnimation.Length > 0.5f && (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.5f || (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.0f) {  		Core.Singleton.SoundDict.Play ("player/step_gravel_0" + new Random ().Next (1' 4) + ".wav"' m_Control.m_MainBody.Position);  	}  	break;  case PlayerController.CharacterState.RUN:  	idleAnimation.Enabled = false;  	walkAnimation.Enabled = true;  	walkAnimation.Loop = true;  	walkAnimation.AddTime (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector);  	if (walkAnimation.TimePosition / walkAnimation.Length > 0.5f && (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.5f || (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.0f) {  		Core.Singleton.SoundDict.Play ("player/step_gravel_0" + new Random ().Next (1' 4) + ".wav"' m_Control.m_MainBody.Position);  	}  	break;  }  
Magic Number,Tachycardia,Character,C:\repos\secred_Tachycardia\src\Player\Character.cs,Update,The following statement contains a magic number: if (walkAnimation.TimePosition / walkAnimation.Length > 0.5f && (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.5f || (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.0f) {  	Core.Singleton.SoundDict.Play ("player/step_gravel_0" + new Random ().Next (1' 4) + ".wav"' m_Control.m_MainBody.Position);  }  
Magic Number,Tachycardia,Character,C:\repos\secred_Tachycardia\src\Player\Character.cs,Update,The following statement contains a magic number: Core.Singleton.SoundDict.Play ("player/step_gravel_0" + new Random ().Next (1' 4) + ".wav"' m_Control.m_MainBody.Position);  
Magic Number,Tachycardia,Character,C:\repos\secred_Tachycardia\src\Player\Character.cs,Update,The following statement contains a magic number: if (walkAnimation.TimePosition / walkAnimation.Length > 0.5f && (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.5f || (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.0f) {  	Core.Singleton.SoundDict.Play ("player/step_gravel_0" + new Random ().Next (1' 4) + ".wav"' m_Control.m_MainBody.Position);  }  
Magic Number,Tachycardia,Character,C:\repos\secred_Tachycardia\src\Player\Character.cs,Update,The following statement contains a magic number: Core.Singleton.SoundDict.Play ("player/step_gravel_0" + new Random ().Next (1' 4) + ".wav"' m_Control.m_MainBody.Position);  
Magic Number,Tachycardia,GameState,C:\repos\secred_Tachycardia\src\States\GameState.cs,Enter,The following statement contains a magic number: Core.Singleton.GameCamera.Distance = 4;  
Magic Number,Tachycardia,GameState,C:\repos\secred_Tachycardia\src\States\GameState.cs,Enter,The following statement contains a magic number: Core.Singleton.GameCamera.Angle = new Degree (20);  
Magic Number,Tachycardia,GameState,C:\repos\secred_Tachycardia\src\States\GameState.cs,MouseMoved,The following statement contains a magic number: Core.Singleton.m_GameCamera.orientation *= Mogre.Vector3.UNIT_Z.GetRotationTo (new Vector3 ((float)evt.state.X.rel / -5 * Core.m_FixedTime' 0' 1.0f).NormalisedCopy);  
Magic Number,Tachycardia,IntroState,C:\repos\secred_Tachycardia\src\States\IntroState.cs,Init,The following statement contains a magic number: Core.Singleton.GameCamera.Distance = 8;  
Magic Number,Tachycardia,IntroState,C:\repos\secred_Tachycardia\src\States\IntroState.cs,Init,The following statement contains a magic number: Core.Singleton.GameCamera.Angle = new Degree (20);  
Magic Number,Tachycardia,IntroState,C:\repos\secred_Tachycardia\src\States\IntroState.cs,Update,The following statement contains a magic number: if (angTime > 400) {  	angDest = angDest > 0 ? -1 : 1;  	angTime = 0;  }  
Magic Number,Tachycardia.Objects,Elevator,C:\repos\secred_Tachycardia\src\Objects\Logic\Elevator.cs,ElevatorControl,The following statement contains a magic number: if (m_Body.Position.y >= 30 && m_Direction == 1) {  	caunter++;  	//m_Direction = 0.1f;  	if (caunter >= 200) {  		m_Direction = -1;  		caunter = 0;  	}  }  
Magic Number,Tachycardia.Objects,Elevator,C:\repos\secred_Tachycardia\src\Objects\Logic\Elevator.cs,ElevatorControl,The following statement contains a magic number: if (m_Body.Position.y >= 30 && m_Direction == 1) {  	caunter++;  	//m_Direction = 0.1f;  	if (caunter >= 200) {  		m_Direction = -1;  		caunter = 0;  	}  }  
Magic Number,Tachycardia.Objects,Elevator,C:\repos\secred_Tachycardia\src\Objects\Logic\Elevator.cs,ElevatorControl,The following statement contains a magic number: if (caunter >= 200) {  	m_Direction = -1;  	caunter = 0;  }  
Magic Number,Tachycardia.Objects,Elevator,C:\repos\secred_Tachycardia\src\Objects\Logic\Elevator.cs,ElevatorControl,The following statement contains a magic number: if (m_Body.Position.y <= -5 && m_Direction == -1) {  	caunter++;  	if (caunter >= 1000) {  		m_Direction = 1;  		caunter = 0;  	}  }  
Magic Number,Tachycardia.Objects,Elevator,C:\repos\secred_Tachycardia\src\Objects\Logic\Elevator.cs,ElevatorControl,The following statement contains a magic number: if (m_Body.Position.y <= -5 && m_Direction == -1) {  	caunter++;  	if (caunter >= 1000) {  		m_Direction = 1;  		caunter = 0;  	}  }  
Magic Number,Tachycardia.Objects,Elevator,C:\repos\secred_Tachycardia\src\Objects\Logic\Elevator.cs,ElevatorControl,The following statement contains a magic number: if (caunter >= 1000) {  	m_Direction = 1;  	caunter = 0;  }  
Magic Number,Tachycardia.Objects,Elevator,C:\repos\secred_Tachycardia\src\Objects\Logic\Elevator.cs,Elevator,The following statement contains a magic number: m_Node.Rotate (new Mogre.Quaternion (new Mogre.Radian (Mogre.Math.RadiansToDegrees (20))' new Mogre.Vector3 (0f' 1f' 0f)));  
Magic Number,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,UserProcess,The following statement contains a magic number: if (contact.Body0.Type == (int)PhysicsManager.BodyTypes.PLAYER || contact.Body0.Type == (int)PhysicsManager.BodyTypes.NPC) {  	Tachycardia.PlayerController controler = (Tachycardia.PlayerController)contact.Body0.UserData;  	if (controler != null) {  		if (controler.m_Pose.m_name == "fly" && controler.m_jumpLimit < Core.m_FixedFPS / 2) {  			if (controler.m_MainBody.Velocity.y < -8)  				killtest (controler.m_MainBody.Position);  			controler.ChangePoseTo ("normal");  			Console.WriteLine (controler.m_Pose.m_name);  		}  		controler.m_Onground = 0;  	}  }  else if (contact.Body1.Type == (int)PhysicsManager.BodyTypes.PLAYER || contact.Body1.Type == (int)PhysicsManager.BodyTypes.NPC) {  	Tachycardia.PlayerController controler = (Tachycardia.PlayerController)contact.Body1.UserData;  	if (controler != null) {  		if (controler.m_Pose.m_name == "fly" && controler.m_jumpLimit < Core.m_FixedFPS / 2) {  			if (controler.m_MainBody.Velocity.y < -8)  				killtest (controler.m_MainBody.Position);  			controler.ChangePoseTo ("normal");  			Console.WriteLine (controler.m_Pose.m_name);  		}  		controler.m_Onground = 0;  	}  }  
Magic Number,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,UserProcess,The following statement contains a magic number: if (contact.Body0.Type == (int)PhysicsManager.BodyTypes.PLAYER || contact.Body0.Type == (int)PhysicsManager.BodyTypes.NPC) {  	Tachycardia.PlayerController controler = (Tachycardia.PlayerController)contact.Body0.UserData;  	if (controler != null) {  		if (controler.m_Pose.m_name == "fly" && controler.m_jumpLimit < Core.m_FixedFPS / 2) {  			if (controler.m_MainBody.Velocity.y < -8)  				killtest (controler.m_MainBody.Position);  			controler.ChangePoseTo ("normal");  			Console.WriteLine (controler.m_Pose.m_name);  		}  		controler.m_Onground = 0;  	}  }  else if (contact.Body1.Type == (int)PhysicsManager.BodyTypes.PLAYER || contact.Body1.Type == (int)PhysicsManager.BodyTypes.NPC) {  	Tachycardia.PlayerController controler = (Tachycardia.PlayerController)contact.Body1.UserData;  	if (controler != null) {  		if (controler.m_Pose.m_name == "fly" && controler.m_jumpLimit < Core.m_FixedFPS / 2) {  			if (controler.m_MainBody.Velocity.y < -8)  				killtest (controler.m_MainBody.Position);  			controler.ChangePoseTo ("normal");  			Console.WriteLine (controler.m_Pose.m_name);  		}  		controler.m_Onground = 0;  	}  }  
Magic Number,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,UserProcess,The following statement contains a magic number: if (contact.Body0.Type == (int)PhysicsManager.BodyTypes.PLAYER || contact.Body0.Type == (int)PhysicsManager.BodyTypes.NPC) {  	Tachycardia.PlayerController controler = (Tachycardia.PlayerController)contact.Body0.UserData;  	if (controler != null) {  		if (controler.m_Pose.m_name == "fly" && controler.m_jumpLimit < Core.m_FixedFPS / 2) {  			if (controler.m_MainBody.Velocity.y < -8)  				killtest (controler.m_MainBody.Position);  			controler.ChangePoseTo ("normal");  			Console.WriteLine (controler.m_Pose.m_name);  		}  		controler.m_Onground = 0;  	}  }  else if (contact.Body1.Type == (int)PhysicsManager.BodyTypes.PLAYER || contact.Body1.Type == (int)PhysicsManager.BodyTypes.NPC) {  	Tachycardia.PlayerController controler = (Tachycardia.PlayerController)contact.Body1.UserData;  	if (controler != null) {  		if (controler.m_Pose.m_name == "fly" && controler.m_jumpLimit < Core.m_FixedFPS / 2) {  			if (controler.m_MainBody.Velocity.y < -8)  				killtest (controler.m_MainBody.Position);  			controler.ChangePoseTo ("normal");  			Console.WriteLine (controler.m_Pose.m_name);  		}  		controler.m_Onground = 0;  	}  }  
Magic Number,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,UserProcess,The following statement contains a magic number: if (contact.Body0.Type == (int)PhysicsManager.BodyTypes.PLAYER || contact.Body0.Type == (int)PhysicsManager.BodyTypes.NPC) {  	Tachycardia.PlayerController controler = (Tachycardia.PlayerController)contact.Body0.UserData;  	if (controler != null) {  		if (controler.m_Pose.m_name == "fly" && controler.m_jumpLimit < Core.m_FixedFPS / 2) {  			if (controler.m_MainBody.Velocity.y < -8)  				killtest (controler.m_MainBody.Position);  			controler.ChangePoseTo ("normal");  			Console.WriteLine (controler.m_Pose.m_name);  		}  		controler.m_Onground = 0;  	}  }  else if (contact.Body1.Type == (int)PhysicsManager.BodyTypes.PLAYER || contact.Body1.Type == (int)PhysicsManager.BodyTypes.NPC) {  	Tachycardia.PlayerController controler = (Tachycardia.PlayerController)contact.Body1.UserData;  	if (controler != null) {  		if (controler.m_Pose.m_name == "fly" && controler.m_jumpLimit < Core.m_FixedFPS / 2) {  			if (controler.m_MainBody.Velocity.y < -8)  				killtest (controler.m_MainBody.Position);  			controler.ChangePoseTo ("normal");  			Console.WriteLine (controler.m_Pose.m_name);  		}  		controler.m_Onground = 0;  	}  }  
Magic Number,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,UserProcess,The following statement contains a magic number: if (controler != null) {  	if (controler.m_Pose.m_name == "fly" && controler.m_jumpLimit < Core.m_FixedFPS / 2) {  		if (controler.m_MainBody.Velocity.y < -8)  			killtest (controler.m_MainBody.Position);  		controler.ChangePoseTo ("normal");  		Console.WriteLine (controler.m_Pose.m_name);  	}  	controler.m_Onground = 0;  }  
Magic Number,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,UserProcess,The following statement contains a magic number: if (controler != null) {  	if (controler.m_Pose.m_name == "fly" && controler.m_jumpLimit < Core.m_FixedFPS / 2) {  		if (controler.m_MainBody.Velocity.y < -8)  			killtest (controler.m_MainBody.Position);  		controler.ChangePoseTo ("normal");  		Console.WriteLine (controler.m_Pose.m_name);  	}  	controler.m_Onground = 0;  }  
Magic Number,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,UserProcess,The following statement contains a magic number: if (controler.m_Pose.m_name == "fly" && controler.m_jumpLimit < Core.m_FixedFPS / 2) {  	if (controler.m_MainBody.Velocity.y < -8)  		killtest (controler.m_MainBody.Position);  	controler.ChangePoseTo ("normal");  	Console.WriteLine (controler.m_Pose.m_name);  }  
Magic Number,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,UserProcess,The following statement contains a magic number: if (controler.m_Pose.m_name == "fly" && controler.m_jumpLimit < Core.m_FixedFPS / 2) {  	if (controler.m_MainBody.Velocity.y < -8)  		killtest (controler.m_MainBody.Position);  	controler.ChangePoseTo ("normal");  	Console.WriteLine (controler.m_Pose.m_name);  }  
Magic Number,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,UserProcess,The following statement contains a magic number: if (controler.m_MainBody.Velocity.y < -8)  	killtest (controler.m_MainBody.Position);  
Magic Number,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,UserProcess,The following statement contains a magic number: if (contact.Body1.Type == (int)PhysicsManager.BodyTypes.PLAYER || contact.Body1.Type == (int)PhysicsManager.BodyTypes.NPC) {  	Tachycardia.PlayerController controler = (Tachycardia.PlayerController)contact.Body1.UserData;  	if (controler != null) {  		if (controler.m_Pose.m_name == "fly" && controler.m_jumpLimit < Core.m_FixedFPS / 2) {  			if (controler.m_MainBody.Velocity.y < -8)  				killtest (controler.m_MainBody.Position);  			controler.ChangePoseTo ("normal");  			Console.WriteLine (controler.m_Pose.m_name);  		}  		controler.m_Onground = 0;  	}  }  
Magic Number,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,UserProcess,The following statement contains a magic number: if (contact.Body1.Type == (int)PhysicsManager.BodyTypes.PLAYER || contact.Body1.Type == (int)PhysicsManager.BodyTypes.NPC) {  	Tachycardia.PlayerController controler = (Tachycardia.PlayerController)contact.Body1.UserData;  	if (controler != null) {  		if (controler.m_Pose.m_name == "fly" && controler.m_jumpLimit < Core.m_FixedFPS / 2) {  			if (controler.m_MainBody.Velocity.y < -8)  				killtest (controler.m_MainBody.Position);  			controler.ChangePoseTo ("normal");  			Console.WriteLine (controler.m_Pose.m_name);  		}  		controler.m_Onground = 0;  	}  }  
Magic Number,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,UserProcess,The following statement contains a magic number: if (controler != null) {  	if (controler.m_Pose.m_name == "fly" && controler.m_jumpLimit < Core.m_FixedFPS / 2) {  		if (controler.m_MainBody.Velocity.y < -8)  			killtest (controler.m_MainBody.Position);  		controler.ChangePoseTo ("normal");  		Console.WriteLine (controler.m_Pose.m_name);  	}  	controler.m_Onground = 0;  }  
Magic Number,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,UserProcess,The following statement contains a magic number: if (controler != null) {  	if (controler.m_Pose.m_name == "fly" && controler.m_jumpLimit < Core.m_FixedFPS / 2) {  		if (controler.m_MainBody.Velocity.y < -8)  			killtest (controler.m_MainBody.Position);  		controler.ChangePoseTo ("normal");  		Console.WriteLine (controler.m_Pose.m_name);  	}  	controler.m_Onground = 0;  }  
Magic Number,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,UserProcess,The following statement contains a magic number: if (controler.m_Pose.m_name == "fly" && controler.m_jumpLimit < Core.m_FixedFPS / 2) {  	if (controler.m_MainBody.Velocity.y < -8)  		killtest (controler.m_MainBody.Position);  	controler.ChangePoseTo ("normal");  	Console.WriteLine (controler.m_Pose.m_name);  }  
Magic Number,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,UserProcess,The following statement contains a magic number: if (controler.m_Pose.m_name == "fly" && controler.m_jumpLimit < Core.m_FixedFPS / 2) {  	if (controler.m_MainBody.Velocity.y < -8)  		killtest (controler.m_MainBody.Position);  	controler.ChangePoseTo ("normal");  	Console.WriteLine (controler.m_Pose.m_name);  }  
Magic Number,Tachycardia.Objects.PhysicsMaterials,GroundPlayerCallback,C:\repos\secred_Tachycardia\src\Objects\PhysicsMaterials\GroundPlayerCallback.cs,UserProcess,The following statement contains a magic number: if (controler.m_MainBody.Velocity.y < -8)  	killtest (controler.m_MainBody.Position);  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: switch (format) {  case ALFormat.Mono8:  	return 1;  case ALFormat.Mono16:  	return 2;  case ALFormat.Stereo8:  	return 2;  case ALFormat.Stereo16:  	return 4;  case ALFormat.MonoFloat32Ext:  	return 4;  case ALFormat.MonoDoubleExt:  	return 8;  case ALFormat.StereoFloat32Ext:  	return 8;  case ALFormat.StereoDoubleExt:  	return 16;  case ALFormat.MultiQuad8Ext:  	return 4;  case ALFormat.MultiQuad16Ext:  	return 8;  case ALFormat.MultiQuad32Ext:  	return 16;  case ALFormat.Multi51Chn8Ext:  	return 6;  case ALFormat.Multi51Chn16Ext:  	return 12;  case ALFormat.Multi51Chn32Ext:  	return 24;  case ALFormat.Multi61Chn8Ext:  	return 7;  case ALFormat.Multi71Chn16Ext:  	return 14;  case ALFormat.Multi71Chn32Ext:  	return 28;  case ALFormat.MultiRear8Ext:  	return 1;  case ALFormat.MultiRear16Ext:  	return 2;  case ALFormat.MultiRear32Ext:  	return 4;  default:  	return 1;  // Unknown sample size.  }  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: switch (format) {  case ALFormat.Mono8:  	return 1;  case ALFormat.Mono16:  	return 2;  case ALFormat.Stereo8:  	return 2;  case ALFormat.Stereo16:  	return 4;  case ALFormat.MonoFloat32Ext:  	return 4;  case ALFormat.MonoDoubleExt:  	return 8;  case ALFormat.StereoFloat32Ext:  	return 8;  case ALFormat.StereoDoubleExt:  	return 16;  case ALFormat.MultiQuad8Ext:  	return 4;  case ALFormat.MultiQuad16Ext:  	return 8;  case ALFormat.MultiQuad32Ext:  	return 16;  case ALFormat.Multi51Chn8Ext:  	return 6;  case ALFormat.Multi51Chn16Ext:  	return 12;  case ALFormat.Multi51Chn32Ext:  	return 24;  case ALFormat.Multi61Chn8Ext:  	return 7;  case ALFormat.Multi71Chn16Ext:  	return 14;  case ALFormat.Multi71Chn32Ext:  	return 28;  case ALFormat.MultiRear8Ext:  	return 1;  case ALFormat.MultiRear16Ext:  	return 2;  case ALFormat.MultiRear32Ext:  	return 4;  default:  	return 1;  // Unknown sample size.  }  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: switch (format) {  case ALFormat.Mono8:  	return 1;  case ALFormat.Mono16:  	return 2;  case ALFormat.Stereo8:  	return 2;  case ALFormat.Stereo16:  	return 4;  case ALFormat.MonoFloat32Ext:  	return 4;  case ALFormat.MonoDoubleExt:  	return 8;  case ALFormat.StereoFloat32Ext:  	return 8;  case ALFormat.StereoDoubleExt:  	return 16;  case ALFormat.MultiQuad8Ext:  	return 4;  case ALFormat.MultiQuad16Ext:  	return 8;  case ALFormat.MultiQuad32Ext:  	return 16;  case ALFormat.Multi51Chn8Ext:  	return 6;  case ALFormat.Multi51Chn16Ext:  	return 12;  case ALFormat.Multi51Chn32Ext:  	return 24;  case ALFormat.Multi61Chn8Ext:  	return 7;  case ALFormat.Multi71Chn16Ext:  	return 14;  case ALFormat.Multi71Chn32Ext:  	return 28;  case ALFormat.MultiRear8Ext:  	return 1;  case ALFormat.MultiRear16Ext:  	return 2;  case ALFormat.MultiRear32Ext:  	return 4;  default:  	return 1;  // Unknown sample size.  }  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: switch (format) {  case ALFormat.Mono8:  	return 1;  case ALFormat.Mono16:  	return 2;  case ALFormat.Stereo8:  	return 2;  case ALFormat.Stereo16:  	return 4;  case ALFormat.MonoFloat32Ext:  	return 4;  case ALFormat.MonoDoubleExt:  	return 8;  case ALFormat.StereoFloat32Ext:  	return 8;  case ALFormat.StereoDoubleExt:  	return 16;  case ALFormat.MultiQuad8Ext:  	return 4;  case ALFormat.MultiQuad16Ext:  	return 8;  case ALFormat.MultiQuad32Ext:  	return 16;  case ALFormat.Multi51Chn8Ext:  	return 6;  case ALFormat.Multi51Chn16Ext:  	return 12;  case ALFormat.Multi51Chn32Ext:  	return 24;  case ALFormat.Multi61Chn8Ext:  	return 7;  case ALFormat.Multi71Chn16Ext:  	return 14;  case ALFormat.Multi71Chn32Ext:  	return 28;  case ALFormat.MultiRear8Ext:  	return 1;  case ALFormat.MultiRear16Ext:  	return 2;  case ALFormat.MultiRear32Ext:  	return 4;  default:  	return 1;  // Unknown sample size.  }  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: switch (format) {  case ALFormat.Mono8:  	return 1;  case ALFormat.Mono16:  	return 2;  case ALFormat.Stereo8:  	return 2;  case ALFormat.Stereo16:  	return 4;  case ALFormat.MonoFloat32Ext:  	return 4;  case ALFormat.MonoDoubleExt:  	return 8;  case ALFormat.StereoFloat32Ext:  	return 8;  case ALFormat.StereoDoubleExt:  	return 16;  case ALFormat.MultiQuad8Ext:  	return 4;  case ALFormat.MultiQuad16Ext:  	return 8;  case ALFormat.MultiQuad32Ext:  	return 16;  case ALFormat.Multi51Chn8Ext:  	return 6;  case ALFormat.Multi51Chn16Ext:  	return 12;  case ALFormat.Multi51Chn32Ext:  	return 24;  case ALFormat.Multi61Chn8Ext:  	return 7;  case ALFormat.Multi71Chn16Ext:  	return 14;  case ALFormat.Multi71Chn32Ext:  	return 28;  case ALFormat.MultiRear8Ext:  	return 1;  case ALFormat.MultiRear16Ext:  	return 2;  case ALFormat.MultiRear32Ext:  	return 4;  default:  	return 1;  // Unknown sample size.  }  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: switch (format) {  case ALFormat.Mono8:  	return 1;  case ALFormat.Mono16:  	return 2;  case ALFormat.Stereo8:  	return 2;  case ALFormat.Stereo16:  	return 4;  case ALFormat.MonoFloat32Ext:  	return 4;  case ALFormat.MonoDoubleExt:  	return 8;  case ALFormat.StereoFloat32Ext:  	return 8;  case ALFormat.StereoDoubleExt:  	return 16;  case ALFormat.MultiQuad8Ext:  	return 4;  case ALFormat.MultiQuad16Ext:  	return 8;  case ALFormat.MultiQuad32Ext:  	return 16;  case ALFormat.Multi51Chn8Ext:  	return 6;  case ALFormat.Multi51Chn16Ext:  	return 12;  case ALFormat.Multi51Chn32Ext:  	return 24;  case ALFormat.Multi61Chn8Ext:  	return 7;  case ALFormat.Multi71Chn16Ext:  	return 14;  case ALFormat.Multi71Chn32Ext:  	return 28;  case ALFormat.MultiRear8Ext:  	return 1;  case ALFormat.MultiRear16Ext:  	return 2;  case ALFormat.MultiRear32Ext:  	return 4;  default:  	return 1;  // Unknown sample size.  }  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: switch (format) {  case ALFormat.Mono8:  	return 1;  case ALFormat.Mono16:  	return 2;  case ALFormat.Stereo8:  	return 2;  case ALFormat.Stereo16:  	return 4;  case ALFormat.MonoFloat32Ext:  	return 4;  case ALFormat.MonoDoubleExt:  	return 8;  case ALFormat.StereoFloat32Ext:  	return 8;  case ALFormat.StereoDoubleExt:  	return 16;  case ALFormat.MultiQuad8Ext:  	return 4;  case ALFormat.MultiQuad16Ext:  	return 8;  case ALFormat.MultiQuad32Ext:  	return 16;  case ALFormat.Multi51Chn8Ext:  	return 6;  case ALFormat.Multi51Chn16Ext:  	return 12;  case ALFormat.Multi51Chn32Ext:  	return 24;  case ALFormat.Multi61Chn8Ext:  	return 7;  case ALFormat.Multi71Chn16Ext:  	return 14;  case ALFormat.Multi71Chn32Ext:  	return 28;  case ALFormat.MultiRear8Ext:  	return 1;  case ALFormat.MultiRear16Ext:  	return 2;  case ALFormat.MultiRear32Ext:  	return 4;  default:  	return 1;  // Unknown sample size.  }  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: switch (format) {  case ALFormat.Mono8:  	return 1;  case ALFormat.Mono16:  	return 2;  case ALFormat.Stereo8:  	return 2;  case ALFormat.Stereo16:  	return 4;  case ALFormat.MonoFloat32Ext:  	return 4;  case ALFormat.MonoDoubleExt:  	return 8;  case ALFormat.StereoFloat32Ext:  	return 8;  case ALFormat.StereoDoubleExt:  	return 16;  case ALFormat.MultiQuad8Ext:  	return 4;  case ALFormat.MultiQuad16Ext:  	return 8;  case ALFormat.MultiQuad32Ext:  	return 16;  case ALFormat.Multi51Chn8Ext:  	return 6;  case ALFormat.Multi51Chn16Ext:  	return 12;  case ALFormat.Multi51Chn32Ext:  	return 24;  case ALFormat.Multi61Chn8Ext:  	return 7;  case ALFormat.Multi71Chn16Ext:  	return 14;  case ALFormat.Multi71Chn32Ext:  	return 28;  case ALFormat.MultiRear8Ext:  	return 1;  case ALFormat.MultiRear16Ext:  	return 2;  case ALFormat.MultiRear32Ext:  	return 4;  default:  	return 1;  // Unknown sample size.  }  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: switch (format) {  case ALFormat.Mono8:  	return 1;  case ALFormat.Mono16:  	return 2;  case ALFormat.Stereo8:  	return 2;  case ALFormat.Stereo16:  	return 4;  case ALFormat.MonoFloat32Ext:  	return 4;  case ALFormat.MonoDoubleExt:  	return 8;  case ALFormat.StereoFloat32Ext:  	return 8;  case ALFormat.StereoDoubleExt:  	return 16;  case ALFormat.MultiQuad8Ext:  	return 4;  case ALFormat.MultiQuad16Ext:  	return 8;  case ALFormat.MultiQuad32Ext:  	return 16;  case ALFormat.Multi51Chn8Ext:  	return 6;  case ALFormat.Multi51Chn16Ext:  	return 12;  case ALFormat.Multi51Chn32Ext:  	return 24;  case ALFormat.Multi61Chn8Ext:  	return 7;  case ALFormat.Multi71Chn16Ext:  	return 14;  case ALFormat.Multi71Chn32Ext:  	return 28;  case ALFormat.MultiRear8Ext:  	return 1;  case ALFormat.MultiRear16Ext:  	return 2;  case ALFormat.MultiRear32Ext:  	return 4;  default:  	return 1;  // Unknown sample size.  }  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: switch (format) {  case ALFormat.Mono8:  	return 1;  case ALFormat.Mono16:  	return 2;  case ALFormat.Stereo8:  	return 2;  case ALFormat.Stereo16:  	return 4;  case ALFormat.MonoFloat32Ext:  	return 4;  case ALFormat.MonoDoubleExt:  	return 8;  case ALFormat.StereoFloat32Ext:  	return 8;  case ALFormat.StereoDoubleExt:  	return 16;  case ALFormat.MultiQuad8Ext:  	return 4;  case ALFormat.MultiQuad16Ext:  	return 8;  case ALFormat.MultiQuad32Ext:  	return 16;  case ALFormat.Multi51Chn8Ext:  	return 6;  case ALFormat.Multi51Chn16Ext:  	return 12;  case ALFormat.Multi51Chn32Ext:  	return 24;  case ALFormat.Multi61Chn8Ext:  	return 7;  case ALFormat.Multi71Chn16Ext:  	return 14;  case ALFormat.Multi71Chn32Ext:  	return 28;  case ALFormat.MultiRear8Ext:  	return 1;  case ALFormat.MultiRear16Ext:  	return 2;  case ALFormat.MultiRear32Ext:  	return 4;  default:  	return 1;  // Unknown sample size.  }  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: switch (format) {  case ALFormat.Mono8:  	return 1;  case ALFormat.Mono16:  	return 2;  case ALFormat.Stereo8:  	return 2;  case ALFormat.Stereo16:  	return 4;  case ALFormat.MonoFloat32Ext:  	return 4;  case ALFormat.MonoDoubleExt:  	return 8;  case ALFormat.StereoFloat32Ext:  	return 8;  case ALFormat.StereoDoubleExt:  	return 16;  case ALFormat.MultiQuad8Ext:  	return 4;  case ALFormat.MultiQuad16Ext:  	return 8;  case ALFormat.MultiQuad32Ext:  	return 16;  case ALFormat.Multi51Chn8Ext:  	return 6;  case ALFormat.Multi51Chn16Ext:  	return 12;  case ALFormat.Multi51Chn32Ext:  	return 24;  case ALFormat.Multi61Chn8Ext:  	return 7;  case ALFormat.Multi71Chn16Ext:  	return 14;  case ALFormat.Multi71Chn32Ext:  	return 28;  case ALFormat.MultiRear8Ext:  	return 1;  case ALFormat.MultiRear16Ext:  	return 2;  case ALFormat.MultiRear32Ext:  	return 4;  default:  	return 1;  // Unknown sample size.  }  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: switch (format) {  case ALFormat.Mono8:  	return 1;  case ALFormat.Mono16:  	return 2;  case ALFormat.Stereo8:  	return 2;  case ALFormat.Stereo16:  	return 4;  case ALFormat.MonoFloat32Ext:  	return 4;  case ALFormat.MonoDoubleExt:  	return 8;  case ALFormat.StereoFloat32Ext:  	return 8;  case ALFormat.StereoDoubleExt:  	return 16;  case ALFormat.MultiQuad8Ext:  	return 4;  case ALFormat.MultiQuad16Ext:  	return 8;  case ALFormat.MultiQuad32Ext:  	return 16;  case ALFormat.Multi51Chn8Ext:  	return 6;  case ALFormat.Multi51Chn16Ext:  	return 12;  case ALFormat.Multi51Chn32Ext:  	return 24;  case ALFormat.Multi61Chn8Ext:  	return 7;  case ALFormat.Multi71Chn16Ext:  	return 14;  case ALFormat.Multi71Chn32Ext:  	return 28;  case ALFormat.MultiRear8Ext:  	return 1;  case ALFormat.MultiRear16Ext:  	return 2;  case ALFormat.MultiRear32Ext:  	return 4;  default:  	return 1;  // Unknown sample size.  }  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: switch (format) {  case ALFormat.Mono8:  	return 1;  case ALFormat.Mono16:  	return 2;  case ALFormat.Stereo8:  	return 2;  case ALFormat.Stereo16:  	return 4;  case ALFormat.MonoFloat32Ext:  	return 4;  case ALFormat.MonoDoubleExt:  	return 8;  case ALFormat.StereoFloat32Ext:  	return 8;  case ALFormat.StereoDoubleExt:  	return 16;  case ALFormat.MultiQuad8Ext:  	return 4;  case ALFormat.MultiQuad16Ext:  	return 8;  case ALFormat.MultiQuad32Ext:  	return 16;  case ALFormat.Multi51Chn8Ext:  	return 6;  case ALFormat.Multi51Chn16Ext:  	return 12;  case ALFormat.Multi51Chn32Ext:  	return 24;  case ALFormat.Multi61Chn8Ext:  	return 7;  case ALFormat.Multi71Chn16Ext:  	return 14;  case ALFormat.Multi71Chn32Ext:  	return 28;  case ALFormat.MultiRear8Ext:  	return 1;  case ALFormat.MultiRear16Ext:  	return 2;  case ALFormat.MultiRear32Ext:  	return 4;  default:  	return 1;  // Unknown sample size.  }  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: switch (format) {  case ALFormat.Mono8:  	return 1;  case ALFormat.Mono16:  	return 2;  case ALFormat.Stereo8:  	return 2;  case ALFormat.Stereo16:  	return 4;  case ALFormat.MonoFloat32Ext:  	return 4;  case ALFormat.MonoDoubleExt:  	return 8;  case ALFormat.StereoFloat32Ext:  	return 8;  case ALFormat.StereoDoubleExt:  	return 16;  case ALFormat.MultiQuad8Ext:  	return 4;  case ALFormat.MultiQuad16Ext:  	return 8;  case ALFormat.MultiQuad32Ext:  	return 16;  case ALFormat.Multi51Chn8Ext:  	return 6;  case ALFormat.Multi51Chn16Ext:  	return 12;  case ALFormat.Multi51Chn32Ext:  	return 24;  case ALFormat.Multi61Chn8Ext:  	return 7;  case ALFormat.Multi71Chn16Ext:  	return 14;  case ALFormat.Multi71Chn32Ext:  	return 28;  case ALFormat.MultiRear8Ext:  	return 1;  case ALFormat.MultiRear16Ext:  	return 2;  case ALFormat.MultiRear32Ext:  	return 4;  default:  	return 1;  // Unknown sample size.  }  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: switch (format) {  case ALFormat.Mono8:  	return 1;  case ALFormat.Mono16:  	return 2;  case ALFormat.Stereo8:  	return 2;  case ALFormat.Stereo16:  	return 4;  case ALFormat.MonoFloat32Ext:  	return 4;  case ALFormat.MonoDoubleExt:  	return 8;  case ALFormat.StereoFloat32Ext:  	return 8;  case ALFormat.StereoDoubleExt:  	return 16;  case ALFormat.MultiQuad8Ext:  	return 4;  case ALFormat.MultiQuad16Ext:  	return 8;  case ALFormat.MultiQuad32Ext:  	return 16;  case ALFormat.Multi51Chn8Ext:  	return 6;  case ALFormat.Multi51Chn16Ext:  	return 12;  case ALFormat.Multi51Chn32Ext:  	return 24;  case ALFormat.Multi61Chn8Ext:  	return 7;  case ALFormat.Multi71Chn16Ext:  	return 14;  case ALFormat.Multi71Chn32Ext:  	return 28;  case ALFormat.MultiRear8Ext:  	return 1;  case ALFormat.MultiRear16Ext:  	return 2;  case ALFormat.MultiRear32Ext:  	return 4;  default:  	return 1;  // Unknown sample size.  }  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: switch (format) {  case ALFormat.Mono8:  	return 1;  case ALFormat.Mono16:  	return 2;  case ALFormat.Stereo8:  	return 2;  case ALFormat.Stereo16:  	return 4;  case ALFormat.MonoFloat32Ext:  	return 4;  case ALFormat.MonoDoubleExt:  	return 8;  case ALFormat.StereoFloat32Ext:  	return 8;  case ALFormat.StereoDoubleExt:  	return 16;  case ALFormat.MultiQuad8Ext:  	return 4;  case ALFormat.MultiQuad16Ext:  	return 8;  case ALFormat.MultiQuad32Ext:  	return 16;  case ALFormat.Multi51Chn8Ext:  	return 6;  case ALFormat.Multi51Chn16Ext:  	return 12;  case ALFormat.Multi51Chn32Ext:  	return 24;  case ALFormat.Multi61Chn8Ext:  	return 7;  case ALFormat.Multi71Chn16Ext:  	return 14;  case ALFormat.Multi71Chn32Ext:  	return 28;  case ALFormat.MultiRear8Ext:  	return 1;  case ALFormat.MultiRear16Ext:  	return 2;  case ALFormat.MultiRear32Ext:  	return 4;  default:  	return 1;  // Unknown sample size.  }  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: switch (format) {  case ALFormat.Mono8:  	return 1;  case ALFormat.Mono16:  	return 2;  case ALFormat.Stereo8:  	return 2;  case ALFormat.Stereo16:  	return 4;  case ALFormat.MonoFloat32Ext:  	return 4;  case ALFormat.MonoDoubleExt:  	return 8;  case ALFormat.StereoFloat32Ext:  	return 8;  case ALFormat.StereoDoubleExt:  	return 16;  case ALFormat.MultiQuad8Ext:  	return 4;  case ALFormat.MultiQuad16Ext:  	return 8;  case ALFormat.MultiQuad32Ext:  	return 16;  case ALFormat.Multi51Chn8Ext:  	return 6;  case ALFormat.Multi51Chn16Ext:  	return 12;  case ALFormat.Multi51Chn32Ext:  	return 24;  case ALFormat.Multi61Chn8Ext:  	return 7;  case ALFormat.Multi71Chn16Ext:  	return 14;  case ALFormat.Multi71Chn32Ext:  	return 28;  case ALFormat.MultiRear8Ext:  	return 1;  case ALFormat.MultiRear16Ext:  	return 2;  case ALFormat.MultiRear32Ext:  	return 4;  default:  	return 1;  // Unknown sample size.  }  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: switch (format) {  case ALFormat.Mono8:  	return 1;  case ALFormat.Mono16:  	return 2;  case ALFormat.Stereo8:  	return 2;  case ALFormat.Stereo16:  	return 4;  case ALFormat.MonoFloat32Ext:  	return 4;  case ALFormat.MonoDoubleExt:  	return 8;  case ALFormat.StereoFloat32Ext:  	return 8;  case ALFormat.StereoDoubleExt:  	return 16;  case ALFormat.MultiQuad8Ext:  	return 4;  case ALFormat.MultiQuad16Ext:  	return 8;  case ALFormat.MultiQuad32Ext:  	return 16;  case ALFormat.Multi51Chn8Ext:  	return 6;  case ALFormat.Multi51Chn16Ext:  	return 12;  case ALFormat.Multi51Chn32Ext:  	return 24;  case ALFormat.Multi61Chn8Ext:  	return 7;  case ALFormat.Multi71Chn16Ext:  	return 14;  case ALFormat.Multi71Chn32Ext:  	return 28;  case ALFormat.MultiRear8Ext:  	return 1;  case ALFormat.MultiRear16Ext:  	return 2;  case ALFormat.MultiRear32Ext:  	return 4;  default:  	return 1;  // Unknown sample size.  }  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: return 2;  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: return 2;  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: return 4;  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: return 4;  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: return 8;  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: return 8;  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: return 16;  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: return 4;  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: return 8;  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: return 16;  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: return 6;  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: return 12;  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: return 24;  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: return 7;  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: return 14;  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: return 28;  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: return 2;  
Magic Number,OpenTK.Audio,AudioCapture,C:\repos\secred_Tachycardia\src\Sound\Audio\AudioCapture.cs,GetSampleSize,The following statement contains a magic number: return 4;  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: for (int i = 0; i < s.Length; i++) {  	if (s [i] == 0)  		break;  	write (s [i]' 8);  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: write (s [i]' 8);  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: while (bytes-- != 0) {  	s [i++] = (byte)(read (8));  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: s [i++] = (byte)(read (8));  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (endbyte + 4 >= storage) {  	byte[] foo = new byte[storage + BUFFER_INCREMENT];  	Array.Copy (buffer' 0' foo' 0' storage);  	buffer = foo;  	storage += BUFFER_INCREMENT;  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 8) {  	buffer [ptr + 1] = (byte)((uint)vvalue >> (8 - endbit));  	if (bits >= 16) {  		buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  		if (bits >= 24) {  			buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  			if (bits >= 32) {  				if (endbit > 0)  					buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  				else  					buffer [ptr + 4] = 0;  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 8) {  	buffer [ptr + 1] = (byte)((uint)vvalue >> (8 - endbit));  	if (bits >= 16) {  		buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  		if (bits >= 24) {  			buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  			if (bits >= 32) {  				if (endbit > 0)  					buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  				else  					buffer [ptr + 4] = 0;  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 8) {  	buffer [ptr + 1] = (byte)((uint)vvalue >> (8 - endbit));  	if (bits >= 16) {  		buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  		if (bits >= 24) {  			buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  			if (bits >= 32) {  				if (endbit > 0)  					buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  				else  					buffer [ptr + 4] = 0;  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 8) {  	buffer [ptr + 1] = (byte)((uint)vvalue >> (8 - endbit));  	if (bits >= 16) {  		buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  		if (bits >= 24) {  			buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  			if (bits >= 32) {  				if (endbit > 0)  					buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  				else  					buffer [ptr + 4] = 0;  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 8) {  	buffer [ptr + 1] = (byte)((uint)vvalue >> (8 - endbit));  	if (bits >= 16) {  		buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  		if (bits >= 24) {  			buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  			if (bits >= 32) {  				if (endbit > 0)  					buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  				else  					buffer [ptr + 4] = 0;  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 8) {  	buffer [ptr + 1] = (byte)((uint)vvalue >> (8 - endbit));  	if (bits >= 16) {  		buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  		if (bits >= 24) {  			buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  			if (bits >= 32) {  				if (endbit > 0)  					buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  				else  					buffer [ptr + 4] = 0;  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 8) {  	buffer [ptr + 1] = (byte)((uint)vvalue >> (8 - endbit));  	if (bits >= 16) {  		buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  		if (bits >= 24) {  			buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  			if (bits >= 32) {  				if (endbit > 0)  					buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  				else  					buffer [ptr + 4] = 0;  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 8) {  	buffer [ptr + 1] = (byte)((uint)vvalue >> (8 - endbit));  	if (bits >= 16) {  		buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  		if (bits >= 24) {  			buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  			if (bits >= 32) {  				if (endbit > 0)  					buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  				else  					buffer [ptr + 4] = 0;  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 8) {  	buffer [ptr + 1] = (byte)((uint)vvalue >> (8 - endbit));  	if (bits >= 16) {  		buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  		if (bits >= 24) {  			buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  			if (bits >= 32) {  				if (endbit > 0)  					buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  				else  					buffer [ptr + 4] = 0;  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 8) {  	buffer [ptr + 1] = (byte)((uint)vvalue >> (8 - endbit));  	if (bits >= 16) {  		buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  		if (bits >= 24) {  			buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  			if (bits >= 32) {  				if (endbit > 0)  					buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  				else  					buffer [ptr + 4] = 0;  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 8) {  	buffer [ptr + 1] = (byte)((uint)vvalue >> (8 - endbit));  	if (bits >= 16) {  		buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  		if (bits >= 24) {  			buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  			if (bits >= 32) {  				if (endbit > 0)  					buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  				else  					buffer [ptr + 4] = 0;  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 8) {  	buffer [ptr + 1] = (byte)((uint)vvalue >> (8 - endbit));  	if (bits >= 16) {  		buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  		if (bits >= 24) {  			buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  			if (bits >= 32) {  				if (endbit > 0)  					buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  				else  					buffer [ptr + 4] = 0;  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: buffer [ptr + 1] = (byte)((uint)vvalue >> (8 - endbit));  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 16) {  	buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  	if (bits >= 24) {  		buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  		if (bits >= 32) {  			if (endbit > 0)  				buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  			else  				buffer [ptr + 4] = 0;  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 16) {  	buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  	if (bits >= 24) {  		buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  		if (bits >= 32) {  			if (endbit > 0)  				buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  			else  				buffer [ptr + 4] = 0;  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 16) {  	buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  	if (bits >= 24) {  		buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  		if (bits >= 32) {  			if (endbit > 0)  				buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  			else  				buffer [ptr + 4] = 0;  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 16) {  	buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  	if (bits >= 24) {  		buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  		if (bits >= 32) {  			if (endbit > 0)  				buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  			else  				buffer [ptr + 4] = 0;  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 16) {  	buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  	if (bits >= 24) {  		buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  		if (bits >= 32) {  			if (endbit > 0)  				buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  			else  				buffer [ptr + 4] = 0;  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 16) {  	buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  	if (bits >= 24) {  		buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  		if (bits >= 32) {  			if (endbit > 0)  				buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  			else  				buffer [ptr + 4] = 0;  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 16) {  	buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  	if (bits >= 24) {  		buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  		if (bits >= 32) {  			if (endbit > 0)  				buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  			else  				buffer [ptr + 4] = 0;  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 16) {  	buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  	if (bits >= 24) {  		buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  		if (bits >= 32) {  			if (endbit > 0)  				buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  			else  				buffer [ptr + 4] = 0;  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 16) {  	buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  	if (bits >= 24) {  		buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  		if (bits >= 32) {  			if (endbit > 0)  				buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  			else  				buffer [ptr + 4] = 0;  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 16) {  	buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  	if (bits >= 24) {  		buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  		if (bits >= 32) {  			if (endbit > 0)  				buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  			else  				buffer [ptr + 4] = 0;  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: buffer [ptr + 2] = (byte)((uint)vvalue >> (16 - endbit));  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 24) {  	buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  	if (bits >= 32) {  		if (endbit > 0)  			buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  		else  			buffer [ptr + 4] = 0;  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 24) {  	buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  	if (bits >= 32) {  		if (endbit > 0)  			buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  		else  			buffer [ptr + 4] = 0;  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 24) {  	buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  	if (bits >= 32) {  		if (endbit > 0)  			buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  		else  			buffer [ptr + 4] = 0;  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 24) {  	buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  	if (bits >= 32) {  		if (endbit > 0)  			buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  		else  			buffer [ptr + 4] = 0;  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 24) {  	buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  	if (bits >= 32) {  		if (endbit > 0)  			buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  		else  			buffer [ptr + 4] = 0;  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 24) {  	buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  	if (bits >= 32) {  		if (endbit > 0)  			buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  		else  			buffer [ptr + 4] = 0;  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 24) {  	buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  	if (bits >= 32) {  		if (endbit > 0)  			buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  		else  			buffer [ptr + 4] = 0;  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: buffer [ptr + 3] = (byte)((uint)vvalue >> (24 - endbit));  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 32) {  	if (endbit > 0)  		buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  	else  		buffer [ptr + 4] = 0;  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 32) {  	if (endbit > 0)  		buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  	else  		buffer [ptr + 4] = 0;  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 32) {  	if (endbit > 0)  		buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  	else  		buffer [ptr + 4] = 0;  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (bits >= 32) {  	if (endbit > 0)  		buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  	else  		buffer [ptr + 4] = 0;  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (endbit > 0)  	buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  else  	buffer [ptr + 4] = 0;  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (endbit > 0)  	buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  else  	buffer [ptr + 4] = 0;  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: if (endbit > 0)  	buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  else  	buffer [ptr + 4] = 0;  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: buffer [ptr + 4] = (byte)((uint)vvalue >> (32 - endbit));  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: buffer [ptr + 4] = 0;  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: endbyte += bits / 8;  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: ptr += bits / 8;  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,write,The following statement contains a magic number: endbit = bits & 7;  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (endbyte + 4 >= storage) {  	if (endbyte + (bits - 1) / 8 >= storage)  		return (-1);  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (endbyte + 4 >= storage) {  	if (endbyte + (bits - 1) / 8 >= storage)  		return (-1);  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (endbyte + (bits - 1) / 8 >= storage)  	return (-1);  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 16) {  	ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  	if (bits > 24) {  		ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  		if ((bits > 32) && (endbit != 0)) {  			ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 16) {  	ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  	if (bits > 24) {  		ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  		if ((bits > 32) && (endbit != 0)) {  			ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 16) {  	ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  	if (bits > 24) {  		ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  		if ((bits > 32) && (endbit != 0)) {  			ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 16) {  	ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  	if (bits > 24) {  		ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  		if ((bits > 32) && (endbit != 0)) {  			ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 16) {  	ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  	if (bits > 24) {  		ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  		if ((bits > 32) && (endbit != 0)) {  			ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 16) {  	ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  	if (bits > 24) {  		ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  		if ((bits > 32) && (endbit != 0)) {  			ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 16) {  	ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  	if (bits > 24) {  		ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  		if ((bits > 32) && (endbit != 0)) {  			ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 16) {  	ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  	if (bits > 24) {  		ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  		if ((bits > 32) && (endbit != 0)) {  			ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 16) {  	ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  	if (bits > 24) {  		ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  		if ((bits > 32) && (endbit != 0)) {  			ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 24) {  	ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  	if ((bits > 32) && (endbit != 0)) {  		ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 24) {  	ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  	if ((bits > 32) && (endbit != 0)) {  		ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 24) {  	ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  	if ((bits > 32) && (endbit != 0)) {  		ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 24) {  	ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  	if ((bits > 32) && (endbit != 0)) {  		ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 24) {  	ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  	if ((bits > 32) && (endbit != 0)) {  		ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if (bits > 24) {  	ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  	if ((bits > 32) && (endbit != 0)) {  		ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if ((bits > 32) && (endbit != 0)) {  	ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if ((bits > 32) && (endbit != 0)) {  	ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: if ((bits > 32) && (endbit != 0)) {  	ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,look,The following statement contains a magic number: ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,adv,The following statement contains a magic number: ptr += bits / 8;  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,adv,The following statement contains a magic number: endbyte += bits / 8;  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,adv,The following statement contains a magic number: endbit = bits & 7;  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,adv1,The following statement contains a magic number: if (endbit > 7) {  	endbit = 0;  	ptr++;  	endbyte++;  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (endbyte + 4 >= storage) {  	ret = -1;  	if (endbyte + (bits - 1) / 8 >= storage) {  		ptr += bits / 8;  		endbyte += bits / 8;  		endbit = bits & 7;  		return (ret);  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (endbyte + 4 >= storage) {  	ret = -1;  	if (endbyte + (bits - 1) / 8 >= storage) {  		ptr += bits / 8;  		endbyte += bits / 8;  		endbit = bits & 7;  		return (ret);  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (endbyte + 4 >= storage) {  	ret = -1;  	if (endbyte + (bits - 1) / 8 >= storage) {  		ptr += bits / 8;  		endbyte += bits / 8;  		endbit = bits & 7;  		return (ret);  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (endbyte + 4 >= storage) {  	ret = -1;  	if (endbyte + (bits - 1) / 8 >= storage) {  		ptr += bits / 8;  		endbyte += bits / 8;  		endbit = bits & 7;  		return (ret);  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (endbyte + 4 >= storage) {  	ret = -1;  	if (endbyte + (bits - 1) / 8 >= storage) {  		ptr += bits / 8;  		endbyte += bits / 8;  		endbit = bits & 7;  		return (ret);  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (endbyte + (bits - 1) / 8 >= storage) {  	ptr += bits / 8;  	endbyte += bits / 8;  	endbit = bits & 7;  	return (ret);  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (endbyte + (bits - 1) / 8 >= storage) {  	ptr += bits / 8;  	endbyte += bits / 8;  	endbit = bits & 7;  	return (ret);  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (endbyte + (bits - 1) / 8 >= storage) {  	ptr += bits / 8;  	endbyte += bits / 8;  	endbit = bits & 7;  	return (ret);  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (endbyte + (bits - 1) / 8 >= storage) {  	ptr += bits / 8;  	endbyte += bits / 8;  	endbit = bits & 7;  	return (ret);  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: ptr += bits / 8;  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: endbyte += bits / 8;  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: endbit = bits & 7;  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 8) {  	ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  	if (bits > 16) {  		ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  		if (bits > 24) {  			ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  			if ((bits > 32) && (endbit != 0)) {  				ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  			}  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: ret |= ((buffer [ptr + 1]) & 0xff) << (8 - endbit);  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 16) {  	ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  	if (bits > 24) {  		ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  		if ((bits > 32) && (endbit != 0)) {  			ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 16) {  	ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  	if (bits > 24) {  		ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  		if ((bits > 32) && (endbit != 0)) {  			ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 16) {  	ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  	if (bits > 24) {  		ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  		if ((bits > 32) && (endbit != 0)) {  			ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 16) {  	ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  	if (bits > 24) {  		ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  		if ((bits > 32) && (endbit != 0)) {  			ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 16) {  	ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  	if (bits > 24) {  		ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  		if ((bits > 32) && (endbit != 0)) {  			ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 16) {  	ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  	if (bits > 24) {  		ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  		if ((bits > 32) && (endbit != 0)) {  			ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 16) {  	ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  	if (bits > 24) {  		ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  		if ((bits > 32) && (endbit != 0)) {  			ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 16) {  	ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  	if (bits > 24) {  		ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  		if ((bits > 32) && (endbit != 0)) {  			ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 16) {  	ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  	if (bits > 24) {  		ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  		if ((bits > 32) && (endbit != 0)) {  			ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  		}  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: ret |= ((buffer [ptr + 2]) & 0xff) << (16 - endbit);  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 24) {  	ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  	if ((bits > 32) && (endbit != 0)) {  		ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 24) {  	ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  	if ((bits > 32) && (endbit != 0)) {  		ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 24) {  	ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  	if ((bits > 32) && (endbit != 0)) {  		ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 24) {  	ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  	if ((bits > 32) && (endbit != 0)) {  		ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 24) {  	ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  	if ((bits > 32) && (endbit != 0)) {  		ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if (bits > 24) {  	ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  	if ((bits > 32) && (endbit != 0)) {  		ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  	}  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: ret |= ((buffer [ptr + 3]) & 0xff) << (24 - endbit);  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if ((bits > 32) && (endbit != 0)) {  	ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if ((bits > 32) && (endbit != 0)) {  	ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: if ((bits > 32) && (endbit != 0)) {  	ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: ret |= ((buffer [ptr + 4]) & 0xff) << (32 - endbit);  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: ptr += bits / 8;  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: endbyte += bits / 8;  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read,The following statement contains a magic number: endbit = bits & 7;  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read1,The following statement contains a magic number: if (endbyte >= storage) {  	ret = -1;  	endbit++;  	if (endbit > 7) {  		endbit = 0;  		ptr++;  		endbyte++;  	}  	return (ret);  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read1,The following statement contains a magic number: if (endbit > 7) {  	endbit = 0;  	ptr++;  	endbyte++;  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,read1,The following statement contains a magic number: if (endbit > 7) {  	endbit = 0;  	ptr++;  	endbyte++;  }  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,bytes,The following statement contains a magic number: return (endbyte + (endbit + 7) / 8);  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,bytes,The following statement contains a magic number: return (endbyte + (endbit + 7) / 8);  
Magic Number,csogg,csBuffer,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Buffer.cs,bits,The following statement contains a magic number: return (endbyte * 8 + endbit);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,crc_entry,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	if ((r & 0x80000000) != 0) {  		r = (r << 1) ^ 0x04c11db7;  		/* The same as the ethernet generator 											polynomial' although we use an 											unreflected alg and an init/final 											of 0' not 0xffffffff */}  	else {  		r <<= 1;  	}  }  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,version,The following statement contains a magic number: return header_base [header + 4] & 0xff;  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,continued,The following statement contains a magic number: return (header_base [header + 5] & 0x01);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,bos,The following statement contains a magic number: return (header_base [header + 5] & 0x02);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,eos,The following statement contains a magic number: return (header_base [header + 5] & 0x04);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo << 8) | (uint)(header_base [header + 12] & 0xff);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo << 8) | (uint)(header_base [header + 12] & 0xff);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo << 8) | (uint)(header_base [header + 11] & 0xff);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo << 8) | (uint)(header_base [header + 11] & 0xff);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo << 8) | (uint)(header_base [header + 10] & 0xff);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo << 8) | (uint)(header_base [header + 10] & 0xff);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo << 8) | (uint)(header_base [header + 9] & 0xff);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo << 8) | (uint)(header_base [header + 9] & 0xff);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo << 8) | (uint)(header_base [header + 8] & 0xff);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo << 8) | (uint)(header_base [header + 8] & 0xff);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo << 8) | (uint)(header_base [header + 7] & 0xff);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo << 8) | (uint)(header_base [header + 7] & 0xff);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo << 8) | (uint)(header_base [header + 6] & 0xff);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,granulepos,The following statement contains a magic number: foo = (foo << 8) | (uint)(header_base [header + 6] & 0xff);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,serialno,The following statement contains a magic number: return (header_base [header + 14] & 0xff) | ((header_base [header + 15] & 0xff) << 8) | ((header_base [header + 16] & 0xff) << 16) | ((header_base [header + 17] & 0xff) << 24);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,serialno,The following statement contains a magic number: return (header_base [header + 14] & 0xff) | ((header_base [header + 15] & 0xff) << 8) | ((header_base [header + 16] & 0xff) << 16) | ((header_base [header + 17] & 0xff) << 24);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,serialno,The following statement contains a magic number: return (header_base [header + 14] & 0xff) | ((header_base [header + 15] & 0xff) << 8) | ((header_base [header + 16] & 0xff) << 16) | ((header_base [header + 17] & 0xff) << 24);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,serialno,The following statement contains a magic number: return (header_base [header + 14] & 0xff) | ((header_base [header + 15] & 0xff) << 8) | ((header_base [header + 16] & 0xff) << 16) | ((header_base [header + 17] & 0xff) << 24);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,serialno,The following statement contains a magic number: return (header_base [header + 14] & 0xff) | ((header_base [header + 15] & 0xff) << 8) | ((header_base [header + 16] & 0xff) << 16) | ((header_base [header + 17] & 0xff) << 24);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,serialno,The following statement contains a magic number: return (header_base [header + 14] & 0xff) | ((header_base [header + 15] & 0xff) << 8) | ((header_base [header + 16] & 0xff) << 16) | ((header_base [header + 17] & 0xff) << 24);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,serialno,The following statement contains a magic number: return (header_base [header + 14] & 0xff) | ((header_base [header + 15] & 0xff) << 8) | ((header_base [header + 16] & 0xff) << 16) | ((header_base [header + 17] & 0xff) << 24);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,pageno,The following statement contains a magic number: return (header_base [header + 18] & 0xff) | ((header_base [header + 19] & 0xff) << 8) | ((header_base [header + 20] & 0xff) << 16) | ((header_base [header + 21] & 0xff) << 24);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,pageno,The following statement contains a magic number: return (header_base [header + 18] & 0xff) | ((header_base [header + 19] & 0xff) << 8) | ((header_base [header + 20] & 0xff) << 16) | ((header_base [header + 21] & 0xff) << 24);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,pageno,The following statement contains a magic number: return (header_base [header + 18] & 0xff) | ((header_base [header + 19] & 0xff) << 8) | ((header_base [header + 20] & 0xff) << 16) | ((header_base [header + 21] & 0xff) << 24);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,pageno,The following statement contains a magic number: return (header_base [header + 18] & 0xff) | ((header_base [header + 19] & 0xff) << 8) | ((header_base [header + 20] & 0xff) << 16) | ((header_base [header + 21] & 0xff) << 24);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,pageno,The following statement contains a magic number: return (header_base [header + 18] & 0xff) | ((header_base [header + 19] & 0xff) << 8) | ((header_base [header + 20] & 0xff) << 16) | ((header_base [header + 21] & 0xff) << 24);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,pageno,The following statement contains a magic number: return (header_base [header + 18] & 0xff) | ((header_base [header + 19] & 0xff) << 8) | ((header_base [header + 20] & 0xff) << 16) | ((header_base [header + 21] & 0xff) << 24);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,pageno,The following statement contains a magic number: return (header_base [header + 18] & 0xff) | ((header_base [header + 19] & 0xff) << 8) | ((header_base [header + 20] & 0xff) << 16) | ((header_base [header + 21] & 0xff) << 24);  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,checksum,The following statement contains a magic number: for (int i = 0; i < header_len; i++) {  	a = header_base [header + i] & 0xffu;  	b = (crc_reg >> 24) & 0xff;  	crc_reg = (crc_reg << 8) ^ crc_lookup [a ^ b];  	//crc_reg = (crc_reg<<8)^(uint)(crc_lookup[((crc_reg >> 24)&0xff)^(header_base[header+i]&0xff)]);  }  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,checksum,The following statement contains a magic number: for (int i = 0; i < header_len; i++) {  	a = header_base [header + i] & 0xffu;  	b = (crc_reg >> 24) & 0xff;  	crc_reg = (crc_reg << 8) ^ crc_lookup [a ^ b];  	//crc_reg = (crc_reg<<8)^(uint)(crc_lookup[((crc_reg >> 24)&0xff)^(header_base[header+i]&0xff)]);  }  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,checksum,The following statement contains a magic number: b = (crc_reg >> 24) & 0xff;  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,checksum,The following statement contains a magic number: crc_reg = (crc_reg << 8) ^ crc_lookup [a ^ b];  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,checksum,The following statement contains a magic number: for (int i = 0; i < body_len; i++) {  	a = body_base [body + i] & 0xffu;  	b = (crc_reg >> 24) & 0xff;  	crc_reg = (crc_reg << 8) ^ crc_lookup [a ^ b];  	//crc_reg = (crc_reg<<8)^(uint)(crc_lookup[((crc_reg >> 24)&0xff)^(body_base[body+i]&0xff)]);  }  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,checksum,The following statement contains a magic number: for (int i = 0; i < body_len; i++) {  	a = body_base [body + i] & 0xffu;  	b = (crc_reg >> 24) & 0xff;  	crc_reg = (crc_reg << 8) ^ crc_lookup [a ^ b];  	//crc_reg = (crc_reg<<8)^(uint)(crc_lookup[((crc_reg >> 24)&0xff)^(body_base[body+i]&0xff)]);  }  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,checksum,The following statement contains a magic number: b = (crc_reg >> 24) & 0xff;  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,checksum,The following statement contains a magic number: crc_reg = (crc_reg << 8) ^ crc_lookup [a ^ b];  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,checksum,The following statement contains a magic number: header_base [header + 22] = (byte)crc_reg/*&0xff*/;  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,checksum,The following statement contains a magic number: header_base [header + 23] = (byte)(crc_reg >> 8)/*&0xff*/;  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,checksum,The following statement contains a magic number: header_base [header + 23] = (byte)(crc_reg >> 8)/*&0xff*/;  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,checksum,The following statement contains a magic number: header_base [header + 24] = (byte)(crc_reg >> 16)/*&0xff*/;  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,checksum,The following statement contains a magic number: header_base [header + 24] = (byte)(crc_reg >> 16)/*&0xff*/;  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,checksum,The following statement contains a magic number: header_base [header + 25] = (byte)(crc_reg >> 24)/*&0xff*/;  
Magic Number,csogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\Page.cs,checksum,The following statement contains a magic number: header_base [header + 25] = (byte)(crc_reg >> 24)/*&0xff*/;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,init,The following statement contains a magic number: body_storage = 16 * 1024;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,init,The following statement contains a magic number: body_storage = 16 * 1024;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,init,The following statement contains a magic number: lacing_storage = 1024;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,body_expand,The following statement contains a magic number: if (body_storage <= body_fill + needed) {  	body_storage += (needed + 1024);  	byte[] foo = new byte[body_storage];  	Array.Copy (body_data' 0' foo' 0' body_data.Length);  	body_data = foo;  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,body_expand,The following statement contains a magic number: body_storage += (needed + 1024);  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,lacing_expand,The following statement contains a magic number: if (lacing_storage <= lacing_fill + needed) {  	lacing_storage += (needed + 32);  	int[] foo = new int[lacing_storage];  	Array.Copy (lacing_vals' 0' foo' 0' lacing_vals.Length);  	lacing_vals = foo;  	long[] bar = new long[lacing_storage];  	Array.Copy (granule_vals' 0' bar' 0' granule_vals.Length);  	granule_vals = bar;  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,lacing_expand,The following statement contains a magic number: lacing_storage += (needed + 32);  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,packetin,The following statement contains a magic number: for (j = 0; j < lacing_val - 1; j++) {  	lacing_vals [lacing_fill + j] = 255;  	granule_vals [lacing_fill + j] = granulepos;  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,packetin,The following statement contains a magic number: lacing_vals [lacing_fill + j] = 255;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,packetin,The following statement contains a magic number: lacing_vals [lacing_fill + j] = (op.bytes) % 255;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,packetout,The following statement contains a magic number: while (size == 255) {  	int val = lacing_vals [++ptr];  	size = val & 0xff;  	if ((val & 0x200) != 0)  		op.e_o_s = 0x200;  	bytes += size;  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,pagein,The following statement contains a magic number: if (_pageno != pageno) {  	int i;  	// unroll previous partial packet (if any)  	for (i = lacing_packet; i < lacing_fill; i++) {  		body_fill -= lacing_vals [i] & 0xff;  		//System.out.println("??");  	}  	lacing_fill = lacing_packet;  	// make a note of dropped data in segment table  	if (pageno != -1) {  		lacing_vals [lacing_fill++] = 0x400;  		lacing_packet++;  	}  	// are we a 'continued packet' page?  If so' we'll need to skip  	// some segments  	if (continued != 0) {  		bos = 0;  		for (; segptr < segments; segptr++) {  			int val = (header_base [header + 27 + segptr] & 0xff);  			body += val;  			bodysize -= val;  			if (val < 255) {  				segptr++;  				break;  			}  		}  	}  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,pagein,The following statement contains a magic number: if (_pageno != pageno) {  	int i;  	// unroll previous partial packet (if any)  	for (i = lacing_packet; i < lacing_fill; i++) {  		body_fill -= lacing_vals [i] & 0xff;  		//System.out.println("??");  	}  	lacing_fill = lacing_packet;  	// make a note of dropped data in segment table  	if (pageno != -1) {  		lacing_vals [lacing_fill++] = 0x400;  		lacing_packet++;  	}  	// are we a 'continued packet' page?  If so' we'll need to skip  	// some segments  	if (continued != 0) {  		bos = 0;  		for (; segptr < segments; segptr++) {  			int val = (header_base [header + 27 + segptr] & 0xff);  			body += val;  			bodysize -= val;  			if (val < 255) {  				segptr++;  				break;  			}  		}  	}  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,pagein,The following statement contains a magic number: if (continued != 0) {  	bos = 0;  	for (; segptr < segments; segptr++) {  		int val = (header_base [header + 27 + segptr] & 0xff);  		body += val;  		bodysize -= val;  		if (val < 255) {  			segptr++;  			break;  		}  	}  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,pagein,The following statement contains a magic number: if (continued != 0) {  	bos = 0;  	for (; segptr < segments; segptr++) {  		int val = (header_base [header + 27 + segptr] & 0xff);  		body += val;  		bodysize -= val;  		if (val < 255) {  			segptr++;  			break;  		}  	}  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,pagein,The following statement contains a magic number: for (; segptr < segments; segptr++) {  	int val = (header_base [header + 27 + segptr] & 0xff);  	body += val;  	bodysize -= val;  	if (val < 255) {  		segptr++;  		break;  	}  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,pagein,The following statement contains a magic number: for (; segptr < segments; segptr++) {  	int val = (header_base [header + 27 + segptr] & 0xff);  	body += val;  	bodysize -= val;  	if (val < 255) {  		segptr++;  		break;  	}  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,pagein,The following statement contains a magic number: if (val < 255) {  	segptr++;  	break;  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,pagein,The following statement contains a magic number: while (segptr < segments) {  	int val = (header_base [header + 27 + segptr] & 0xff);  	lacing_vals [lacing_fill] = val;  	granule_vals [lacing_fill] = -1;  	if (bos != 0) {  		lacing_vals [lacing_fill] |= 0x100;  		bos = 0;  	}  	if (val < 255)  		saved = lacing_fill;  	lacing_fill++;  	segptr++;  	if (val < 255)  		lacing_packet = lacing_fill;  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,pagein,The following statement contains a magic number: while (segptr < segments) {  	int val = (header_base [header + 27 + segptr] & 0xff);  	lacing_vals [lacing_fill] = val;  	granule_vals [lacing_fill] = -1;  	if (bos != 0) {  		lacing_vals [lacing_fill] |= 0x100;  		bos = 0;  	}  	if (val < 255)  		saved = lacing_fill;  	lacing_fill++;  	segptr++;  	if (val < 255)  		lacing_packet = lacing_fill;  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,pagein,The following statement contains a magic number: while (segptr < segments) {  	int val = (header_base [header + 27 + segptr] & 0xff);  	lacing_vals [lacing_fill] = val;  	granule_vals [lacing_fill] = -1;  	if (bos != 0) {  		lacing_vals [lacing_fill] |= 0x100;  		bos = 0;  	}  	if (val < 255)  		saved = lacing_fill;  	lacing_fill++;  	segptr++;  	if (val < 255)  		lacing_packet = lacing_fill;  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,pagein,The following statement contains a magic number: if (val < 255)  	saved = lacing_fill;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,pagein,The following statement contains a magic number: if (val < 255)  	lacing_packet = lacing_fill;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: if (b_o_s == 0) {  	/* 'initial header page' case */granule_pos = 0;  	for (vals = 0; vals < maxvals; vals++) {  		if ((lacing_vals [vals] & 0x0ff) < 255) {  			vals++;  			break;  		}  	}  }  else {  	for (vals = 0; vals < maxvals; vals++) {  		if (acc > 4096)  			break;  		acc += (lacing_vals [vals] & 0x0ff);  		granule_pos = granule_vals [vals];  	}  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: if (b_o_s == 0) {  	/* 'initial header page' case */granule_pos = 0;  	for (vals = 0; vals < maxvals; vals++) {  		if ((lacing_vals [vals] & 0x0ff) < 255) {  			vals++;  			break;  		}  	}  }  else {  	for (vals = 0; vals < maxvals; vals++) {  		if (acc > 4096)  			break;  		acc += (lacing_vals [vals] & 0x0ff);  		granule_pos = granule_vals [vals];  	}  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: for (vals = 0; vals < maxvals; vals++) {  	if ((lacing_vals [vals] & 0x0ff) < 255) {  		vals++;  		break;  	}  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: if ((lacing_vals [vals] & 0x0ff) < 255) {  	vals++;  	break;  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: for (vals = 0; vals < maxvals; vals++) {  	if (acc > 4096)  		break;  	acc += (lacing_vals [vals] & 0x0ff);  	granule_pos = granule_vals [vals];  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: if (acc > 4096)  	break;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: header [4] = 0x00;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: header [5] = 0x00;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: if ((lacing_vals [0] & 0x100) == 0)  	header [5] |= 0x01;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: header [5] |= 0x01;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: if (b_o_s == 0)  	header [5] |= 0x02;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: header [5] |= 0x02;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: if (e_o_s != 0 && lacing_fill == vals)  	header [5] |= 0x04;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: header [5] |= 0x04;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: for (i = 6; i < 14; i++) {  	header [i] = (byte)granule_pos;  	granule_pos >>= 8;  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: for (i = 6; i < 14; i++) {  	header [i] = (byte)granule_pos;  	granule_pos >>= 8;  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: for (i = 6; i < 14; i++) {  	header [i] = (byte)granule_pos;  	granule_pos >>= 8;  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: i = 6
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: granule_pos >>= 8;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: for (i = 14; i < 18; i++) {  	header [i] = (byte)_serialno;  	_serialno >>= 8;  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: for (i = 14; i < 18; i++) {  	header [i] = (byte)_serialno;  	_serialno >>= 8;  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: for (i = 14; i < 18; i++) {  	header [i] = (byte)_serialno;  	_serialno >>= 8;  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: i = 14
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: _serialno >>= 8;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: for (i = 18; i < 22; i++) {  	header [i] = (byte)_pageno;  	_pageno >>= 8;  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: for (i = 18; i < 22; i++) {  	header [i] = (byte)_pageno;  	_pageno >>= 8;  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: for (i = 18; i < 22; i++) {  	header [i] = (byte)_pageno;  	_pageno >>= 8;  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: i = 18
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: _pageno >>= 8;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: header [22] = 0;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: header [23] = 0;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: header [24] = 0;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: header [25] = 0;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: header [26] = (byte)vals;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: for (i = 0; i < vals; i++) {  	header [i + 27] = (byte)lacing_vals [i];  	bytes += (header [i + 27] & 0xff);  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: for (i = 0; i < vals; i++) {  	header [i + 27] = (byte)lacing_vals [i];  	bytes += (header [i + 27] & 0xff);  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: header [i + 27] = (byte)lacing_vals [i];  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: bytes += (header [i + 27] & 0xff);  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: og.header_len = header_fill = vals + 27;  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: Array.Copy (lacing_vals' vals' lacing_vals' 0' lacing_fill * 4);  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,flush,The following statement contains a magic number: Array.Copy (granule_vals' vals' granule_vals' 0' lacing_fill * 8);  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,pageout,The following statement contains a magic number: if ((e_o_s != 0 && lacing_fill != 0) || /* 'were done' now flush' case */body_fill - body_returned > 4096 || /* 'page nominal size' case */lacing_fill >= 255 || /* 'segment table full' case */(lacing_fill != 0 && b_o_s == 0)) {  	/* 'initial header page' case */return flush (og);  }  
Magic Number,csogg,StreamState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\StreamState.cs,pageout,The following statement contains a magic number: if ((e_o_s != 0 && lacing_fill != 0) || /* 'were done' now flush' case */body_fill - body_returned > 4096 || /* 'page nominal size' case */lacing_fill >= 255 || /* 'segment table full' case */(lacing_fill != 0 && b_o_s == 0)) {  	/* 'initial header page' case */return flush (og);  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,buffer,The following statement contains a magic number: if (size > storage - fill) {  	// We need to extend the internal buffer  	int newsize = size + fill + 4096;  	// an extra page to be nice  	if (data != null) {  		byte[] foo = new byte[newsize];  		Array.Copy (data' 0' foo' 0' data.Length);  		data = foo;  	}  	else {  		data = new byte[newsize];  	}  	storage = newsize;  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if (headerbytes == 0) {  	int _headerbytes' i;  	if (bytes < 27)  		return (0);  	// not enough for a header  	/* verify capture pattern *///!!!!!!!!!!!  	if (data [page] != 'O' || data [page + 1] != 'g' || data [page + 2] != 'g' || data [page + 3] != 'S') {  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  	_headerbytes = (data [page + 26] & 0xff) + 27;  	if (bytes < _headerbytes)  		return (0);  	// not enough for header + seg table  	// count up body length in the segment table  	for (i = 0; i < (data [page + 26] & 0xff); i++) {  		bodybytes += (data [page + 27 + i] & 0xff);  	}  	headerbytes = _headerbytes;  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if (headerbytes == 0) {  	int _headerbytes' i;  	if (bytes < 27)  		return (0);  	// not enough for a header  	/* verify capture pattern *///!!!!!!!!!!!  	if (data [page] != 'O' || data [page + 1] != 'g' || data [page + 2] != 'g' || data [page + 3] != 'S') {  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  	_headerbytes = (data [page + 26] & 0xff) + 27;  	if (bytes < _headerbytes)  		return (0);  	// not enough for header + seg table  	// count up body length in the segment table  	for (i = 0; i < (data [page + 26] & 0xff); i++) {  		bodybytes += (data [page + 27 + i] & 0xff);  	}  	headerbytes = _headerbytes;  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if (headerbytes == 0) {  	int _headerbytes' i;  	if (bytes < 27)  		return (0);  	// not enough for a header  	/* verify capture pattern *///!!!!!!!!!!!  	if (data [page] != 'O' || data [page + 1] != 'g' || data [page + 2] != 'g' || data [page + 3] != 'S') {  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  	_headerbytes = (data [page + 26] & 0xff) + 27;  	if (bytes < _headerbytes)  		return (0);  	// not enough for header + seg table  	// count up body length in the segment table  	for (i = 0; i < (data [page + 26] & 0xff); i++) {  		bodybytes += (data [page + 27 + i] & 0xff);  	}  	headerbytes = _headerbytes;  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if (headerbytes == 0) {  	int _headerbytes' i;  	if (bytes < 27)  		return (0);  	// not enough for a header  	/* verify capture pattern *///!!!!!!!!!!!  	if (data [page] != 'O' || data [page + 1] != 'g' || data [page + 2] != 'g' || data [page + 3] != 'S') {  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  	_headerbytes = (data [page + 26] & 0xff) + 27;  	if (bytes < _headerbytes)  		return (0);  	// not enough for header + seg table  	// count up body length in the segment table  	for (i = 0; i < (data [page + 26] & 0xff); i++) {  		bodybytes += (data [page + 27 + i] & 0xff);  	}  	headerbytes = _headerbytes;  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if (headerbytes == 0) {  	int _headerbytes' i;  	if (bytes < 27)  		return (0);  	// not enough for a header  	/* verify capture pattern *///!!!!!!!!!!!  	if (data [page] != 'O' || data [page + 1] != 'g' || data [page + 2] != 'g' || data [page + 3] != 'S') {  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  	_headerbytes = (data [page + 26] & 0xff) + 27;  	if (bytes < _headerbytes)  		return (0);  	// not enough for header + seg table  	// count up body length in the segment table  	for (i = 0; i < (data [page + 26] & 0xff); i++) {  		bodybytes += (data [page + 27 + i] & 0xff);  	}  	headerbytes = _headerbytes;  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if (headerbytes == 0) {  	int _headerbytes' i;  	if (bytes < 27)  		return (0);  	// not enough for a header  	/* verify capture pattern *///!!!!!!!!!!!  	if (data [page] != 'O' || data [page + 1] != 'g' || data [page + 2] != 'g' || data [page + 3] != 'S') {  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  	_headerbytes = (data [page + 26] & 0xff) + 27;  	if (bytes < _headerbytes)  		return (0);  	// not enough for header + seg table  	// count up body length in the segment table  	for (i = 0; i < (data [page + 26] & 0xff); i++) {  		bodybytes += (data [page + 27 + i] & 0xff);  	}  	headerbytes = _headerbytes;  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if (headerbytes == 0) {  	int _headerbytes' i;  	if (bytes < 27)  		return (0);  	// not enough for a header  	/* verify capture pattern *///!!!!!!!!!!!  	if (data [page] != 'O' || data [page + 1] != 'g' || data [page + 2] != 'g' || data [page + 3] != 'S') {  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  	_headerbytes = (data [page + 26] & 0xff) + 27;  	if (bytes < _headerbytes)  		return (0);  	// not enough for header + seg table  	// count up body length in the segment table  	for (i = 0; i < (data [page + 26] & 0xff); i++) {  		bodybytes += (data [page + 27 + i] & 0xff);  	}  	headerbytes = _headerbytes;  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if (bytes < 27)  	return (0);  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if (data [page] != 'O' || data [page + 1] != 'g' || data [page + 2] != 'g' || data [page + 3] != 'S') {  	headerbytes = 0;  	bodybytes = 0;  	// search for possible capture  	next = 0;  	for (int ii = 0; ii < bytes - 1; ii++) {  		if (data [page + 1 + ii] == 'O') {  			next = page + 1 + ii;  			break;  		}  	}  	//next=memchr(page+1''O''bytes-1);  	if (next == 0)  		next = fill;  	returned = next;  	return (-(next - page));  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if (data [page] != 'O' || data [page + 1] != 'g' || data [page + 2] != 'g' || data [page + 3] != 'S') {  	headerbytes = 0;  	bodybytes = 0;  	// search for possible capture  	next = 0;  	for (int ii = 0; ii < bytes - 1; ii++) {  		if (data [page + 1 + ii] == 'O') {  			next = page + 1 + ii;  			break;  		}  	}  	//next=memchr(page+1''O''bytes-1);  	if (next == 0)  		next = fill;  	returned = next;  	return (-(next - page));  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: _headerbytes = (data [page + 26] & 0xff) + 27;  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: _headerbytes = (data [page + 26] & 0xff) + 27;  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: for (i = 0; i < (data [page + 26] & 0xff); i++) {  	bodybytes += (data [page + 27 + i] & 0xff);  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: for (i = 0; i < (data [page + 26] & 0xff); i++) {  	bodybytes += (data [page + 27 + i] & 0xff);  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: bodybytes += (data [page + 27 + i] & 0xff);  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock (chksum) {  	// Grab the checksum bytes' set the header field to zero  	Array.Copy (data' page + 22' chksum' 0' 4);  	data [page + 22] = 0;  	data [page + 23] = 0;  	data [page + 24] = 0;  	data [page + 25] = 0;  	// set up a temp page struct and recompute the checksum  	Page log = pageseek_p;  	log.header_base = data;  	log.header = page;  	log.header_len = headerbytes;  	log.body_base = data;  	log.body = page + headerbytes;  	log.body_len = bodybytes;  	log.checksum ();  	// Compare  	if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  		// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  		// replace the computed checksum with the one actually read in  		Array.Copy (chksum' 0' data' page + 22' 4);  		// Bad checksum. Lose sync */  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock (chksum) {  	// Grab the checksum bytes' set the header field to zero  	Array.Copy (data' page + 22' chksum' 0' 4);  	data [page + 22] = 0;  	data [page + 23] = 0;  	data [page + 24] = 0;  	data [page + 25] = 0;  	// set up a temp page struct and recompute the checksum  	Page log = pageseek_p;  	log.header_base = data;  	log.header = page;  	log.header_len = headerbytes;  	log.body_base = data;  	log.body = page + headerbytes;  	log.body_len = bodybytes;  	log.checksum ();  	// Compare  	if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  		// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  		// replace the computed checksum with the one actually read in  		Array.Copy (chksum' 0' data' page + 22' 4);  		// Bad checksum. Lose sync */  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock (chksum) {  	// Grab the checksum bytes' set the header field to zero  	Array.Copy (data' page + 22' chksum' 0' 4);  	data [page + 22] = 0;  	data [page + 23] = 0;  	data [page + 24] = 0;  	data [page + 25] = 0;  	// set up a temp page struct and recompute the checksum  	Page log = pageseek_p;  	log.header_base = data;  	log.header = page;  	log.header_len = headerbytes;  	log.body_base = data;  	log.body = page + headerbytes;  	log.body_len = bodybytes;  	log.checksum ();  	// Compare  	if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  		// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  		// replace the computed checksum with the one actually read in  		Array.Copy (chksum' 0' data' page + 22' 4);  		// Bad checksum. Lose sync */  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock (chksum) {  	// Grab the checksum bytes' set the header field to zero  	Array.Copy (data' page + 22' chksum' 0' 4);  	data [page + 22] = 0;  	data [page + 23] = 0;  	data [page + 24] = 0;  	data [page + 25] = 0;  	// set up a temp page struct and recompute the checksum  	Page log = pageseek_p;  	log.header_base = data;  	log.header = page;  	log.header_len = headerbytes;  	log.body_base = data;  	log.body = page + headerbytes;  	log.body_len = bodybytes;  	log.checksum ();  	// Compare  	if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  		// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  		// replace the computed checksum with the one actually read in  		Array.Copy (chksum' 0' data' page + 22' 4);  		// Bad checksum. Lose sync */  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock (chksum) {  	// Grab the checksum bytes' set the header field to zero  	Array.Copy (data' page + 22' chksum' 0' 4);  	data [page + 22] = 0;  	data [page + 23] = 0;  	data [page + 24] = 0;  	data [page + 25] = 0;  	// set up a temp page struct and recompute the checksum  	Page log = pageseek_p;  	log.header_base = data;  	log.header = page;  	log.header_len = headerbytes;  	log.body_base = data;  	log.body = page + headerbytes;  	log.body_len = bodybytes;  	log.checksum ();  	// Compare  	if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  		// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  		// replace the computed checksum with the one actually read in  		Array.Copy (chksum' 0' data' page + 22' 4);  		// Bad checksum. Lose sync */  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock (chksum) {  	// Grab the checksum bytes' set the header field to zero  	Array.Copy (data' page + 22' chksum' 0' 4);  	data [page + 22] = 0;  	data [page + 23] = 0;  	data [page + 24] = 0;  	data [page + 25] = 0;  	// set up a temp page struct and recompute the checksum  	Page log = pageseek_p;  	log.header_base = data;  	log.header = page;  	log.header_len = headerbytes;  	log.body_base = data;  	log.body = page + headerbytes;  	log.body_len = bodybytes;  	log.checksum ();  	// Compare  	if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  		// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  		// replace the computed checksum with the one actually read in  		Array.Copy (chksum' 0' data' page + 22' 4);  		// Bad checksum. Lose sync */  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock (chksum) {  	// Grab the checksum bytes' set the header field to zero  	Array.Copy (data' page + 22' chksum' 0' 4);  	data [page + 22] = 0;  	data [page + 23] = 0;  	data [page + 24] = 0;  	data [page + 25] = 0;  	// set up a temp page struct and recompute the checksum  	Page log = pageseek_p;  	log.header_base = data;  	log.header = page;  	log.header_len = headerbytes;  	log.body_base = data;  	log.body = page + headerbytes;  	log.body_len = bodybytes;  	log.checksum ();  	// Compare  	if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  		// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  		// replace the computed checksum with the one actually read in  		Array.Copy (chksum' 0' data' page + 22' 4);  		// Bad checksum. Lose sync */  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock (chksum) {  	// Grab the checksum bytes' set the header field to zero  	Array.Copy (data' page + 22' chksum' 0' 4);  	data [page + 22] = 0;  	data [page + 23] = 0;  	data [page + 24] = 0;  	data [page + 25] = 0;  	// set up a temp page struct and recompute the checksum  	Page log = pageseek_p;  	log.header_base = data;  	log.header = page;  	log.header_len = headerbytes;  	log.body_base = data;  	log.body = page + headerbytes;  	log.body_len = bodybytes;  	log.checksum ();  	// Compare  	if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  		// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  		// replace the computed checksum with the one actually read in  		Array.Copy (chksum' 0' data' page + 22' 4);  		// Bad checksum. Lose sync */  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock (chksum) {  	// Grab the checksum bytes' set the header field to zero  	Array.Copy (data' page + 22' chksum' 0' 4);  	data [page + 22] = 0;  	data [page + 23] = 0;  	data [page + 24] = 0;  	data [page + 25] = 0;  	// set up a temp page struct and recompute the checksum  	Page log = pageseek_p;  	log.header_base = data;  	log.header = page;  	log.header_len = headerbytes;  	log.body_base = data;  	log.body = page + headerbytes;  	log.body_len = bodybytes;  	log.checksum ();  	// Compare  	if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  		// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  		// replace the computed checksum with the one actually read in  		Array.Copy (chksum' 0' data' page + 22' 4);  		// Bad checksum. Lose sync */  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock (chksum) {  	// Grab the checksum bytes' set the header field to zero  	Array.Copy (data' page + 22' chksum' 0' 4);  	data [page + 22] = 0;  	data [page + 23] = 0;  	data [page + 24] = 0;  	data [page + 25] = 0;  	// set up a temp page struct and recompute the checksum  	Page log = pageseek_p;  	log.header_base = data;  	log.header = page;  	log.header_len = headerbytes;  	log.body_base = data;  	log.body = page + headerbytes;  	log.body_len = bodybytes;  	log.checksum ();  	// Compare  	if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  		// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  		// replace the computed checksum with the one actually read in  		Array.Copy (chksum' 0' data' page + 22' 4);  		// Bad checksum. Lose sync */  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock (chksum) {  	// Grab the checksum bytes' set the header field to zero  	Array.Copy (data' page + 22' chksum' 0' 4);  	data [page + 22] = 0;  	data [page + 23] = 0;  	data [page + 24] = 0;  	data [page + 25] = 0;  	// set up a temp page struct and recompute the checksum  	Page log = pageseek_p;  	log.header_base = data;  	log.header = page;  	log.header_len = headerbytes;  	log.body_base = data;  	log.body = page + headerbytes;  	log.body_len = bodybytes;  	log.checksum ();  	// Compare  	if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  		// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  		// replace the computed checksum with the one actually read in  		Array.Copy (chksum' 0' data' page + 22' 4);  		// Bad checksum. Lose sync */  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock (chksum) {  	// Grab the checksum bytes' set the header field to zero  	Array.Copy (data' page + 22' chksum' 0' 4);  	data [page + 22] = 0;  	data [page + 23] = 0;  	data [page + 24] = 0;  	data [page + 25] = 0;  	// set up a temp page struct and recompute the checksum  	Page log = pageseek_p;  	log.header_base = data;  	log.header = page;  	log.header_len = headerbytes;  	log.body_base = data;  	log.body = page + headerbytes;  	log.body_len = bodybytes;  	log.checksum ();  	// Compare  	if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  		// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  		// replace the computed checksum with the one actually read in  		Array.Copy (chksum' 0' data' page + 22' 4);  		// Bad checksum. Lose sync */  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock (chksum) {  	// Grab the checksum bytes' set the header field to zero  	Array.Copy (data' page + 22' chksum' 0' 4);  	data [page + 22] = 0;  	data [page + 23] = 0;  	data [page + 24] = 0;  	data [page + 25] = 0;  	// set up a temp page struct and recompute the checksum  	Page log = pageseek_p;  	log.header_base = data;  	log.header = page;  	log.header_len = headerbytes;  	log.body_base = data;  	log.body = page + headerbytes;  	log.body_len = bodybytes;  	log.checksum ();  	// Compare  	if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  		// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  		// replace the computed checksum with the one actually read in  		Array.Copy (chksum' 0' data' page + 22' 4);  		// Bad checksum. Lose sync */  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: lock (chksum) {  	// Grab the checksum bytes' set the header field to zero  	Array.Copy (data' page + 22' chksum' 0' 4);  	data [page + 22] = 0;  	data [page + 23] = 0;  	data [page + 24] = 0;  	data [page + 25] = 0;  	// set up a temp page struct and recompute the checksum  	Page log = pageseek_p;  	log.header_base = data;  	log.header = page;  	log.header_len = headerbytes;  	log.body_base = data;  	log.body = page + headerbytes;  	log.body_len = bodybytes;  	log.checksum ();  	// Compare  	if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  		// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  		// replace the computed checksum with the one actually read in  		Array.Copy (chksum' 0' data' page + 22' 4);  		// Bad checksum. Lose sync */  		headerbytes = 0;  		bodybytes = 0;  		// search for possible capture  		next = 0;  		for (int ii = 0; ii < bytes - 1; ii++) {  			if (data [page + 1 + ii] == 'O') {  				next = page + 1 + ii;  				break;  			}  		}  		//next=memchr(page+1''O''bytes-1);  		if (next == 0)  			next = fill;  		returned = next;  		return (-(next - page));  	}  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: Array.Copy (data' page + 22' chksum' 0' 4);  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: Array.Copy (data' page + 22' chksum' 0' 4);  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: data [page + 22] = 0;  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: data [page + 23] = 0;  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: data [page + 24] = 0;  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: data [page + 25] = 0;  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  	// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  	// replace the computed checksum with the one actually read in  	Array.Copy (chksum' 0' data' page + 22' 4);  	// Bad checksum. Lose sync */  	headerbytes = 0;  	bodybytes = 0;  	// search for possible capture  	next = 0;  	for (int ii = 0; ii < bytes - 1; ii++) {  		if (data [page + 1 + ii] == 'O') {  			next = page + 1 + ii;  			break;  		}  	}  	//next=memchr(page+1''O''bytes-1);  	if (next == 0)  		next = fill;  	returned = next;  	return (-(next - page));  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  	// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  	// replace the computed checksum with the one actually read in  	Array.Copy (chksum' 0' data' page + 22' 4);  	// Bad checksum. Lose sync */  	headerbytes = 0;  	bodybytes = 0;  	// search for possible capture  	next = 0;  	for (int ii = 0; ii < bytes - 1; ii++) {  		if (data [page + 1 + ii] == 'O') {  			next = page + 1 + ii;  			break;  		}  	}  	//next=memchr(page+1''O''bytes-1);  	if (next == 0)  		next = fill;  	returned = next;  	return (-(next - page));  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  	// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  	// replace the computed checksum with the one actually read in  	Array.Copy (chksum' 0' data' page + 22' 4);  	// Bad checksum. Lose sync */  	headerbytes = 0;  	bodybytes = 0;  	// search for possible capture  	next = 0;  	for (int ii = 0; ii < bytes - 1; ii++) {  		if (data [page + 1 + ii] == 'O') {  			next = page + 1 + ii;  			break;  		}  	}  	//next=memchr(page+1''O''bytes-1);  	if (next == 0)  		next = fill;  	returned = next;  	return (-(next - page));  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  	// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  	// replace the computed checksum with the one actually read in  	Array.Copy (chksum' 0' data' page + 22' 4);  	// Bad checksum. Lose sync */  	headerbytes = 0;  	bodybytes = 0;  	// search for possible capture  	next = 0;  	for (int ii = 0; ii < bytes - 1; ii++) {  		if (data [page + 1 + ii] == 'O') {  			next = page + 1 + ii;  			break;  		}  	}  	//next=memchr(page+1''O''bytes-1);  	if (next == 0)  		next = fill;  	returned = next;  	return (-(next - page));  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  	// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  	// replace the computed checksum with the one actually read in  	Array.Copy (chksum' 0' data' page + 22' 4);  	// Bad checksum. Lose sync */  	headerbytes = 0;  	bodybytes = 0;  	// search for possible capture  	next = 0;  	for (int ii = 0; ii < bytes - 1; ii++) {  		if (data [page + 1 + ii] == 'O') {  			next = page + 1 + ii;  			break;  		}  	}  	//next=memchr(page+1''O''bytes-1);  	if (next == 0)  		next = fill;  	returned = next;  	return (-(next - page));  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  	// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  	// replace the computed checksum with the one actually read in  	Array.Copy (chksum' 0' data' page + 22' 4);  	// Bad checksum. Lose sync */  	headerbytes = 0;  	bodybytes = 0;  	// search for possible capture  	next = 0;  	for (int ii = 0; ii < bytes - 1; ii++) {  		if (data [page + 1 + ii] == 'O') {  			next = page + 1 + ii;  			break;  		}  	}  	//next=memchr(page+1''O''bytes-1);  	if (next == 0)  		next = fill;  	returned = next;  	return (-(next - page));  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  	// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  	// replace the computed checksum with the one actually read in  	Array.Copy (chksum' 0' data' page + 22' 4);  	// Bad checksum. Lose sync */  	headerbytes = 0;  	bodybytes = 0;  	// search for possible capture  	next = 0;  	for (int ii = 0; ii < bytes - 1; ii++) {  		if (data [page + 1 + ii] == 'O') {  			next = page + 1 + ii;  			break;  		}  	}  	//next=memchr(page+1''O''bytes-1);  	if (next == 0)  		next = fill;  	returned = next;  	return (-(next - page));  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: if (chksum [0] != data [page + 22] || chksum [1] != data [page + 23] || chksum [2] != data [page + 24] || chksum [3] != data [page + 25]) {  	// D'oh.  Mismatch! Corrupt page (or miscapture and not a page at all)  	// replace the computed checksum with the one actually read in  	Array.Copy (chksum' 0' data' page + 22' 4);  	// Bad checksum. Lose sync */  	headerbytes = 0;  	bodybytes = 0;  	// search for possible capture  	next = 0;  	for (int ii = 0; ii < bytes - 1; ii++) {  		if (data [page + 1 + ii] == 'O') {  			next = page + 1 + ii;  			break;  		}  	}  	//next=memchr(page+1''O''bytes-1);  	if (next == 0)  		next = fill;  	returned = next;  	return (-(next - page));  }  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: Array.Copy (chksum' 0' data' page + 22' 4);  
Magic Number,csogg,SyncState,C:\repos\secred_Tachycardia\src\Sound\Audio\csogg\SyncState.cs,pageseek,The following statement contains a magic number: Array.Copy (chksum' 0' data' page + 22' 4);  
Magic Number,csvorbis,Block,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Block.cs,synthesis,The following statement contains a magic number: sequence = op.packetno - 3;  
Magic Number,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,decodev_add,The following statement contains a magic number: if (dim > 8) {  	for (i = 0; i < n;) {  		entry = decode (b);  		if (entry == -1)  			return (-1);  		t = entry * dim;  		for (j = 0; j < dim;) {  			a [offset + (i++)] += valuelist [t + (j++)];  		}  	}  }  else {  	for (i = 0; i < n;) {  		entry = decode (b);  		if (entry == -1)  			return (-1);  		t = entry * dim;  		j = 0;  		for (k = 0; k < dim; k++) {  			a [offset + (i++)] += valuelist [t + (j++)];  		}  	}  }  
Magic Number,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,best,The following statement contains a magic number: if (nt != null) {  	// optimized using the decision tree  	while (true) {  		double cc = 0.0;  		int p = nt.p [ptr];  		int q = nt.q [ptr];  		for (int k = 0' o = 0; k < dim; k++' o += step) {  			cc += (valuelist [p + k] - valuelist [q + k]) * (a [o] - (valuelist [p + k] + valuelist [q + k]) * .5);  		}  		if (cc > 0.0) {  			// in A  			ptr = -nt.ptr0 [ptr];  		}  		else {  			// in B  			ptr = -nt.ptr1 [ptr];  		}  		if (ptr <= 0)  			break;  	}  	return (-ptr);  }  
Magic Number,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,best,The following statement contains a magic number: while (true) {  	double cc = 0.0;  	int p = nt.p [ptr];  	int q = nt.q [ptr];  	for (int k = 0' o = 0; k < dim; k++' o += step) {  		cc += (valuelist [p + k] - valuelist [q + k]) * (a [o] - (valuelist [p + k] + valuelist [q + k]) * .5);  	}  	if (cc > 0.0) {  		// in A  		ptr = -nt.ptr0 [ptr];  	}  	else {  		// in B  		ptr = -nt.ptr1 [ptr];  	}  	if (ptr <= 0)  		break;  }  
Magic Number,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,best,The following statement contains a magic number: for (int k = 0' o = 0; k < dim; k++' o += step) {  	cc += (valuelist [p + k] - valuelist [q + k]) * (a [o] - (valuelist [p + k] + valuelist [q + k]) * .5);  }  
Magic Number,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,best,The following statement contains a magic number: cc += (valuelist [p + k] - valuelist [q + k]) * (a [o] - (valuelist [p + k] + valuelist [q + k]) * .5);  
Magic Number,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,make_words,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int length = l [i];  	if (length > 0) {  		int entry = marker [length];  		// when we claim a node for an entry' we also claim the nodes  		// below it (pruning off the imagined tree that may have dangled  		// from it) as well as blocking the use of any nodes directly  		// above for leaves  		// update ourself  		if (length < 32 && ((uint)entry >> length) != 0) {  			// error condition; the lengths must specify an overpopulated tree  			//free(r);  			return (null);  		}  		r [i] = entry;  		// Look to see if the next shorter marker points to the node  		// above. if so' update it and repeat.  		{  			for (int j = length; j > 0; j--) {  				if ((marker [j] & 1) != 0) {  					// have to jump branches  					if (j == 1)  						marker [1]++;  					else  						marker [j] = marker [j - 1] << 1;  					break;  					// invariant says next upper marker would already  					// have been moved if it was on the same path  				}  				marker [j]++;  			}  		// prune the tree; the implicit invariant says all the longer  		// markers were dangling from our just-taken node.  Dangle them  		// from our *new* node.  		}  		for (int j = length + 1; j < 33; j++) {  			if (((uint)marker [j] >> 1) == entry) {  				entry = marker [j];  				marker [j] = marker [j - 1] << 1;  			}  			else {  				break;  			}  		}  	}  }  
Magic Number,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,make_words,The following statement contains a magic number: for (int i = 0; i < n; i++) {  	int length = l [i];  	if (length > 0) {  		int entry = marker [length];  		// when we claim a node for an entry' we also claim the nodes  		// below it (pruning off the imagined tree that may have dangled  		// from it) as well as blocking the use of any nodes directly  		// above for leaves  		// update ourself  		if (length < 32 && ((uint)entry >> length) != 0) {  			// error condition; the lengths must specify an overpopulated tree  			//free(r);  			return (null);  		}  		r [i] = entry;  		// Look to see if the next shorter marker points to the node  		// above. if so' update it and repeat.  		{  			for (int j = length; j > 0; j--) {  				if ((marker [j] & 1) != 0) {  					// have to jump branches  					if (j == 1)  						marker [1]++;  					else  						marker [j] = marker [j - 1] << 1;  					break;  					// invariant says next upper marker would already  					// have been moved if it was on the same path  				}  				marker [j]++;  			}  		// prune the tree; the implicit invariant says all the longer  		// markers were dangling from our just-taken node.  Dangle them  		// from our *new* node.  		}  		for (int j = length + 1; j < 33; j++) {  			if (((uint)marker [j] >> 1) == entry) {  				entry = marker [j];  				marker [j] = marker [j - 1] << 1;  			}  			else {  				break;  			}  		}  	}  }  
Magic Number,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,make_words,The following statement contains a magic number: if (length > 0) {  	int entry = marker [length];  	// when we claim a node for an entry' we also claim the nodes  	// below it (pruning off the imagined tree that may have dangled  	// from it) as well as blocking the use of any nodes directly  	// above for leaves  	// update ourself  	if (length < 32 && ((uint)entry >> length) != 0) {  		// error condition; the lengths must specify an overpopulated tree  		//free(r);  		return (null);  	}  	r [i] = entry;  	// Look to see if the next shorter marker points to the node  	// above. if so' update it and repeat.  	{  		for (int j = length; j > 0; j--) {  			if ((marker [j] & 1) != 0) {  				// have to jump branches  				if (j == 1)  					marker [1]++;  				else  					marker [j] = marker [j - 1] << 1;  				break;  				// invariant says next upper marker would already  				// have been moved if it was on the same path  			}  			marker [j]++;  		}  	// prune the tree; the implicit invariant says all the longer  	// markers were dangling from our just-taken node.  Dangle them  	// from our *new* node.  	}  	for (int j = length + 1; j < 33; j++) {  		if (((uint)marker [j] >> 1) == entry) {  			entry = marker [j];  			marker [j] = marker [j - 1] << 1;  		}  		else {  			break;  		}  	}  }  
Magic Number,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,make_words,The following statement contains a magic number: if (length > 0) {  	int entry = marker [length];  	// when we claim a node for an entry' we also claim the nodes  	// below it (pruning off the imagined tree that may have dangled  	// from it) as well as blocking the use of any nodes directly  	// above for leaves  	// update ourself  	if (length < 32 && ((uint)entry >> length) != 0) {  		// error condition; the lengths must specify an overpopulated tree  		//free(r);  		return (null);  	}  	r [i] = entry;  	// Look to see if the next shorter marker points to the node  	// above. if so' update it and repeat.  	{  		for (int j = length; j > 0; j--) {  			if ((marker [j] & 1) != 0) {  				// have to jump branches  				if (j == 1)  					marker [1]++;  				else  					marker [j] = marker [j - 1] << 1;  				break;  				// invariant says next upper marker would already  				// have been moved if it was on the same path  			}  			marker [j]++;  		}  	// prune the tree; the implicit invariant says all the longer  	// markers were dangling from our just-taken node.  Dangle them  	// from our *new* node.  	}  	for (int j = length + 1; j < 33; j++) {  		if (((uint)marker [j] >> 1) == entry) {  			entry = marker [j];  			marker [j] = marker [j - 1] << 1;  		}  		else {  			break;  		}  	}  }  
Magic Number,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,make_words,The following statement contains a magic number: if (length < 32 && ((uint)entry >> length) != 0) {  	// error condition; the lengths must specify an overpopulated tree  	//free(r);  	return (null);  }  
Magic Number,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,make_words,The following statement contains a magic number: for (int j = length + 1; j < 33; j++) {  	if (((uint)marker [j] >> 1) == entry) {  		entry = marker [j];  		marker [j] = marker [j - 1] << 1;  	}  	else {  		break;  	}  }  
Magic Number,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,make_decode_tree,The following statement contains a magic number: t.aux = entries * 2;  
Magic Number,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,make_decode_tree,The following statement contains a magic number: t.tabn = ilog (entries) - 4;  
Magic Number,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,make_decode_tree,The following statement contains a magic number: if (t.tabn < 5)  	t.tabn = 5;  
Magic Number,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,make_decode_tree,The following statement contains a magic number: if (t.tabn < 5)  	t.tabn = 5;  
Magic Number,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,make_decode_tree,The following statement contains a magic number: t.tabn = 5;  
Magic Number,csvorbis,Comment,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Comment.cs,unpack,The following statement contains a magic number: comments = opb.read (32);  
Magic Number,csvorbis,Comment,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Comment.cs,unpack,The following statement contains a magic number: for (int i = 0; i < comments; i++) {  	int len = opb.read (32);  	if (len < 0) {  		//goto err_out;  		clear ();  		return (-1);  	}  	comment_lengths [i] = len;  	user_comments [i] = new byte[len + 1];  	opb.read (user_comments [i]' len);  }  
Magic Number,csvorbis,Comment,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Comment.cs,pack,The following statement contains a magic number: opb.write (0x03' 8);  
Magic Number,csvorbis,Comment,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Comment.cs,pack,The following statement contains a magic number: opb.write (temp.Length' 32);  
Magic Number,csvorbis,Comment,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Comment.cs,pack,The following statement contains a magic number: opb.write (comments' 32);  
Magic Number,csvorbis,Comment,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Comment.cs,pack,The following statement contains a magic number: if (comments != 0) {  	for (int i = 0; i < comments; i++) {  		if (user_comments [i] != null) {  			opb.write (comment_lengths [i]' 32);  			opb.write (user_comments [i]);  		}  		else {  			opb.write (0' 32);  		}  	}  }  
Magic Number,csvorbis,Comment,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Comment.cs,pack,The following statement contains a magic number: if (comments != 0) {  	for (int i = 0; i < comments; i++) {  		if (user_comments [i] != null) {  			opb.write (comment_lengths [i]' 32);  			opb.write (user_comments [i]);  		}  		else {  			opb.write (0' 32);  		}  	}  }  
Magic Number,csvorbis,Comment,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Comment.cs,pack,The following statement contains a magic number: for (int i = 0; i < comments; i++) {  	if (user_comments [i] != null) {  		opb.write (comment_lengths [i]' 32);  		opb.write (user_comments [i]);  	}  	else {  		opb.write (0' 32);  	}  }  
Magic Number,csvorbis,Comment,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Comment.cs,pack,The following statement contains a magic number: for (int i = 0; i < comments; i++) {  	if (user_comments [i] != null) {  		opb.write (comment_lengths [i]' 32);  		opb.write (user_comments [i]);  	}  	else {  		opb.write (0' 32);  	}  }  
Magic Number,csvorbis,Comment,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Comment.cs,pack,The following statement contains a magic number: if (user_comments [i] != null) {  	opb.write (comment_lengths [i]' 32);  	opb.write (user_comments [i]);  }  else {  	opb.write (0' 32);  }  
Magic Number,csvorbis,Comment,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Comment.cs,pack,The following statement contains a magic number: if (user_comments [i] != null) {  	opb.write (comment_lengths [i]' 32);  	opb.write (user_comments [i]);  }  else {  	opb.write (0' 32);  }  
Magic Number,csvorbis,Comment,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Comment.cs,pack,The following statement contains a magic number: opb.write (comment_lengths [i]' 32);  
Magic Number,csvorbis,Comment,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Comment.cs,pack,The following statement contains a magic number: opb.write (0' 32);  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,init,The following statement contains a magic number: trigcache = new float[3 * n];  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,init,The following statement contains a magic number: splitcache = new int[32];  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: if (j < 4)  	ntry = ntryh [j];  else  	ntry += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: if (j < 4)  	ntry = ntryh [j];  else  	ntry += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: ntry += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: if (ntry != 2)  	goto L107;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: ifac [2] = 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: ifac [2] = 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: for (k1 = 0; k1 < nfm1; k1++) {  	ip = ifac [k1 + 2];  	ld = 0;  	l2 = l1 * ip;  	ido = n / l2;  	ipm = ip - 1;  	for (j = 0; j < ipm; j++) {  		ld += l1;  		i = iis;  		argld = (float)ld * argh;  		fi = 0.0f;  		for (ii = 2; ii < ido; ii += 2) {  			fi += 1.0f;  			arg = fi * argld;  			wa [index + i++] = (float)Math.Cos (arg);  			wa [index + i++] = (float)Math.Sin (arg);  		}  		iis += ido;  	}  	l1 = l2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: for (k1 = 0; k1 < nfm1; k1++) {  	ip = ifac [k1 + 2];  	ld = 0;  	l2 = l1 * ip;  	ido = n / l2;  	ipm = ip - 1;  	for (j = 0; j < ipm; j++) {  		ld += l1;  		i = iis;  		argld = (float)ld * argh;  		fi = 0.0f;  		for (ii = 2; ii < ido; ii += 2) {  			fi += 1.0f;  			arg = fi * argld;  			wa [index + i++] = (float)Math.Cos (arg);  			wa [index + i++] = (float)Math.Sin (arg);  		}  		iis += ido;  	}  	l1 = l2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: for (k1 = 0; k1 < nfm1; k1++) {  	ip = ifac [k1 + 2];  	ld = 0;  	l2 = l1 * ip;  	ido = n / l2;  	ipm = ip - 1;  	for (j = 0; j < ipm; j++) {  		ld += l1;  		i = iis;  		argld = (float)ld * argh;  		fi = 0.0f;  		for (ii = 2; ii < ido; ii += 2) {  			fi += 1.0f;  			arg = fi * argld;  			wa [index + i++] = (float)Math.Cos (arg);  			wa [index + i++] = (float)Math.Sin (arg);  		}  		iis += ido;  	}  	l1 = l2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: ip = ifac [k1 + 2];  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: for (j = 0; j < ipm; j++) {  	ld += l1;  	i = iis;  	argld = (float)ld * argh;  	fi = 0.0f;  	for (ii = 2; ii < ido; ii += 2) {  		fi += 1.0f;  		arg = fi * argld;  		wa [index + i++] = (float)Math.Cos (arg);  		wa [index + i++] = (float)Math.Sin (arg);  	}  	iis += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: for (j = 0; j < ipm; j++) {  	ld += l1;  	i = iis;  	argld = (float)ld * argh;  	fi = 0.0f;  	for (ii = 2; ii < ido; ii += 2) {  		fi += 1.0f;  		arg = fi * argld;  		wa [index + i++] = (float)Math.Cos (arg);  		wa [index + i++] = (float)Math.Sin (arg);  	}  	iis += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: for (ii = 2; ii < ido; ii += 2) {  	fi += 1.0f;  	arg = fi * argld;  	wa [index + i++] = (float)Math.Cos (arg);  	wa [index + i++] = (float)Math.Sin (arg);  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: for (ii = 2; ii < ido; ii += 2) {  	fi += 1.0f;  	arg = fi * argld;  	wa [index + i++] = (float)Math.Cos (arg);  	wa [index + i++] = (float)Math.Sin (arg);  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: ii = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drfti1,The following statement contains a magic number: ii += 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: if (ido < 2)  	return;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: if (ido == 2)  	goto L105;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t3 = t2;  	t4 = (t1 << 1) + (ido << 1);  	t5 = t1;  	t6 = t1 + t1;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 -= 2;  		t5 += 2;  		t6 += 2;  		tr2 = wa1 [index + i - 2] * cc [t3 - 1] + wa1 [index + i - 1] * cc [t3];  		ti2 = wa1 [index + i - 2] * cc [t3] - wa1 [index + i - 1] * cc [t3 - 1];  		ch [t6] = cc [t5] + ti2;  		ch [t4] = ti2 - cc [t5];  		ch [t6 - 1] = cc [t5 - 1] + tr2;  		ch [t4 - 1] = cc [t5 - 1] - tr2;  	}  	t1 += ido;  	t2 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t3 = t2;  	t4 = (t1 << 1) + (ido << 1);  	t5 = t1;  	t6 = t1 + t1;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 -= 2;  		t5 += 2;  		t6 += 2;  		tr2 = wa1 [index + i - 2] * cc [t3 - 1] + wa1 [index + i - 1] * cc [t3];  		ti2 = wa1 [index + i - 2] * cc [t3] - wa1 [index + i - 1] * cc [t3 - 1];  		ch [t6] = cc [t5] + ti2;  		ch [t4] = ti2 - cc [t5];  		ch [t6 - 1] = cc [t5 - 1] + tr2;  		ch [t4 - 1] = cc [t5 - 1] - tr2;  	}  	t1 += ido;  	t2 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t3 = t2;  	t4 = (t1 << 1) + (ido << 1);  	t5 = t1;  	t6 = t1 + t1;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 -= 2;  		t5 += 2;  		t6 += 2;  		tr2 = wa1 [index + i - 2] * cc [t3 - 1] + wa1 [index + i - 1] * cc [t3];  		ti2 = wa1 [index + i - 2] * cc [t3] - wa1 [index + i - 1] * cc [t3 - 1];  		ch [t6] = cc [t5] + ti2;  		ch [t4] = ti2 - cc [t5];  		ch [t6 - 1] = cc [t5 - 1] + tr2;  		ch [t4 - 1] = cc [t5 - 1] - tr2;  	}  	t1 += ido;  	t2 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t3 = t2;  	t4 = (t1 << 1) + (ido << 1);  	t5 = t1;  	t6 = t1 + t1;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 -= 2;  		t5 += 2;  		t6 += 2;  		tr2 = wa1 [index + i - 2] * cc [t3 - 1] + wa1 [index + i - 1] * cc [t3];  		ti2 = wa1 [index + i - 2] * cc [t3] - wa1 [index + i - 1] * cc [t3 - 1];  		ch [t6] = cc [t5] + ti2;  		ch [t4] = ti2 - cc [t5];  		ch [t6 - 1] = cc [t5 - 1] + tr2;  		ch [t4 - 1] = cc [t5 - 1] - tr2;  	}  	t1 += ido;  	t2 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t3 = t2;  	t4 = (t1 << 1) + (ido << 1);  	t5 = t1;  	t6 = t1 + t1;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 -= 2;  		t5 += 2;  		t6 += 2;  		tr2 = wa1 [index + i - 2] * cc [t3 - 1] + wa1 [index + i - 1] * cc [t3];  		ti2 = wa1 [index + i - 2] * cc [t3] - wa1 [index + i - 1] * cc [t3 - 1];  		ch [t6] = cc [t5] + ti2;  		ch [t4] = ti2 - cc [t5];  		ch [t6 - 1] = cc [t5 - 1] + tr2;  		ch [t4 - 1] = cc [t5 - 1] - tr2;  	}  	t1 += ido;  	t2 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t3 = t2;  	t4 = (t1 << 1) + (ido << 1);  	t5 = t1;  	t6 = t1 + t1;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 -= 2;  		t5 += 2;  		t6 += 2;  		tr2 = wa1 [index + i - 2] * cc [t3 - 1] + wa1 [index + i - 1] * cc [t3];  		ti2 = wa1 [index + i - 2] * cc [t3] - wa1 [index + i - 1] * cc [t3 - 1];  		ch [t6] = cc [t5] + ti2;  		ch [t4] = ti2 - cc [t5];  		ch [t6 - 1] = cc [t5 - 1] + tr2;  		ch [t4 - 1] = cc [t5 - 1] - tr2;  	}  	t1 += ido;  	t2 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t3 = t2;  	t4 = (t1 << 1) + (ido << 1);  	t5 = t1;  	t6 = t1 + t1;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 -= 2;  		t5 += 2;  		t6 += 2;  		tr2 = wa1 [index + i - 2] * cc [t3 - 1] + wa1 [index + i - 1] * cc [t3];  		ti2 = wa1 [index + i - 2] * cc [t3] - wa1 [index + i - 1] * cc [t3 - 1];  		ch [t6] = cc [t5] + ti2;  		ch [t4] = ti2 - cc [t5];  		ch [t6 - 1] = cc [t5 - 1] + tr2;  		ch [t4 - 1] = cc [t5 - 1] - tr2;  	}  	t1 += ido;  	t2 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t3 = t2;  	t4 = (t1 << 1) + (ido << 1);  	t5 = t1;  	t6 = t1 + t1;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 -= 2;  		t5 += 2;  		t6 += 2;  		tr2 = wa1 [index + i - 2] * cc [t3 - 1] + wa1 [index + i - 1] * cc [t3];  		ti2 = wa1 [index + i - 2] * cc [t3] - wa1 [index + i - 1] * cc [t3 - 1];  		ch [t6] = cc [t5] + ti2;  		ch [t4] = ti2 - cc [t5];  		ch [t6 - 1] = cc [t5 - 1] + tr2;  		ch [t4 - 1] = cc [t5 - 1] - tr2;  	}  	t1 += ido;  	t2 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 -= 2;  	t5 += 2;  	t6 += 2;  	tr2 = wa1 [index + i - 2] * cc [t3 - 1] + wa1 [index + i - 1] * cc [t3];  	ti2 = wa1 [index + i - 2] * cc [t3] - wa1 [index + i - 1] * cc [t3 - 1];  	ch [t6] = cc [t5] + ti2;  	ch [t4] = ti2 - cc [t5];  	ch [t6 - 1] = cc [t5 - 1] + tr2;  	ch [t4 - 1] = cc [t5 - 1] - tr2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 -= 2;  	t5 += 2;  	t6 += 2;  	tr2 = wa1 [index + i - 2] * cc [t3 - 1] + wa1 [index + i - 1] * cc [t3];  	ti2 = wa1 [index + i - 2] * cc [t3] - wa1 [index + i - 1] * cc [t3 - 1];  	ch [t6] = cc [t5] + ti2;  	ch [t4] = ti2 - cc [t5];  	ch [t6 - 1] = cc [t5 - 1] + tr2;  	ch [t4 - 1] = cc [t5 - 1] - tr2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 -= 2;  	t5 += 2;  	t6 += 2;  	tr2 = wa1 [index + i - 2] * cc [t3 - 1] + wa1 [index + i - 1] * cc [t3];  	ti2 = wa1 [index + i - 2] * cc [t3] - wa1 [index + i - 1] * cc [t3 - 1];  	ch [t6] = cc [t5] + ti2;  	ch [t4] = ti2 - cc [t5];  	ch [t6 - 1] = cc [t5 - 1] + tr2;  	ch [t4 - 1] = cc [t5 - 1] - tr2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 -= 2;  	t5 += 2;  	t6 += 2;  	tr2 = wa1 [index + i - 2] * cc [t3 - 1] + wa1 [index + i - 1] * cc [t3];  	ti2 = wa1 [index + i - 2] * cc [t3] - wa1 [index + i - 1] * cc [t3 - 1];  	ch [t6] = cc [t5] + ti2;  	ch [t4] = ti2 - cc [t5];  	ch [t6 - 1] = cc [t5 - 1] + tr2;  	ch [t4 - 1] = cc [t5 - 1] - tr2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 -= 2;  	t5 += 2;  	t6 += 2;  	tr2 = wa1 [index + i - 2] * cc [t3 - 1] + wa1 [index + i - 1] * cc [t3];  	ti2 = wa1 [index + i - 2] * cc [t3] - wa1 [index + i - 1] * cc [t3 - 1];  	ch [t6] = cc [t5] + ti2;  	ch [t4] = ti2 - cc [t5];  	ch [t6 - 1] = cc [t5 - 1] + tr2;  	ch [t4 - 1] = cc [t5 - 1] - tr2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 -= 2;  	t5 += 2;  	t6 += 2;  	tr2 = wa1 [index + i - 2] * cc [t3 - 1] + wa1 [index + i - 1] * cc [t3];  	ti2 = wa1 [index + i - 2] * cc [t3] - wa1 [index + i - 1] * cc [t3 - 1];  	ch [t6] = cc [t5] + ti2;  	ch [t4] = ti2 - cc [t5];  	ch [t6 - 1] = cc [t5 - 1] + tr2;  	ch [t4 - 1] = cc [t5 - 1] - tr2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 -= 2;  	t5 += 2;  	t6 += 2;  	tr2 = wa1 [index + i - 2] * cc [t3 - 1] + wa1 [index + i - 1] * cc [t3];  	ti2 = wa1 [index + i - 2] * cc [t3] - wa1 [index + i - 1] * cc [t3 - 1];  	ch [t6] = cc [t5] + ti2;  	ch [t4] = ti2 - cc [t5];  	ch [t6 - 1] = cc [t5 - 1] + tr2;  	ch [t4 - 1] = cc [t5 - 1] - tr2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 -= 2;  	t5 += 2;  	t6 += 2;  	tr2 = wa1 [index + i - 2] * cc [t3 - 1] + wa1 [index + i - 1] * cc [t3];  	ti2 = wa1 [index + i - 2] * cc [t3] - wa1 [index + i - 1] * cc [t3 - 1];  	ch [t6] = cc [t5] + ti2;  	ch [t4] = ti2 - cc [t5];  	ch [t6 - 1] = cc [t5 - 1] + tr2;  	ch [t4 - 1] = cc [t5 - 1] - tr2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: i = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: i += 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: t3 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: t4 -= 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: t5 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: t6 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: tr2 = wa1 [index + i - 2] * cc [t3 - 1] + wa1 [index + i - 1] * cc [t3];  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: ti2 = wa1 [index + i - 2] * cc [t3] - wa1 [index + i - 1] * cc [t3 - 1];  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf2,The following statement contains a magic number: if (ido % 2 == 1)  	return;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	tr1 = cc [t1] + cc [t2];  	tr2 = cc [t3] + cc [t4];  	ch [t5 = t3 << 2] = tr1 + tr2;  	ch [(ido << 2) + t5 - 1] = tr2 - tr1;  	ch [(t5 += (ido << 1)) - 1] = cc [t3] - cc [t4];  	ch [t5] = cc [t2] - cc [t1];  	t1 += ido;  	t2 += ido;  	t3 += ido;  	t4 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	tr1 = cc [t1] + cc [t2];  	tr2 = cc [t3] + cc [t4];  	ch [t5 = t3 << 2] = tr1 + tr2;  	ch [(ido << 2) + t5 - 1] = tr2 - tr1;  	ch [(t5 += (ido << 1)) - 1] = cc [t3] - cc [t4];  	ch [t5] = cc [t2] - cc [t1];  	t1 += ido;  	t2 += ido;  	t3 += ido;  	t4 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: ch [t5 = t3 << 2] = tr1 + tr2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: ch [(ido << 2) + t5 - 1] = tr2 - tr1;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: if (ido < 2)  	return;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: if (ido == 2)  	goto L105;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t2 = t1;  	t4 = t1 << 2;  	t5 = (t6 = ido << 1) + t4;  	for (i = 2; i < ido; i += 2) {  		t3 = (t2 += 2);  		t4 += 2;  		t5 -= 2;  		t3 += t0;  		cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  		ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  		ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  		ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  		tr1 = cr2 + cr4;  		tr4 = cr4 - cr2;  		ti1 = ci2 + ci4;  		ti4 = ci2 - ci4;  		ti2 = cc [t2] + ci3;  		ti3 = cc [t2] - ci3;  		tr2 = cc [t2 - 1] + cr3;  		tr3 = cc [t2 - 1] - cr3;  		ch [t4 - 1] = tr1 + tr2;  		ch [t4] = ti1 + ti2;  		ch [t5 - 1] = tr3 - ti4;  		ch [t5] = tr4 - ti3;  		ch [t4 + t6 - 1] = ti4 + tr3;  		ch [t4 + t6] = tr4 + ti3;  		ch [t5 + t6 - 1] = tr2 - tr1;  		ch [t5 + t6] = ti1 - ti2;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t2 = t1;  	t4 = t1 << 2;  	t5 = (t6 = ido << 1) + t4;  	for (i = 2; i < ido; i += 2) {  		t3 = (t2 += 2);  		t4 += 2;  		t5 -= 2;  		t3 += t0;  		cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  		ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  		ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  		ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  		tr1 = cr2 + cr4;  		tr4 = cr4 - cr2;  		ti1 = ci2 + ci4;  		ti4 = ci2 - ci4;  		ti2 = cc [t2] + ci3;  		ti3 = cc [t2] - ci3;  		tr2 = cc [t2 - 1] + cr3;  		tr3 = cc [t2 - 1] - cr3;  		ch [t4 - 1] = tr1 + tr2;  		ch [t4] = ti1 + ti2;  		ch [t5 - 1] = tr3 - ti4;  		ch [t5] = tr4 - ti3;  		ch [t4 + t6 - 1] = ti4 + tr3;  		ch [t4 + t6] = tr4 + ti3;  		ch [t5 + t6 - 1] = tr2 - tr1;  		ch [t5 + t6] = ti1 - ti2;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t2 = t1;  	t4 = t1 << 2;  	t5 = (t6 = ido << 1) + t4;  	for (i = 2; i < ido; i += 2) {  		t3 = (t2 += 2);  		t4 += 2;  		t5 -= 2;  		t3 += t0;  		cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  		ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  		ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  		ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  		tr1 = cr2 + cr4;  		tr4 = cr4 - cr2;  		ti1 = ci2 + ci4;  		ti4 = ci2 - ci4;  		ti2 = cc [t2] + ci3;  		ti3 = cc [t2] - ci3;  		tr2 = cc [t2 - 1] + cr3;  		tr3 = cc [t2 - 1] - cr3;  		ch [t4 - 1] = tr1 + tr2;  		ch [t4] = ti1 + ti2;  		ch [t5 - 1] = tr3 - ti4;  		ch [t5] = tr4 - ti3;  		ch [t4 + t6 - 1] = ti4 + tr3;  		ch [t4 + t6] = tr4 + ti3;  		ch [t5 + t6 - 1] = tr2 - tr1;  		ch [t5 + t6] = ti1 - ti2;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t2 = t1;  	t4 = t1 << 2;  	t5 = (t6 = ido << 1) + t4;  	for (i = 2; i < ido; i += 2) {  		t3 = (t2 += 2);  		t4 += 2;  		t5 -= 2;  		t3 += t0;  		cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  		ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  		ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  		ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  		tr1 = cr2 + cr4;  		tr4 = cr4 - cr2;  		ti1 = ci2 + ci4;  		ti4 = ci2 - ci4;  		ti2 = cc [t2] + ci3;  		ti3 = cc [t2] - ci3;  		tr2 = cc [t2 - 1] + cr3;  		tr3 = cc [t2 - 1] - cr3;  		ch [t4 - 1] = tr1 + tr2;  		ch [t4] = ti1 + ti2;  		ch [t5 - 1] = tr3 - ti4;  		ch [t5] = tr4 - ti3;  		ch [t4 + t6 - 1] = ti4 + tr3;  		ch [t4 + t6] = tr4 + ti3;  		ch [t5 + t6 - 1] = tr2 - tr1;  		ch [t5 + t6] = ti1 - ti2;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t2 = t1;  	t4 = t1 << 2;  	t5 = (t6 = ido << 1) + t4;  	for (i = 2; i < ido; i += 2) {  		t3 = (t2 += 2);  		t4 += 2;  		t5 -= 2;  		t3 += t0;  		cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  		ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  		ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  		ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  		tr1 = cr2 + cr4;  		tr4 = cr4 - cr2;  		ti1 = ci2 + ci4;  		ti4 = ci2 - ci4;  		ti2 = cc [t2] + ci3;  		ti3 = cc [t2] - ci3;  		tr2 = cc [t2 - 1] + cr3;  		tr3 = cc [t2 - 1] - cr3;  		ch [t4 - 1] = tr1 + tr2;  		ch [t4] = ti1 + ti2;  		ch [t5 - 1] = tr3 - ti4;  		ch [t5] = tr4 - ti3;  		ch [t4 + t6 - 1] = ti4 + tr3;  		ch [t4 + t6] = tr4 + ti3;  		ch [t5 + t6 - 1] = tr2 - tr1;  		ch [t5 + t6] = ti1 - ti2;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t2 = t1;  	t4 = t1 << 2;  	t5 = (t6 = ido << 1) + t4;  	for (i = 2; i < ido; i += 2) {  		t3 = (t2 += 2);  		t4 += 2;  		t5 -= 2;  		t3 += t0;  		cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  		ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  		ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  		ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  		tr1 = cr2 + cr4;  		tr4 = cr4 - cr2;  		ti1 = ci2 + ci4;  		ti4 = ci2 - ci4;  		ti2 = cc [t2] + ci3;  		ti3 = cc [t2] - ci3;  		tr2 = cc [t2 - 1] + cr3;  		tr3 = cc [t2 - 1] - cr3;  		ch [t4 - 1] = tr1 + tr2;  		ch [t4] = ti1 + ti2;  		ch [t5 - 1] = tr3 - ti4;  		ch [t5] = tr4 - ti3;  		ch [t4 + t6 - 1] = ti4 + tr3;  		ch [t4 + t6] = tr4 + ti3;  		ch [t5 + t6 - 1] = tr2 - tr1;  		ch [t5 + t6] = ti1 - ti2;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t2 = t1;  	t4 = t1 << 2;  	t5 = (t6 = ido << 1) + t4;  	for (i = 2; i < ido; i += 2) {  		t3 = (t2 += 2);  		t4 += 2;  		t5 -= 2;  		t3 += t0;  		cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  		ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  		ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  		ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  		tr1 = cr2 + cr4;  		tr4 = cr4 - cr2;  		ti1 = ci2 + ci4;  		ti4 = ci2 - ci4;  		ti2 = cc [t2] + ci3;  		ti3 = cc [t2] - ci3;  		tr2 = cc [t2 - 1] + cr3;  		tr3 = cc [t2 - 1] - cr3;  		ch [t4 - 1] = tr1 + tr2;  		ch [t4] = ti1 + ti2;  		ch [t5 - 1] = tr3 - ti4;  		ch [t5] = tr4 - ti3;  		ch [t4 + t6 - 1] = ti4 + tr3;  		ch [t4 + t6] = tr4 + ti3;  		ch [t5 + t6 - 1] = tr2 - tr1;  		ch [t5 + t6] = ti1 - ti2;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t2 = t1;  	t4 = t1 << 2;  	t5 = (t6 = ido << 1) + t4;  	for (i = 2; i < ido; i += 2) {  		t3 = (t2 += 2);  		t4 += 2;  		t5 -= 2;  		t3 += t0;  		cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  		ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  		ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  		ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  		tr1 = cr2 + cr4;  		tr4 = cr4 - cr2;  		ti1 = ci2 + ci4;  		ti4 = ci2 - ci4;  		ti2 = cc [t2] + ci3;  		ti3 = cc [t2] - ci3;  		tr2 = cc [t2 - 1] + cr3;  		tr3 = cc [t2 - 1] - cr3;  		ch [t4 - 1] = tr1 + tr2;  		ch [t4] = ti1 + ti2;  		ch [t5 - 1] = tr3 - ti4;  		ch [t5] = tr4 - ti3;  		ch [t4 + t6 - 1] = ti4 + tr3;  		ch [t4 + t6] = tr4 + ti3;  		ch [t5 + t6 - 1] = tr2 - tr1;  		ch [t5 + t6] = ti1 - ti2;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t2 = t1;  	t4 = t1 << 2;  	t5 = (t6 = ido << 1) + t4;  	for (i = 2; i < ido; i += 2) {  		t3 = (t2 += 2);  		t4 += 2;  		t5 -= 2;  		t3 += t0;  		cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  		ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  		ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  		ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  		tr1 = cr2 + cr4;  		tr4 = cr4 - cr2;  		ti1 = ci2 + ci4;  		ti4 = ci2 - ci4;  		ti2 = cc [t2] + ci3;  		ti3 = cc [t2] - ci3;  		tr2 = cc [t2 - 1] + cr3;  		tr3 = cc [t2 - 1] - cr3;  		ch [t4 - 1] = tr1 + tr2;  		ch [t4] = ti1 + ti2;  		ch [t5 - 1] = tr3 - ti4;  		ch [t5] = tr4 - ti3;  		ch [t4 + t6 - 1] = ti4 + tr3;  		ch [t4 + t6] = tr4 + ti3;  		ch [t5 + t6 - 1] = tr2 - tr1;  		ch [t5 + t6] = ti1 - ti2;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t2 = t1;  	t4 = t1 << 2;  	t5 = (t6 = ido << 1) + t4;  	for (i = 2; i < ido; i += 2) {  		t3 = (t2 += 2);  		t4 += 2;  		t5 -= 2;  		t3 += t0;  		cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  		ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  		ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  		ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  		tr1 = cr2 + cr4;  		tr4 = cr4 - cr2;  		ti1 = ci2 + ci4;  		ti4 = ci2 - ci4;  		ti2 = cc [t2] + ci3;  		ti3 = cc [t2] - ci3;  		tr2 = cc [t2 - 1] + cr3;  		tr3 = cc [t2 - 1] - cr3;  		ch [t4 - 1] = tr1 + tr2;  		ch [t4] = ti1 + ti2;  		ch [t5 - 1] = tr3 - ti4;  		ch [t5] = tr4 - ti3;  		ch [t4 + t6 - 1] = ti4 + tr3;  		ch [t4 + t6] = tr4 + ti3;  		ch [t5 + t6 - 1] = tr2 - tr1;  		ch [t5 + t6] = ti1 - ti2;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t2 = t1;  	t4 = t1 << 2;  	t5 = (t6 = ido << 1) + t4;  	for (i = 2; i < ido; i += 2) {  		t3 = (t2 += 2);  		t4 += 2;  		t5 -= 2;  		t3 += t0;  		cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  		ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  		ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  		ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  		tr1 = cr2 + cr4;  		tr4 = cr4 - cr2;  		ti1 = ci2 + ci4;  		ti4 = ci2 - ci4;  		ti2 = cc [t2] + ci3;  		ti3 = cc [t2] - ci3;  		tr2 = cc [t2 - 1] + cr3;  		tr3 = cc [t2 - 1] - cr3;  		ch [t4 - 1] = tr1 + tr2;  		ch [t4] = ti1 + ti2;  		ch [t5 - 1] = tr3 - ti4;  		ch [t5] = tr4 - ti3;  		ch [t4 + t6 - 1] = ti4 + tr3;  		ch [t4 + t6] = tr4 + ti3;  		ch [t5 + t6 - 1] = tr2 - tr1;  		ch [t5 + t6] = ti1 - ti2;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t2 = t1;  	t4 = t1 << 2;  	t5 = (t6 = ido << 1) + t4;  	for (i = 2; i < ido; i += 2) {  		t3 = (t2 += 2);  		t4 += 2;  		t5 -= 2;  		t3 += t0;  		cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  		ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  		ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  		t3 += t0;  		cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  		ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  		tr1 = cr2 + cr4;  		tr4 = cr4 - cr2;  		ti1 = ci2 + ci4;  		ti4 = ci2 - ci4;  		ti2 = cc [t2] + ci3;  		ti3 = cc [t2] - ci3;  		tr2 = cc [t2 - 1] + cr3;  		tr3 = cc [t2 - 1] - cr3;  		ch [t4 - 1] = tr1 + tr2;  		ch [t4] = ti1 + ti2;  		ch [t5 - 1] = tr3 - ti4;  		ch [t5] = tr4 - ti3;  		ch [t4 + t6 - 1] = ti4 + tr3;  		ch [t4 + t6] = tr4 + ti3;  		ch [t5 + t6 - 1] = tr2 - tr1;  		ch [t5 + t6] = ti1 - ti2;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: t4 = t1 << 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 = (t2 += 2);  	t4 += 2;  	t5 -= 2;  	t3 += t0;  	cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  	ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  	ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  	ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  	tr1 = cr2 + cr4;  	tr4 = cr4 - cr2;  	ti1 = ci2 + ci4;  	ti4 = ci2 - ci4;  	ti2 = cc [t2] + ci3;  	ti3 = cc [t2] - ci3;  	tr2 = cc [t2 - 1] + cr3;  	tr3 = cc [t2 - 1] - cr3;  	ch [t4 - 1] = tr1 + tr2;  	ch [t4] = ti1 + ti2;  	ch [t5 - 1] = tr3 - ti4;  	ch [t5] = tr4 - ti3;  	ch [t4 + t6 - 1] = ti4 + tr3;  	ch [t4 + t6] = tr4 + ti3;  	ch [t5 + t6 - 1] = tr2 - tr1;  	ch [t5 + t6] = ti1 - ti2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 = (t2 += 2);  	t4 += 2;  	t5 -= 2;  	t3 += t0;  	cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  	ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  	ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  	ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  	tr1 = cr2 + cr4;  	tr4 = cr4 - cr2;  	ti1 = ci2 + ci4;  	ti4 = ci2 - ci4;  	ti2 = cc [t2] + ci3;  	ti3 = cc [t2] - ci3;  	tr2 = cc [t2 - 1] + cr3;  	tr3 = cc [t2 - 1] - cr3;  	ch [t4 - 1] = tr1 + tr2;  	ch [t4] = ti1 + ti2;  	ch [t5 - 1] = tr3 - ti4;  	ch [t5] = tr4 - ti3;  	ch [t4 + t6 - 1] = ti4 + tr3;  	ch [t4 + t6] = tr4 + ti3;  	ch [t5 + t6 - 1] = tr2 - tr1;  	ch [t5 + t6] = ti1 - ti2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 = (t2 += 2);  	t4 += 2;  	t5 -= 2;  	t3 += t0;  	cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  	ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  	ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  	ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  	tr1 = cr2 + cr4;  	tr4 = cr4 - cr2;  	ti1 = ci2 + ci4;  	ti4 = ci2 - ci4;  	ti2 = cc [t2] + ci3;  	ti3 = cc [t2] - ci3;  	tr2 = cc [t2 - 1] + cr3;  	tr3 = cc [t2 - 1] - cr3;  	ch [t4 - 1] = tr1 + tr2;  	ch [t4] = ti1 + ti2;  	ch [t5 - 1] = tr3 - ti4;  	ch [t5] = tr4 - ti3;  	ch [t4 + t6 - 1] = ti4 + tr3;  	ch [t4 + t6] = tr4 + ti3;  	ch [t5 + t6 - 1] = tr2 - tr1;  	ch [t5 + t6] = ti1 - ti2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 = (t2 += 2);  	t4 += 2;  	t5 -= 2;  	t3 += t0;  	cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  	ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  	ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  	ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  	tr1 = cr2 + cr4;  	tr4 = cr4 - cr2;  	ti1 = ci2 + ci4;  	ti4 = ci2 - ci4;  	ti2 = cc [t2] + ci3;  	ti3 = cc [t2] - ci3;  	tr2 = cc [t2 - 1] + cr3;  	tr3 = cc [t2 - 1] - cr3;  	ch [t4 - 1] = tr1 + tr2;  	ch [t4] = ti1 + ti2;  	ch [t5 - 1] = tr3 - ti4;  	ch [t5] = tr4 - ti3;  	ch [t4 + t6 - 1] = ti4 + tr3;  	ch [t4 + t6] = tr4 + ti3;  	ch [t5 + t6 - 1] = tr2 - tr1;  	ch [t5 + t6] = ti1 - ti2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 = (t2 += 2);  	t4 += 2;  	t5 -= 2;  	t3 += t0;  	cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  	ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  	ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  	ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  	tr1 = cr2 + cr4;  	tr4 = cr4 - cr2;  	ti1 = ci2 + ci4;  	ti4 = ci2 - ci4;  	ti2 = cc [t2] + ci3;  	ti3 = cc [t2] - ci3;  	tr2 = cc [t2 - 1] + cr3;  	tr3 = cc [t2 - 1] - cr3;  	ch [t4 - 1] = tr1 + tr2;  	ch [t4] = ti1 + ti2;  	ch [t5 - 1] = tr3 - ti4;  	ch [t5] = tr4 - ti3;  	ch [t4 + t6 - 1] = ti4 + tr3;  	ch [t4 + t6] = tr4 + ti3;  	ch [t5 + t6 - 1] = tr2 - tr1;  	ch [t5 + t6] = ti1 - ti2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 = (t2 += 2);  	t4 += 2;  	t5 -= 2;  	t3 += t0;  	cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  	ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  	ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  	ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  	tr1 = cr2 + cr4;  	tr4 = cr4 - cr2;  	ti1 = ci2 + ci4;  	ti4 = ci2 - ci4;  	ti2 = cc [t2] + ci3;  	ti3 = cc [t2] - ci3;  	tr2 = cc [t2 - 1] + cr3;  	tr3 = cc [t2 - 1] - cr3;  	ch [t4 - 1] = tr1 + tr2;  	ch [t4] = ti1 + ti2;  	ch [t5 - 1] = tr3 - ti4;  	ch [t5] = tr4 - ti3;  	ch [t4 + t6 - 1] = ti4 + tr3;  	ch [t4 + t6] = tr4 + ti3;  	ch [t5 + t6 - 1] = tr2 - tr1;  	ch [t5 + t6] = ti1 - ti2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 = (t2 += 2);  	t4 += 2;  	t5 -= 2;  	t3 += t0;  	cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  	ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  	ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  	ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  	tr1 = cr2 + cr4;  	tr4 = cr4 - cr2;  	ti1 = ci2 + ci4;  	ti4 = ci2 - ci4;  	ti2 = cc [t2] + ci3;  	ti3 = cc [t2] - ci3;  	tr2 = cc [t2 - 1] + cr3;  	tr3 = cc [t2 - 1] - cr3;  	ch [t4 - 1] = tr1 + tr2;  	ch [t4] = ti1 + ti2;  	ch [t5 - 1] = tr3 - ti4;  	ch [t5] = tr4 - ti3;  	ch [t4 + t6 - 1] = ti4 + tr3;  	ch [t4 + t6] = tr4 + ti3;  	ch [t5 + t6 - 1] = tr2 - tr1;  	ch [t5 + t6] = ti1 - ti2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 = (t2 += 2);  	t4 += 2;  	t5 -= 2;  	t3 += t0;  	cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  	ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  	ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  	ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  	tr1 = cr2 + cr4;  	tr4 = cr4 - cr2;  	ti1 = ci2 + ci4;  	ti4 = ci2 - ci4;  	ti2 = cc [t2] + ci3;  	ti3 = cc [t2] - ci3;  	tr2 = cc [t2 - 1] + cr3;  	tr3 = cc [t2 - 1] - cr3;  	ch [t4 - 1] = tr1 + tr2;  	ch [t4] = ti1 + ti2;  	ch [t5 - 1] = tr3 - ti4;  	ch [t5] = tr4 - ti3;  	ch [t4 + t6 - 1] = ti4 + tr3;  	ch [t4 + t6] = tr4 + ti3;  	ch [t5 + t6 - 1] = tr2 - tr1;  	ch [t5 + t6] = ti1 - ti2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 = (t2 += 2);  	t4 += 2;  	t5 -= 2;  	t3 += t0;  	cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  	ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  	ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  	ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  	tr1 = cr2 + cr4;  	tr4 = cr4 - cr2;  	ti1 = ci2 + ci4;  	ti4 = ci2 - ci4;  	ti2 = cc [t2] + ci3;  	ti3 = cc [t2] - ci3;  	tr2 = cc [t2 - 1] + cr3;  	tr3 = cc [t2 - 1] - cr3;  	ch [t4 - 1] = tr1 + tr2;  	ch [t4] = ti1 + ti2;  	ch [t5 - 1] = tr3 - ti4;  	ch [t5] = tr4 - ti3;  	ch [t4 + t6 - 1] = ti4 + tr3;  	ch [t4 + t6] = tr4 + ti3;  	ch [t5 + t6 - 1] = tr2 - tr1;  	ch [t5 + t6] = ti1 - ti2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 = (t2 += 2);  	t4 += 2;  	t5 -= 2;  	t3 += t0;  	cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  	ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  	ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  	ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  	tr1 = cr2 + cr4;  	tr4 = cr4 - cr2;  	ti1 = ci2 + ci4;  	ti4 = ci2 - ci4;  	ti2 = cc [t2] + ci3;  	ti3 = cc [t2] - ci3;  	tr2 = cc [t2 - 1] + cr3;  	tr3 = cc [t2 - 1] - cr3;  	ch [t4 - 1] = tr1 + tr2;  	ch [t4] = ti1 + ti2;  	ch [t5 - 1] = tr3 - ti4;  	ch [t5] = tr4 - ti3;  	ch [t4 + t6 - 1] = ti4 + tr3;  	ch [t4 + t6] = tr4 + ti3;  	ch [t5 + t6 - 1] = tr2 - tr1;  	ch [t5 + t6] = ti1 - ti2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 = (t2 += 2);  	t4 += 2;  	t5 -= 2;  	t3 += t0;  	cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  	ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  	ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  	t3 += t0;  	cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  	ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  	tr1 = cr2 + cr4;  	tr4 = cr4 - cr2;  	ti1 = ci2 + ci4;  	ti4 = ci2 - ci4;  	ti2 = cc [t2] + ci3;  	ti3 = cc [t2] - ci3;  	tr2 = cc [t2 - 1] + cr3;  	tr3 = cc [t2 - 1] - cr3;  	ch [t4 - 1] = tr1 + tr2;  	ch [t4] = ti1 + ti2;  	ch [t5 - 1] = tr3 - ti4;  	ch [t5] = tr4 - ti3;  	ch [t4 + t6 - 1] = ti4 + tr3;  	ch [t4 + t6] = tr4 + ti3;  	ch [t5 + t6 - 1] = tr2 - tr1;  	ch [t5 + t6] = ti1 - ti2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: i = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: i += 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: t3 = (t2 += 2);  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: t4 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: t5 -= 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: cr2 = wa1 [index1 + i - 2] * cc [t3 - 1] + wa1 [index1 + i - 1] * cc [t3];  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: ci2 = wa1 [index1 + i - 2] * cc [t3] - wa1 [index1 + i - 1] * cc [t3 - 1];  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: cr3 = wa2 [index2 + i - 2] * cc [t3 - 1] + wa2 [index2 + i - 1] * cc [t3];  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: ci3 = wa2 [index2 + i - 2] * cc [t3] - wa2 [index2 + i - 1] * cc [t3 - 1];  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: cr4 = wa3 [index3 + i - 2] * cc [t3 - 1] + wa3 [index3 + i - 1] * cc [t3];  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: ci4 = wa3 [index3 + i - 2] * cc [t3] - wa3 [index3 + i - 1] * cc [t3 - 1];  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradf4,The following statement contains a magic number: t3 = ido << 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if (nbd > l1) {  	for (j = 1; j < ip; j++) {  		t1 += t0;  		iis += ido;  		t2 = -ido + t1;  		for (k = 0; k < l1; k++) {  			idij = iis - 1;  			t2 += ido;  			t3 = t2;  			for (i = 2; i < ido; i += 2) {  				idij += 2;  				t3 += 2;  				ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  				ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  			}  		}  	}  }  else {  	for (j = 1; j < ip; j++) {  		iis += ido;  		idij = iis - 1;  		t1 += t0;  		t2 = t1;  		for (i = 2; i < ido; i += 2) {  			idij += 2;  			t2 += 2;  			t3 = t2;  			for (k = 0; k < l1; k++) {  				ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  				ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  				t3 += ido;  			}  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if (nbd > l1) {  	for (j = 1; j < ip; j++) {  		t1 += t0;  		iis += ido;  		t2 = -ido + t1;  		for (k = 0; k < l1; k++) {  			idij = iis - 1;  			t2 += ido;  			t3 = t2;  			for (i = 2; i < ido; i += 2) {  				idij += 2;  				t3 += 2;  				ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  				ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  			}  		}  	}  }  else {  	for (j = 1; j < ip; j++) {  		iis += ido;  		idij = iis - 1;  		t1 += t0;  		t2 = t1;  		for (i = 2; i < ido; i += 2) {  			idij += 2;  			t2 += 2;  			t3 = t2;  			for (k = 0; k < l1; k++) {  				ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  				ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  				t3 += ido;  			}  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if (nbd > l1) {  	for (j = 1; j < ip; j++) {  		t1 += t0;  		iis += ido;  		t2 = -ido + t1;  		for (k = 0; k < l1; k++) {  			idij = iis - 1;  			t2 += ido;  			t3 = t2;  			for (i = 2; i < ido; i += 2) {  				idij += 2;  				t3 += 2;  				ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  				ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  			}  		}  	}  }  else {  	for (j = 1; j < ip; j++) {  		iis += ido;  		idij = iis - 1;  		t1 += t0;  		t2 = t1;  		for (i = 2; i < ido; i += 2) {  			idij += 2;  			t2 += 2;  			t3 = t2;  			for (k = 0; k < l1; k++) {  				ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  				ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  				t3 += ido;  			}  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if (nbd > l1) {  	for (j = 1; j < ip; j++) {  		t1 += t0;  		iis += ido;  		t2 = -ido + t1;  		for (k = 0; k < l1; k++) {  			idij = iis - 1;  			t2 += ido;  			t3 = t2;  			for (i = 2; i < ido; i += 2) {  				idij += 2;  				t3 += 2;  				ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  				ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  			}  		}  	}  }  else {  	for (j = 1; j < ip; j++) {  		iis += ido;  		idij = iis - 1;  		t1 += t0;  		t2 = t1;  		for (i = 2; i < ido; i += 2) {  			idij += 2;  			t2 += 2;  			t3 = t2;  			for (k = 0; k < l1; k++) {  				ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  				ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  				t3 += ido;  			}  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if (nbd > l1) {  	for (j = 1; j < ip; j++) {  		t1 += t0;  		iis += ido;  		t2 = -ido + t1;  		for (k = 0; k < l1; k++) {  			idij = iis - 1;  			t2 += ido;  			t3 = t2;  			for (i = 2; i < ido; i += 2) {  				idij += 2;  				t3 += 2;  				ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  				ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  			}  		}  	}  }  else {  	for (j = 1; j < ip; j++) {  		iis += ido;  		idij = iis - 1;  		t1 += t0;  		t2 = t1;  		for (i = 2; i < ido; i += 2) {  			idij += 2;  			t2 += 2;  			t3 = t2;  			for (k = 0; k < l1; k++) {  				ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  				ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  				t3 += ido;  			}  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if (nbd > l1) {  	for (j = 1; j < ip; j++) {  		t1 += t0;  		iis += ido;  		t2 = -ido + t1;  		for (k = 0; k < l1; k++) {  			idij = iis - 1;  			t2 += ido;  			t3 = t2;  			for (i = 2; i < ido; i += 2) {  				idij += 2;  				t3 += 2;  				ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  				ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  			}  		}  	}  }  else {  	for (j = 1; j < ip; j++) {  		iis += ido;  		idij = iis - 1;  		t1 += t0;  		t2 = t1;  		for (i = 2; i < ido; i += 2) {  			idij += 2;  			t2 += 2;  			t3 = t2;  			for (k = 0; k < l1; k++) {  				ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  				ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  				t3 += ido;  			}  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if (nbd > l1) {  	for (j = 1; j < ip; j++) {  		t1 += t0;  		iis += ido;  		t2 = -ido + t1;  		for (k = 0; k < l1; k++) {  			idij = iis - 1;  			t2 += ido;  			t3 = t2;  			for (i = 2; i < ido; i += 2) {  				idij += 2;  				t3 += 2;  				ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  				ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  			}  		}  	}  }  else {  	for (j = 1; j < ip; j++) {  		iis += ido;  		idij = iis - 1;  		t1 += t0;  		t2 = t1;  		for (i = 2; i < ido; i += 2) {  			idij += 2;  			t2 += 2;  			t3 = t2;  			for (k = 0; k < l1; k++) {  				ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  				ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  				t3 += ido;  			}  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if (nbd > l1) {  	for (j = 1; j < ip; j++) {  		t1 += t0;  		iis += ido;  		t2 = -ido + t1;  		for (k = 0; k < l1; k++) {  			idij = iis - 1;  			t2 += ido;  			t3 = t2;  			for (i = 2; i < ido; i += 2) {  				idij += 2;  				t3 += 2;  				ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  				ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  			}  		}  	}  }  else {  	for (j = 1; j < ip; j++) {  		iis += ido;  		idij = iis - 1;  		t1 += t0;  		t2 = t1;  		for (i = 2; i < ido; i += 2) {  			idij += 2;  			t2 += 2;  			t3 = t2;  			for (k = 0; k < l1; k++) {  				ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  				ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  				t3 += ido;  			}  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ip; j++) {  	t1 += t0;  	iis += ido;  	t2 = -ido + t1;  	for (k = 0; k < l1; k++) {  		idij = iis - 1;  		t2 += ido;  		t3 = t2;  		for (i = 2; i < ido; i += 2) {  			idij += 2;  			t3 += 2;  			ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  			ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ip; j++) {  	t1 += t0;  	iis += ido;  	t2 = -ido + t1;  	for (k = 0; k < l1; k++) {  		idij = iis - 1;  		t2 += ido;  		t3 = t2;  		for (i = 2; i < ido; i += 2) {  			idij += 2;  			t3 += 2;  			ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  			ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ip; j++) {  	t1 += t0;  	iis += ido;  	t2 = -ido + t1;  	for (k = 0; k < l1; k++) {  		idij = iis - 1;  		t2 += ido;  		t3 = t2;  		for (i = 2; i < ido; i += 2) {  			idij += 2;  			t3 += 2;  			ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  			ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ip; j++) {  	t1 += t0;  	iis += ido;  	t2 = -ido + t1;  	for (k = 0; k < l1; k++) {  		idij = iis - 1;  		t2 += ido;  		t3 = t2;  		for (i = 2; i < ido; i += 2) {  			idij += 2;  			t3 += 2;  			ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  			ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	idij = iis - 1;  	t2 += ido;  	t3 = t2;  	for (i = 2; i < ido; i += 2) {  		idij += 2;  		t3 += 2;  		ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  		ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	idij = iis - 1;  	t2 += ido;  	t3 = t2;  	for (i = 2; i < ido; i += 2) {  		idij += 2;  		t3 += 2;  		ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  		ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	idij = iis - 1;  	t2 += ido;  	t3 = t2;  	for (i = 2; i < ido; i += 2) {  		idij += 2;  		t3 += 2;  		ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  		ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	idij = iis - 1;  	t2 += ido;  	t3 = t2;  	for (i = 2; i < ido; i += 2) {  		idij += 2;  		t3 += 2;  		ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  		ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	idij += 2;  	t3 += 2;  	ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  	ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	idij += 2;  	t3 += 2;  	ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  	ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	idij += 2;  	t3 += 2;  	ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  	ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	idij += 2;  	t3 += 2;  	ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  	ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: i = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: i += 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: idij += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: t3 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ip; j++) {  	iis += ido;  	idij = iis - 1;  	t1 += t0;  	t2 = t1;  	for (i = 2; i < ido; i += 2) {  		idij += 2;  		t2 += 2;  		t3 = t2;  		for (k = 0; k < l1; k++) {  			ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  			ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  			t3 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ip; j++) {  	iis += ido;  	idij = iis - 1;  	t1 += t0;  	t2 = t1;  	for (i = 2; i < ido; i += 2) {  		idij += 2;  		t2 += 2;  		t3 = t2;  		for (k = 0; k < l1; k++) {  			ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  			ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  			t3 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ip; j++) {  	iis += ido;  	idij = iis - 1;  	t1 += t0;  	t2 = t1;  	for (i = 2; i < ido; i += 2) {  		idij += 2;  		t2 += 2;  		t3 = t2;  		for (k = 0; k < l1; k++) {  			ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  			ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  			t3 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ip; j++) {  	iis += ido;  	idij = iis - 1;  	t1 += t0;  	t2 = t1;  	for (i = 2; i < ido; i += 2) {  		idij += 2;  		t2 += 2;  		t3 = t2;  		for (k = 0; k < l1; k++) {  			ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  			ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  			t3 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	idij += 2;  	t2 += 2;  	t3 = t2;  	for (k = 0; k < l1; k++) {  		ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  		ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  		t3 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	idij += 2;  	t2 += 2;  	t3 = t2;  	for (k = 0; k < l1; k++) {  		ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  		ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  		t3 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	idij += 2;  	t2 += 2;  	t3 = t2;  	for (k = 0; k < l1; k++) {  		ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  		ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  		t3 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	idij += 2;  	t2 += 2;  	t3 = t2;  	for (k = 0; k < l1; k++) {  		ch [t3 - 1] = wa [index + idij - 1] * c1 [t3 - 1] + wa [index + idij] * c1 [t3];  		ch [t3] = wa [index + idij - 1] * c1 [t3] - wa [index + idij] * c1 [t3 - 1];  		t3 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: i = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: i += 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: idij += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: t2 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if (nbd < l1) {  	for (j = 1; j < ipph; j++) {  		t1 += t0;  		t2 -= t0;  		t3 = t1;  		t4 = t2;  		for (i = 2; i < ido; i += 2) {  			t3 += 2;  			t4 += 2;  			t5 = t3 - ido;  			t6 = t4 - ido;  			for (k = 0; k < l1; k++) {  				t5 += ido;  				t6 += ido;  				c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  				c1 [t6 - 1] = ch [t5] - ch [t6];  				c1 [t5] = ch [t5] + ch [t6];  				c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  			}  		}  	}  }  else {  	for (j = 1; j < ipph; j++) {  		t1 += t0;  		t2 -= t0;  		t3 = t1;  		t4 = t2;  		for (k = 0; k < l1; k++) {  			t5 = t3;  			t6 = t4;  			for (i = 2; i < ido; i += 2) {  				t5 += 2;  				t6 += 2;  				c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  				c1 [t6 - 1] = ch [t5] - ch [t6];  				c1 [t5] = ch [t5] + ch [t6];  				c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  			}  			t3 += ido;  			t4 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if (nbd < l1) {  	for (j = 1; j < ipph; j++) {  		t1 += t0;  		t2 -= t0;  		t3 = t1;  		t4 = t2;  		for (i = 2; i < ido; i += 2) {  			t3 += 2;  			t4 += 2;  			t5 = t3 - ido;  			t6 = t4 - ido;  			for (k = 0; k < l1; k++) {  				t5 += ido;  				t6 += ido;  				c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  				c1 [t6 - 1] = ch [t5] - ch [t6];  				c1 [t5] = ch [t5] + ch [t6];  				c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  			}  		}  	}  }  else {  	for (j = 1; j < ipph; j++) {  		t1 += t0;  		t2 -= t0;  		t3 = t1;  		t4 = t2;  		for (k = 0; k < l1; k++) {  			t5 = t3;  			t6 = t4;  			for (i = 2; i < ido; i += 2) {  				t5 += 2;  				t6 += 2;  				c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  				c1 [t6 - 1] = ch [t5] - ch [t6];  				c1 [t5] = ch [t5] + ch [t6];  				c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  			}  			t3 += ido;  			t4 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if (nbd < l1) {  	for (j = 1; j < ipph; j++) {  		t1 += t0;  		t2 -= t0;  		t3 = t1;  		t4 = t2;  		for (i = 2; i < ido; i += 2) {  			t3 += 2;  			t4 += 2;  			t5 = t3 - ido;  			t6 = t4 - ido;  			for (k = 0; k < l1; k++) {  				t5 += ido;  				t6 += ido;  				c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  				c1 [t6 - 1] = ch [t5] - ch [t6];  				c1 [t5] = ch [t5] + ch [t6];  				c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  			}  		}  	}  }  else {  	for (j = 1; j < ipph; j++) {  		t1 += t0;  		t2 -= t0;  		t3 = t1;  		t4 = t2;  		for (k = 0; k < l1; k++) {  			t5 = t3;  			t6 = t4;  			for (i = 2; i < ido; i += 2) {  				t5 += 2;  				t6 += 2;  				c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  				c1 [t6 - 1] = ch [t5] - ch [t6];  				c1 [t5] = ch [t5] + ch [t6];  				c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  			}  			t3 += ido;  			t4 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if (nbd < l1) {  	for (j = 1; j < ipph; j++) {  		t1 += t0;  		t2 -= t0;  		t3 = t1;  		t4 = t2;  		for (i = 2; i < ido; i += 2) {  			t3 += 2;  			t4 += 2;  			t5 = t3 - ido;  			t6 = t4 - ido;  			for (k = 0; k < l1; k++) {  				t5 += ido;  				t6 += ido;  				c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  				c1 [t6 - 1] = ch [t5] - ch [t6];  				c1 [t5] = ch [t5] + ch [t6];  				c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  			}  		}  	}  }  else {  	for (j = 1; j < ipph; j++) {  		t1 += t0;  		t2 -= t0;  		t3 = t1;  		t4 = t2;  		for (k = 0; k < l1; k++) {  			t5 = t3;  			t6 = t4;  			for (i = 2; i < ido; i += 2) {  				t5 += 2;  				t6 += 2;  				c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  				c1 [t6 - 1] = ch [t5] - ch [t6];  				c1 [t5] = ch [t5] + ch [t6];  				c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  			}  			t3 += ido;  			t4 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if (nbd < l1) {  	for (j = 1; j < ipph; j++) {  		t1 += t0;  		t2 -= t0;  		t3 = t1;  		t4 = t2;  		for (i = 2; i < ido; i += 2) {  			t3 += 2;  			t4 += 2;  			t5 = t3 - ido;  			t6 = t4 - ido;  			for (k = 0; k < l1; k++) {  				t5 += ido;  				t6 += ido;  				c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  				c1 [t6 - 1] = ch [t5] - ch [t6];  				c1 [t5] = ch [t5] + ch [t6];  				c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  			}  		}  	}  }  else {  	for (j = 1; j < ipph; j++) {  		t1 += t0;  		t2 -= t0;  		t3 = t1;  		t4 = t2;  		for (k = 0; k < l1; k++) {  			t5 = t3;  			t6 = t4;  			for (i = 2; i < ido; i += 2) {  				t5 += 2;  				t6 += 2;  				c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  				c1 [t6 - 1] = ch [t5] - ch [t6];  				c1 [t5] = ch [t5] + ch [t6];  				c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  			}  			t3 += ido;  			t4 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if (nbd < l1) {  	for (j = 1; j < ipph; j++) {  		t1 += t0;  		t2 -= t0;  		t3 = t1;  		t4 = t2;  		for (i = 2; i < ido; i += 2) {  			t3 += 2;  			t4 += 2;  			t5 = t3 - ido;  			t6 = t4 - ido;  			for (k = 0; k < l1; k++) {  				t5 += ido;  				t6 += ido;  				c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  				c1 [t6 - 1] = ch [t5] - ch [t6];  				c1 [t5] = ch [t5] + ch [t6];  				c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  			}  		}  	}  }  else {  	for (j = 1; j < ipph; j++) {  		t1 += t0;  		t2 -= t0;  		t3 = t1;  		t4 = t2;  		for (k = 0; k < l1; k++) {  			t5 = t3;  			t6 = t4;  			for (i = 2; i < ido; i += 2) {  				t5 += 2;  				t6 += 2;  				c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  				c1 [t6 - 1] = ch [t5] - ch [t6];  				c1 [t5] = ch [t5] + ch [t6];  				c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  			}  			t3 += ido;  			t4 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if (nbd < l1) {  	for (j = 1; j < ipph; j++) {  		t1 += t0;  		t2 -= t0;  		t3 = t1;  		t4 = t2;  		for (i = 2; i < ido; i += 2) {  			t3 += 2;  			t4 += 2;  			t5 = t3 - ido;  			t6 = t4 - ido;  			for (k = 0; k < l1; k++) {  				t5 += ido;  				t6 += ido;  				c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  				c1 [t6 - 1] = ch [t5] - ch [t6];  				c1 [t5] = ch [t5] + ch [t6];  				c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  			}  		}  	}  }  else {  	for (j = 1; j < ipph; j++) {  		t1 += t0;  		t2 -= t0;  		t3 = t1;  		t4 = t2;  		for (k = 0; k < l1; k++) {  			t5 = t3;  			t6 = t4;  			for (i = 2; i < ido; i += 2) {  				t5 += 2;  				t6 += 2;  				c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  				c1 [t6 - 1] = ch [t5] - ch [t6];  				c1 [t5] = ch [t5] + ch [t6];  				c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  			}  			t3 += ido;  			t4 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: if (nbd < l1) {  	for (j = 1; j < ipph; j++) {  		t1 += t0;  		t2 -= t0;  		t3 = t1;  		t4 = t2;  		for (i = 2; i < ido; i += 2) {  			t3 += 2;  			t4 += 2;  			t5 = t3 - ido;  			t6 = t4 - ido;  			for (k = 0; k < l1; k++) {  				t5 += ido;  				t6 += ido;  				c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  				c1 [t6 - 1] = ch [t5] - ch [t6];  				c1 [t5] = ch [t5] + ch [t6];  				c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  			}  		}  	}  }  else {  	for (j = 1; j < ipph; j++) {  		t1 += t0;  		t2 -= t0;  		t3 = t1;  		t4 = t2;  		for (k = 0; k < l1; k++) {  			t5 = t3;  			t6 = t4;  			for (i = 2; i < ido; i += 2) {  				t5 += 2;  				t6 += 2;  				c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  				c1 [t6 - 1] = ch [t5] - ch [t6];  				c1 [t5] = ch [t5] + ch [t6];  				c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  			}  			t3 += ido;  			t4 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t5 = t3 - ido;  		t6 = t4 - ido;  		for (k = 0; k < l1; k++) {  			t5 += ido;  			t6 += ido;  			c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  			c1 [t6 - 1] = ch [t5] - ch [t6];  			c1 [t5] = ch [t5] + ch [t6];  			c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t5 = t3 - ido;  		t6 = t4 - ido;  		for (k = 0; k < l1; k++) {  			t5 += ido;  			t6 += ido;  			c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  			c1 [t6 - 1] = ch [t5] - ch [t6];  			c1 [t5] = ch [t5] + ch [t6];  			c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t5 = t3 - ido;  		t6 = t4 - ido;  		for (k = 0; k < l1; k++) {  			t5 += ido;  			t6 += ido;  			c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  			c1 [t6 - 1] = ch [t5] - ch [t6];  			c1 [t5] = ch [t5] + ch [t6];  			c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t5 = t3 - ido;  		t6 = t4 - ido;  		for (k = 0; k < l1; k++) {  			t5 += ido;  			t6 += ido;  			c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  			c1 [t6 - 1] = ch [t5] - ch [t6];  			c1 [t5] = ch [t5] + ch [t6];  			c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t5 = t3 - ido;  	t6 = t4 - ido;  	for (k = 0; k < l1; k++) {  		t5 += ido;  		t6 += ido;  		c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  		c1 [t6 - 1] = ch [t5] - ch [t6];  		c1 [t5] = ch [t5] + ch [t6];  		c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t5 = t3 - ido;  	t6 = t4 - ido;  	for (k = 0; k < l1; k++) {  		t5 += ido;  		t6 += ido;  		c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  		c1 [t6 - 1] = ch [t5] - ch [t6];  		c1 [t5] = ch [t5] + ch [t6];  		c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t5 = t3 - ido;  	t6 = t4 - ido;  	for (k = 0; k < l1; k++) {  		t5 += ido;  		t6 += ido;  		c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  		c1 [t6 - 1] = ch [t5] - ch [t6];  		c1 [t5] = ch [t5] + ch [t6];  		c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t5 = t3 - ido;  	t6 = t4 - ido;  	for (k = 0; k < l1; k++) {  		t5 += ido;  		t6 += ido;  		c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  		c1 [t6 - 1] = ch [t5] - ch [t6];  		c1 [t5] = ch [t5] + ch [t6];  		c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: i = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: i += 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: t3 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: t4 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	for (k = 0; k < l1; k++) {  		t5 = t3;  		t6 = t4;  		for (i = 2; i < ido; i += 2) {  			t5 += 2;  			t6 += 2;  			c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  			c1 [t6 - 1] = ch [t5] - ch [t6];  			c1 [t5] = ch [t5] + ch [t6];  			c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  		}  		t3 += ido;  		t4 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	for (k = 0; k < l1; k++) {  		t5 = t3;  		t6 = t4;  		for (i = 2; i < ido; i += 2) {  			t5 += 2;  			t6 += 2;  			c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  			c1 [t6 - 1] = ch [t5] - ch [t6];  			c1 [t5] = ch [t5] + ch [t6];  			c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  		}  		t3 += ido;  		t4 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	for (k = 0; k < l1; k++) {  		t5 = t3;  		t6 = t4;  		for (i = 2; i < ido; i += 2) {  			t5 += 2;  			t6 += 2;  			c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  			c1 [t6 - 1] = ch [t5] - ch [t6];  			c1 [t5] = ch [t5] + ch [t6];  			c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  		}  		t3 += ido;  		t4 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	for (k = 0; k < l1; k++) {  		t5 = t3;  		t6 = t4;  		for (i = 2; i < ido; i += 2) {  			t5 += 2;  			t6 += 2;  			c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  			c1 [t6 - 1] = ch [t5] - ch [t6];  			c1 [t5] = ch [t5] + ch [t6];  			c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  		}  		t3 += ido;  		t4 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = t3;  	t6 = t4;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 += 2;  		c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  		c1 [t6 - 1] = ch [t5] - ch [t6];  		c1 [t5] = ch [t5] + ch [t6];  		c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  	}  	t3 += ido;  	t4 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = t3;  	t6 = t4;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 += 2;  		c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  		c1 [t6 - 1] = ch [t5] - ch [t6];  		c1 [t5] = ch [t5] + ch [t6];  		c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  	}  	t3 += ido;  	t4 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = t3;  	t6 = t4;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 += 2;  		c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  		c1 [t6 - 1] = ch [t5] - ch [t6];  		c1 [t5] = ch [t5] + ch [t6];  		c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  	}  	t3 += ido;  	t4 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = t3;  	t6 = t4;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 += 2;  		c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  		c1 [t6 - 1] = ch [t5] - ch [t6];  		c1 [t5] = ch [t5] + ch [t6];  		c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  	}  	t3 += ido;  	t4 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 += 2;  	c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  	c1 [t6 - 1] = ch [t5] - ch [t6];  	c1 [t5] = ch [t5] + ch [t6];  	c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 += 2;  	c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  	c1 [t6 - 1] = ch [t5] - ch [t6];  	c1 [t5] = ch [t5] + ch [t6];  	c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 += 2;  	c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  	c1 [t6 - 1] = ch [t5] - ch [t6];  	c1 [t5] = ch [t5] + ch [t6];  	c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 += 2;  	c1 [t5 - 1] = ch [t5 - 1] + ch [t6 - 1];  	c1 [t6 - 1] = ch [t5] - ch [t6];  	c1 [t5] = ch [t5] + ch [t6];  	c1 [t6] = ch [t6 - 1] - ch [t5 - 1];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: i = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: i += 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: t5 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: t6 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (l = 1; l < ipph; l++) {  	t1 += idl1;  	t2 -= idl1;  	ar1h = dcp * ar1 - dsp * ai1;  	ai1 = dcp * ai1 + dsp * ar1;  	ar1 = ar1h;  	t4 = t1;  	t5 = t2;  	t6 = t3;  	t7 = idl1;  	for (ik = 0; ik < idl1; ik++) {  		ch2 [t4++] = c2 [ik] + ar1 * c2 [t7++];  		ch2 [t5++] = ai1 * c2 [t6++];  	}  	dc2 = ar1;  	ds2 = ai1;  	ar2 = ar1;  	ai2 = ai1;  	t4 = idl1;  	t5 = (ipp2 - 1) * idl1;  	for (j = 2; j < ipph; j++) {  		t4 += idl1;  		t5 -= idl1;  		ar2h = dc2 * ar2 - ds2 * ai2;  		ai2 = dc2 * ai2 + ds2 * ar2;  		ar2 = ar2h;  		t6 = t1;  		t7 = t2;  		t8 = t4;  		t9 = t5;  		for (ik = 0; ik < idl1; ik++) {  			ch2 [t6] += ar2 * c2 [t8++];  			t6++;  			ch2 [t7] += ai2 * c2 [t9++];  			t7++;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 2; j < ipph; j++) {  	t4 += idl1;  	t5 -= idl1;  	ar2h = dc2 * ar2 - ds2 * ai2;  	ai2 = dc2 * ai2 + ds2 * ar2;  	ar2 = ar2h;  	t6 = t1;  	t7 = t2;  	t8 = t4;  	t9 = t5;  	for (ik = 0; ik < idl1; ik++) {  		ch2 [t6] += ar2 * c2 [t8++];  		t6++;  		ch2 [t7] += ai2 * c2 [t9++];  		t7++;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: j = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t2;  	t3 += t2;  	t4 += t0;  	t5 -= t0;  	t6 = t1;  	t7 = t3;  	t8 = t4;  	t9 = t5;  	for (k = 0; k < l1; k++) {  		for (i = 2; i < ido; i += 2) {  			ic = idp2 - i;  			cc [i + t7 - 1] = ch [i + t8 - 1] + ch [i + t9 - 1];  			cc [ic + t6 - 1] = ch [i + t8 - 1] - ch [i + t9 - 1];  			cc [i + t7] = ch [i + t8] + ch [i + t9];  			cc [ic + t6] = ch [i + t9] - ch [i + t8];  		}  		t6 += t10;  		t7 += t10;  		t8 += ido;  		t9 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t2;  	t3 += t2;  	t4 += t0;  	t5 -= t0;  	t6 = t1;  	t7 = t3;  	t8 = t4;  	t9 = t5;  	for (k = 0; k < l1; k++) {  		for (i = 2; i < ido; i += 2) {  			ic = idp2 - i;  			cc [i + t7 - 1] = ch [i + t8 - 1] + ch [i + t9 - 1];  			cc [ic + t6 - 1] = ch [i + t8 - 1] - ch [i + t9 - 1];  			cc [i + t7] = ch [i + t8] + ch [i + t9];  			cc [ic + t6] = ch [i + t9] - ch [i + t8];  		}  		t6 += t10;  		t7 += t10;  		t8 += ido;  		t9 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	for (i = 2; i < ido; i += 2) {  		ic = idp2 - i;  		cc [i + t7 - 1] = ch [i + t8 - 1] + ch [i + t9 - 1];  		cc [ic + t6 - 1] = ch [i + t8 - 1] - ch [i + t9 - 1];  		cc [i + t7] = ch [i + t8] + ch [i + t9];  		cc [ic + t6] = ch [i + t9] - ch [i + t8];  	}  	t6 += t10;  	t7 += t10;  	t8 += ido;  	t9 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	for (i = 2; i < ido; i += 2) {  		ic = idp2 - i;  		cc [i + t7 - 1] = ch [i + t8 - 1] + ch [i + t9 - 1];  		cc [ic + t6 - 1] = ch [i + t8 - 1] - ch [i + t9 - 1];  		cc [i + t7] = ch [i + t8] + ch [i + t9];  		cc [ic + t6] = ch [i + t9] - ch [i + t8];  	}  	t6 += t10;  	t7 += t10;  	t8 += ido;  	t9 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	ic = idp2 - i;  	cc [i + t7 - 1] = ch [i + t8 - 1] + ch [i + t9 - 1];  	cc [ic + t6 - 1] = ch [i + t8 - 1] - ch [i + t9 - 1];  	cc [i + t7] = ch [i + t8] + ch [i + t9];  	cc [ic + t6] = ch [i + t9] - ch [i + t8];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	ic = idp2 - i;  	cc [i + t7 - 1] = ch [i + t8 - 1] + ch [i + t9 - 1];  	cc [ic + t6 - 1] = ch [i + t8 - 1] - ch [i + t9 - 1];  	cc [i + t7] = ch [i + t8] + ch [i + t9];  	cc [ic + t6] = ch [i + t9] - ch [i + t8];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: i = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: i += 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t2;  	t3 += t2;  	t4 += t0;  	t5 -= t0;  	for (i = 2; i < ido; i += 2) {  		t6 = idp2 + t1 - i;  		t7 = i + t3;  		t8 = i + t4;  		t9 = i + t5;  		for (k = 0; k < l1; k++) {  			cc [t7 - 1] = ch [t8 - 1] + ch [t9 - 1];  			cc [t6 - 1] = ch [t8 - 1] - ch [t9 - 1];  			cc [t7] = ch [t8] + ch [t9];  			cc [t6] = ch [t9] - ch [t8];  			t6 += t10;  			t7 += t10;  			t8 += ido;  			t9 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t2;  	t3 += t2;  	t4 += t0;  	t5 -= t0;  	for (i = 2; i < ido; i += 2) {  		t6 = idp2 + t1 - i;  		t7 = i + t3;  		t8 = i + t4;  		t9 = i + t5;  		for (k = 0; k < l1; k++) {  			cc [t7 - 1] = ch [t8 - 1] + ch [t9 - 1];  			cc [t6 - 1] = ch [t8 - 1] - ch [t9 - 1];  			cc [t7] = ch [t8] + ch [t9];  			cc [t6] = ch [t9] - ch [t8];  			t6 += t10;  			t7 += t10;  			t8 += ido;  			t9 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t6 = idp2 + t1 - i;  	t7 = i + t3;  	t8 = i + t4;  	t9 = i + t5;  	for (k = 0; k < l1; k++) {  		cc [t7 - 1] = ch [t8 - 1] + ch [t9 - 1];  		cc [t6 - 1] = ch [t8 - 1] - ch [t9 - 1];  		cc [t7] = ch [t8] + ch [t9];  		cc [t6] = ch [t9] - ch [t8];  		t6 += t10;  		t7 += t10;  		t8 += ido;  		t9 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t6 = idp2 + t1 - i;  	t7 = i + t3;  	t8 = i + t4;  	t9 = i + t5;  	for (k = 0; k < l1; k++) {  		cc [t7 - 1] = ch [t8 - 1] + ch [t9 - 1];  		cc [t6 - 1] = ch [t8 - 1] - ch [t9 - 1];  		cc [t7] = ch [t8] + ch [t9];  		cc [t6] = ch [t9] - ch [t8];  		t6 += t10;  		t7 += t10;  		t8 += ido;  		t9 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: i = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradfg,The following statement contains a magic number: i += 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drftf1,The following statement contains a magic number: for (k1 = 0; k1 < nf; k1++) {  	kh = nf - k1;  	ip = ifac [kh + 1];  	l1 = l2 / ip;  	ido = n / l2;  	idl1 = ido * l1;  	iw -= (ip - 1) * ido;  	na = 1 - na;  	if (ip != 4)  		goto L102;  	ix2 = iw + ido;  	ix3 = ix2 + ido;  	if (na != 0)  		dradf4 (ido' l1' ch' c' wa' iw - 1' wa' ix2 - 1' wa' ix3 - 1);  	else  		dradf4 (ido' l1' c' ch' wa' iw - 1' wa' ix2 - 1' wa' ix3 - 1);  	goto L110;  	L102:  	if (ip != 2)  		goto L104;  	if (na != 0)  		goto L103;  	dradf2 (ido' l1' c' ch' wa' iw - 1);  	goto L110;  	L103:  	dradf2 (ido' l1' ch' c' wa' iw - 1);  	goto L110;  	L104:  	if (ido == 1)  		na = 1 - na;  	if (na != 0)  		goto L109;  	dradfg (ido' ip' l1' idl1' c' c' c' ch' ch' wa' iw - 1);  	na = 1;  	goto L110;  	L109:  	dradfg (ido' ip' l1' idl1' ch' ch' ch' c' c' wa' iw - 1);  	na = 0;  	l2 = l1;  	break;  	L110:  	l2 = l1;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drftf1,The following statement contains a magic number: for (k1 = 0; k1 < nf; k1++) {  	kh = nf - k1;  	ip = ifac [kh + 1];  	l1 = l2 / ip;  	ido = n / l2;  	idl1 = ido * l1;  	iw -= (ip - 1) * ido;  	na = 1 - na;  	if (ip != 4)  		goto L102;  	ix2 = iw + ido;  	ix3 = ix2 + ido;  	if (na != 0)  		dradf4 (ido' l1' ch' c' wa' iw - 1' wa' ix2 - 1' wa' ix3 - 1);  	else  		dradf4 (ido' l1' c' ch' wa' iw - 1' wa' ix2 - 1' wa' ix3 - 1);  	goto L110;  	L102:  	if (ip != 2)  		goto L104;  	if (na != 0)  		goto L103;  	dradf2 (ido' l1' c' ch' wa' iw - 1);  	goto L110;  	L103:  	dradf2 (ido' l1' ch' c' wa' iw - 1);  	goto L110;  	L104:  	if (ido == 1)  		na = 1 - na;  	if (na != 0)  		goto L109;  	dradfg (ido' ip' l1' idl1' c' c' c' ch' ch' wa' iw - 1);  	na = 1;  	goto L110;  	L109:  	dradfg (ido' ip' l1' idl1' ch' ch' ch' c' c' wa' iw - 1);  	na = 0;  	l2 = l1;  	break;  	L110:  	l2 = l1;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drftf1,The following statement contains a magic number: if (ip != 4)  	goto L102;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drftf1,The following statement contains a magic number: if (ip != 2)  	goto L104;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: if (ido < 2)  	return;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: if (ido == 2)  	goto L105;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t3 = t1;  	t5 = (t4 = t2) + (ido << 1);  	t6 = t0 + t1;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t5 -= 2;  		t6 += 2;  		ch [t3 - 1] = cc [t4 - 1] + cc [t5 - 1];  		tr2 = cc [t4 - 1] - cc [t5 - 1];  		ch [t3] = cc [t4] - cc [t5];  		ti2 = cc [t4] + cc [t5];  		ch [t6 - 1] = wa1 [index + i - 2] * tr2 - wa1 [index + i - 1] * ti2;  		ch [t6] = wa1 [index + i - 2] * ti2 + wa1 [index + i - 1] * tr2;  	}  	t2 = (t1 += ido) << 1;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t3 = t1;  	t5 = (t4 = t2) + (ido << 1);  	t6 = t0 + t1;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t5 -= 2;  		t6 += 2;  		ch [t3 - 1] = cc [t4 - 1] + cc [t5 - 1];  		tr2 = cc [t4 - 1] - cc [t5 - 1];  		ch [t3] = cc [t4] - cc [t5];  		ti2 = cc [t4] + cc [t5];  		ch [t6 - 1] = wa1 [index + i - 2] * tr2 - wa1 [index + i - 1] * ti2;  		ch [t6] = wa1 [index + i - 2] * ti2 + wa1 [index + i - 1] * tr2;  	}  	t2 = (t1 += ido) << 1;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t3 = t1;  	t5 = (t4 = t2) + (ido << 1);  	t6 = t0 + t1;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t5 -= 2;  		t6 += 2;  		ch [t3 - 1] = cc [t4 - 1] + cc [t5 - 1];  		tr2 = cc [t4 - 1] - cc [t5 - 1];  		ch [t3] = cc [t4] - cc [t5];  		ti2 = cc [t4] + cc [t5];  		ch [t6 - 1] = wa1 [index + i - 2] * tr2 - wa1 [index + i - 1] * ti2;  		ch [t6] = wa1 [index + i - 2] * ti2 + wa1 [index + i - 1] * tr2;  	}  	t2 = (t1 += ido) << 1;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t3 = t1;  	t5 = (t4 = t2) + (ido << 1);  	t6 = t0 + t1;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t5 -= 2;  		t6 += 2;  		ch [t3 - 1] = cc [t4 - 1] + cc [t5 - 1];  		tr2 = cc [t4 - 1] - cc [t5 - 1];  		ch [t3] = cc [t4] - cc [t5];  		ti2 = cc [t4] + cc [t5];  		ch [t6 - 1] = wa1 [index + i - 2] * tr2 - wa1 [index + i - 1] * ti2;  		ch [t6] = wa1 [index + i - 2] * ti2 + wa1 [index + i - 1] * tr2;  	}  	t2 = (t1 += ido) << 1;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t3 = t1;  	t5 = (t4 = t2) + (ido << 1);  	t6 = t0 + t1;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t5 -= 2;  		t6 += 2;  		ch [t3 - 1] = cc [t4 - 1] + cc [t5 - 1];  		tr2 = cc [t4 - 1] - cc [t5 - 1];  		ch [t3] = cc [t4] - cc [t5];  		ti2 = cc [t4] + cc [t5];  		ch [t6 - 1] = wa1 [index + i - 2] * tr2 - wa1 [index + i - 1] * ti2;  		ch [t6] = wa1 [index + i - 2] * ti2 + wa1 [index + i - 1] * tr2;  	}  	t2 = (t1 += ido) << 1;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t3 = t1;  	t5 = (t4 = t2) + (ido << 1);  	t6 = t0 + t1;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t5 -= 2;  		t6 += 2;  		ch [t3 - 1] = cc [t4 - 1] + cc [t5 - 1];  		tr2 = cc [t4 - 1] - cc [t5 - 1];  		ch [t3] = cc [t4] - cc [t5];  		ti2 = cc [t4] + cc [t5];  		ch [t6 - 1] = wa1 [index + i - 2] * tr2 - wa1 [index + i - 1] * ti2;  		ch [t6] = wa1 [index + i - 2] * ti2 + wa1 [index + i - 1] * tr2;  	}  	t2 = (t1 += ido) << 1;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t3 = t1;  	t5 = (t4 = t2) + (ido << 1);  	t6 = t0 + t1;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t5 -= 2;  		t6 += 2;  		ch [t3 - 1] = cc [t4 - 1] + cc [t5 - 1];  		tr2 = cc [t4 - 1] - cc [t5 - 1];  		ch [t3] = cc [t4] - cc [t5];  		ti2 = cc [t4] + cc [t5];  		ch [t6 - 1] = wa1 [index + i - 2] * tr2 - wa1 [index + i - 1] * ti2;  		ch [t6] = wa1 [index + i - 2] * ti2 + wa1 [index + i - 1] * tr2;  	}  	t2 = (t1 += ido) << 1;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t3 = t1;  	t5 = (t4 = t2) + (ido << 1);  	t6 = t0 + t1;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t5 -= 2;  		t6 += 2;  		ch [t3 - 1] = cc [t4 - 1] + cc [t5 - 1];  		tr2 = cc [t4 - 1] - cc [t5 - 1];  		ch [t3] = cc [t4] - cc [t5];  		ti2 = cc [t4] + cc [t5];  		ch [t6 - 1] = wa1 [index + i - 2] * tr2 - wa1 [index + i - 1] * ti2;  		ch [t6] = wa1 [index + i - 2] * ti2 + wa1 [index + i - 1] * tr2;  	}  	t2 = (t1 += ido) << 1;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t5 -= 2;  	t6 += 2;  	ch [t3 - 1] = cc [t4 - 1] + cc [t5 - 1];  	tr2 = cc [t4 - 1] - cc [t5 - 1];  	ch [t3] = cc [t4] - cc [t5];  	ti2 = cc [t4] + cc [t5];  	ch [t6 - 1] = wa1 [index + i - 2] * tr2 - wa1 [index + i - 1] * ti2;  	ch [t6] = wa1 [index + i - 2] * ti2 + wa1 [index + i - 1] * tr2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t5 -= 2;  	t6 += 2;  	ch [t3 - 1] = cc [t4 - 1] + cc [t5 - 1];  	tr2 = cc [t4 - 1] - cc [t5 - 1];  	ch [t3] = cc [t4] - cc [t5];  	ti2 = cc [t4] + cc [t5];  	ch [t6 - 1] = wa1 [index + i - 2] * tr2 - wa1 [index + i - 1] * ti2;  	ch [t6] = wa1 [index + i - 2] * ti2 + wa1 [index + i - 1] * tr2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t5 -= 2;  	t6 += 2;  	ch [t3 - 1] = cc [t4 - 1] + cc [t5 - 1];  	tr2 = cc [t4 - 1] - cc [t5 - 1];  	ch [t3] = cc [t4] - cc [t5];  	ti2 = cc [t4] + cc [t5];  	ch [t6 - 1] = wa1 [index + i - 2] * tr2 - wa1 [index + i - 1] * ti2;  	ch [t6] = wa1 [index + i - 2] * ti2 + wa1 [index + i - 1] * tr2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t5 -= 2;  	t6 += 2;  	ch [t3 - 1] = cc [t4 - 1] + cc [t5 - 1];  	tr2 = cc [t4 - 1] - cc [t5 - 1];  	ch [t3] = cc [t4] - cc [t5];  	ti2 = cc [t4] + cc [t5];  	ch [t6 - 1] = wa1 [index + i - 2] * tr2 - wa1 [index + i - 1] * ti2;  	ch [t6] = wa1 [index + i - 2] * ti2 + wa1 [index + i - 1] * tr2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t5 -= 2;  	t6 += 2;  	ch [t3 - 1] = cc [t4 - 1] + cc [t5 - 1];  	tr2 = cc [t4 - 1] - cc [t5 - 1];  	ch [t3] = cc [t4] - cc [t5];  	ti2 = cc [t4] + cc [t5];  	ch [t6 - 1] = wa1 [index + i - 2] * tr2 - wa1 [index + i - 1] * ti2;  	ch [t6] = wa1 [index + i - 2] * ti2 + wa1 [index + i - 1] * tr2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t5 -= 2;  	t6 += 2;  	ch [t3 - 1] = cc [t4 - 1] + cc [t5 - 1];  	tr2 = cc [t4 - 1] - cc [t5 - 1];  	ch [t3] = cc [t4] - cc [t5];  	ti2 = cc [t4] + cc [t5];  	ch [t6 - 1] = wa1 [index + i - 2] * tr2 - wa1 [index + i - 1] * ti2;  	ch [t6] = wa1 [index + i - 2] * ti2 + wa1 [index + i - 1] * tr2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t5 -= 2;  	t6 += 2;  	ch [t3 - 1] = cc [t4 - 1] + cc [t5 - 1];  	tr2 = cc [t4 - 1] - cc [t5 - 1];  	ch [t3] = cc [t4] - cc [t5];  	ti2 = cc [t4] + cc [t5];  	ch [t6 - 1] = wa1 [index + i - 2] * tr2 - wa1 [index + i - 1] * ti2;  	ch [t6] = wa1 [index + i - 2] * ti2 + wa1 [index + i - 1] * tr2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t5 -= 2;  	t6 += 2;  	ch [t3 - 1] = cc [t4 - 1] + cc [t5 - 1];  	tr2 = cc [t4 - 1] - cc [t5 - 1];  	ch [t3] = cc [t4] - cc [t5];  	ti2 = cc [t4] + cc [t5];  	ch [t6 - 1] = wa1 [index + i - 2] * tr2 - wa1 [index + i - 1] * ti2;  	ch [t6] = wa1 [index + i - 2] * ti2 + wa1 [index + i - 1] * tr2;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: i = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: i += 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: t3 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: t4 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: t5 -= 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: t6 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: ch [t6 - 1] = wa1 [index + i - 2] * tr2 - wa1 [index + i - 1] * ti2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: ch [t6] = wa1 [index + i - 2] * ti2 + wa1 [index + i - 1] * tr2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb2,The following statement contains a magic number: if ((ido % 2) == 1)  	return;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t7 = t1 + (t1 << 1);  	t6 = (t5 = t7 + t3);  	t8 = t1;  	t10 = (t9 = t1 + t0) + t0;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 -= 2;  		t7 += 2;  		t8 += 2;  		t9 += 2;  		t10 += 2;  		tr2 = cc [t5 - 1] + cc [t6 - 1];  		cr2 = cc [t7 - 1] + (taur * tr2);  		ch [t8 - 1] = cc [t7 - 1] + tr2;  		ti2 = cc [t5] - cc [t6];  		ci2 = cc [t7] + (taur * ti2);  		ch [t8] = cc [t7] + ti2;  		cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  		ci3 = taui * (cc [t5] + cc [t6]);  		dr2 = cr2 - ci3;  		dr3 = cr2 + ci3;  		di2 = ci2 + cr3;  		di3 = ci2 - cr3;  		ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  		ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  		ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  		ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t7 = t1 + (t1 << 1);  	t6 = (t5 = t7 + t3);  	t8 = t1;  	t10 = (t9 = t1 + t0) + t0;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 -= 2;  		t7 += 2;  		t8 += 2;  		t9 += 2;  		t10 += 2;  		tr2 = cc [t5 - 1] + cc [t6 - 1];  		cr2 = cc [t7 - 1] + (taur * tr2);  		ch [t8 - 1] = cc [t7 - 1] + tr2;  		ti2 = cc [t5] - cc [t6];  		ci2 = cc [t7] + (taur * ti2);  		ch [t8] = cc [t7] + ti2;  		cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  		ci3 = taui * (cc [t5] + cc [t6]);  		dr2 = cr2 - ci3;  		dr3 = cr2 + ci3;  		di2 = ci2 + cr3;  		di3 = ci2 - cr3;  		ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  		ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  		ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  		ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t7 = t1 + (t1 << 1);  	t6 = (t5 = t7 + t3);  	t8 = t1;  	t10 = (t9 = t1 + t0) + t0;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 -= 2;  		t7 += 2;  		t8 += 2;  		t9 += 2;  		t10 += 2;  		tr2 = cc [t5 - 1] + cc [t6 - 1];  		cr2 = cc [t7 - 1] + (taur * tr2);  		ch [t8 - 1] = cc [t7 - 1] + tr2;  		ti2 = cc [t5] - cc [t6];  		ci2 = cc [t7] + (taur * ti2);  		ch [t8] = cc [t7] + ti2;  		cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  		ci3 = taui * (cc [t5] + cc [t6]);  		dr2 = cr2 - ci3;  		dr3 = cr2 + ci3;  		di2 = ci2 + cr3;  		di3 = ci2 - cr3;  		ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  		ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  		ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  		ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t7 = t1 + (t1 << 1);  	t6 = (t5 = t7 + t3);  	t8 = t1;  	t10 = (t9 = t1 + t0) + t0;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 -= 2;  		t7 += 2;  		t8 += 2;  		t9 += 2;  		t10 += 2;  		tr2 = cc [t5 - 1] + cc [t6 - 1];  		cr2 = cc [t7 - 1] + (taur * tr2);  		ch [t8 - 1] = cc [t7 - 1] + tr2;  		ti2 = cc [t5] - cc [t6];  		ci2 = cc [t7] + (taur * ti2);  		ch [t8] = cc [t7] + ti2;  		cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  		ci3 = taui * (cc [t5] + cc [t6]);  		dr2 = cr2 - ci3;  		dr3 = cr2 + ci3;  		di2 = ci2 + cr3;  		di3 = ci2 - cr3;  		ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  		ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  		ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  		ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t7 = t1 + (t1 << 1);  	t6 = (t5 = t7 + t3);  	t8 = t1;  	t10 = (t9 = t1 + t0) + t0;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 -= 2;  		t7 += 2;  		t8 += 2;  		t9 += 2;  		t10 += 2;  		tr2 = cc [t5 - 1] + cc [t6 - 1];  		cr2 = cc [t7 - 1] + (taur * tr2);  		ch [t8 - 1] = cc [t7 - 1] + tr2;  		ti2 = cc [t5] - cc [t6];  		ci2 = cc [t7] + (taur * ti2);  		ch [t8] = cc [t7] + ti2;  		cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  		ci3 = taui * (cc [t5] + cc [t6]);  		dr2 = cr2 - ci3;  		dr3 = cr2 + ci3;  		di2 = ci2 + cr3;  		di3 = ci2 - cr3;  		ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  		ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  		ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  		ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t7 = t1 + (t1 << 1);  	t6 = (t5 = t7 + t3);  	t8 = t1;  	t10 = (t9 = t1 + t0) + t0;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 -= 2;  		t7 += 2;  		t8 += 2;  		t9 += 2;  		t10 += 2;  		tr2 = cc [t5 - 1] + cc [t6 - 1];  		cr2 = cc [t7 - 1] + (taur * tr2);  		ch [t8 - 1] = cc [t7 - 1] + tr2;  		ti2 = cc [t5] - cc [t6];  		ci2 = cc [t7] + (taur * ti2);  		ch [t8] = cc [t7] + ti2;  		cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  		ci3 = taui * (cc [t5] + cc [t6]);  		dr2 = cr2 - ci3;  		dr3 = cr2 + ci3;  		di2 = ci2 + cr3;  		di3 = ci2 - cr3;  		ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  		ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  		ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  		ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t7 = t1 + (t1 << 1);  	t6 = (t5 = t7 + t3);  	t8 = t1;  	t10 = (t9 = t1 + t0) + t0;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 -= 2;  		t7 += 2;  		t8 += 2;  		t9 += 2;  		t10 += 2;  		tr2 = cc [t5 - 1] + cc [t6 - 1];  		cr2 = cc [t7 - 1] + (taur * tr2);  		ch [t8 - 1] = cc [t7 - 1] + tr2;  		ti2 = cc [t5] - cc [t6];  		ci2 = cc [t7] + (taur * ti2);  		ch [t8] = cc [t7] + ti2;  		cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  		ci3 = taui * (cc [t5] + cc [t6]);  		dr2 = cr2 - ci3;  		dr3 = cr2 + ci3;  		di2 = ci2 + cr3;  		di3 = ci2 - cr3;  		ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  		ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  		ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  		ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t7 = t1 + (t1 << 1);  	t6 = (t5 = t7 + t3);  	t8 = t1;  	t10 = (t9 = t1 + t0) + t0;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 -= 2;  		t7 += 2;  		t8 += 2;  		t9 += 2;  		t10 += 2;  		tr2 = cc [t5 - 1] + cc [t6 - 1];  		cr2 = cc [t7 - 1] + (taur * tr2);  		ch [t8 - 1] = cc [t7 - 1] + tr2;  		ti2 = cc [t5] - cc [t6];  		ci2 = cc [t7] + (taur * ti2);  		ch [t8] = cc [t7] + ti2;  		cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  		ci3 = taui * (cc [t5] + cc [t6]);  		dr2 = cr2 - ci3;  		dr3 = cr2 + ci3;  		di2 = ci2 + cr3;  		di3 = ci2 - cr3;  		ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  		ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  		ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  		ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t7 = t1 + (t1 << 1);  	t6 = (t5 = t7 + t3);  	t8 = t1;  	t10 = (t9 = t1 + t0) + t0;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 -= 2;  		t7 += 2;  		t8 += 2;  		t9 += 2;  		t10 += 2;  		tr2 = cc [t5 - 1] + cc [t6 - 1];  		cr2 = cc [t7 - 1] + (taur * tr2);  		ch [t8 - 1] = cc [t7 - 1] + tr2;  		ti2 = cc [t5] - cc [t6];  		ci2 = cc [t7] + (taur * ti2);  		ch [t8] = cc [t7] + ti2;  		cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  		ci3 = taui * (cc [t5] + cc [t6]);  		dr2 = cr2 - ci3;  		dr3 = cr2 + ci3;  		di2 = ci2 + cr3;  		di3 = ci2 - cr3;  		ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  		ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  		ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  		ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t7 = t1 + (t1 << 1);  	t6 = (t5 = t7 + t3);  	t8 = t1;  	t10 = (t9 = t1 + t0) + t0;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 -= 2;  		t7 += 2;  		t8 += 2;  		t9 += 2;  		t10 += 2;  		tr2 = cc [t5 - 1] + cc [t6 - 1];  		cr2 = cc [t7 - 1] + (taur * tr2);  		ch [t8 - 1] = cc [t7 - 1] + tr2;  		ti2 = cc [t5] - cc [t6];  		ci2 = cc [t7] + (taur * ti2);  		ch [t8] = cc [t7] + ti2;  		cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  		ci3 = taui * (cc [t5] + cc [t6]);  		dr2 = cr2 - ci3;  		dr3 = cr2 + ci3;  		di2 = ci2 + cr3;  		di3 = ci2 - cr3;  		ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  		ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  		ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  		ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t7 = t1 + (t1 << 1);  	t6 = (t5 = t7 + t3);  	t8 = t1;  	t10 = (t9 = t1 + t0) + t0;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 -= 2;  		t7 += 2;  		t8 += 2;  		t9 += 2;  		t10 += 2;  		tr2 = cc [t5 - 1] + cc [t6 - 1];  		cr2 = cc [t7 - 1] + (taur * tr2);  		ch [t8 - 1] = cc [t7 - 1] + tr2;  		ti2 = cc [t5] - cc [t6];  		ci2 = cc [t7] + (taur * ti2);  		ch [t8] = cc [t7] + ti2;  		cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  		ci3 = taui * (cc [t5] + cc [t6]);  		dr2 = cr2 - ci3;  		dr3 = cr2 + ci3;  		di2 = ci2 + cr3;  		di3 = ci2 - cr3;  		ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  		ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  		ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  		ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t7 = t1 + (t1 << 1);  	t6 = (t5 = t7 + t3);  	t8 = t1;  	t10 = (t9 = t1 + t0) + t0;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 -= 2;  		t7 += 2;  		t8 += 2;  		t9 += 2;  		t10 += 2;  		tr2 = cc [t5 - 1] + cc [t6 - 1];  		cr2 = cc [t7 - 1] + (taur * tr2);  		ch [t8 - 1] = cc [t7 - 1] + tr2;  		ti2 = cc [t5] - cc [t6];  		ci2 = cc [t7] + (taur * ti2);  		ch [t8] = cc [t7] + ti2;  		cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  		ci3 = taui * (cc [t5] + cc [t6]);  		dr2 = cr2 - ci3;  		dr3 = cr2 + ci3;  		di2 = ci2 + cr3;  		di3 = ci2 - cr3;  		ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  		ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  		ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  		ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 -= 2;  	t7 += 2;  	t8 += 2;  	t9 += 2;  	t10 += 2;  	tr2 = cc [t5 - 1] + cc [t6 - 1];  	cr2 = cc [t7 - 1] + (taur * tr2);  	ch [t8 - 1] = cc [t7 - 1] + tr2;  	ti2 = cc [t5] - cc [t6];  	ci2 = cc [t7] + (taur * ti2);  	ch [t8] = cc [t7] + ti2;  	cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  	ci3 = taui * (cc [t5] + cc [t6]);  	dr2 = cr2 - ci3;  	dr3 = cr2 + ci3;  	di2 = ci2 + cr3;  	di3 = ci2 - cr3;  	ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  	ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  	ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  	ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 -= 2;  	t7 += 2;  	t8 += 2;  	t9 += 2;  	t10 += 2;  	tr2 = cc [t5 - 1] + cc [t6 - 1];  	cr2 = cc [t7 - 1] + (taur * tr2);  	ch [t8 - 1] = cc [t7 - 1] + tr2;  	ti2 = cc [t5] - cc [t6];  	ci2 = cc [t7] + (taur * ti2);  	ch [t8] = cc [t7] + ti2;  	cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  	ci3 = taui * (cc [t5] + cc [t6]);  	dr2 = cr2 - ci3;  	dr3 = cr2 + ci3;  	di2 = ci2 + cr3;  	di3 = ci2 - cr3;  	ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  	ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  	ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  	ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 -= 2;  	t7 += 2;  	t8 += 2;  	t9 += 2;  	t10 += 2;  	tr2 = cc [t5 - 1] + cc [t6 - 1];  	cr2 = cc [t7 - 1] + (taur * tr2);  	ch [t8 - 1] = cc [t7 - 1] + tr2;  	ti2 = cc [t5] - cc [t6];  	ci2 = cc [t7] + (taur * ti2);  	ch [t8] = cc [t7] + ti2;  	cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  	ci3 = taui * (cc [t5] + cc [t6]);  	dr2 = cr2 - ci3;  	dr3 = cr2 + ci3;  	di2 = ci2 + cr3;  	di3 = ci2 - cr3;  	ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  	ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  	ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  	ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 -= 2;  	t7 += 2;  	t8 += 2;  	t9 += 2;  	t10 += 2;  	tr2 = cc [t5 - 1] + cc [t6 - 1];  	cr2 = cc [t7 - 1] + (taur * tr2);  	ch [t8 - 1] = cc [t7 - 1] + tr2;  	ti2 = cc [t5] - cc [t6];  	ci2 = cc [t7] + (taur * ti2);  	ch [t8] = cc [t7] + ti2;  	cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  	ci3 = taui * (cc [t5] + cc [t6]);  	dr2 = cr2 - ci3;  	dr3 = cr2 + ci3;  	di2 = ci2 + cr3;  	di3 = ci2 - cr3;  	ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  	ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  	ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  	ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 -= 2;  	t7 += 2;  	t8 += 2;  	t9 += 2;  	t10 += 2;  	tr2 = cc [t5 - 1] + cc [t6 - 1];  	cr2 = cc [t7 - 1] + (taur * tr2);  	ch [t8 - 1] = cc [t7 - 1] + tr2;  	ti2 = cc [t5] - cc [t6];  	ci2 = cc [t7] + (taur * ti2);  	ch [t8] = cc [t7] + ti2;  	cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  	ci3 = taui * (cc [t5] + cc [t6]);  	dr2 = cr2 - ci3;  	dr3 = cr2 + ci3;  	di2 = ci2 + cr3;  	di3 = ci2 - cr3;  	ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  	ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  	ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  	ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 -= 2;  	t7 += 2;  	t8 += 2;  	t9 += 2;  	t10 += 2;  	tr2 = cc [t5 - 1] + cc [t6 - 1];  	cr2 = cc [t7 - 1] + (taur * tr2);  	ch [t8 - 1] = cc [t7 - 1] + tr2;  	ti2 = cc [t5] - cc [t6];  	ci2 = cc [t7] + (taur * ti2);  	ch [t8] = cc [t7] + ti2;  	cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  	ci3 = taui * (cc [t5] + cc [t6]);  	dr2 = cr2 - ci3;  	dr3 = cr2 + ci3;  	di2 = ci2 + cr3;  	di3 = ci2 - cr3;  	ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  	ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  	ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  	ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 -= 2;  	t7 += 2;  	t8 += 2;  	t9 += 2;  	t10 += 2;  	tr2 = cc [t5 - 1] + cc [t6 - 1];  	cr2 = cc [t7 - 1] + (taur * tr2);  	ch [t8 - 1] = cc [t7 - 1] + tr2;  	ti2 = cc [t5] - cc [t6];  	ci2 = cc [t7] + (taur * ti2);  	ch [t8] = cc [t7] + ti2;  	cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  	ci3 = taui * (cc [t5] + cc [t6]);  	dr2 = cr2 - ci3;  	dr3 = cr2 + ci3;  	di2 = ci2 + cr3;  	di3 = ci2 - cr3;  	ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  	ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  	ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  	ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 -= 2;  	t7 += 2;  	t8 += 2;  	t9 += 2;  	t10 += 2;  	tr2 = cc [t5 - 1] + cc [t6 - 1];  	cr2 = cc [t7 - 1] + (taur * tr2);  	ch [t8 - 1] = cc [t7 - 1] + tr2;  	ti2 = cc [t5] - cc [t6];  	ci2 = cc [t7] + (taur * ti2);  	ch [t8] = cc [t7] + ti2;  	cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  	ci3 = taui * (cc [t5] + cc [t6]);  	dr2 = cr2 - ci3;  	dr3 = cr2 + ci3;  	di2 = ci2 + cr3;  	di3 = ci2 - cr3;  	ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  	ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  	ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  	ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 -= 2;  	t7 += 2;  	t8 += 2;  	t9 += 2;  	t10 += 2;  	tr2 = cc [t5 - 1] + cc [t6 - 1];  	cr2 = cc [t7 - 1] + (taur * tr2);  	ch [t8 - 1] = cc [t7 - 1] + tr2;  	ti2 = cc [t5] - cc [t6];  	ci2 = cc [t7] + (taur * ti2);  	ch [t8] = cc [t7] + ti2;  	cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  	ci3 = taui * (cc [t5] + cc [t6]);  	dr2 = cr2 - ci3;  	dr3 = cr2 + ci3;  	di2 = ci2 + cr3;  	di3 = ci2 - cr3;  	ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  	ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  	ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  	ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 -= 2;  	t7 += 2;  	t8 += 2;  	t9 += 2;  	t10 += 2;  	tr2 = cc [t5 - 1] + cc [t6 - 1];  	cr2 = cc [t7 - 1] + (taur * tr2);  	ch [t8 - 1] = cc [t7 - 1] + tr2;  	ti2 = cc [t5] - cc [t6];  	ci2 = cc [t7] + (taur * ti2);  	ch [t8] = cc [t7] + ti2;  	cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  	ci3 = taui * (cc [t5] + cc [t6]);  	dr2 = cr2 - ci3;  	dr3 = cr2 + ci3;  	di2 = ci2 + cr3;  	di3 = ci2 - cr3;  	ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  	ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  	ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  	ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 -= 2;  	t7 += 2;  	t8 += 2;  	t9 += 2;  	t10 += 2;  	tr2 = cc [t5 - 1] + cc [t6 - 1];  	cr2 = cc [t7 - 1] + (taur * tr2);  	ch [t8 - 1] = cc [t7 - 1] + tr2;  	ti2 = cc [t5] - cc [t6];  	ci2 = cc [t7] + (taur * ti2);  	ch [t8] = cc [t7] + ti2;  	cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  	ci3 = taui * (cc [t5] + cc [t6]);  	dr2 = cr2 - ci3;  	dr3 = cr2 + ci3;  	di2 = ci2 + cr3;  	di3 = ci2 - cr3;  	ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  	ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  	ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  	ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 -= 2;  	t7 += 2;  	t8 += 2;  	t9 += 2;  	t10 += 2;  	tr2 = cc [t5 - 1] + cc [t6 - 1];  	cr2 = cc [t7 - 1] + (taur * tr2);  	ch [t8 - 1] = cc [t7 - 1] + tr2;  	ti2 = cc [t5] - cc [t6];  	ci2 = cc [t7] + (taur * ti2);  	ch [t8] = cc [t7] + ti2;  	cr3 = taui * (cc [t5 - 1] - cc [t6 - 1]);  	ci3 = taui * (cc [t5] + cc [t6]);  	dr2 = cr2 - ci3;  	dr3 = cr2 + ci3;  	di2 = ci2 + cr3;  	di3 = ci2 - cr3;  	ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  	ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  	ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  	ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: i = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: i += 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: t5 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: t6 -= 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: t7 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: t8 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: t9 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: t10 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: ch [t9 - 1] = wa1 [index1 + i - 2] * dr2 - wa1 [index1 + i - 1] * di2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: ch [t9] = wa1 [index1 + i - 2] * di2 + wa1 [index1 + i - 1] * dr2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: ch [t10 - 1] = wa2 [index2 + i - 2] * dr3 - wa2 [index2 + i - 1] * di3;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb3,The following statement contains a magic number: ch [t10] = wa2 [index2 + i - 2] * di3 + wa2 [index2 + i - 1] * dr3;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: t2 = ido << 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: if (ido < 2)  	return;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: if (ido == 2)  	goto L105;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = (t4 = (t3 = (t2 = t1 << 2) + t6)) + t6;  	t7 = t1;  	for (i = 2; i < ido; i += 2) {  		t2 += 2;  		t3 += 2;  		t4 -= 2;  		t5 -= 2;  		t7 += 2;  		ti1 = cc [t2] + cc [t5];  		ti2 = cc [t2] - cc [t5];  		ti3 = cc [t3] - cc [t4];  		tr4 = cc [t3] + cc [t4];  		tr1 = cc [t2 - 1] - cc [t5 - 1];  		tr2 = cc [t2 - 1] + cc [t5 - 1];  		ti4 = cc [t3 - 1] - cc [t4 - 1];  		tr3 = cc [t3 - 1] + cc [t4 - 1];  		ch [t7 - 1] = tr2 + tr3;  		cr3 = tr2 - tr3;  		ch [t7] = ti2 + ti3;  		ci3 = ti2 - ti3;  		cr2 = tr1 - tr4;  		cr4 = tr1 + tr4;  		ci2 = ti1 + ti4;  		ci4 = ti1 - ti4;  		ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  		ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  		ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  		ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  		ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  		ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = (t4 = (t3 = (t2 = t1 << 2) + t6)) + t6;  	t7 = t1;  	for (i = 2; i < ido; i += 2) {  		t2 += 2;  		t3 += 2;  		t4 -= 2;  		t5 -= 2;  		t7 += 2;  		ti1 = cc [t2] + cc [t5];  		ti2 = cc [t2] - cc [t5];  		ti3 = cc [t3] - cc [t4];  		tr4 = cc [t3] + cc [t4];  		tr1 = cc [t2 - 1] - cc [t5 - 1];  		tr2 = cc [t2 - 1] + cc [t5 - 1];  		ti4 = cc [t3 - 1] - cc [t4 - 1];  		tr3 = cc [t3 - 1] + cc [t4 - 1];  		ch [t7 - 1] = tr2 + tr3;  		cr3 = tr2 - tr3;  		ch [t7] = ti2 + ti3;  		ci3 = ti2 - ti3;  		cr2 = tr1 - tr4;  		cr4 = tr1 + tr4;  		ci2 = ti1 + ti4;  		ci4 = ti1 - ti4;  		ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  		ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  		ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  		ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  		ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  		ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = (t4 = (t3 = (t2 = t1 << 2) + t6)) + t6;  	t7 = t1;  	for (i = 2; i < ido; i += 2) {  		t2 += 2;  		t3 += 2;  		t4 -= 2;  		t5 -= 2;  		t7 += 2;  		ti1 = cc [t2] + cc [t5];  		ti2 = cc [t2] - cc [t5];  		ti3 = cc [t3] - cc [t4];  		tr4 = cc [t3] + cc [t4];  		tr1 = cc [t2 - 1] - cc [t5 - 1];  		tr2 = cc [t2 - 1] + cc [t5 - 1];  		ti4 = cc [t3 - 1] - cc [t4 - 1];  		tr3 = cc [t3 - 1] + cc [t4 - 1];  		ch [t7 - 1] = tr2 + tr3;  		cr3 = tr2 - tr3;  		ch [t7] = ti2 + ti3;  		ci3 = ti2 - ti3;  		cr2 = tr1 - tr4;  		cr4 = tr1 + tr4;  		ci2 = ti1 + ti4;  		ci4 = ti1 - ti4;  		ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  		ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  		ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  		ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  		ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  		ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = (t4 = (t3 = (t2 = t1 << 2) + t6)) + t6;  	t7 = t1;  	for (i = 2; i < ido; i += 2) {  		t2 += 2;  		t3 += 2;  		t4 -= 2;  		t5 -= 2;  		t7 += 2;  		ti1 = cc [t2] + cc [t5];  		ti2 = cc [t2] - cc [t5];  		ti3 = cc [t3] - cc [t4];  		tr4 = cc [t3] + cc [t4];  		tr1 = cc [t2 - 1] - cc [t5 - 1];  		tr2 = cc [t2 - 1] + cc [t5 - 1];  		ti4 = cc [t3 - 1] - cc [t4 - 1];  		tr3 = cc [t3 - 1] + cc [t4 - 1];  		ch [t7 - 1] = tr2 + tr3;  		cr3 = tr2 - tr3;  		ch [t7] = ti2 + ti3;  		ci3 = ti2 - ti3;  		cr2 = tr1 - tr4;  		cr4 = tr1 + tr4;  		ci2 = ti1 + ti4;  		ci4 = ti1 - ti4;  		ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  		ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  		ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  		ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  		ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  		ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = (t4 = (t3 = (t2 = t1 << 2) + t6)) + t6;  	t7 = t1;  	for (i = 2; i < ido; i += 2) {  		t2 += 2;  		t3 += 2;  		t4 -= 2;  		t5 -= 2;  		t7 += 2;  		ti1 = cc [t2] + cc [t5];  		ti2 = cc [t2] - cc [t5];  		ti3 = cc [t3] - cc [t4];  		tr4 = cc [t3] + cc [t4];  		tr1 = cc [t2 - 1] - cc [t5 - 1];  		tr2 = cc [t2 - 1] + cc [t5 - 1];  		ti4 = cc [t3 - 1] - cc [t4 - 1];  		tr3 = cc [t3 - 1] + cc [t4 - 1];  		ch [t7 - 1] = tr2 + tr3;  		cr3 = tr2 - tr3;  		ch [t7] = ti2 + ti3;  		ci3 = ti2 - ti3;  		cr2 = tr1 - tr4;  		cr4 = tr1 + tr4;  		ci2 = ti1 + ti4;  		ci4 = ti1 - ti4;  		ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  		ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  		ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  		ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  		ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  		ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = (t4 = (t3 = (t2 = t1 << 2) + t6)) + t6;  	t7 = t1;  	for (i = 2; i < ido; i += 2) {  		t2 += 2;  		t3 += 2;  		t4 -= 2;  		t5 -= 2;  		t7 += 2;  		ti1 = cc [t2] + cc [t5];  		ti2 = cc [t2] - cc [t5];  		ti3 = cc [t3] - cc [t4];  		tr4 = cc [t3] + cc [t4];  		tr1 = cc [t2 - 1] - cc [t5 - 1];  		tr2 = cc [t2 - 1] + cc [t5 - 1];  		ti4 = cc [t3 - 1] - cc [t4 - 1];  		tr3 = cc [t3 - 1] + cc [t4 - 1];  		ch [t7 - 1] = tr2 + tr3;  		cr3 = tr2 - tr3;  		ch [t7] = ti2 + ti3;  		ci3 = ti2 - ti3;  		cr2 = tr1 - tr4;  		cr4 = tr1 + tr4;  		ci2 = ti1 + ti4;  		ci4 = ti1 - ti4;  		ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  		ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  		ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  		ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  		ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  		ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = (t4 = (t3 = (t2 = t1 << 2) + t6)) + t6;  	t7 = t1;  	for (i = 2; i < ido; i += 2) {  		t2 += 2;  		t3 += 2;  		t4 -= 2;  		t5 -= 2;  		t7 += 2;  		ti1 = cc [t2] + cc [t5];  		ti2 = cc [t2] - cc [t5];  		ti3 = cc [t3] - cc [t4];  		tr4 = cc [t3] + cc [t4];  		tr1 = cc [t2 - 1] - cc [t5 - 1];  		tr2 = cc [t2 - 1] + cc [t5 - 1];  		ti4 = cc [t3 - 1] - cc [t4 - 1];  		tr3 = cc [t3 - 1] + cc [t4 - 1];  		ch [t7 - 1] = tr2 + tr3;  		cr3 = tr2 - tr3;  		ch [t7] = ti2 + ti3;  		ci3 = ti2 - ti3;  		cr2 = tr1 - tr4;  		cr4 = tr1 + tr4;  		ci2 = ti1 + ti4;  		ci4 = ti1 - ti4;  		ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  		ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  		ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  		ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  		ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  		ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = (t4 = (t3 = (t2 = t1 << 2) + t6)) + t6;  	t7 = t1;  	for (i = 2; i < ido; i += 2) {  		t2 += 2;  		t3 += 2;  		t4 -= 2;  		t5 -= 2;  		t7 += 2;  		ti1 = cc [t2] + cc [t5];  		ti2 = cc [t2] - cc [t5];  		ti3 = cc [t3] - cc [t4];  		tr4 = cc [t3] + cc [t4];  		tr1 = cc [t2 - 1] - cc [t5 - 1];  		tr2 = cc [t2 - 1] + cc [t5 - 1];  		ti4 = cc [t3 - 1] - cc [t4 - 1];  		tr3 = cc [t3 - 1] + cc [t4 - 1];  		ch [t7 - 1] = tr2 + tr3;  		cr3 = tr2 - tr3;  		ch [t7] = ti2 + ti3;  		ci3 = ti2 - ti3;  		cr2 = tr1 - tr4;  		cr4 = tr1 + tr4;  		ci2 = ti1 + ti4;  		ci4 = ti1 - ti4;  		ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  		ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  		ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  		ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  		ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  		ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = (t4 = (t3 = (t2 = t1 << 2) + t6)) + t6;  	t7 = t1;  	for (i = 2; i < ido; i += 2) {  		t2 += 2;  		t3 += 2;  		t4 -= 2;  		t5 -= 2;  		t7 += 2;  		ti1 = cc [t2] + cc [t5];  		ti2 = cc [t2] - cc [t5];  		ti3 = cc [t3] - cc [t4];  		tr4 = cc [t3] + cc [t4];  		tr1 = cc [t2 - 1] - cc [t5 - 1];  		tr2 = cc [t2 - 1] + cc [t5 - 1];  		ti4 = cc [t3 - 1] - cc [t4 - 1];  		tr3 = cc [t3 - 1] + cc [t4 - 1];  		ch [t7 - 1] = tr2 + tr3;  		cr3 = tr2 - tr3;  		ch [t7] = ti2 + ti3;  		ci3 = ti2 - ti3;  		cr2 = tr1 - tr4;  		cr4 = tr1 + tr4;  		ci2 = ti1 + ti4;  		ci4 = ti1 - ti4;  		ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  		ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  		ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  		ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  		ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  		ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = (t4 = (t3 = (t2 = t1 << 2) + t6)) + t6;  	t7 = t1;  	for (i = 2; i < ido; i += 2) {  		t2 += 2;  		t3 += 2;  		t4 -= 2;  		t5 -= 2;  		t7 += 2;  		ti1 = cc [t2] + cc [t5];  		ti2 = cc [t2] - cc [t5];  		ti3 = cc [t3] - cc [t4];  		tr4 = cc [t3] + cc [t4];  		tr1 = cc [t2 - 1] - cc [t5 - 1];  		tr2 = cc [t2 - 1] + cc [t5 - 1];  		ti4 = cc [t3 - 1] - cc [t4 - 1];  		tr3 = cc [t3 - 1] + cc [t4 - 1];  		ch [t7 - 1] = tr2 + tr3;  		cr3 = tr2 - tr3;  		ch [t7] = ti2 + ti3;  		ci3 = ti2 - ti3;  		cr2 = tr1 - tr4;  		cr4 = tr1 + tr4;  		ci2 = ti1 + ti4;  		ci4 = ti1 - ti4;  		ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  		ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  		ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  		ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  		ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  		ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = (t4 = (t3 = (t2 = t1 << 2) + t6)) + t6;  	t7 = t1;  	for (i = 2; i < ido; i += 2) {  		t2 += 2;  		t3 += 2;  		t4 -= 2;  		t5 -= 2;  		t7 += 2;  		ti1 = cc [t2] + cc [t5];  		ti2 = cc [t2] - cc [t5];  		ti3 = cc [t3] - cc [t4];  		tr4 = cc [t3] + cc [t4];  		tr1 = cc [t2 - 1] - cc [t5 - 1];  		tr2 = cc [t2 - 1] + cc [t5 - 1];  		ti4 = cc [t3 - 1] - cc [t4 - 1];  		tr3 = cc [t3 - 1] + cc [t4 - 1];  		ch [t7 - 1] = tr2 + tr3;  		cr3 = tr2 - tr3;  		ch [t7] = ti2 + ti3;  		ci3 = ti2 - ti3;  		cr2 = tr1 - tr4;  		cr4 = tr1 + tr4;  		ci2 = ti1 + ti4;  		ci4 = ti1 - ti4;  		ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  		ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  		ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  		ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  		ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  		ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = (t4 = (t3 = (t2 = t1 << 2) + t6)) + t6;  	t7 = t1;  	for (i = 2; i < ido; i += 2) {  		t2 += 2;  		t3 += 2;  		t4 -= 2;  		t5 -= 2;  		t7 += 2;  		ti1 = cc [t2] + cc [t5];  		ti2 = cc [t2] - cc [t5];  		ti3 = cc [t3] - cc [t4];  		tr4 = cc [t3] + cc [t4];  		tr1 = cc [t2 - 1] - cc [t5 - 1];  		tr2 = cc [t2 - 1] + cc [t5 - 1];  		ti4 = cc [t3 - 1] - cc [t4 - 1];  		tr3 = cc [t3 - 1] + cc [t4 - 1];  		ch [t7 - 1] = tr2 + tr3;  		cr3 = tr2 - tr3;  		ch [t7] = ti2 + ti3;  		ci3 = ti2 - ti3;  		cr2 = tr1 - tr4;  		cr4 = tr1 + tr4;  		ci2 = ti1 + ti4;  		ci4 = ti1 - ti4;  		ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  		ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  		ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  		ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  		ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  		ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = (t4 = (t3 = (t2 = t1 << 2) + t6)) + t6;  	t7 = t1;  	for (i = 2; i < ido; i += 2) {  		t2 += 2;  		t3 += 2;  		t4 -= 2;  		t5 -= 2;  		t7 += 2;  		ti1 = cc [t2] + cc [t5];  		ti2 = cc [t2] - cc [t5];  		ti3 = cc [t3] - cc [t4];  		tr4 = cc [t3] + cc [t4];  		tr1 = cc [t2 - 1] - cc [t5 - 1];  		tr2 = cc [t2 - 1] + cc [t5 - 1];  		ti4 = cc [t3 - 1] - cc [t4 - 1];  		tr3 = cc [t3 - 1] + cc [t4 - 1];  		ch [t7 - 1] = tr2 + tr3;  		cr3 = tr2 - tr3;  		ch [t7] = ti2 + ti3;  		ci3 = ti2 - ti3;  		cr2 = tr1 - tr4;  		cr4 = tr1 + tr4;  		ci2 = ti1 + ti4;  		ci4 = ti1 - ti4;  		ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  		ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  		ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  		ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  		ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  		ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = (t4 = (t3 = (t2 = t1 << 2) + t6)) + t6;  	t7 = t1;  	for (i = 2; i < ido; i += 2) {  		t2 += 2;  		t3 += 2;  		t4 -= 2;  		t5 -= 2;  		t7 += 2;  		ti1 = cc [t2] + cc [t5];  		ti2 = cc [t2] - cc [t5];  		ti3 = cc [t3] - cc [t4];  		tr4 = cc [t3] + cc [t4];  		tr1 = cc [t2 - 1] - cc [t5 - 1];  		tr2 = cc [t2 - 1] + cc [t5 - 1];  		ti4 = cc [t3 - 1] - cc [t4 - 1];  		tr3 = cc [t3 - 1] + cc [t4 - 1];  		ch [t7 - 1] = tr2 + tr3;  		cr3 = tr2 - tr3;  		ch [t7] = ti2 + ti3;  		ci3 = ti2 - ti3;  		cr2 = tr1 - tr4;  		cr4 = tr1 + tr4;  		ci2 = ti1 + ti4;  		ci4 = ti1 - ti4;  		ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  		ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  		ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  		ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  		ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  		ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  	}  	t1 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: t5 = (t4 = (t3 = (t2 = t1 << 2) + t6)) + t6;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t2 += 2;  	t3 += 2;  	t4 -= 2;  	t5 -= 2;  	t7 += 2;  	ti1 = cc [t2] + cc [t5];  	ti2 = cc [t2] - cc [t5];  	ti3 = cc [t3] - cc [t4];  	tr4 = cc [t3] + cc [t4];  	tr1 = cc [t2 - 1] - cc [t5 - 1];  	tr2 = cc [t2 - 1] + cc [t5 - 1];  	ti4 = cc [t3 - 1] - cc [t4 - 1];  	tr3 = cc [t3 - 1] + cc [t4 - 1];  	ch [t7 - 1] = tr2 + tr3;  	cr3 = tr2 - tr3;  	ch [t7] = ti2 + ti3;  	ci3 = ti2 - ti3;  	cr2 = tr1 - tr4;  	cr4 = tr1 + tr4;  	ci2 = ti1 + ti4;  	ci4 = ti1 - ti4;  	ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  	ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  	ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  	ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  	ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  	ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t2 += 2;  	t3 += 2;  	t4 -= 2;  	t5 -= 2;  	t7 += 2;  	ti1 = cc [t2] + cc [t5];  	ti2 = cc [t2] - cc [t5];  	ti3 = cc [t3] - cc [t4];  	tr4 = cc [t3] + cc [t4];  	tr1 = cc [t2 - 1] - cc [t5 - 1];  	tr2 = cc [t2 - 1] + cc [t5 - 1];  	ti4 = cc [t3 - 1] - cc [t4 - 1];  	tr3 = cc [t3 - 1] + cc [t4 - 1];  	ch [t7 - 1] = tr2 + tr3;  	cr3 = tr2 - tr3;  	ch [t7] = ti2 + ti3;  	ci3 = ti2 - ti3;  	cr2 = tr1 - tr4;  	cr4 = tr1 + tr4;  	ci2 = ti1 + ti4;  	ci4 = ti1 - ti4;  	ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  	ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  	ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  	ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  	ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  	ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t2 += 2;  	t3 += 2;  	t4 -= 2;  	t5 -= 2;  	t7 += 2;  	ti1 = cc [t2] + cc [t5];  	ti2 = cc [t2] - cc [t5];  	ti3 = cc [t3] - cc [t4];  	tr4 = cc [t3] + cc [t4];  	tr1 = cc [t2 - 1] - cc [t5 - 1];  	tr2 = cc [t2 - 1] + cc [t5 - 1];  	ti4 = cc [t3 - 1] - cc [t4 - 1];  	tr3 = cc [t3 - 1] + cc [t4 - 1];  	ch [t7 - 1] = tr2 + tr3;  	cr3 = tr2 - tr3;  	ch [t7] = ti2 + ti3;  	ci3 = ti2 - ti3;  	cr2 = tr1 - tr4;  	cr4 = tr1 + tr4;  	ci2 = ti1 + ti4;  	ci4 = ti1 - ti4;  	ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  	ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  	ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  	ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  	ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  	ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t2 += 2;  	t3 += 2;  	t4 -= 2;  	t5 -= 2;  	t7 += 2;  	ti1 = cc [t2] + cc [t5];  	ti2 = cc [t2] - cc [t5];  	ti3 = cc [t3] - cc [t4];  	tr4 = cc [t3] + cc [t4];  	tr1 = cc [t2 - 1] - cc [t5 - 1];  	tr2 = cc [t2 - 1] + cc [t5 - 1];  	ti4 = cc [t3 - 1] - cc [t4 - 1];  	tr3 = cc [t3 - 1] + cc [t4 - 1];  	ch [t7 - 1] = tr2 + tr3;  	cr3 = tr2 - tr3;  	ch [t7] = ti2 + ti3;  	ci3 = ti2 - ti3;  	cr2 = tr1 - tr4;  	cr4 = tr1 + tr4;  	ci2 = ti1 + ti4;  	ci4 = ti1 - ti4;  	ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  	ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  	ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  	ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  	ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  	ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t2 += 2;  	t3 += 2;  	t4 -= 2;  	t5 -= 2;  	t7 += 2;  	ti1 = cc [t2] + cc [t5];  	ti2 = cc [t2] - cc [t5];  	ti3 = cc [t3] - cc [t4];  	tr4 = cc [t3] + cc [t4];  	tr1 = cc [t2 - 1] - cc [t5 - 1];  	tr2 = cc [t2 - 1] + cc [t5 - 1];  	ti4 = cc [t3 - 1] - cc [t4 - 1];  	tr3 = cc [t3 - 1] + cc [t4 - 1];  	ch [t7 - 1] = tr2 + tr3;  	cr3 = tr2 - tr3;  	ch [t7] = ti2 + ti3;  	ci3 = ti2 - ti3;  	cr2 = tr1 - tr4;  	cr4 = tr1 + tr4;  	ci2 = ti1 + ti4;  	ci4 = ti1 - ti4;  	ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  	ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  	ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  	ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  	ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  	ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t2 += 2;  	t3 += 2;  	t4 -= 2;  	t5 -= 2;  	t7 += 2;  	ti1 = cc [t2] + cc [t5];  	ti2 = cc [t2] - cc [t5];  	ti3 = cc [t3] - cc [t4];  	tr4 = cc [t3] + cc [t4];  	tr1 = cc [t2 - 1] - cc [t5 - 1];  	tr2 = cc [t2 - 1] + cc [t5 - 1];  	ti4 = cc [t3 - 1] - cc [t4 - 1];  	tr3 = cc [t3 - 1] + cc [t4 - 1];  	ch [t7 - 1] = tr2 + tr3;  	cr3 = tr2 - tr3;  	ch [t7] = ti2 + ti3;  	ci3 = ti2 - ti3;  	cr2 = tr1 - tr4;  	cr4 = tr1 + tr4;  	ci2 = ti1 + ti4;  	ci4 = ti1 - ti4;  	ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  	ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  	ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  	ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  	ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  	ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t2 += 2;  	t3 += 2;  	t4 -= 2;  	t5 -= 2;  	t7 += 2;  	ti1 = cc [t2] + cc [t5];  	ti2 = cc [t2] - cc [t5];  	ti3 = cc [t3] - cc [t4];  	tr4 = cc [t3] + cc [t4];  	tr1 = cc [t2 - 1] - cc [t5 - 1];  	tr2 = cc [t2 - 1] + cc [t5 - 1];  	ti4 = cc [t3 - 1] - cc [t4 - 1];  	tr3 = cc [t3 - 1] + cc [t4 - 1];  	ch [t7 - 1] = tr2 + tr3;  	cr3 = tr2 - tr3;  	ch [t7] = ti2 + ti3;  	ci3 = ti2 - ti3;  	cr2 = tr1 - tr4;  	cr4 = tr1 + tr4;  	ci2 = ti1 + ti4;  	ci4 = ti1 - ti4;  	ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  	ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  	ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  	ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  	ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  	ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t2 += 2;  	t3 += 2;  	t4 -= 2;  	t5 -= 2;  	t7 += 2;  	ti1 = cc [t2] + cc [t5];  	ti2 = cc [t2] - cc [t5];  	ti3 = cc [t3] - cc [t4];  	tr4 = cc [t3] + cc [t4];  	tr1 = cc [t2 - 1] - cc [t5 - 1];  	tr2 = cc [t2 - 1] + cc [t5 - 1];  	ti4 = cc [t3 - 1] - cc [t4 - 1];  	tr3 = cc [t3 - 1] + cc [t4 - 1];  	ch [t7 - 1] = tr2 + tr3;  	cr3 = tr2 - tr3;  	ch [t7] = ti2 + ti3;  	ci3 = ti2 - ti3;  	cr2 = tr1 - tr4;  	cr4 = tr1 + tr4;  	ci2 = ti1 + ti4;  	ci4 = ti1 - ti4;  	ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  	ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  	ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  	ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  	ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  	ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t2 += 2;  	t3 += 2;  	t4 -= 2;  	t5 -= 2;  	t7 += 2;  	ti1 = cc [t2] + cc [t5];  	ti2 = cc [t2] - cc [t5];  	ti3 = cc [t3] - cc [t4];  	tr4 = cc [t3] + cc [t4];  	tr1 = cc [t2 - 1] - cc [t5 - 1];  	tr2 = cc [t2 - 1] + cc [t5 - 1];  	ti4 = cc [t3 - 1] - cc [t4 - 1];  	tr3 = cc [t3 - 1] + cc [t4 - 1];  	ch [t7 - 1] = tr2 + tr3;  	cr3 = tr2 - tr3;  	ch [t7] = ti2 + ti3;  	ci3 = ti2 - ti3;  	cr2 = tr1 - tr4;  	cr4 = tr1 + tr4;  	ci2 = ti1 + ti4;  	ci4 = ti1 - ti4;  	ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  	ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  	ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  	ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  	ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  	ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t2 += 2;  	t3 += 2;  	t4 -= 2;  	t5 -= 2;  	t7 += 2;  	ti1 = cc [t2] + cc [t5];  	ti2 = cc [t2] - cc [t5];  	ti3 = cc [t3] - cc [t4];  	tr4 = cc [t3] + cc [t4];  	tr1 = cc [t2 - 1] - cc [t5 - 1];  	tr2 = cc [t2 - 1] + cc [t5 - 1];  	ti4 = cc [t3 - 1] - cc [t4 - 1];  	tr3 = cc [t3 - 1] + cc [t4 - 1];  	ch [t7 - 1] = tr2 + tr3;  	cr3 = tr2 - tr3;  	ch [t7] = ti2 + ti3;  	ci3 = ti2 - ti3;  	cr2 = tr1 - tr4;  	cr4 = tr1 + tr4;  	ci2 = ti1 + ti4;  	ci4 = ti1 - ti4;  	ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  	ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  	ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  	ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  	ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  	ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t2 += 2;  	t3 += 2;  	t4 -= 2;  	t5 -= 2;  	t7 += 2;  	ti1 = cc [t2] + cc [t5];  	ti2 = cc [t2] - cc [t5];  	ti3 = cc [t3] - cc [t4];  	tr4 = cc [t3] + cc [t4];  	tr1 = cc [t2 - 1] - cc [t5 - 1];  	tr2 = cc [t2 - 1] + cc [t5 - 1];  	ti4 = cc [t3 - 1] - cc [t4 - 1];  	tr3 = cc [t3 - 1] + cc [t4 - 1];  	ch [t7 - 1] = tr2 + tr3;  	cr3 = tr2 - tr3;  	ch [t7] = ti2 + ti3;  	ci3 = ti2 - ti3;  	cr2 = tr1 - tr4;  	cr4 = tr1 + tr4;  	ci2 = ti1 + ti4;  	ci4 = ti1 - ti4;  	ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  	ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  	ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  	ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  	ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  	ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t2 += 2;  	t3 += 2;  	t4 -= 2;  	t5 -= 2;  	t7 += 2;  	ti1 = cc [t2] + cc [t5];  	ti2 = cc [t2] - cc [t5];  	ti3 = cc [t3] - cc [t4];  	tr4 = cc [t3] + cc [t4];  	tr1 = cc [t2 - 1] - cc [t5 - 1];  	tr2 = cc [t2 - 1] + cc [t5 - 1];  	ti4 = cc [t3 - 1] - cc [t4 - 1];  	tr3 = cc [t3 - 1] + cc [t4 - 1];  	ch [t7 - 1] = tr2 + tr3;  	cr3 = tr2 - tr3;  	ch [t7] = ti2 + ti3;  	ci3 = ti2 - ti3;  	cr2 = tr1 - tr4;  	cr4 = tr1 + tr4;  	ci2 = ti1 + ti4;  	ci4 = ti1 - ti4;  	ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  	ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  	ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  	ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  	ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  	ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t2 += 2;  	t3 += 2;  	t4 -= 2;  	t5 -= 2;  	t7 += 2;  	ti1 = cc [t2] + cc [t5];  	ti2 = cc [t2] - cc [t5];  	ti3 = cc [t3] - cc [t4];  	tr4 = cc [t3] + cc [t4];  	tr1 = cc [t2 - 1] - cc [t5 - 1];  	tr2 = cc [t2 - 1] + cc [t5 - 1];  	ti4 = cc [t3 - 1] - cc [t4 - 1];  	tr3 = cc [t3 - 1] + cc [t4 - 1];  	ch [t7 - 1] = tr2 + tr3;  	cr3 = tr2 - tr3;  	ch [t7] = ti2 + ti3;  	ci3 = ti2 - ti3;  	cr2 = tr1 - tr4;  	cr4 = tr1 + tr4;  	ci2 = ti1 + ti4;  	ci4 = ti1 - ti4;  	ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  	ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  	ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  	ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  	ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  	ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: i = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: i += 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: t2 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: t3 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: t4 -= 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: t5 -= 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: t7 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: ch [(t8 = t7 + t0) - 1] = wa1 [index1 + i - 2] * cr2 - wa1 [index1 + i - 1] * ci2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: ch [t8] = wa1 [index1 + i - 2] * ci2 + wa1 [index1 + i - 1] * cr2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: ch [(t8 += t0) - 1] = wa2 [index2 + i - 2] * cr3 - wa2 [index2 + i - 1] * ci3;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: ch [t8] = wa2 [index2 + i - 2] * ci3 + wa2 [index2 + i - 1] * cr3;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: ch [(t8 += t0) - 1] = wa3 [index3 + i - 2] * cr4 - wa3 [index3 + i - 1] * ci4;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: ch [t8] = wa3 [index3 + i - 2] * ci4 + wa3 [index3 + i - 1] * cr4;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: if (ido % 2 == 1)  	return;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradb4,The following statement contains a magic number: t2 = ido << 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	t7 += (ido << 1);  	t8 = t7;  	for (k = 0; k < l1; k++) {  		t5 = t3;  		t6 = t4;  		t9 = t8;  		t11 = t8;  		for (i = 2; i < ido; i += 2) {  			t5 += 2;  			t6 += 2;  			t9 += 2;  			t11 -= 2;  			ch [t5 - 1] = cc [t9 - 1] + cc [t11 - 1];  			ch [t6 - 1] = cc [t9 - 1] - cc [t11 - 1];  			ch [t5] = cc [t9] - cc [t11];  			ch [t6] = cc [t9] + cc [t11];  		}  		t3 += ido;  		t4 += ido;  		t8 += t10;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	t7 += (ido << 1);  	t8 = t7;  	for (k = 0; k < l1; k++) {  		t5 = t3;  		t6 = t4;  		t9 = t8;  		t11 = t8;  		for (i = 2; i < ido; i += 2) {  			t5 += 2;  			t6 += 2;  			t9 += 2;  			t11 -= 2;  			ch [t5 - 1] = cc [t9 - 1] + cc [t11 - 1];  			ch [t6 - 1] = cc [t9 - 1] - cc [t11 - 1];  			ch [t5] = cc [t9] - cc [t11];  			ch [t6] = cc [t9] + cc [t11];  		}  		t3 += ido;  		t4 += ido;  		t8 += t10;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	t7 += (ido << 1);  	t8 = t7;  	for (k = 0; k < l1; k++) {  		t5 = t3;  		t6 = t4;  		t9 = t8;  		t11 = t8;  		for (i = 2; i < ido; i += 2) {  			t5 += 2;  			t6 += 2;  			t9 += 2;  			t11 -= 2;  			ch [t5 - 1] = cc [t9 - 1] + cc [t11 - 1];  			ch [t6 - 1] = cc [t9 - 1] - cc [t11 - 1];  			ch [t5] = cc [t9] - cc [t11];  			ch [t6] = cc [t9] + cc [t11];  		}  		t3 += ido;  		t4 += ido;  		t8 += t10;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	t7 += (ido << 1);  	t8 = t7;  	for (k = 0; k < l1; k++) {  		t5 = t3;  		t6 = t4;  		t9 = t8;  		t11 = t8;  		for (i = 2; i < ido; i += 2) {  			t5 += 2;  			t6 += 2;  			t9 += 2;  			t11 -= 2;  			ch [t5 - 1] = cc [t9 - 1] + cc [t11 - 1];  			ch [t6 - 1] = cc [t9 - 1] - cc [t11 - 1];  			ch [t5] = cc [t9] - cc [t11];  			ch [t6] = cc [t9] + cc [t11];  		}  		t3 += ido;  		t4 += ido;  		t8 += t10;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	t7 += (ido << 1);  	t8 = t7;  	for (k = 0; k < l1; k++) {  		t5 = t3;  		t6 = t4;  		t9 = t8;  		t11 = t8;  		for (i = 2; i < ido; i += 2) {  			t5 += 2;  			t6 += 2;  			t9 += 2;  			t11 -= 2;  			ch [t5 - 1] = cc [t9 - 1] + cc [t11 - 1];  			ch [t6 - 1] = cc [t9 - 1] - cc [t11 - 1];  			ch [t5] = cc [t9] - cc [t11];  			ch [t6] = cc [t9] + cc [t11];  		}  		t3 += ido;  		t4 += ido;  		t8 += t10;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	t7 += (ido << 1);  	t8 = t7;  	for (k = 0; k < l1; k++) {  		t5 = t3;  		t6 = t4;  		t9 = t8;  		t11 = t8;  		for (i = 2; i < ido; i += 2) {  			t5 += 2;  			t6 += 2;  			t9 += 2;  			t11 -= 2;  			ch [t5 - 1] = cc [t9 - 1] + cc [t11 - 1];  			ch [t6 - 1] = cc [t9 - 1] - cc [t11 - 1];  			ch [t5] = cc [t9] - cc [t11];  			ch [t6] = cc [t9] + cc [t11];  		}  		t3 += ido;  		t4 += ido;  		t8 += t10;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = t3;  	t6 = t4;  	t9 = t8;  	t11 = t8;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 += 2;  		t9 += 2;  		t11 -= 2;  		ch [t5 - 1] = cc [t9 - 1] + cc [t11 - 1];  		ch [t6 - 1] = cc [t9 - 1] - cc [t11 - 1];  		ch [t5] = cc [t9] - cc [t11];  		ch [t6] = cc [t9] + cc [t11];  	}  	t3 += ido;  	t4 += ido;  	t8 += t10;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = t3;  	t6 = t4;  	t9 = t8;  	t11 = t8;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 += 2;  		t9 += 2;  		t11 -= 2;  		ch [t5 - 1] = cc [t9 - 1] + cc [t11 - 1];  		ch [t6 - 1] = cc [t9 - 1] - cc [t11 - 1];  		ch [t5] = cc [t9] - cc [t11];  		ch [t6] = cc [t9] + cc [t11];  	}  	t3 += ido;  	t4 += ido;  	t8 += t10;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = t3;  	t6 = t4;  	t9 = t8;  	t11 = t8;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 += 2;  		t9 += 2;  		t11 -= 2;  		ch [t5 - 1] = cc [t9 - 1] + cc [t11 - 1];  		ch [t6 - 1] = cc [t9 - 1] - cc [t11 - 1];  		ch [t5] = cc [t9] - cc [t11];  		ch [t6] = cc [t9] + cc [t11];  	}  	t3 += ido;  	t4 += ido;  	t8 += t10;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = t3;  	t6 = t4;  	t9 = t8;  	t11 = t8;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 += 2;  		t9 += 2;  		t11 -= 2;  		ch [t5 - 1] = cc [t9 - 1] + cc [t11 - 1];  		ch [t6 - 1] = cc [t9 - 1] - cc [t11 - 1];  		ch [t5] = cc [t9] - cc [t11];  		ch [t6] = cc [t9] + cc [t11];  	}  	t3 += ido;  	t4 += ido;  	t8 += t10;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = t3;  	t6 = t4;  	t9 = t8;  	t11 = t8;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 += 2;  		t9 += 2;  		t11 -= 2;  		ch [t5 - 1] = cc [t9 - 1] + cc [t11 - 1];  		ch [t6 - 1] = cc [t9 - 1] - cc [t11 - 1];  		ch [t5] = cc [t9] - cc [t11];  		ch [t6] = cc [t9] + cc [t11];  	}  	t3 += ido;  	t4 += ido;  	t8 += t10;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = t3;  	t6 = t4;  	t9 = t8;  	t11 = t8;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 += 2;  		t9 += 2;  		t11 -= 2;  		ch [t5 - 1] = cc [t9 - 1] + cc [t11 - 1];  		ch [t6 - 1] = cc [t9 - 1] - cc [t11 - 1];  		ch [t5] = cc [t9] - cc [t11];  		ch [t6] = cc [t9] + cc [t11];  	}  	t3 += ido;  	t4 += ido;  	t8 += t10;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 += 2;  	t9 += 2;  	t11 -= 2;  	ch [t5 - 1] = cc [t9 - 1] + cc [t11 - 1];  	ch [t6 - 1] = cc [t9 - 1] - cc [t11 - 1];  	ch [t5] = cc [t9] - cc [t11];  	ch [t6] = cc [t9] + cc [t11];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 += 2;  	t9 += 2;  	t11 -= 2;  	ch [t5 - 1] = cc [t9 - 1] + cc [t11 - 1];  	ch [t6 - 1] = cc [t9 - 1] - cc [t11 - 1];  	ch [t5] = cc [t9] - cc [t11];  	ch [t6] = cc [t9] + cc [t11];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 += 2;  	t9 += 2;  	t11 -= 2;  	ch [t5 - 1] = cc [t9 - 1] + cc [t11 - 1];  	ch [t6 - 1] = cc [t9 - 1] - cc [t11 - 1];  	ch [t5] = cc [t9] - cc [t11];  	ch [t6] = cc [t9] + cc [t11];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 += 2;  	t9 += 2;  	t11 -= 2;  	ch [t5 - 1] = cc [t9 - 1] + cc [t11 - 1];  	ch [t6 - 1] = cc [t9 - 1] - cc [t11 - 1];  	ch [t5] = cc [t9] - cc [t11];  	ch [t6] = cc [t9] + cc [t11];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 += 2;  	t9 += 2;  	t11 -= 2;  	ch [t5 - 1] = cc [t9 - 1] + cc [t11 - 1];  	ch [t6 - 1] = cc [t9 - 1] - cc [t11 - 1];  	ch [t5] = cc [t9] - cc [t11];  	ch [t6] = cc [t9] + cc [t11];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 += 2;  	t9 += 2;  	t11 -= 2;  	ch [t5 - 1] = cc [t9 - 1] + cc [t11 - 1];  	ch [t6 - 1] = cc [t9 - 1] - cc [t11 - 1];  	ch [t5] = cc [t9] - cc [t11];  	ch [t6] = cc [t9] + cc [t11];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: i = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: i += 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: t5 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: t6 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: t9 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: t11 -= 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	t7 += (ido << 1);  	t8 = t7;  	t9 = t7;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t8 += 2;  		t9 -= 2;  		t5 = t3;  		t6 = t4;  		t11 = t8;  		t12 = t9;  		for (k = 0; k < l1; k++) {  			ch [t5 - 1] = cc [t11 - 1] + cc [t12 - 1];  			ch [t6 - 1] = cc [t11 - 1] - cc [t12 - 1];  			ch [t5] = cc [t11] - cc [t12];  			ch [t6] = cc [t11] + cc [t12];  			t5 += ido;  			t6 += ido;  			t11 += t10;  			t12 += t10;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	t7 += (ido << 1);  	t8 = t7;  	t9 = t7;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t8 += 2;  		t9 -= 2;  		t5 = t3;  		t6 = t4;  		t11 = t8;  		t12 = t9;  		for (k = 0; k < l1; k++) {  			ch [t5 - 1] = cc [t11 - 1] + cc [t12 - 1];  			ch [t6 - 1] = cc [t11 - 1] - cc [t12 - 1];  			ch [t5] = cc [t11] - cc [t12];  			ch [t6] = cc [t11] + cc [t12];  			t5 += ido;  			t6 += ido;  			t11 += t10;  			t12 += t10;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	t7 += (ido << 1);  	t8 = t7;  	t9 = t7;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t8 += 2;  		t9 -= 2;  		t5 = t3;  		t6 = t4;  		t11 = t8;  		t12 = t9;  		for (k = 0; k < l1; k++) {  			ch [t5 - 1] = cc [t11 - 1] + cc [t12 - 1];  			ch [t6 - 1] = cc [t11 - 1] - cc [t12 - 1];  			ch [t5] = cc [t11] - cc [t12];  			ch [t6] = cc [t11] + cc [t12];  			t5 += ido;  			t6 += ido;  			t11 += t10;  			t12 += t10;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	t7 += (ido << 1);  	t8 = t7;  	t9 = t7;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t8 += 2;  		t9 -= 2;  		t5 = t3;  		t6 = t4;  		t11 = t8;  		t12 = t9;  		for (k = 0; k < l1; k++) {  			ch [t5 - 1] = cc [t11 - 1] + cc [t12 - 1];  			ch [t6 - 1] = cc [t11 - 1] - cc [t12 - 1];  			ch [t5] = cc [t11] - cc [t12];  			ch [t6] = cc [t11] + cc [t12];  			t5 += ido;  			t6 += ido;  			t11 += t10;  			t12 += t10;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	t7 += (ido << 1);  	t8 = t7;  	t9 = t7;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t8 += 2;  		t9 -= 2;  		t5 = t3;  		t6 = t4;  		t11 = t8;  		t12 = t9;  		for (k = 0; k < l1; k++) {  			ch [t5 - 1] = cc [t11 - 1] + cc [t12 - 1];  			ch [t6 - 1] = cc [t11 - 1] - cc [t12 - 1];  			ch [t5] = cc [t11] - cc [t12];  			ch [t6] = cc [t11] + cc [t12];  			t5 += ido;  			t6 += ido;  			t11 += t10;  			t12 += t10;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	t7 += (ido << 1);  	t8 = t7;  	t9 = t7;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t8 += 2;  		t9 -= 2;  		t5 = t3;  		t6 = t4;  		t11 = t8;  		t12 = t9;  		for (k = 0; k < l1; k++) {  			ch [t5 - 1] = cc [t11 - 1] + cc [t12 - 1];  			ch [t6 - 1] = cc [t11 - 1] - cc [t12 - 1];  			ch [t5] = cc [t11] - cc [t12];  			ch [t6] = cc [t11] + cc [t12];  			t5 += ido;  			t6 += ido;  			t11 += t10;  			t12 += t10;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t8 += 2;  	t9 -= 2;  	t5 = t3;  	t6 = t4;  	t11 = t8;  	t12 = t9;  	for (k = 0; k < l1; k++) {  		ch [t5 - 1] = cc [t11 - 1] + cc [t12 - 1];  		ch [t6 - 1] = cc [t11 - 1] - cc [t12 - 1];  		ch [t5] = cc [t11] - cc [t12];  		ch [t6] = cc [t11] + cc [t12];  		t5 += ido;  		t6 += ido;  		t11 += t10;  		t12 += t10;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t8 += 2;  	t9 -= 2;  	t5 = t3;  	t6 = t4;  	t11 = t8;  	t12 = t9;  	for (k = 0; k < l1; k++) {  		ch [t5 - 1] = cc [t11 - 1] + cc [t12 - 1];  		ch [t6 - 1] = cc [t11 - 1] - cc [t12 - 1];  		ch [t5] = cc [t11] - cc [t12];  		ch [t6] = cc [t11] + cc [t12];  		t5 += ido;  		t6 += ido;  		t11 += t10;  		t12 += t10;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t8 += 2;  	t9 -= 2;  	t5 = t3;  	t6 = t4;  	t11 = t8;  	t12 = t9;  	for (k = 0; k < l1; k++) {  		ch [t5 - 1] = cc [t11 - 1] + cc [t12 - 1];  		ch [t6 - 1] = cc [t11 - 1] - cc [t12 - 1];  		ch [t5] = cc [t11] - cc [t12];  		ch [t6] = cc [t11] + cc [t12];  		t5 += ido;  		t6 += ido;  		t11 += t10;  		t12 += t10;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t8 += 2;  	t9 -= 2;  	t5 = t3;  	t6 = t4;  	t11 = t8;  	t12 = t9;  	for (k = 0; k < l1; k++) {  		ch [t5 - 1] = cc [t11 - 1] + cc [t12 - 1];  		ch [t6 - 1] = cc [t11 - 1] - cc [t12 - 1];  		ch [t5] = cc [t11] - cc [t12];  		ch [t6] = cc [t11] + cc [t12];  		t5 += ido;  		t6 += ido;  		t11 += t10;  		t12 += t10;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t8 += 2;  	t9 -= 2;  	t5 = t3;  	t6 = t4;  	t11 = t8;  	t12 = t9;  	for (k = 0; k < l1; k++) {  		ch [t5 - 1] = cc [t11 - 1] + cc [t12 - 1];  		ch [t6 - 1] = cc [t11 - 1] - cc [t12 - 1];  		ch [t5] = cc [t11] - cc [t12];  		ch [t6] = cc [t11] + cc [t12];  		t5 += ido;  		t6 += ido;  		t11 += t10;  		t12 += t10;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t8 += 2;  	t9 -= 2;  	t5 = t3;  	t6 = t4;  	t11 = t8;  	t12 = t9;  	for (k = 0; k < l1; k++) {  		ch [t5 - 1] = cc [t11 - 1] + cc [t12 - 1];  		ch [t6 - 1] = cc [t11 - 1] - cc [t12 - 1];  		ch [t5] = cc [t11] - cc [t12];  		ch [t6] = cc [t11] + cc [t12];  		t5 += ido;  		t6 += ido;  		t11 += t10;  		t12 += t10;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: i = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: i += 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: t3 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: t4 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: t8 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: t9 -= 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (l = 1; l < ipph; l++) {  	t1 += idl1;  	t2 -= idl1;  	ar1h = dcp * ar1 - dsp * ai1;  	ai1 = dcp * ai1 + dsp * ar1;  	ar1 = ar1h;  	t4 = t1;  	t5 = t2;  	t6 = 0;  	t7 = idl1;  	t8 = t3;  	for (ik = 0; ik < idl1; ik++) {  		c2 [t4++] = ch2 [t6++] + ar1 * ch2 [t7++];  		c2 [t5++] = ai1 * ch2 [t8++];  	}  	dc2 = ar1;  	ds2 = ai1;  	ar2 = ar1;  	ai2 = ai1;  	t6 = idl1;  	t7 = t9 - idl1;  	for (j = 2; j < ipph; j++) {  		t6 += idl1;  		t7 -= idl1;  		ar2h = dc2 * ar2 - ds2 * ai2;  		ai2 = dc2 * ai2 + ds2 * ar2;  		ar2 = ar2h;  		t4 = t1;  		t5 = t2;  		t11 = t6;  		t12 = t7;  		for (ik = 0; ik < idl1; ik++) {  			c2 [t4] += ar2 * ch2 [t11++];  			t4++;  			c2 [t5] += ai2 * ch2 [t12++];  			t5++;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 2; j < ipph; j++) {  	t6 += idl1;  	t7 -= idl1;  	ar2h = dc2 * ar2 - ds2 * ai2;  	ai2 = dc2 * ai2 + ds2 * ar2;  	ar2 = ar2h;  	t4 = t1;  	t5 = t2;  	t11 = t6;  	t12 = t7;  	for (ik = 0; ik < idl1; ik++) {  		c2 [t4] += ar2 * ch2 [t11++];  		t4++;  		c2 [t5] += ai2 * ch2 [t12++];  		t5++;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: j = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	for (k = 0; k < l1; k++) {  		t5 = t3;  		t6 = t4;  		for (i = 2; i < ido; i += 2) {  			t5 += 2;  			t6 += 2;  			ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  			ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  			ch [t5] = c1 [t5] + c1 [t6 - 1];  			ch [t6] = c1 [t5] - c1 [t6 - 1];  		}  		t3 += ido;  		t4 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	for (k = 0; k < l1; k++) {  		t5 = t3;  		t6 = t4;  		for (i = 2; i < ido; i += 2) {  			t5 += 2;  			t6 += 2;  			ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  			ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  			ch [t5] = c1 [t5] + c1 [t6 - 1];  			ch [t6] = c1 [t5] - c1 [t6 - 1];  		}  		t3 += ido;  		t4 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	for (k = 0; k < l1; k++) {  		t5 = t3;  		t6 = t4;  		for (i = 2; i < ido; i += 2) {  			t5 += 2;  			t6 += 2;  			ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  			ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  			ch [t5] = c1 [t5] + c1 [t6 - 1];  			ch [t6] = c1 [t5] - c1 [t6 - 1];  		}  		t3 += ido;  		t4 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	for (k = 0; k < l1; k++) {  		t5 = t3;  		t6 = t4;  		for (i = 2; i < ido; i += 2) {  			t5 += 2;  			t6 += 2;  			ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  			ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  			ch [t5] = c1 [t5] + c1 [t6 - 1];  			ch [t6] = c1 [t5] - c1 [t6 - 1];  		}  		t3 += ido;  		t4 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = t3;  	t6 = t4;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 += 2;  		ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  		ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  		ch [t5] = c1 [t5] + c1 [t6 - 1];  		ch [t6] = c1 [t5] - c1 [t6 - 1];  	}  	t3 += ido;  	t4 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = t3;  	t6 = t4;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 += 2;  		ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  		ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  		ch [t5] = c1 [t5] + c1 [t6 - 1];  		ch [t6] = c1 [t5] - c1 [t6 - 1];  	}  	t3 += ido;  	t4 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = t3;  	t6 = t4;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 += 2;  		ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  		ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  		ch [t5] = c1 [t5] + c1 [t6 - 1];  		ch [t6] = c1 [t5] - c1 [t6 - 1];  	}  	t3 += ido;  	t4 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	t5 = t3;  	t6 = t4;  	for (i = 2; i < ido; i += 2) {  		t5 += 2;  		t6 += 2;  		ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  		ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  		ch [t5] = c1 [t5] + c1 [t6 - 1];  		ch [t6] = c1 [t5] - c1 [t6 - 1];  	}  	t3 += ido;  	t4 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 += 2;  	ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  	ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  	ch [t5] = c1 [t5] + c1 [t6 - 1];  	ch [t6] = c1 [t5] - c1 [t6 - 1];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 += 2;  	ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  	ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  	ch [t5] = c1 [t5] + c1 [t6 - 1];  	ch [t6] = c1 [t5] - c1 [t6 - 1];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 += 2;  	ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  	ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  	ch [t5] = c1 [t5] + c1 [t6 - 1];  	ch [t6] = c1 [t5] - c1 [t6 - 1];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t5 += 2;  	t6 += 2;  	ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  	ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  	ch [t5] = c1 [t5] + c1 [t6 - 1];  	ch [t6] = c1 [t5] - c1 [t6 - 1];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: i = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: i += 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: t5 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: t6 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t5 = t3;  		t6 = t4;  		for (k = 0; k < l1; k++) {  			ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  			ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  			ch [t5] = c1 [t5] + c1 [t6 - 1];  			ch [t6] = c1 [t5] - c1 [t6 - 1];  			t5 += ido;  			t6 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t5 = t3;  		t6 = t4;  		for (k = 0; k < l1; k++) {  			ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  			ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  			ch [t5] = c1 [t5] + c1 [t6 - 1];  			ch [t6] = c1 [t5] - c1 [t6 - 1];  			t5 += ido;  			t6 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t5 = t3;  		t6 = t4;  		for (k = 0; k < l1; k++) {  			ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  			ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  			ch [t5] = c1 [t5] + c1 [t6 - 1];  			ch [t6] = c1 [t5] - c1 [t6 - 1];  			t5 += ido;  			t6 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ipph; j++) {  	t1 += t0;  	t2 -= t0;  	t3 = t1;  	t4 = t2;  	for (i = 2; i < ido; i += 2) {  		t3 += 2;  		t4 += 2;  		t5 = t3;  		t6 = t4;  		for (k = 0; k < l1; k++) {  			ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  			ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  			ch [t5] = c1 [t5] + c1 [t6 - 1];  			ch [t6] = c1 [t5] - c1 [t6 - 1];  			t5 += ido;  			t6 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t5 = t3;  	t6 = t4;  	for (k = 0; k < l1; k++) {  		ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  		ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  		ch [t5] = c1 [t5] + c1 [t6 - 1];  		ch [t6] = c1 [t5] - c1 [t6 - 1];  		t5 += ido;  		t6 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t5 = t3;  	t6 = t4;  	for (k = 0; k < l1; k++) {  		ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  		ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  		ch [t5] = c1 [t5] + c1 [t6 - 1];  		ch [t6] = c1 [t5] - c1 [t6 - 1];  		t5 += ido;  		t6 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t5 = t3;  	t6 = t4;  	for (k = 0; k < l1; k++) {  		ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  		ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  		ch [t5] = c1 [t5] + c1 [t6 - 1];  		ch [t6] = c1 [t5] - c1 [t6 - 1];  		t5 += ido;  		t6 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t3 += 2;  	t4 += 2;  	t5 = t3;  	t6 = t4;  	for (k = 0; k < l1; k++) {  		ch [t5 - 1] = c1 [t5 - 1] - c1 [t6];  		ch [t6 - 1] = c1 [t5 - 1] + c1 [t6];  		ch [t5] = c1 [t5] + c1 [t6 - 1];  		ch [t6] = c1 [t5] - c1 [t6 - 1];  		t5 += ido;  		t6 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: i = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: i += 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: t3 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: t4 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ip; j++) {  	iis += ido;  	t1 += t0;  	idij = iis;  	t2 = t1;  	for (i = 2; i < ido; i += 2) {  		t2 += 2;  		idij += 2;  		t3 = t2;  		for (k = 0; k < l1; k++) {  			c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  			c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  			t3 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ip; j++) {  	iis += ido;  	t1 += t0;  	idij = iis;  	t2 = t1;  	for (i = 2; i < ido; i += 2) {  		t2 += 2;  		idij += 2;  		t3 = t2;  		for (k = 0; k < l1; k++) {  			c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  			c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  			t3 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ip; j++) {  	iis += ido;  	t1 += t0;  	idij = iis;  	t2 = t1;  	for (i = 2; i < ido; i += 2) {  		t2 += 2;  		idij += 2;  		t3 = t2;  		for (k = 0; k < l1; k++) {  			c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  			c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  			t3 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ip; j++) {  	iis += ido;  	t1 += t0;  	idij = iis;  	t2 = t1;  	for (i = 2; i < ido; i += 2) {  		t2 += 2;  		idij += 2;  		t3 = t2;  		for (k = 0; k < l1; k++) {  			c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  			c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  			t3 += ido;  		}  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t2 += 2;  	idij += 2;  	t3 = t2;  	for (k = 0; k < l1; k++) {  		c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  		c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  		t3 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t2 += 2;  	idij += 2;  	t3 = t2;  	for (k = 0; k < l1; k++) {  		c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  		c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  		t3 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t2 += 2;  	idij += 2;  	t3 = t2;  	for (k = 0; k < l1; k++) {  		c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  		c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  		t3 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	t2 += 2;  	idij += 2;  	t3 = t2;  	for (k = 0; k < l1; k++) {  		c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  		c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  		t3 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: i = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: i += 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: t2 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: idij += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ip; j++) {  	iis += ido;  	t1 += t0;  	t2 = t1;  	for (k = 0; k < l1; k++) {  		idij = iis;  		t3 = t2;  		for (i = 2; i < ido; i += 2) {  			idij += 2;  			t3 += 2;  			c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  			c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  		}  		t2 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ip; j++) {  	iis += ido;  	t1 += t0;  	t2 = t1;  	for (k = 0; k < l1; k++) {  		idij = iis;  		t3 = t2;  		for (i = 2; i < ido; i += 2) {  			idij += 2;  			t3 += 2;  			c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  			c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  		}  		t2 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ip; j++) {  	iis += ido;  	t1 += t0;  	t2 = t1;  	for (k = 0; k < l1; k++) {  		idij = iis;  		t3 = t2;  		for (i = 2; i < ido; i += 2) {  			idij += 2;  			t3 += 2;  			c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  			c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  		}  		t2 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (j = 1; j < ip; j++) {  	iis += ido;  	t1 += t0;  	t2 = t1;  	for (k = 0; k < l1; k++) {  		idij = iis;  		t3 = t2;  		for (i = 2; i < ido; i += 2) {  			idij += 2;  			t3 += 2;  			c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  			c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  		}  		t2 += ido;  	}  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	idij = iis;  	t3 = t2;  	for (i = 2; i < ido; i += 2) {  		idij += 2;  		t3 += 2;  		c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  		c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  	}  	t2 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	idij = iis;  	t3 = t2;  	for (i = 2; i < ido; i += 2) {  		idij += 2;  		t3 += 2;  		c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  		c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  	}  	t2 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	idij = iis;  	t3 = t2;  	for (i = 2; i < ido; i += 2) {  		idij += 2;  		t3 += 2;  		c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  		c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  	}  	t2 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (k = 0; k < l1; k++) {  	idij = iis;  	t3 = t2;  	for (i = 2; i < ido; i += 2) {  		idij += 2;  		t3 += 2;  		c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  		c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  	}  	t2 += ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	idij += 2;  	t3 += 2;  	c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  	c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	idij += 2;  	t3 += 2;  	c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  	c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	idij += 2;  	t3 += 2;  	c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  	c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: for (i = 2; i < ido; i += 2) {  	idij += 2;  	t3 += 2;  	c1 [t3 - 1] = wa [index + idij - 1] * ch [t3 - 1] - wa [index + idij] * ch [t3];  	c1 [t3] = wa [index + idij - 1] * ch [t3] + wa [index + idij] * ch [t3 - 1];  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: i = 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: i += 2
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: idij += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,dradbg,The following statement contains a magic number: t3 += 2;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drftb1,The following statement contains a magic number: for (k1 = 0; k1 < nf; k1++) {  	ip = ifac [k1 + 2];  	l2 = ip * l1;  	ido = n / l2;  	idl1 = ido * l1;  	if (ip != 4)  		goto L103;  	ix2 = iw + ido;  	ix3 = ix2 + ido;  	if (na != 0)  		dradb4 (ido' l1' ch' c' wa' index + iw - 1' wa' index + ix2 - 1' wa' index + ix3 - 1);  	else  		dradb4 (ido' l1' c' ch' wa' index + iw - 1' wa' index + ix2 - 1' wa' index + ix3 - 1);  	na = 1 - na;  	goto L115;  	L103:  	if (ip != 2)  		goto L106;  	if (na != 0)  		dradb2 (ido' l1' ch' c' wa' index + iw - 1);  	else  		dradb2 (ido' l1' c' ch' wa' index + iw - 1);  	na = 1 - na;  	goto L115;  	L106:  	if (ip != 3)  		goto L109;  	ix2 = iw + ido;  	if (na != 0)  		dradb3 (ido' l1' ch' c' wa' index + iw - 1' wa' index + ix2 - 1);  	else  		dradb3 (ido' l1' c' ch' wa' index + iw - 1' wa' index + ix2 - 1);  	na = 1 - na;  	goto L115;  	L109:  	if (na != 0)  		dradbg (ido' ip' l1' idl1' ch' ch' ch' c' c' wa' index + iw - 1);  	else  		dradbg (ido' ip' l1' idl1' c' c' c' ch' ch' wa' index + iw - 1);  	if (ido == 1)  		na = 1 - na;  	l1 = l2;  	iw += (ip - 1) * ido;  	L115:  	l1 = l2;  	iw += (ip - 1) * ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drftb1,The following statement contains a magic number: for (k1 = 0; k1 < nf; k1++) {  	ip = ifac [k1 + 2];  	l2 = ip * l1;  	ido = n / l2;  	idl1 = ido * l1;  	if (ip != 4)  		goto L103;  	ix2 = iw + ido;  	ix3 = ix2 + ido;  	if (na != 0)  		dradb4 (ido' l1' ch' c' wa' index + iw - 1' wa' index + ix2 - 1' wa' index + ix3 - 1);  	else  		dradb4 (ido' l1' c' ch' wa' index + iw - 1' wa' index + ix2 - 1' wa' index + ix3 - 1);  	na = 1 - na;  	goto L115;  	L103:  	if (ip != 2)  		goto L106;  	if (na != 0)  		dradb2 (ido' l1' ch' c' wa' index + iw - 1);  	else  		dradb2 (ido' l1' c' ch' wa' index + iw - 1);  	na = 1 - na;  	goto L115;  	L106:  	if (ip != 3)  		goto L109;  	ix2 = iw + ido;  	if (na != 0)  		dradb3 (ido' l1' ch' c' wa' index + iw - 1' wa' index + ix2 - 1);  	else  		dradb3 (ido' l1' c' ch' wa' index + iw - 1' wa' index + ix2 - 1);  	na = 1 - na;  	goto L115;  	L109:  	if (na != 0)  		dradbg (ido' ip' l1' idl1' ch' ch' ch' c' c' wa' index + iw - 1);  	else  		dradbg (ido' ip' l1' idl1' c' c' c' ch' ch' wa' index + iw - 1);  	if (ido == 1)  		na = 1 - na;  	l1 = l2;  	iw += (ip - 1) * ido;  	L115:  	l1 = l2;  	iw += (ip - 1) * ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drftb1,The following statement contains a magic number: for (k1 = 0; k1 < nf; k1++) {  	ip = ifac [k1 + 2];  	l2 = ip * l1;  	ido = n / l2;  	idl1 = ido * l1;  	if (ip != 4)  		goto L103;  	ix2 = iw + ido;  	ix3 = ix2 + ido;  	if (na != 0)  		dradb4 (ido' l1' ch' c' wa' index + iw - 1' wa' index + ix2 - 1' wa' index + ix3 - 1);  	else  		dradb4 (ido' l1' c' ch' wa' index + iw - 1' wa' index + ix2 - 1' wa' index + ix3 - 1);  	na = 1 - na;  	goto L115;  	L103:  	if (ip != 2)  		goto L106;  	if (na != 0)  		dradb2 (ido' l1' ch' c' wa' index + iw - 1);  	else  		dradb2 (ido' l1' c' ch' wa' index + iw - 1);  	na = 1 - na;  	goto L115;  	L106:  	if (ip != 3)  		goto L109;  	ix2 = iw + ido;  	if (na != 0)  		dradb3 (ido' l1' ch' c' wa' index + iw - 1' wa' index + ix2 - 1);  	else  		dradb3 (ido' l1' c' ch' wa' index + iw - 1' wa' index + ix2 - 1);  	na = 1 - na;  	goto L115;  	L109:  	if (na != 0)  		dradbg (ido' ip' l1' idl1' ch' ch' ch' c' c' wa' index + iw - 1);  	else  		dradbg (ido' ip' l1' idl1' c' c' c' ch' ch' wa' index + iw - 1);  	if (ido == 1)  		na = 1 - na;  	l1 = l2;  	iw += (ip - 1) * ido;  	L115:  	l1 = l2;  	iw += (ip - 1) * ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drftb1,The following statement contains a magic number: for (k1 = 0; k1 < nf; k1++) {  	ip = ifac [k1 + 2];  	l2 = ip * l1;  	ido = n / l2;  	idl1 = ido * l1;  	if (ip != 4)  		goto L103;  	ix2 = iw + ido;  	ix3 = ix2 + ido;  	if (na != 0)  		dradb4 (ido' l1' ch' c' wa' index + iw - 1' wa' index + ix2 - 1' wa' index + ix3 - 1);  	else  		dradb4 (ido' l1' c' ch' wa' index + iw - 1' wa' index + ix2 - 1' wa' index + ix3 - 1);  	na = 1 - na;  	goto L115;  	L103:  	if (ip != 2)  		goto L106;  	if (na != 0)  		dradb2 (ido' l1' ch' c' wa' index + iw - 1);  	else  		dradb2 (ido' l1' c' ch' wa' index + iw - 1);  	na = 1 - na;  	goto L115;  	L106:  	if (ip != 3)  		goto L109;  	ix2 = iw + ido;  	if (na != 0)  		dradb3 (ido' l1' ch' c' wa' index + iw - 1' wa' index + ix2 - 1);  	else  		dradb3 (ido' l1' c' ch' wa' index + iw - 1' wa' index + ix2 - 1);  	na = 1 - na;  	goto L115;  	L109:  	if (na != 0)  		dradbg (ido' ip' l1' idl1' ch' ch' ch' c' c' wa' index + iw - 1);  	else  		dradbg (ido' ip' l1' idl1' c' c' c' ch' ch' wa' index + iw - 1);  	if (ido == 1)  		na = 1 - na;  	l1 = l2;  	iw += (ip - 1) * ido;  	L115:  	l1 = l2;  	iw += (ip - 1) * ido;  }  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drftb1,The following statement contains a magic number: ip = ifac [k1 + 2];  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drftb1,The following statement contains a magic number: if (ip != 4)  	goto L103;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drftb1,The following statement contains a magic number: if (ip != 2)  	goto L106;  
Magic Number,csvorbis,Drft,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Drft.cs,drftb1,The following statement contains a magic number: if (ip != 3)  	goto L109;  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,DspState,The following statement contains a magic number: transform = new Object[2][];  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd = new float[2][][][][];  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd [0] = new float[2][][][];  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd [0] [0] = new float[2][][];  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd [0] [1] = new float[2][][];  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd [0] [0] [0] = new float[2][];  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd [0] [0] [1] = new float[2][];  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd [0] [1] [0] = new float[2][];  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd [0] [1] [1] = new float[2][];  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd [1] = new float[2][][][];  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd [1] [0] = new float[2][][];  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd [1] [1] = new float[2][][];  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd [1] [0] [0] = new float[2][];  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd [1] [0] [1] = new float[2][];  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd [1] [1] [0] = new float[2][];  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,DspState,The following statement contains a magic number: wnd [1] [1] [1] = new float[2][];  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,window,The following statement contains a magic number: switch (type) {  case 0:  	// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi)  	{  		int leftbegin = wnd / 4 - left / 2;  		int rightbegin = wnd - wnd / 4 - right / 2;  		for (int i = 0; i < left; i++) {  			float x = (float)((i + .5) / left * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + leftbegin] = x;  		}  		for (int i = leftbegin + left; i < rightbegin; i++) {  			ret [i] = 1.0f;  		}  		for (int i = 0; i < right; i++) {  			float x = (float)((right - i - .5) / right * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + rightbegin] = x;  		}  	}  	break;  default:  	//free(ret);  	return (null);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,window,The following statement contains a magic number: switch (type) {  case 0:  	// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi)  	{  		int leftbegin = wnd / 4 - left / 2;  		int rightbegin = wnd - wnd / 4 - right / 2;  		for (int i = 0; i < left; i++) {  			float x = (float)((i + .5) / left * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + leftbegin] = x;  		}  		for (int i = leftbegin + left; i < rightbegin; i++) {  			ret [i] = 1.0f;  		}  		for (int i = 0; i < right; i++) {  			float x = (float)((right - i - .5) / right * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + rightbegin] = x;  		}  	}  	break;  default:  	//free(ret);  	return (null);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,window,The following statement contains a magic number: switch (type) {  case 0:  	// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi)  	{  		int leftbegin = wnd / 4 - left / 2;  		int rightbegin = wnd - wnd / 4 - right / 2;  		for (int i = 0; i < left; i++) {  			float x = (float)((i + .5) / left * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + leftbegin] = x;  		}  		for (int i = leftbegin + left; i < rightbegin; i++) {  			ret [i] = 1.0f;  		}  		for (int i = 0; i < right; i++) {  			float x = (float)((right - i - .5) / right * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + rightbegin] = x;  		}  	}  	break;  default:  	//free(ret);  	return (null);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,window,The following statement contains a magic number: switch (type) {  case 0:  	// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi)  	{  		int leftbegin = wnd / 4 - left / 2;  		int rightbegin = wnd - wnd / 4 - right / 2;  		for (int i = 0; i < left; i++) {  			float x = (float)((i + .5) / left * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + leftbegin] = x;  		}  		for (int i = leftbegin + left; i < rightbegin; i++) {  			ret [i] = 1.0f;  		}  		for (int i = 0; i < right; i++) {  			float x = (float)((right - i - .5) / right * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + rightbegin] = x;  		}  	}  	break;  default:  	//free(ret);  	return (null);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,window,The following statement contains a magic number: switch (type) {  case 0:  	// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi)  	{  		int leftbegin = wnd / 4 - left / 2;  		int rightbegin = wnd - wnd / 4 - right / 2;  		for (int i = 0; i < left; i++) {  			float x = (float)((i + .5) / left * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + leftbegin] = x;  		}  		for (int i = leftbegin + left; i < rightbegin; i++) {  			ret [i] = 1.0f;  		}  		for (int i = 0; i < right; i++) {  			float x = (float)((right - i - .5) / right * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + rightbegin] = x;  		}  	}  	break;  default:  	//free(ret);  	return (null);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,window,The following statement contains a magic number: switch (type) {  case 0:  	// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi)  	{  		int leftbegin = wnd / 4 - left / 2;  		int rightbegin = wnd - wnd / 4 - right / 2;  		for (int i = 0; i < left; i++) {  			float x = (float)((i + .5) / left * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + leftbegin] = x;  		}  		for (int i = leftbegin + left; i < rightbegin; i++) {  			ret [i] = 1.0f;  		}  		for (int i = 0; i < right; i++) {  			float x = (float)((right - i - .5) / right * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + rightbegin] = x;  		}  	}  	break;  default:  	//free(ret);  	return (null);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,window,The following statement contains a magic number: switch (type) {  case 0:  	// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi)  	{  		int leftbegin = wnd / 4 - left / 2;  		int rightbegin = wnd - wnd / 4 - right / 2;  		for (int i = 0; i < left; i++) {  			float x = (float)((i + .5) / left * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + leftbegin] = x;  		}  		for (int i = leftbegin + left; i < rightbegin; i++) {  			ret [i] = 1.0f;  		}  		for (int i = 0; i < right; i++) {  			float x = (float)((right - i - .5) / right * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + rightbegin] = x;  		}  	}  	break;  default:  	//free(ret);  	return (null);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,window,The following statement contains a magic number: switch (type) {  case 0:  	// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi)  	{  		int leftbegin = wnd / 4 - left / 2;  		int rightbegin = wnd - wnd / 4 - right / 2;  		for (int i = 0; i < left; i++) {  			float x = (float)((i + .5) / left * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + leftbegin] = x;  		}  		for (int i = leftbegin + left; i < rightbegin; i++) {  			ret [i] = 1.0f;  		}  		for (int i = 0; i < right; i++) {  			float x = (float)((right - i - .5) / right * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + rightbegin] = x;  		}  	}  	break;  default:  	//free(ret);  	return (null);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,window,The following statement contains a magic number: switch (type) {  case 0:  	// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi)  	{  		int leftbegin = wnd / 4 - left / 2;  		int rightbegin = wnd - wnd / 4 - right / 2;  		for (int i = 0; i < left; i++) {  			float x = (float)((i + .5) / left * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + leftbegin] = x;  		}  		for (int i = leftbegin + left; i < rightbegin; i++) {  			ret [i] = 1.0f;  		}  		for (int i = 0; i < right; i++) {  			float x = (float)((right - i - .5) / right * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + rightbegin] = x;  		}  	}  	break;  default:  	//free(ret);  	return (null);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,window,The following statement contains a magic number: switch (type) {  case 0:  	// The 'vorbis window' (window 0) is sin(sin(x)*sin(x)*2pi)  	{  		int leftbegin = wnd / 4 - left / 2;  		int rightbegin = wnd - wnd / 4 - right / 2;  		for (int i = 0; i < left; i++) {  			float x = (float)((i + .5) / left * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + leftbegin] = x;  		}  		for (int i = leftbegin + left; i < rightbegin; i++) {  			ret [i] = 1.0f;  		}  		for (int i = 0; i < right; i++) {  			float x = (float)((right - i - .5) / right * M_PI / 2.0);  			x = (float)Math.Sin (x);  			x *= x;  			x *= (float)(M_PI / 2.0);  			x = (float)Math.Sin (x);  			ret [i + rightbegin] = x;  		}  	}  	break;  default:  	//free(ret);  	return (null);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,window,The following statement contains a magic number: for (int i = 0; i < left; i++) {  	float x = (float)((i + .5) / left * M_PI / 2.0);  	x = (float)Math.Sin (x);  	x *= x;  	x *= (float)(M_PI / 2.0);  	x = (float)Math.Sin (x);  	ret [i + leftbegin] = x;  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,window,The following statement contains a magic number: for (int i = 0; i < left; i++) {  	float x = (float)((i + .5) / left * M_PI / 2.0);  	x = (float)Math.Sin (x);  	x *= x;  	x *= (float)(M_PI / 2.0);  	x = (float)Math.Sin (x);  	ret [i + leftbegin] = x;  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,window,The following statement contains a magic number: for (int i = 0; i < left; i++) {  	float x = (float)((i + .5) / left * M_PI / 2.0);  	x = (float)Math.Sin (x);  	x *= x;  	x *= (float)(M_PI / 2.0);  	x = (float)Math.Sin (x);  	ret [i + leftbegin] = x;  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,window,The following statement contains a magic number: x *= (float)(M_PI / 2.0);  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,window,The following statement contains a magic number: for (int i = 0; i < right; i++) {  	float x = (float)((right - i - .5) / right * M_PI / 2.0);  	x = (float)Math.Sin (x);  	x *= x;  	x *= (float)(M_PI / 2.0);  	x = (float)Math.Sin (x);  	ret [i + rightbegin] = x;  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,window,The following statement contains a magic number: for (int i = 0; i < right; i++) {  	float x = (float)((right - i - .5) / right * M_PI / 2.0);  	x = (float)Math.Sin (x);  	x *= x;  	x *= (float)(M_PI / 2.0);  	x = (float)Math.Sin (x);  	ret [i + rightbegin] = x;  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,window,The following statement contains a magic number: for (int i = 0; i < right; i++) {  	float x = (float)((right - i - .5) / right * M_PI / 2.0);  	x = (float)Math.Sin (x);  	x *= x;  	x *= (float)(M_PI / 2.0);  	x = (float)Math.Sin (x);  	ret [i + rightbegin] = x;  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,window,The following statement contains a magic number: x *= (float)(M_PI / 2.0);  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: for (int i = 0; i < VI_WINDOWB; i++) {  	wnd [0] [0] [0] [i] = window (i' vi.blocksizes [0]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [1] / 2);  	wnd [1] [1] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [0] / 2);  	wnd [1] [1] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [1] / 2);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: for (int i = 0; i < VI_WINDOWB; i++) {  	wnd [0] [0] [0] [i] = window (i' vi.blocksizes [0]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [1] / 2);  	wnd [1] [1] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [0] / 2);  	wnd [1] [1] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [1] / 2);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: for (int i = 0; i < VI_WINDOWB; i++) {  	wnd [0] [0] [0] [i] = window (i' vi.blocksizes [0]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [1] / 2);  	wnd [1] [1] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [0] / 2);  	wnd [1] [1] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [1] / 2);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: for (int i = 0; i < VI_WINDOWB; i++) {  	wnd [0] [0] [0] [i] = window (i' vi.blocksizes [0]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [1] / 2);  	wnd [1] [1] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [0] / 2);  	wnd [1] [1] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [1] / 2);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: for (int i = 0; i < VI_WINDOWB; i++) {  	wnd [0] [0] [0] [i] = window (i' vi.blocksizes [0]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [1] / 2);  	wnd [1] [1] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [0] / 2);  	wnd [1] [1] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [1] / 2);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: for (int i = 0; i < VI_WINDOWB; i++) {  	wnd [0] [0] [0] [i] = window (i' vi.blocksizes [0]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [1] / 2);  	wnd [1] [1] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [0] / 2);  	wnd [1] [1] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [1] / 2);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: for (int i = 0; i < VI_WINDOWB; i++) {  	wnd [0] [0] [0] [i] = window (i' vi.blocksizes [0]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [1] / 2);  	wnd [1] [1] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [0] / 2);  	wnd [1] [1] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [1] / 2);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: for (int i = 0; i < VI_WINDOWB; i++) {  	wnd [0] [0] [0] [i] = window (i' vi.blocksizes [0]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [1] / 2);  	wnd [1] [1] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [0] / 2);  	wnd [1] [1] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [1] / 2);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: for (int i = 0; i < VI_WINDOWB; i++) {  	wnd [0] [0] [0] [i] = window (i' vi.blocksizes [0]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [1] / 2);  	wnd [1] [1] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [0] / 2);  	wnd [1] [1] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [1] / 2);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: for (int i = 0; i < VI_WINDOWB; i++) {  	wnd [0] [0] [0] [i] = window (i' vi.blocksizes [0]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  	wnd [1] [0] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [1] / 2);  	wnd [1] [1] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [0] / 2);  	wnd [1] [1] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [1] / 2);  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: wnd [0] [0] [0] [i] = window (i' vi.blocksizes [0]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: wnd [0] [0] [0] [i] = window (i' vi.blocksizes [0]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: wnd [1] [0] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: wnd [1] [0] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [0] / 2);  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: wnd [1] [0] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [1] / 2);  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: wnd [1] [0] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [0] / 2' vi.blocksizes [1] / 2);  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: wnd [1] [1] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [0] / 2);  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: wnd [1] [1] [0] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [0] / 2);  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: wnd [1] [1] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [1] / 2);  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: wnd [1] [1] [1] [i] = window (i' vi.blocksizes [1]' vi.blocksizes [1] / 2' vi.blocksizes [1] / 2);  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: pcm_storage = 8192;  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,init,The following statement contains a magic number: centerW = vi.blocksizes [1] / 2;  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,synthesis_init,The following statement contains a magic number: centerW -= vi.blocksizes [W] / 4 + vi.blocksizes [lW] / 4;  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,synthesis_init,The following statement contains a magic number: centerW -= vi.blocksizes [W] / 4 + vi.blocksizes [lW] / 4;  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,DspState,The following statement contains a magic number: centerW -= vi.blocksizes [W] / 4 + vi.blocksizes [lW] / 4;  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,DspState,The following statement contains a magic number: centerW -= vi.blocksizes [W] / 4 + vi.blocksizes [lW] / 4;  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: if (centerW > vi.blocksizes [1] / 2 && pcm_returned > 8192) {  	// don't shift too much; we need to have a minimum PCM buffer of  	// 1/2 long block  	int shiftPCM = centerW - vi.blocksizes [1] / 2;  	shiftPCM = (pcm_returned < shiftPCM ? pcm_returned : shiftPCM);  	pcm_current -= shiftPCM;  	centerW -= shiftPCM;  	pcm_returned -= shiftPCM;  	if (shiftPCM != 0) {  		for (int i = 0; i < vi.channels; i++) {  			Array.Copy (pcm [i]' shiftPCM' pcm [i]' 0' pcm_current);  		}  	}  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: if (centerW > vi.blocksizes [1] / 2 && pcm_returned > 8192) {  	// don't shift too much; we need to have a minimum PCM buffer of  	// 1/2 long block  	int shiftPCM = centerW - vi.blocksizes [1] / 2;  	shiftPCM = (pcm_returned < shiftPCM ? pcm_returned : shiftPCM);  	pcm_current -= shiftPCM;  	centerW -= shiftPCM;  	pcm_returned -= shiftPCM;  	if (shiftPCM != 0) {  		for (int i = 0; i < vi.channels; i++) {  			Array.Copy (pcm [i]' shiftPCM' pcm [i]' 0' pcm_current);  		}  	}  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: if (centerW > vi.blocksizes [1] / 2 && pcm_returned > 8192) {  	// don't shift too much; we need to have a minimum PCM buffer of  	// 1/2 long block  	int shiftPCM = centerW - vi.blocksizes [1] / 2;  	shiftPCM = (pcm_returned < shiftPCM ? pcm_returned : shiftPCM);  	pcm_current -= shiftPCM;  	centerW -= shiftPCM;  	pcm_returned -= shiftPCM;  	if (shiftPCM != 0) {  		for (int i = 0; i < vi.channels; i++) {  			Array.Copy (pcm [i]' shiftPCM' pcm [i]' 0' pcm_current);  		}  	}  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: switch (W) {  case 0:  	beginSl = 0;  	endSl = vi.blocksizes [0] / 2;  	break;  case 1:  	beginSl = vi.blocksizes [1] / 4 - vi.blocksizes [lW] / 4;  	endSl = beginSl + vi.blocksizes [lW] / 2;  	break;  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: switch (W) {  case 0:  	beginSl = 0;  	endSl = vi.blocksizes [0] / 2;  	break;  case 1:  	beginSl = vi.blocksizes [1] / 4 - vi.blocksizes [lW] / 4;  	endSl = beginSl + vi.blocksizes [lW] / 2;  	break;  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: switch (W) {  case 0:  	beginSl = 0;  	endSl = vi.blocksizes [0] / 2;  	break;  case 1:  	beginSl = vi.blocksizes [1] / 4 - vi.blocksizes [lW] / 4;  	endSl = beginSl + vi.blocksizes [lW] / 2;  	break;  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: switch (W) {  case 0:  	beginSl = 0;  	endSl = vi.blocksizes [0] / 2;  	break;  case 1:  	beginSl = vi.blocksizes [1] / 4 - vi.blocksizes [lW] / 4;  	endSl = beginSl + vi.blocksizes [lW] / 2;  	break;  }  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: endSl = vi.blocksizes [0] / 2;  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: beginSl = vi.blocksizes [1] / 4 - vi.blocksizes [lW] / 4;  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: beginSl = vi.blocksizes [1] / 4 - vi.blocksizes [lW] / 4;  
Magic Number,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,synthesis_blockin,The following statement contains a magic number: endSl = beginSl + vi.blocksizes [lW] / 2;  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,pack,The following statement contains a magic number: opb.write (info.order' 8);  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,pack,The following statement contains a magic number: opb.write (info.rate' 16);  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,pack,The following statement contains a magic number: opb.write (info.barkmap' 16);  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,pack,The following statement contains a magic number: opb.write (info.ampbits' 6);  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,pack,The following statement contains a magic number: opb.write (info.ampdB' 8);  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,pack,The following statement contains a magic number: opb.write (info.numbooks - 1' 4);  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,pack,The following statement contains a magic number: for (int j = 0; j < info.numbooks; j++)  	opb.write (info.books [j]' 8);  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,pack,The following statement contains a magic number: opb.write (info.books [j]' 8);  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,unpack,The following statement contains a magic number: info.order = opb.read (8);  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,unpack,The following statement contains a magic number: info.rate = opb.read (16);  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,unpack,The following statement contains a magic number: info.barkmap = opb.read (16);  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,unpack,The following statement contains a magic number: info.ampbits = opb.read (6);  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,unpack,The following statement contains a magic number: info.ampdB = opb.read (8);  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,unpack,The following statement contains a magic number: info.numbooks = opb.read (4) + 1;  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,unpack,The following statement contains a magic number: for (int j = 0; j < info.numbooks; j++) {  	info.books [j] = opb.read (8);  	if (info.books [j] < 0 || info.books [j] >= vi.books) {  		//free_info(info);  		return (null);  	}  }  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,unpack,The following statement contains a magic number: info.books [j] = opb.read (8);  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,look,The following statement contains a magic number: look.n = vi.blocksizes [mi.blockflag] / 2;  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,look,The following statement contains a magic number: scale = look.ln / (float)toBARK ((float)(info.rate / 2.0));  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,look,The following statement contains a magic number: for (int j = 0; j < look.n; j++) {  	int val = (int)Math.Floor (toBARK ((float)((info.rate / 2.0) / look.n * j)) * scale);  	// bark numbers represent band edges  	if (val >= look.ln)  		val = look.ln;  	// guard against the approximation  	look.linearmap [j] = val;  }  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,toBARK,The following statement contains a magic number: a = 13.1 * Math.Atan (0.00074 * f);  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,toBARK,The following statement contains a magic number: a = 13.1 * Math.Atan (0.00074 * f);  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,toBARK,The following statement contains a magic number: b = 2.24 * Math.Atan (f * f * 1.85e-8);  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,toBARK,The following statement contains a magic number: b = 2.24 * Math.Atan (f * f * 1.85e-8);  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,toBARK,The following statement contains a magic number: c = 1.0e-4 * f;  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,fromdB,The following statement contains a magic number: return (float)(Math.Exp ((x) * .11512925));  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,lsp_to_lpc,The following statement contains a magic number: for (i = 0; i < m2; i++) {  	O [i] = (float)(-2.0 * Math.Cos (lsp [i * 2]));  	E [i] = (float)(-2.0 * Math.Cos (lsp [i * 2 + 1]));  }  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,lsp_to_lpc,The following statement contains a magic number: for (i = 0; i < m2; i++) {  	O [i] = (float)(-2.0 * Math.Cos (lsp [i * 2]));  	E [i] = (float)(-2.0 * Math.Cos (lsp [i * 2 + 1]));  }  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,lsp_to_lpc,The following statement contains a magic number: for (i = 0; i < m2; i++) {  	O [i] = (float)(-2.0 * Math.Cos (lsp [i * 2]));  	E [i] = (float)(-2.0 * Math.Cos (lsp [i * 2 + 1]));  }  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,lsp_to_lpc,The following statement contains a magic number: for (i = 0; i < m2; i++) {  	O [i] = (float)(-2.0 * Math.Cos (lsp [i * 2]));  	E [i] = (float)(-2.0 * Math.Cos (lsp [i * 2 + 1]));  }  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,lsp_to_lpc,The following statement contains a magic number: O [i] = (float)(-2.0 * Math.Cos (lsp [i * 2]));  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,lsp_to_lpc,The following statement contains a magic number: O [i] = (float)(-2.0 * Math.Cos (lsp [i * 2]));  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,lsp_to_lpc,The following statement contains a magic number: E [i] = (float)(-2.0 * Math.Cos (lsp [i * 2 + 1]));  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,lsp_to_lpc,The following statement contains a magic number: E [i] = (float)(-2.0 * Math.Cos (lsp [i * 2 + 1]));  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,lsp_to_lpc,The following statement contains a magic number: for (i = 1; i < m + 1; i++) {  	A = B = 0.0f;  	for (j = 0; j < m2; j++) {  		temp = O [j] * Ao [j] + Ae [j];  		Ae [j] = Ao [j];  		Ao [j] = A;  		A += temp;  		temp = E [j] * Bo [j] + Be [j];  		Be [j] = Bo [j];  		Bo [j] = B;  		B += temp;  	}  	lpc [i - 1] = (A + Ao [j] + B - Ae [j]) / 2;  	Ao [j] = A;  	Ae [j] = B;  }  
Magic Number,csvorbis,Floor0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor0.cs,lsp_to_lpc,The following statement contains a magic number: lpc [i - 1] = (A + Ao [j] + B - Ae [j]) / 2;  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,pack,The following statement contains a magic number: opb.write (info.partitions' 5);  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,pack,The following statement contains a magic number: for (int j = 0; j < info.partitions; j++) {  	opb.write (info.partitionclass [j]' 4);  	/* only 0 to 15 legal */if (maxclass < info.partitionclass [j])  		maxclass = info.partitionclass [j];  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,pack,The following statement contains a magic number: opb.write (info.partitionclass [j]' 4);  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,pack,The following statement contains a magic number: for (int j = 0; j < maxclass + 1; j++) {  	opb.write (info.class_dim [j] - 1' 3);  	/* 1 to 8 */opb.write (info.class_subs [j]' 2);  	/* 0 to 3 */if (info.class_subs [j] != 0) {  		opb.write (info.class_book [j]' 8);  	}  	for (int k = 0; k < (1 << info.class_subs [j]); k++) {  		opb.write (info.class_subbook [j] [k] + 1' 8);  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,pack,The following statement contains a magic number: for (int j = 0; j < maxclass + 1; j++) {  	opb.write (info.class_dim [j] - 1' 3);  	/* 1 to 8 */opb.write (info.class_subs [j]' 2);  	/* 0 to 3 */if (info.class_subs [j] != 0) {  		opb.write (info.class_book [j]' 8);  	}  	for (int k = 0; k < (1 << info.class_subs [j]); k++) {  		opb.write (info.class_subbook [j] [k] + 1' 8);  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,pack,The following statement contains a magic number: for (int j = 0; j < maxclass + 1; j++) {  	opb.write (info.class_dim [j] - 1' 3);  	/* 1 to 8 */opb.write (info.class_subs [j]' 2);  	/* 0 to 3 */if (info.class_subs [j] != 0) {  		opb.write (info.class_book [j]' 8);  	}  	for (int k = 0; k < (1 << info.class_subs [j]); k++) {  		opb.write (info.class_subbook [j] [k] + 1' 8);  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,pack,The following statement contains a magic number: for (int j = 0; j < maxclass + 1; j++) {  	opb.write (info.class_dim [j] - 1' 3);  	/* 1 to 8 */opb.write (info.class_subs [j]' 2);  	/* 0 to 3 */if (info.class_subs [j] != 0) {  		opb.write (info.class_book [j]' 8);  	}  	for (int k = 0; k < (1 << info.class_subs [j]); k++) {  		opb.write (info.class_subbook [j] [k] + 1' 8);  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,pack,The following statement contains a magic number: opb.write (info.class_dim [j] - 1' 3);  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,pack,The following statement contains a magic number: opb.write (info.class_subs [j]' 2);  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,pack,The following statement contains a magic number: if (info.class_subs [j] != 0) {  	opb.write (info.class_book [j]' 8);  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,pack,The following statement contains a magic number: opb.write (info.class_book [j]' 8);  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,pack,The following statement contains a magic number: for (int k = 0; k < (1 << info.class_subs [j]); k++) {  	opb.write (info.class_subbook [j] [k] + 1' 8);  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,pack,The following statement contains a magic number: opb.write (info.class_subbook [j] [k] + 1' 8);  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,pack,The following statement contains a magic number: opb.write (info.mult - 1' 2);  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,pack,The following statement contains a magic number: opb.write (ilog2 (maxposit)' 4);  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,pack,The following statement contains a magic number: for (int j = 0' k = 0; j < info.partitions; j++) {  	count += info.class_dim [info.partitionclass [j]];  	for (; k < count; k++) {  		opb.write (info.postlist [k + 2]' rangebits);  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,pack,The following statement contains a magic number: for (; k < count; k++) {  	opb.write (info.postlist [k + 2]' rangebits);  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,pack,The following statement contains a magic number: opb.write (info.postlist [k + 2]' rangebits);  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: info.partitions = opb.read (5);  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: for (int j = 0; j < info.partitions; j++) {  	info.partitionclass [j] = opb.read (4);  	/* only 0 to 15 legal */if (maxclass < info.partitionclass [j])  		maxclass = info.partitionclass [j];  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: info.partitionclass [j] = opb.read (4);  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: for (int j = 0; j < maxclass + 1; j++) {  	info.class_dim [j] = opb.read (3) + 1;  	/* 1 to 8 */info.class_subs [j] = opb.read (2);  	/* 0'1'2'3 bits */if (info.class_subs [j] < 0) {  		//goto err_out;  		info.free ();  		return (null);  	}  	if (info.class_subs [j] != 0) {  		info.class_book [j] = opb.read (8);  	}  	if (info.class_book [j] < 0 || info.class_book [j] >= vi.books) {  		//goto err_out;  		info.free ();  		return (null);  	}  	for (int k = 0; k < (1 << info.class_subs [j]); k++) {  		info.class_subbook [j] [k] = opb.read (8) - 1;  		if (info.class_subbook [j] [k] < -1 || info.class_subbook [j] [k] >= vi.books) {  			//goto err_out;  			info.free ();  			return (null);  		}  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: for (int j = 0; j < maxclass + 1; j++) {  	info.class_dim [j] = opb.read (3) + 1;  	/* 1 to 8 */info.class_subs [j] = opb.read (2);  	/* 0'1'2'3 bits */if (info.class_subs [j] < 0) {  		//goto err_out;  		info.free ();  		return (null);  	}  	if (info.class_subs [j] != 0) {  		info.class_book [j] = opb.read (8);  	}  	if (info.class_book [j] < 0 || info.class_book [j] >= vi.books) {  		//goto err_out;  		info.free ();  		return (null);  	}  	for (int k = 0; k < (1 << info.class_subs [j]); k++) {  		info.class_subbook [j] [k] = opb.read (8) - 1;  		if (info.class_subbook [j] [k] < -1 || info.class_subbook [j] [k] >= vi.books) {  			//goto err_out;  			info.free ();  			return (null);  		}  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: for (int j = 0; j < maxclass + 1; j++) {  	info.class_dim [j] = opb.read (3) + 1;  	/* 1 to 8 */info.class_subs [j] = opb.read (2);  	/* 0'1'2'3 bits */if (info.class_subs [j] < 0) {  		//goto err_out;  		info.free ();  		return (null);  	}  	if (info.class_subs [j] != 0) {  		info.class_book [j] = opb.read (8);  	}  	if (info.class_book [j] < 0 || info.class_book [j] >= vi.books) {  		//goto err_out;  		info.free ();  		return (null);  	}  	for (int k = 0; k < (1 << info.class_subs [j]); k++) {  		info.class_subbook [j] [k] = opb.read (8) - 1;  		if (info.class_subbook [j] [k] < -1 || info.class_subbook [j] [k] >= vi.books) {  			//goto err_out;  			info.free ();  			return (null);  		}  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: for (int j = 0; j < maxclass + 1; j++) {  	info.class_dim [j] = opb.read (3) + 1;  	/* 1 to 8 */info.class_subs [j] = opb.read (2);  	/* 0'1'2'3 bits */if (info.class_subs [j] < 0) {  		//goto err_out;  		info.free ();  		return (null);  	}  	if (info.class_subs [j] != 0) {  		info.class_book [j] = opb.read (8);  	}  	if (info.class_book [j] < 0 || info.class_book [j] >= vi.books) {  		//goto err_out;  		info.free ();  		return (null);  	}  	for (int k = 0; k < (1 << info.class_subs [j]); k++) {  		info.class_subbook [j] [k] = opb.read (8) - 1;  		if (info.class_subbook [j] [k] < -1 || info.class_subbook [j] [k] >= vi.books) {  			//goto err_out;  			info.free ();  			return (null);  		}  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: info.class_dim [j] = opb.read (3) + 1;  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: info.class_subs [j] = opb.read (2);  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: if (info.class_subs [j] != 0) {  	info.class_book [j] = opb.read (8);  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: info.class_book [j] = opb.read (8);  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: for (int k = 0; k < (1 << info.class_subs [j]); k++) {  	info.class_subbook [j] [k] = opb.read (8) - 1;  	if (info.class_subbook [j] [k] < -1 || info.class_subbook [j] [k] >= vi.books) {  		//goto err_out;  		info.free ();  		return (null);  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: info.class_subbook [j] [k] = opb.read (8) - 1;  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: info.mult = opb.read (2) + 1;  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: rangebits = opb.read (4);  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: for (int j = 0' k = 0; j < info.partitions; j++) {  	count += info.class_dim [info.partitionclass [j]];  	for (; k < count; k++) {  		int t = info.postlist [k + 2] = opb.read (rangebits);  		if (t < 0 || t >= (1 << rangebits)) {  			//goto err_out;  			info.free ();  			return (null);  		}  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,unpack,The following statement contains a magic number: for (; k < count; k++) {  	int t = info.postlist [k + 2] = opb.read (rangebits);  	if (t < 0 || t >= (1 << rangebits)) {  		//goto err_out;  		info.free ();  		return (null);  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,look,The following statement contains a magic number: _n += 2;  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,look,The following statement contains a magic number: switch (info.mult) {  case 1:  	/* 1024 -> 256 */look.quant_q = 256;  	break;  case 2:  	/* 1024 -> 128 */look.quant_q = 128;  	break;  case 3:  	/* 1024 -> 86 */look.quant_q = 86;  	break;  case 4:  	/* 1024 -> 64 */look.quant_q = 64;  	break;  default:  	look.quant_q = -1;  	break;  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,look,The following statement contains a magic number: switch (info.mult) {  case 1:  	/* 1024 -> 256 */look.quant_q = 256;  	break;  case 2:  	/* 1024 -> 128 */look.quant_q = 128;  	break;  case 3:  	/* 1024 -> 86 */look.quant_q = 86;  	break;  case 4:  	/* 1024 -> 64 */look.quant_q = 64;  	break;  default:  	look.quant_q = -1;  	break;  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,look,The following statement contains a magic number: switch (info.mult) {  case 1:  	/* 1024 -> 256 */look.quant_q = 256;  	break;  case 2:  	/* 1024 -> 128 */look.quant_q = 128;  	break;  case 3:  	/* 1024 -> 86 */look.quant_q = 86;  	break;  case 4:  	/* 1024 -> 64 */look.quant_q = 64;  	break;  default:  	look.quant_q = -1;  	break;  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,look,The following statement contains a magic number: switch (info.mult) {  case 1:  	/* 1024 -> 256 */look.quant_q = 256;  	break;  case 2:  	/* 1024 -> 128 */look.quant_q = 128;  	break;  case 3:  	/* 1024 -> 86 */look.quant_q = 86;  	break;  case 4:  	/* 1024 -> 64 */look.quant_q = 64;  	break;  default:  	look.quant_q = -1;  	break;  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,look,The following statement contains a magic number: switch (info.mult) {  case 1:  	/* 1024 -> 256 */look.quant_q = 256;  	break;  case 2:  	/* 1024 -> 128 */look.quant_q = 128;  	break;  case 3:  	/* 1024 -> 86 */look.quant_q = 86;  	break;  case 4:  	/* 1024 -> 64 */look.quant_q = 64;  	break;  default:  	look.quant_q = -1;  	break;  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,look,The following statement contains a magic number: switch (info.mult) {  case 1:  	/* 1024 -> 256 */look.quant_q = 256;  	break;  case 2:  	/* 1024 -> 128 */look.quant_q = 128;  	break;  case 3:  	/* 1024 -> 86 */look.quant_q = 86;  	break;  case 4:  	/* 1024 -> 64 */look.quant_q = 64;  	break;  default:  	look.quant_q = -1;  	break;  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,look,The following statement contains a magic number: switch (info.mult) {  case 1:  	/* 1024 -> 256 */look.quant_q = 256;  	break;  case 2:  	/* 1024 -> 128 */look.quant_q = 128;  	break;  case 3:  	/* 1024 -> 86 */look.quant_q = 86;  	break;  case 4:  	/* 1024 -> 64 */look.quant_q = 64;  	break;  default:  	look.quant_q = -1;  	break;  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,look,The following statement contains a magic number: look.quant_q = 256;  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,look,The following statement contains a magic number: look.quant_q = 128;  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,look,The following statement contains a magic number: look.quant_q = 86;  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,look,The following statement contains a magic number: look.quant_q = 64;  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,look,The following statement contains a magic number: for (int j = 0; j < _n - 2; j++) {  	int lo = 0;  	int hi = 1;  	int lx = 0;  	int hx = look.n;  	int currentx = info.postlist [j + 2];  	for (int k = 0; k < j + 2; k++) {  		int x = info.postlist [k];  		if (x > lx && x < currentx) {  			lo = k;  			lx = x;  		}  		if (x < hx && x > currentx) {  			hi = k;  			hx = x;  		}  	}  	look.loneighbor [j] = lo;  	look.hineighbor [j] = hi;  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,look,The following statement contains a magic number: for (int j = 0; j < _n - 2; j++) {  	int lo = 0;  	int hi = 1;  	int lx = 0;  	int hx = look.n;  	int currentx = info.postlist [j + 2];  	for (int k = 0; k < j + 2; k++) {  		int x = info.postlist [k];  		if (x > lx && x < currentx) {  			lo = k;  			lx = x;  		}  		if (x < hx && x > currentx) {  			hi = k;  			hx = x;  		}  	}  	look.loneighbor [j] = lo;  	look.hineighbor [j] = hi;  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,look,The following statement contains a magic number: for (int j = 0; j < _n - 2; j++) {  	int lo = 0;  	int hi = 1;  	int lx = 0;  	int hx = look.n;  	int currentx = info.postlist [j + 2];  	for (int k = 0; k < j + 2; k++) {  		int x = info.postlist [k];  		if (x > lx && x < currentx) {  			lo = k;  			lx = x;  		}  		if (x < hx && x > currentx) {  			hi = k;  			hx = x;  		}  	}  	look.loneighbor [j] = lo;  	look.hineighbor [j] = hi;  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,look,The following statement contains a magic number: for (int k = 0; k < j + 2; k++) {  	int x = info.postlist [k];  	if (x > lx && x < currentx) {  		lo = k;  		lx = x;  	}  	if (x < hx && x > currentx) {  		hi = k;  		hx = x;  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: if (vb.opb.read (1) == 1) {  	int[] fit_value = null;  	if (memo is int[]) {  		fit_value = (int[])memo;  	}  	if (fit_value == null || fit_value.Length < look.posts) {  		fit_value = new int[look.posts];  	}  	else {  		for (int i = 0; i < fit_value.Length; i++)  			fit_value [i] = 0;  	}  	fit_value [0] = vb.opb.read (ilog (look.quant_q - 1));  	fit_value [1] = vb.opb.read (ilog (look.quant_q - 1));  	/* partition by partition */for (int i = 0' j = 2; i < info.partitions; i++) {  		int clss = info.partitionclass [i];  		int cdim = info.class_dim [clss];  		int csubbits = info.class_subs [clss];  		int csub = 1 << csubbits;  		int cval = 0;  		/* decode the partition's first stage cascade value */if (csubbits != 0) {  			cval = books [info.class_book [clss]].decode (vb.opb);  			if (cval == -1) {  				//goto eop;  				return (null);  			}  		}  		for (int k = 0; k < cdim; k++) {  			int book = info.class_subbook [clss] [cval & (csub - 1)];  			cval = (int)((uint)cval >> csubbits);  			if (book >= 0) {  				if ((fit_value [j + k] = books [book].decode (vb.opb)) == -1) {  					return (null);  				}  			}  			else {  				fit_value [j + k] = 0;  			}  		}  		j += cdim;  	}  	/* unwrap positive values and reconsitute via linear interpolation */for (int i = 2; i < look.posts; i++) {  		int predicted = render_point (info.postlist [look.loneighbor [i - 2]]' info.postlist [look.hineighbor [i - 2]]' fit_value [look.loneighbor [i - 2]]' fit_value [look.hineighbor [i - 2]]' info.postlist [i]);  		int hiroom = look.quant_q - predicted;  		int loroom = predicted;  		int room = (hiroom < loroom ? hiroom : loroom) << 1;  		int val = fit_value [i];  		if (val != 0) {  			if (val >= room) {  				if (hiroom > loroom) {  					val = val - loroom;  				}  				else {  					val = -1 - (val - hiroom);  				}  			}  			else {  				if ((val & 1) != 0) {  					val = (int)(-((uint)(val + 1) >> 1));  				}  				else {  					val >>= 1;  				}  			}  			fit_value [i] = val + predicted;  			fit_value [look.loneighbor [i - 2]] &= 0x7fff;  			fit_value [look.hineighbor [i - 2]] &= 0x7fff;  		}  		else {  			fit_value [i] = predicted | 0x8000;  		}  	}  	return (fit_value);  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: if (vb.opb.read (1) == 1) {  	int[] fit_value = null;  	if (memo is int[]) {  		fit_value = (int[])memo;  	}  	if (fit_value == null || fit_value.Length < look.posts) {  		fit_value = new int[look.posts];  	}  	else {  		for (int i = 0; i < fit_value.Length; i++)  			fit_value [i] = 0;  	}  	fit_value [0] = vb.opb.read (ilog (look.quant_q - 1));  	fit_value [1] = vb.opb.read (ilog (look.quant_q - 1));  	/* partition by partition */for (int i = 0' j = 2; i < info.partitions; i++) {  		int clss = info.partitionclass [i];  		int cdim = info.class_dim [clss];  		int csubbits = info.class_subs [clss];  		int csub = 1 << csubbits;  		int cval = 0;  		/* decode the partition's first stage cascade value */if (csubbits != 0) {  			cval = books [info.class_book [clss]].decode (vb.opb);  			if (cval == -1) {  				//goto eop;  				return (null);  			}  		}  		for (int k = 0; k < cdim; k++) {  			int book = info.class_subbook [clss] [cval & (csub - 1)];  			cval = (int)((uint)cval >> csubbits);  			if (book >= 0) {  				if ((fit_value [j + k] = books [book].decode (vb.opb)) == -1) {  					return (null);  				}  			}  			else {  				fit_value [j + k] = 0;  			}  		}  		j += cdim;  	}  	/* unwrap positive values and reconsitute via linear interpolation */for (int i = 2; i < look.posts; i++) {  		int predicted = render_point (info.postlist [look.loneighbor [i - 2]]' info.postlist [look.hineighbor [i - 2]]' fit_value [look.loneighbor [i - 2]]' fit_value [look.hineighbor [i - 2]]' info.postlist [i]);  		int hiroom = look.quant_q - predicted;  		int loroom = predicted;  		int room = (hiroom < loroom ? hiroom : loroom) << 1;  		int val = fit_value [i];  		if (val != 0) {  			if (val >= room) {  				if (hiroom > loroom) {  					val = val - loroom;  				}  				else {  					val = -1 - (val - hiroom);  				}  			}  			else {  				if ((val & 1) != 0) {  					val = (int)(-((uint)(val + 1) >> 1));  				}  				else {  					val >>= 1;  				}  			}  			fit_value [i] = val + predicted;  			fit_value [look.loneighbor [i - 2]] &= 0x7fff;  			fit_value [look.hineighbor [i - 2]] &= 0x7fff;  		}  		else {  			fit_value [i] = predicted | 0x8000;  		}  	}  	return (fit_value);  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: if (vb.opb.read (1) == 1) {  	int[] fit_value = null;  	if (memo is int[]) {  		fit_value = (int[])memo;  	}  	if (fit_value == null || fit_value.Length < look.posts) {  		fit_value = new int[look.posts];  	}  	else {  		for (int i = 0; i < fit_value.Length; i++)  			fit_value [i] = 0;  	}  	fit_value [0] = vb.opb.read (ilog (look.quant_q - 1));  	fit_value [1] = vb.opb.read (ilog (look.quant_q - 1));  	/* partition by partition */for (int i = 0' j = 2; i < info.partitions; i++) {  		int clss = info.partitionclass [i];  		int cdim = info.class_dim [clss];  		int csubbits = info.class_subs [clss];  		int csub = 1 << csubbits;  		int cval = 0;  		/* decode the partition's first stage cascade value */if (csubbits != 0) {  			cval = books [info.class_book [clss]].decode (vb.opb);  			if (cval == -1) {  				//goto eop;  				return (null);  			}  		}  		for (int k = 0; k < cdim; k++) {  			int book = info.class_subbook [clss] [cval & (csub - 1)];  			cval = (int)((uint)cval >> csubbits);  			if (book >= 0) {  				if ((fit_value [j + k] = books [book].decode (vb.opb)) == -1) {  					return (null);  				}  			}  			else {  				fit_value [j + k] = 0;  			}  		}  		j += cdim;  	}  	/* unwrap positive values and reconsitute via linear interpolation */for (int i = 2; i < look.posts; i++) {  		int predicted = render_point (info.postlist [look.loneighbor [i - 2]]' info.postlist [look.hineighbor [i - 2]]' fit_value [look.loneighbor [i - 2]]' fit_value [look.hineighbor [i - 2]]' info.postlist [i]);  		int hiroom = look.quant_q - predicted;  		int loroom = predicted;  		int room = (hiroom < loroom ? hiroom : loroom) << 1;  		int val = fit_value [i];  		if (val != 0) {  			if (val >= room) {  				if (hiroom > loroom) {  					val = val - loroom;  				}  				else {  					val = -1 - (val - hiroom);  				}  			}  			else {  				if ((val & 1) != 0) {  					val = (int)(-((uint)(val + 1) >> 1));  				}  				else {  					val >>= 1;  				}  			}  			fit_value [i] = val + predicted;  			fit_value [look.loneighbor [i - 2]] &= 0x7fff;  			fit_value [look.hineighbor [i - 2]] &= 0x7fff;  		}  		else {  			fit_value [i] = predicted | 0x8000;  		}  	}  	return (fit_value);  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: if (vb.opb.read (1) == 1) {  	int[] fit_value = null;  	if (memo is int[]) {  		fit_value = (int[])memo;  	}  	if (fit_value == null || fit_value.Length < look.posts) {  		fit_value = new int[look.posts];  	}  	else {  		for (int i = 0; i < fit_value.Length; i++)  			fit_value [i] = 0;  	}  	fit_value [0] = vb.opb.read (ilog (look.quant_q - 1));  	fit_value [1] = vb.opb.read (ilog (look.quant_q - 1));  	/* partition by partition */for (int i = 0' j = 2; i < info.partitions; i++) {  		int clss = info.partitionclass [i];  		int cdim = info.class_dim [clss];  		int csubbits = info.class_subs [clss];  		int csub = 1 << csubbits;  		int cval = 0;  		/* decode the partition's first stage cascade value */if (csubbits != 0) {  			cval = books [info.class_book [clss]].decode (vb.opb);  			if (cval == -1) {  				//goto eop;  				return (null);  			}  		}  		for (int k = 0; k < cdim; k++) {  			int book = info.class_subbook [clss] [cval & (csub - 1)];  			cval = (int)((uint)cval >> csubbits);  			if (book >= 0) {  				if ((fit_value [j + k] = books [book].decode (vb.opb)) == -1) {  					return (null);  				}  			}  			else {  				fit_value [j + k] = 0;  			}  		}  		j += cdim;  	}  	/* unwrap positive values and reconsitute via linear interpolation */for (int i = 2; i < look.posts; i++) {  		int predicted = render_point (info.postlist [look.loneighbor [i - 2]]' info.postlist [look.hineighbor [i - 2]]' fit_value [look.loneighbor [i - 2]]' fit_value [look.hineighbor [i - 2]]' info.postlist [i]);  		int hiroom = look.quant_q - predicted;  		int loroom = predicted;  		int room = (hiroom < loroom ? hiroom : loroom) << 1;  		int val = fit_value [i];  		if (val != 0) {  			if (val >= room) {  				if (hiroom > loroom) {  					val = val - loroom;  				}  				else {  					val = -1 - (val - hiroom);  				}  			}  			else {  				if ((val & 1) != 0) {  					val = (int)(-((uint)(val + 1) >> 1));  				}  				else {  					val >>= 1;  				}  			}  			fit_value [i] = val + predicted;  			fit_value [look.loneighbor [i - 2]] &= 0x7fff;  			fit_value [look.hineighbor [i - 2]] &= 0x7fff;  		}  		else {  			fit_value [i] = predicted | 0x8000;  		}  	}  	return (fit_value);  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: if (vb.opb.read (1) == 1) {  	int[] fit_value = null;  	if (memo is int[]) {  		fit_value = (int[])memo;  	}  	if (fit_value == null || fit_value.Length < look.posts) {  		fit_value = new int[look.posts];  	}  	else {  		for (int i = 0; i < fit_value.Length; i++)  			fit_value [i] = 0;  	}  	fit_value [0] = vb.opb.read (ilog (look.quant_q - 1));  	fit_value [1] = vb.opb.read (ilog (look.quant_q - 1));  	/* partition by partition */for (int i = 0' j = 2; i < info.partitions; i++) {  		int clss = info.partitionclass [i];  		int cdim = info.class_dim [clss];  		int csubbits = info.class_subs [clss];  		int csub = 1 << csubbits;  		int cval = 0;  		/* decode the partition's first stage cascade value */if (csubbits != 0) {  			cval = books [info.class_book [clss]].decode (vb.opb);  			if (cval == -1) {  				//goto eop;  				return (null);  			}  		}  		for (int k = 0; k < cdim; k++) {  			int book = info.class_subbook [clss] [cval & (csub - 1)];  			cval = (int)((uint)cval >> csubbits);  			if (book >= 0) {  				if ((fit_value [j + k] = books [book].decode (vb.opb)) == -1) {  					return (null);  				}  			}  			else {  				fit_value [j + k] = 0;  			}  		}  		j += cdim;  	}  	/* unwrap positive values and reconsitute via linear interpolation */for (int i = 2; i < look.posts; i++) {  		int predicted = render_point (info.postlist [look.loneighbor [i - 2]]' info.postlist [look.hineighbor [i - 2]]' fit_value [look.loneighbor [i - 2]]' fit_value [look.hineighbor [i - 2]]' info.postlist [i]);  		int hiroom = look.quant_q - predicted;  		int loroom = predicted;  		int room = (hiroom < loroom ? hiroom : loroom) << 1;  		int val = fit_value [i];  		if (val != 0) {  			if (val >= room) {  				if (hiroom > loroom) {  					val = val - loroom;  				}  				else {  					val = -1 - (val - hiroom);  				}  			}  			else {  				if ((val & 1) != 0) {  					val = (int)(-((uint)(val + 1) >> 1));  				}  				else {  					val >>= 1;  				}  			}  			fit_value [i] = val + predicted;  			fit_value [look.loneighbor [i - 2]] &= 0x7fff;  			fit_value [look.hineighbor [i - 2]] &= 0x7fff;  		}  		else {  			fit_value [i] = predicted | 0x8000;  		}  	}  	return (fit_value);  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: if (vb.opb.read (1) == 1) {  	int[] fit_value = null;  	if (memo is int[]) {  		fit_value = (int[])memo;  	}  	if (fit_value == null || fit_value.Length < look.posts) {  		fit_value = new int[look.posts];  	}  	else {  		for (int i = 0; i < fit_value.Length; i++)  			fit_value [i] = 0;  	}  	fit_value [0] = vb.opb.read (ilog (look.quant_q - 1));  	fit_value [1] = vb.opb.read (ilog (look.quant_q - 1));  	/* partition by partition */for (int i = 0' j = 2; i < info.partitions; i++) {  		int clss = info.partitionclass [i];  		int cdim = info.class_dim [clss];  		int csubbits = info.class_subs [clss];  		int csub = 1 << csubbits;  		int cval = 0;  		/* decode the partition's first stage cascade value */if (csubbits != 0) {  			cval = books [info.class_book [clss]].decode (vb.opb);  			if (cval == -1) {  				//goto eop;  				return (null);  			}  		}  		for (int k = 0; k < cdim; k++) {  			int book = info.class_subbook [clss] [cval & (csub - 1)];  			cval = (int)((uint)cval >> csubbits);  			if (book >= 0) {  				if ((fit_value [j + k] = books [book].decode (vb.opb)) == -1) {  					return (null);  				}  			}  			else {  				fit_value [j + k] = 0;  			}  		}  		j += cdim;  	}  	/* unwrap positive values and reconsitute via linear interpolation */for (int i = 2; i < look.posts; i++) {  		int predicted = render_point (info.postlist [look.loneighbor [i - 2]]' info.postlist [look.hineighbor [i - 2]]' fit_value [look.loneighbor [i - 2]]' fit_value [look.hineighbor [i - 2]]' info.postlist [i]);  		int hiroom = look.quant_q - predicted;  		int loroom = predicted;  		int room = (hiroom < loroom ? hiroom : loroom) << 1;  		int val = fit_value [i];  		if (val != 0) {  			if (val >= room) {  				if (hiroom > loroom) {  					val = val - loroom;  				}  				else {  					val = -1 - (val - hiroom);  				}  			}  			else {  				if ((val & 1) != 0) {  					val = (int)(-((uint)(val + 1) >> 1));  				}  				else {  					val >>= 1;  				}  			}  			fit_value [i] = val + predicted;  			fit_value [look.loneighbor [i - 2]] &= 0x7fff;  			fit_value [look.hineighbor [i - 2]] &= 0x7fff;  		}  		else {  			fit_value [i] = predicted | 0x8000;  		}  	}  	return (fit_value);  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: if (vb.opb.read (1) == 1) {  	int[] fit_value = null;  	if (memo is int[]) {  		fit_value = (int[])memo;  	}  	if (fit_value == null || fit_value.Length < look.posts) {  		fit_value = new int[look.posts];  	}  	else {  		for (int i = 0; i < fit_value.Length; i++)  			fit_value [i] = 0;  	}  	fit_value [0] = vb.opb.read (ilog (look.quant_q - 1));  	fit_value [1] = vb.opb.read (ilog (look.quant_q - 1));  	/* partition by partition */for (int i = 0' j = 2; i < info.partitions; i++) {  		int clss = info.partitionclass [i];  		int cdim = info.class_dim [clss];  		int csubbits = info.class_subs [clss];  		int csub = 1 << csubbits;  		int cval = 0;  		/* decode the partition's first stage cascade value */if (csubbits != 0) {  			cval = books [info.class_book [clss]].decode (vb.opb);  			if (cval == -1) {  				//goto eop;  				return (null);  			}  		}  		for (int k = 0; k < cdim; k++) {  			int book = info.class_subbook [clss] [cval & (csub - 1)];  			cval = (int)((uint)cval >> csubbits);  			if (book >= 0) {  				if ((fit_value [j + k] = books [book].decode (vb.opb)) == -1) {  					return (null);  				}  			}  			else {  				fit_value [j + k] = 0;  			}  		}  		j += cdim;  	}  	/* unwrap positive values and reconsitute via linear interpolation */for (int i = 2; i < look.posts; i++) {  		int predicted = render_point (info.postlist [look.loneighbor [i - 2]]' info.postlist [look.hineighbor [i - 2]]' fit_value [look.loneighbor [i - 2]]' fit_value [look.hineighbor [i - 2]]' info.postlist [i]);  		int hiroom = look.quant_q - predicted;  		int loroom = predicted;  		int room = (hiroom < loroom ? hiroom : loroom) << 1;  		int val = fit_value [i];  		if (val != 0) {  			if (val >= room) {  				if (hiroom > loroom) {  					val = val - loroom;  				}  				else {  					val = -1 - (val - hiroom);  				}  			}  			else {  				if ((val & 1) != 0) {  					val = (int)(-((uint)(val + 1) >> 1));  				}  				else {  					val >>= 1;  				}  			}  			fit_value [i] = val + predicted;  			fit_value [look.loneighbor [i - 2]] &= 0x7fff;  			fit_value [look.hineighbor [i - 2]] &= 0x7fff;  		}  		else {  			fit_value [i] = predicted | 0x8000;  		}  	}  	return (fit_value);  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: if (vb.opb.read (1) == 1) {  	int[] fit_value = null;  	if (memo is int[]) {  		fit_value = (int[])memo;  	}  	if (fit_value == null || fit_value.Length < look.posts) {  		fit_value = new int[look.posts];  	}  	else {  		for (int i = 0; i < fit_value.Length; i++)  			fit_value [i] = 0;  	}  	fit_value [0] = vb.opb.read (ilog (look.quant_q - 1));  	fit_value [1] = vb.opb.read (ilog (look.quant_q - 1));  	/* partition by partition */for (int i = 0' j = 2; i < info.partitions; i++) {  		int clss = info.partitionclass [i];  		int cdim = info.class_dim [clss];  		int csubbits = info.class_subs [clss];  		int csub = 1 << csubbits;  		int cval = 0;  		/* decode the partition's first stage cascade value */if (csubbits != 0) {  			cval = books [info.class_book [clss]].decode (vb.opb);  			if (cval == -1) {  				//goto eop;  				return (null);  			}  		}  		for (int k = 0; k < cdim; k++) {  			int book = info.class_subbook [clss] [cval & (csub - 1)];  			cval = (int)((uint)cval >> csubbits);  			if (book >= 0) {  				if ((fit_value [j + k] = books [book].decode (vb.opb)) == -1) {  					return (null);  				}  			}  			else {  				fit_value [j + k] = 0;  			}  		}  		j += cdim;  	}  	/* unwrap positive values and reconsitute via linear interpolation */for (int i = 2; i < look.posts; i++) {  		int predicted = render_point (info.postlist [look.loneighbor [i - 2]]' info.postlist [look.hineighbor [i - 2]]' fit_value [look.loneighbor [i - 2]]' fit_value [look.hineighbor [i - 2]]' info.postlist [i]);  		int hiroom = look.quant_q - predicted;  		int loroom = predicted;  		int room = (hiroom < loroom ? hiroom : loroom) << 1;  		int val = fit_value [i];  		if (val != 0) {  			if (val >= room) {  				if (hiroom > loroom) {  					val = val - loroom;  				}  				else {  					val = -1 - (val - hiroom);  				}  			}  			else {  				if ((val & 1) != 0) {  					val = (int)(-((uint)(val + 1) >> 1));  				}  				else {  					val >>= 1;  				}  			}  			fit_value [i] = val + predicted;  			fit_value [look.loneighbor [i - 2]] &= 0x7fff;  			fit_value [look.hineighbor [i - 2]] &= 0x7fff;  		}  		else {  			fit_value [i] = predicted | 0x8000;  		}  	}  	return (fit_value);  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: for (int i = 0' j = 2; i < info.partitions; i++) {  	int clss = info.partitionclass [i];  	int cdim = info.class_dim [clss];  	int csubbits = info.class_subs [clss];  	int csub = 1 << csubbits;  	int cval = 0;  	/* decode the partition's first stage cascade value */if (csubbits != 0) {  		cval = books [info.class_book [clss]].decode (vb.opb);  		if (cval == -1) {  			//goto eop;  			return (null);  		}  	}  	for (int k = 0; k < cdim; k++) {  		int book = info.class_subbook [clss] [cval & (csub - 1)];  		cval = (int)((uint)cval >> csubbits);  		if (book >= 0) {  			if ((fit_value [j + k] = books [book].decode (vb.opb)) == -1) {  				return (null);  			}  		}  		else {  			fit_value [j + k] = 0;  		}  	}  	j += cdim;  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: for (int i = 2; i < look.posts; i++) {  	int predicted = render_point (info.postlist [look.loneighbor [i - 2]]' info.postlist [look.hineighbor [i - 2]]' fit_value [look.loneighbor [i - 2]]' fit_value [look.hineighbor [i - 2]]' info.postlist [i]);  	int hiroom = look.quant_q - predicted;  	int loroom = predicted;  	int room = (hiroom < loroom ? hiroom : loroom) << 1;  	int val = fit_value [i];  	if (val != 0) {  		if (val >= room) {  			if (hiroom > loroom) {  				val = val - loroom;  			}  			else {  				val = -1 - (val - hiroom);  			}  		}  		else {  			if ((val & 1) != 0) {  				val = (int)(-((uint)(val + 1) >> 1));  			}  			else {  				val >>= 1;  			}  		}  		fit_value [i] = val + predicted;  		fit_value [look.loneighbor [i - 2]] &= 0x7fff;  		fit_value [look.hineighbor [i - 2]] &= 0x7fff;  	}  	else {  		fit_value [i] = predicted | 0x8000;  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: for (int i = 2; i < look.posts; i++) {  	int predicted = render_point (info.postlist [look.loneighbor [i - 2]]' info.postlist [look.hineighbor [i - 2]]' fit_value [look.loneighbor [i - 2]]' fit_value [look.hineighbor [i - 2]]' info.postlist [i]);  	int hiroom = look.quant_q - predicted;  	int loroom = predicted;  	int room = (hiroom < loroom ? hiroom : loroom) << 1;  	int val = fit_value [i];  	if (val != 0) {  		if (val >= room) {  			if (hiroom > loroom) {  				val = val - loroom;  			}  			else {  				val = -1 - (val - hiroom);  			}  		}  		else {  			if ((val & 1) != 0) {  				val = (int)(-((uint)(val + 1) >> 1));  			}  			else {  				val >>= 1;  			}  		}  		fit_value [i] = val + predicted;  		fit_value [look.loneighbor [i - 2]] &= 0x7fff;  		fit_value [look.hineighbor [i - 2]] &= 0x7fff;  	}  	else {  		fit_value [i] = predicted | 0x8000;  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: for (int i = 2; i < look.posts; i++) {  	int predicted = render_point (info.postlist [look.loneighbor [i - 2]]' info.postlist [look.hineighbor [i - 2]]' fit_value [look.loneighbor [i - 2]]' fit_value [look.hineighbor [i - 2]]' info.postlist [i]);  	int hiroom = look.quant_q - predicted;  	int loroom = predicted;  	int room = (hiroom < loroom ? hiroom : loroom) << 1;  	int val = fit_value [i];  	if (val != 0) {  		if (val >= room) {  			if (hiroom > loroom) {  				val = val - loroom;  			}  			else {  				val = -1 - (val - hiroom);  			}  		}  		else {  			if ((val & 1) != 0) {  				val = (int)(-((uint)(val + 1) >> 1));  			}  			else {  				val >>= 1;  			}  		}  		fit_value [i] = val + predicted;  		fit_value [look.loneighbor [i - 2]] &= 0x7fff;  		fit_value [look.hineighbor [i - 2]] &= 0x7fff;  	}  	else {  		fit_value [i] = predicted | 0x8000;  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: for (int i = 2; i < look.posts; i++) {  	int predicted = render_point (info.postlist [look.loneighbor [i - 2]]' info.postlist [look.hineighbor [i - 2]]' fit_value [look.loneighbor [i - 2]]' fit_value [look.hineighbor [i - 2]]' info.postlist [i]);  	int hiroom = look.quant_q - predicted;  	int loroom = predicted;  	int room = (hiroom < loroom ? hiroom : loroom) << 1;  	int val = fit_value [i];  	if (val != 0) {  		if (val >= room) {  			if (hiroom > loroom) {  				val = val - loroom;  			}  			else {  				val = -1 - (val - hiroom);  			}  		}  		else {  			if ((val & 1) != 0) {  				val = (int)(-((uint)(val + 1) >> 1));  			}  			else {  				val >>= 1;  			}  		}  		fit_value [i] = val + predicted;  		fit_value [look.loneighbor [i - 2]] &= 0x7fff;  		fit_value [look.hineighbor [i - 2]] &= 0x7fff;  	}  	else {  		fit_value [i] = predicted | 0x8000;  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: for (int i = 2; i < look.posts; i++) {  	int predicted = render_point (info.postlist [look.loneighbor [i - 2]]' info.postlist [look.hineighbor [i - 2]]' fit_value [look.loneighbor [i - 2]]' fit_value [look.hineighbor [i - 2]]' info.postlist [i]);  	int hiroom = look.quant_q - predicted;  	int loroom = predicted;  	int room = (hiroom < loroom ? hiroom : loroom) << 1;  	int val = fit_value [i];  	if (val != 0) {  		if (val >= room) {  			if (hiroom > loroom) {  				val = val - loroom;  			}  			else {  				val = -1 - (val - hiroom);  			}  		}  		else {  			if ((val & 1) != 0) {  				val = (int)(-((uint)(val + 1) >> 1));  			}  			else {  				val >>= 1;  			}  		}  		fit_value [i] = val + predicted;  		fit_value [look.loneighbor [i - 2]] &= 0x7fff;  		fit_value [look.hineighbor [i - 2]] &= 0x7fff;  	}  	else {  		fit_value [i] = predicted | 0x8000;  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: for (int i = 2; i < look.posts; i++) {  	int predicted = render_point (info.postlist [look.loneighbor [i - 2]]' info.postlist [look.hineighbor [i - 2]]' fit_value [look.loneighbor [i - 2]]' fit_value [look.hineighbor [i - 2]]' info.postlist [i]);  	int hiroom = look.quant_q - predicted;  	int loroom = predicted;  	int room = (hiroom < loroom ? hiroom : loroom) << 1;  	int val = fit_value [i];  	if (val != 0) {  		if (val >= room) {  			if (hiroom > loroom) {  				val = val - loroom;  			}  			else {  				val = -1 - (val - hiroom);  			}  		}  		else {  			if ((val & 1) != 0) {  				val = (int)(-((uint)(val + 1) >> 1));  			}  			else {  				val >>= 1;  			}  		}  		fit_value [i] = val + predicted;  		fit_value [look.loneighbor [i - 2]] &= 0x7fff;  		fit_value [look.hineighbor [i - 2]] &= 0x7fff;  	}  	else {  		fit_value [i] = predicted | 0x8000;  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: for (int i = 2; i < look.posts; i++) {  	int predicted = render_point (info.postlist [look.loneighbor [i - 2]]' info.postlist [look.hineighbor [i - 2]]' fit_value [look.loneighbor [i - 2]]' fit_value [look.hineighbor [i - 2]]' info.postlist [i]);  	int hiroom = look.quant_q - predicted;  	int loroom = predicted;  	int room = (hiroom < loroom ? hiroom : loroom) << 1;  	int val = fit_value [i];  	if (val != 0) {  		if (val >= room) {  			if (hiroom > loroom) {  				val = val - loroom;  			}  			else {  				val = -1 - (val - hiroom);  			}  		}  		else {  			if ((val & 1) != 0) {  				val = (int)(-((uint)(val + 1) >> 1));  			}  			else {  				val >>= 1;  			}  		}  		fit_value [i] = val + predicted;  		fit_value [look.loneighbor [i - 2]] &= 0x7fff;  		fit_value [look.hineighbor [i - 2]] &= 0x7fff;  	}  	else {  		fit_value [i] = predicted | 0x8000;  	}  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: if (val != 0) {  	if (val >= room) {  		if (hiroom > loroom) {  			val = val - loroom;  		}  		else {  			val = -1 - (val - hiroom);  		}  	}  	else {  		if ((val & 1) != 0) {  			val = (int)(-((uint)(val + 1) >> 1));  		}  		else {  			val >>= 1;  		}  	}  	fit_value [i] = val + predicted;  	fit_value [look.loneighbor [i - 2]] &= 0x7fff;  	fit_value [look.hineighbor [i - 2]] &= 0x7fff;  }  else {  	fit_value [i] = predicted | 0x8000;  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: if (val != 0) {  	if (val >= room) {  		if (hiroom > loroom) {  			val = val - loroom;  		}  		else {  			val = -1 - (val - hiroom);  		}  	}  	else {  		if ((val & 1) != 0) {  			val = (int)(-((uint)(val + 1) >> 1));  		}  		else {  			val >>= 1;  		}  	}  	fit_value [i] = val + predicted;  	fit_value [look.loneighbor [i - 2]] &= 0x7fff;  	fit_value [look.hineighbor [i - 2]] &= 0x7fff;  }  else {  	fit_value [i] = predicted | 0x8000;  }  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: fit_value [look.loneighbor [i - 2]] &= 0x7fff;  
Magic Number,csvorbis,Floor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,inverse1,The following statement contains a magic number: fit_value [look.hineighbor [i - 2]] &= 0x7fff;  
Magic Number,csvorbis,InfoFloor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,InfoFloor1,The following statement contains a magic number: for (int i = 0; i < class_subbook.Length; i++) {  	class_subbook [i] = new int[8];  }  
Magic Number,csvorbis,InfoFloor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,InfoFloor1,The following statement contains a magic number: class_subbook [i] = new int[8];  
Magic Number,csvorbis,InfoFloor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,copy_info,The following statement contains a magic number: for (int j = 0; j < VIF_CLASS; j++) {  	Array.Copy (info.class_subbook [j]' 0' ret.class_subbook [j]' 0' 8);  }  
Magic Number,csvorbis,InfoFloor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,copy_info,The following statement contains a magic number: Array.Copy (info.class_subbook [j]' 0' ret.class_subbook [j]' 0' 8);  
Magic Number,csvorbis,InfoFloor1,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Floor1.cs,copy_info,The following statement contains a magic number: Array.Copy (info.postlist' 0' ret.postlist' 0' VIF_POSIT + 2);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_info,The following statement contains a magic number: version = opb.read (32);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_info,The following statement contains a magic number: channels = opb.read (8);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_info,The following statement contains a magic number: rate = opb.read (32);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_info,The following statement contains a magic number: bitrate_upper = opb.read (32);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_info,The following statement contains a magic number: bitrate_nominal = opb.read (32);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_info,The following statement contains a magic number: bitrate_lower = opb.read (32);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_info,The following statement contains a magic number: blocksizes [0] = 1 << opb.read (4);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_info,The following statement contains a magic number: blocksizes [1] = 1 << opb.read (4);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_info,The following statement contains a magic number: if ((rate < 1) || (channels < 1) || (blocksizes [0] < 8) || (blocksizes [1] < blocksizes [0]) || (opb.read (1) != 1)) {  	//goto err_out; // EOP check  	clear ();  	return (-1);  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: books = opb.read (8) + 1;  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: times = opb.read (6) + 1;  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: for (int i = 0; i < times; i++) {  	time_type [i] = opb.read (16);  	if (time_type [i] < 0 || time_type [i] >= VI_TIMEB) {  		//goto err_out;  		clear ();  		return (-1);  	}  	time_param [i] = FuncTime.time_P [time_type [i]].unpack (this' opb);  	if (time_param [i] == null) {  		//goto err_out;  		clear ();  		return (-1);  	}  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: time_type [i] = opb.read (16);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: floors = opb.read (6) + 1;  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: for (int i = 0; i < floors; i++) {  	floor_type [i] = opb.read (16);  	if (floor_type [i] < 0 || floor_type [i] >= VI_FLOORB) {  		//goto err_out;  		clear ();  		return (-1);  	}  	floor_param [i] = FuncFloor.floor_P [floor_type [i]].unpack (this' opb);  	if (floor_param [i] == null) {  		//goto err_out;  		clear ();  		return (-1);  	}  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: floor_type [i] = opb.read (16);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: residues = opb.read (6) + 1;  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: for (int i = 0; i < residues; i++) {  	residue_type [i] = opb.read (16);  	if (residue_type [i] < 0 || residue_type [i] >= VI_RESB) {  		//	goto err_out;  		clear ();  		return (-1);  	}  	residue_param [i] = FuncResidue.residue_P [residue_type [i]].unpack (this' opb);  	if (residue_param [i] == null) {  		//	goto err_out;  		clear ();  		return (-1);  	}  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: residue_type [i] = opb.read (16);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: maps = opb.read (6) + 1;  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: for (int i = 0; i < maps; i++) {  	map_type [i] = opb.read (16);  	if (map_type [i] < 0 || map_type [i] >= VI_MAPB) {  		//	goto err_out;  		clear ();  		return (-1);  	}  	map_param [i] = FuncMapping.mapping_P [map_type [i]].unpack (this' opb);  	if (map_param [i] == null) {  		//    goto err_out;  		clear ();  		return (-1);  	}  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: map_type [i] = opb.read (16);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: modes = opb.read (6) + 1;  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: for (int i = 0; i < modes; i++) {  	mode_param [i] = new InfoMode ();  	mode_param [i].blockflag = opb.read (1);  	mode_param [i].windowtype = opb.read (16);  	mode_param [i].transformtype = opb.read (16);  	mode_param [i].mapping = opb.read (8);  	if ((mode_param [i].windowtype >= VI_WINDOWB) || (mode_param [i].transformtype >= VI_WINDOWB) || (mode_param [i].mapping >= maps)) {  		//      goto err_out;  		clear ();  		return (-1);  	}  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: for (int i = 0; i < modes; i++) {  	mode_param [i] = new InfoMode ();  	mode_param [i].blockflag = opb.read (1);  	mode_param [i].windowtype = opb.read (16);  	mode_param [i].transformtype = opb.read (16);  	mode_param [i].mapping = opb.read (8);  	if ((mode_param [i].windowtype >= VI_WINDOWB) || (mode_param [i].transformtype >= VI_WINDOWB) || (mode_param [i].mapping >= maps)) {  		//      goto err_out;  		clear ();  		return (-1);  	}  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: for (int i = 0; i < modes; i++) {  	mode_param [i] = new InfoMode ();  	mode_param [i].blockflag = opb.read (1);  	mode_param [i].windowtype = opb.read (16);  	mode_param [i].transformtype = opb.read (16);  	mode_param [i].mapping = opb.read (8);  	if ((mode_param [i].windowtype >= VI_WINDOWB) || (mode_param [i].transformtype >= VI_WINDOWB) || (mode_param [i].mapping >= maps)) {  		//      goto err_out;  		clear ();  		return (-1);  	}  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: mode_param [i].windowtype = opb.read (16);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: mode_param [i].transformtype = opb.read (16);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,unpack_books,The following statement contains a magic number: mode_param [i].mapping = opb.read (8);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,synthesis_headerin,The following statement contains a magic number: if (op != null) {  	opb.readinit (op.packet_base' op.packet' op.bytes);  	// Which of the three types of header is this?  	// Also verify header-ness' vorbis  	{  		byte[] buffer = new byte[6];  		int packtype = opb.read (8);  		//memset(buffer'0'6);  		opb.read (buffer' 6);  		if (buffer [0] != 'v' || buffer [1] != 'o' || buffer [2] != 'r' || buffer [3] != 'b' || buffer [4] != 'i' || buffer [5] != 's') {  			// not a vorbis header  			return (-1);  		}  		switch (packtype) {  		case 0x01:  			// least significant *bit* is read first  			if (op.b_o_s == 0) {  				// Not the initial packet  				return (-1);  			}  			if (rate != 0) {  				// previously initialized info header  				return (-1);  			}  			return (unpack_info (opb));  		case 0x03:  			// least significant *bit* is read first  			if (rate == 0) {  				// um... we didn't get the initial header  				return (-1);  			}  			return (vc.unpack (opb));  		case 0x05:  			// least significant *bit* is read first  			if (rate == 0 || vc.vendor == null) {  				// um... we didn;t get the initial header or comments yet  				return (-1);  			}  			return (unpack_books (opb));  		default:  			// Not a valid vorbis header type  			//return(-1);  			break;  		}  	}  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,synthesis_headerin,The following statement contains a magic number: if (op != null) {  	opb.readinit (op.packet_base' op.packet' op.bytes);  	// Which of the three types of header is this?  	// Also verify header-ness' vorbis  	{  		byte[] buffer = new byte[6];  		int packtype = opb.read (8);  		//memset(buffer'0'6);  		opb.read (buffer' 6);  		if (buffer [0] != 'v' || buffer [1] != 'o' || buffer [2] != 'r' || buffer [3] != 'b' || buffer [4] != 'i' || buffer [5] != 's') {  			// not a vorbis header  			return (-1);  		}  		switch (packtype) {  		case 0x01:  			// least significant *bit* is read first  			if (op.b_o_s == 0) {  				// Not the initial packet  				return (-1);  			}  			if (rate != 0) {  				// previously initialized info header  				return (-1);  			}  			return (unpack_info (opb));  		case 0x03:  			// least significant *bit* is read first  			if (rate == 0) {  				// um... we didn't get the initial header  				return (-1);  			}  			return (vc.unpack (opb));  		case 0x05:  			// least significant *bit* is read first  			if (rate == 0 || vc.vendor == null) {  				// um... we didn;t get the initial header or comments yet  				return (-1);  			}  			return (unpack_books (opb));  		default:  			// Not a valid vorbis header type  			//return(-1);  			break;  		}  	}  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,synthesis_headerin,The following statement contains a magic number: if (op != null) {  	opb.readinit (op.packet_base' op.packet' op.bytes);  	// Which of the three types of header is this?  	// Also verify header-ness' vorbis  	{  		byte[] buffer = new byte[6];  		int packtype = opb.read (8);  		//memset(buffer'0'6);  		opb.read (buffer' 6);  		if (buffer [0] != 'v' || buffer [1] != 'o' || buffer [2] != 'r' || buffer [3] != 'b' || buffer [4] != 'i' || buffer [5] != 's') {  			// not a vorbis header  			return (-1);  		}  		switch (packtype) {  		case 0x01:  			// least significant *bit* is read first  			if (op.b_o_s == 0) {  				// Not the initial packet  				return (-1);  			}  			if (rate != 0) {  				// previously initialized info header  				return (-1);  			}  			return (unpack_info (opb));  		case 0x03:  			// least significant *bit* is read first  			if (rate == 0) {  				// um... we didn't get the initial header  				return (-1);  			}  			return (vc.unpack (opb));  		case 0x05:  			// least significant *bit* is read first  			if (rate == 0 || vc.vendor == null) {  				// um... we didn;t get the initial header or comments yet  				return (-1);  			}  			return (unpack_books (opb));  		default:  			// Not a valid vorbis header type  			//return(-1);  			break;  		}  	}  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,synthesis_headerin,The following statement contains a magic number: if (op != null) {  	opb.readinit (op.packet_base' op.packet' op.bytes);  	// Which of the three types of header is this?  	// Also verify header-ness' vorbis  	{  		byte[] buffer = new byte[6];  		int packtype = opb.read (8);  		//memset(buffer'0'6);  		opb.read (buffer' 6);  		if (buffer [0] != 'v' || buffer [1] != 'o' || buffer [2] != 'r' || buffer [3] != 'b' || buffer [4] != 'i' || buffer [5] != 's') {  			// not a vorbis header  			return (-1);  		}  		switch (packtype) {  		case 0x01:  			// least significant *bit* is read first  			if (op.b_o_s == 0) {  				// Not the initial packet  				return (-1);  			}  			if (rate != 0) {  				// previously initialized info header  				return (-1);  			}  			return (unpack_info (opb));  		case 0x03:  			// least significant *bit* is read first  			if (rate == 0) {  				// um... we didn't get the initial header  				return (-1);  			}  			return (vc.unpack (opb));  		case 0x05:  			// least significant *bit* is read first  			if (rate == 0 || vc.vendor == null) {  				// um... we didn;t get the initial header or comments yet  				return (-1);  			}  			return (unpack_books (opb));  		default:  			// Not a valid vorbis header type  			//return(-1);  			break;  		}  	}  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,synthesis_headerin,The following statement contains a magic number: if (op != null) {  	opb.readinit (op.packet_base' op.packet' op.bytes);  	// Which of the three types of header is this?  	// Also verify header-ness' vorbis  	{  		byte[] buffer = new byte[6];  		int packtype = opb.read (8);  		//memset(buffer'0'6);  		opb.read (buffer' 6);  		if (buffer [0] != 'v' || buffer [1] != 'o' || buffer [2] != 'r' || buffer [3] != 'b' || buffer [4] != 'i' || buffer [5] != 's') {  			// not a vorbis header  			return (-1);  		}  		switch (packtype) {  		case 0x01:  			// least significant *bit* is read first  			if (op.b_o_s == 0) {  				// Not the initial packet  				return (-1);  			}  			if (rate != 0) {  				// previously initialized info header  				return (-1);  			}  			return (unpack_info (opb));  		case 0x03:  			// least significant *bit* is read first  			if (rate == 0) {  				// um... we didn't get the initial header  				return (-1);  			}  			return (vc.unpack (opb));  		case 0x05:  			// least significant *bit* is read first  			if (rate == 0 || vc.vendor == null) {  				// um... we didn;t get the initial header or comments yet  				return (-1);  			}  			return (unpack_books (opb));  		default:  			// Not a valid vorbis header type  			//return(-1);  			break;  		}  	}  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,synthesis_headerin,The following statement contains a magic number: if (op != null) {  	opb.readinit (op.packet_base' op.packet' op.bytes);  	// Which of the three types of header is this?  	// Also verify header-ness' vorbis  	{  		byte[] buffer = new byte[6];  		int packtype = opb.read (8);  		//memset(buffer'0'6);  		opb.read (buffer' 6);  		if (buffer [0] != 'v' || buffer [1] != 'o' || buffer [2] != 'r' || buffer [3] != 'b' || buffer [4] != 'i' || buffer [5] != 's') {  			// not a vorbis header  			return (-1);  		}  		switch (packtype) {  		case 0x01:  			// least significant *bit* is read first  			if (op.b_o_s == 0) {  				// Not the initial packet  				return (-1);  			}  			if (rate != 0) {  				// previously initialized info header  				return (-1);  			}  			return (unpack_info (opb));  		case 0x03:  			// least significant *bit* is read first  			if (rate == 0) {  				// um... we didn't get the initial header  				return (-1);  			}  			return (vc.unpack (opb));  		case 0x05:  			// least significant *bit* is read first  			if (rate == 0 || vc.vendor == null) {  				// um... we didn;t get the initial header or comments yet  				return (-1);  			}  			return (unpack_books (opb));  		default:  			// Not a valid vorbis header type  			//return(-1);  			break;  		}  	}  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,synthesis_headerin,The following statement contains a magic number: if (op != null) {  	opb.readinit (op.packet_base' op.packet' op.bytes);  	// Which of the three types of header is this?  	// Also verify header-ness' vorbis  	{  		byte[] buffer = new byte[6];  		int packtype = opb.read (8);  		//memset(buffer'0'6);  		opb.read (buffer' 6);  		if (buffer [0] != 'v' || buffer [1] != 'o' || buffer [2] != 'r' || buffer [3] != 'b' || buffer [4] != 'i' || buffer [5] != 's') {  			// not a vorbis header  			return (-1);  		}  		switch (packtype) {  		case 0x01:  			// least significant *bit* is read first  			if (op.b_o_s == 0) {  				// Not the initial packet  				return (-1);  			}  			if (rate != 0) {  				// previously initialized info header  				return (-1);  			}  			return (unpack_info (opb));  		case 0x03:  			// least significant *bit* is read first  			if (rate == 0) {  				// um... we didn't get the initial header  				return (-1);  			}  			return (vc.unpack (opb));  		case 0x05:  			// least significant *bit* is read first  			if (rate == 0 || vc.vendor == null) {  				// um... we didn;t get the initial header or comments yet  				return (-1);  			}  			return (unpack_books (opb));  		default:  			// Not a valid vorbis header type  			//return(-1);  			break;  		}  	}  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,synthesis_headerin,The following statement contains a magic number: opb.read (buffer' 6);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,synthesis_headerin,The following statement contains a magic number: if (buffer [0] != 'v' || buffer [1] != 'o' || buffer [2] != 'r' || buffer [3] != 'b' || buffer [4] != 'i' || buffer [5] != 's') {  	// not a vorbis header  	return (-1);  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,synthesis_headerin,The following statement contains a magic number: if (buffer [0] != 'v' || buffer [1] != 'o' || buffer [2] != 'r' || buffer [3] != 'b' || buffer [4] != 'i' || buffer [5] != 's') {  	// not a vorbis header  	return (-1);  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,synthesis_headerin,The following statement contains a magic number: if (buffer [0] != 'v' || buffer [1] != 'o' || buffer [2] != 'r' || buffer [3] != 'b' || buffer [4] != 'i' || buffer [5] != 's') {  	// not a vorbis header  	return (-1);  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,synthesis_headerin,The following statement contains a magic number: if (buffer [0] != 'v' || buffer [1] != 'o' || buffer [2] != 'r' || buffer [3] != 'b' || buffer [4] != 'i' || buffer [5] != 's') {  	// not a vorbis header  	return (-1);  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_info,The following statement contains a magic number: opb.write (0x01' 8);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_info,The following statement contains a magic number: opb.write (0x00' 32);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_info,The following statement contains a magic number: opb.write (channels' 8);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_info,The following statement contains a magic number: opb.write (rate' 32);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_info,The following statement contains a magic number: opb.write (bitrate_upper' 32);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_info,The following statement contains a magic number: opb.write (bitrate_nominal' 32);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_info,The following statement contains a magic number: opb.write (bitrate_lower' 32);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_info,The following statement contains a magic number: opb.write (ilog2 (blocksizes [0])' 4);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_info,The following statement contains a magic number: opb.write (ilog2 (blocksizes [1])' 4);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write (0x05' 8);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write (books - 1' 8);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write (times - 1' 6);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: for (int i = 0; i < times; i++) {  	opb.write (time_type [i]' 16);  	FuncTime.time_P [time_type [i]].pack (this.time_param [i]' opb);  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write (time_type [i]' 16);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write (floors - 1' 6);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: for (int i = 0; i < floors; i++) {  	opb.write (floor_type [i]' 16);  	FuncFloor.floor_P [floor_type [i]].pack (floor_param [i]' opb);  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write (floor_type [i]' 16);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write (residues - 1' 6);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: for (int i = 0; i < residues; i++) {  	opb.write (residue_type [i]' 16);  	FuncResidue.residue_P [residue_type [i]].pack (residue_param [i]' opb);  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write (residue_type [i]' 16);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write (maps - 1' 6);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: for (int i = 0; i < maps; i++) {  	opb.write (map_type [i]' 16);  	FuncMapping.mapping_P [map_type [i]].pack (this' map_param [i]' opb);  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write (map_type [i]' 16);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write (modes - 1' 6);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: for (int i = 0; i < modes; i++) {  	opb.write (mode_param [i].blockflag' 1);  	opb.write (mode_param [i].windowtype' 16);  	opb.write (mode_param [i].transformtype' 16);  	opb.write (mode_param [i].mapping' 8);  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: for (int i = 0; i < modes; i++) {  	opb.write (mode_param [i].blockflag' 1);  	opb.write (mode_param [i].windowtype' 16);  	opb.write (mode_param [i].transformtype' 16);  	opb.write (mode_param [i].mapping' 8);  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: for (int i = 0; i < modes; i++) {  	opb.write (mode_param [i].blockflag' 1);  	opb.write (mode_param [i].windowtype' 16);  	opb.write (mode_param [i].transformtype' 16);  	opb.write (mode_param [i].mapping' 8);  }  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write (mode_param [i].windowtype' 16);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write (mode_param [i].transformtype' 16);  
Magic Number,csvorbis,Info,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Info.cs,pack_books,The following statement contains a magic number: opb.write (mode_param [i].mapping' 8);  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_from_data,The following statement contains a magic number: for (i = 0; i < m; i++) {  	float r = -aut [i + 1];  	if (error == 0) {  		for (int k = 0; k < m; k++)  			lpc [k] = 0.0f;  		return 0;  	}  	// Sum up this iteration's reflection coefficient; note that in  	// Vorbis we don't save it.  If anyone wants to recycle this code  	// and needs reflection coefficients' save the results of 'r' from  	// each iteration.  	for (j = 0; j < i; j++)  		r -= lpc [j] * aut [i - j];  	r /= error;  	// Update LPC coefficients and total error  	lpc [i] = r;  	for (j = 0; j < i / 2; j++) {  		float tmp = lpc [j];  		lpc [j] += r * lpc [i - 1 - j];  		lpc [i - 1 - j] += r * tmp;  	}  	if (i % 2 != 0)  		lpc [j] += lpc [j] * r;  	error *= (float)(1.0 - r * r);  }  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_from_data,The following statement contains a magic number: for (i = 0; i < m; i++) {  	float r = -aut [i + 1];  	if (error == 0) {  		for (int k = 0; k < m; k++)  			lpc [k] = 0.0f;  		return 0;  	}  	// Sum up this iteration's reflection coefficient; note that in  	// Vorbis we don't save it.  If anyone wants to recycle this code  	// and needs reflection coefficients' save the results of 'r' from  	// each iteration.  	for (j = 0; j < i; j++)  		r -= lpc [j] * aut [i - j];  	r /= error;  	// Update LPC coefficients and total error  	lpc [i] = r;  	for (j = 0; j < i / 2; j++) {  		float tmp = lpc [j];  		lpc [j] += r * lpc [i - 1 - j];  		lpc [i - 1 - j] += r * tmp;  	}  	if (i % 2 != 0)  		lpc [j] += lpc [j] * r;  	error *= (float)(1.0 - r * r);  }  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_from_data,The following statement contains a magic number: for (j = 0; j < i / 2; j++) {  	float tmp = lpc [j];  	lpc [j] += r * lpc [i - 1 - j];  	lpc [i - 1 - j] += r * tmp;  }  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_from_data,The following statement contains a magic number: if (i % 2 != 0)  	lpc [j] += lpc [j] * r;  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_from_curve,The following statement contains a magic number: for (i = 0; i < n; i++) {  	work [i * 2] = curve [i] * fscale;  	work [i * 2 + 1] = 0;  }  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_from_curve,The following statement contains a magic number: for (i = 0; i < n; i++) {  	work [i * 2] = curve [i] * fscale;  	work [i * 2 + 1] = 0;  }  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_from_curve,The following statement contains a magic number: work [i * 2] = curve [i] * fscale;  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_from_curve,The following statement contains a magic number: work [i * 2 + 1] = 0;  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_from_curve,The following statement contains a magic number: work [n * 2 - 1] = curve [n - 1] * fscale;  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_from_curve,The following statement contains a magic number: n *= 2;  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_from_curve,The following statement contains a magic number: for (i = 0' j = n / 2; i < n / 2;) {  	float temp = work [i];  	work [i++] = work [j];  	work [j++] = temp;  }  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_from_curve,The following statement contains a magic number: for (i = 0' j = n / 2; i < n / 2;) {  	float temp = work [i];  	work [i++] = work [j];  	work [j++] = temp;  }  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_from_curve,The following statement contains a magic number: j = n / 2
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,init,The following statement contains a magic number: fft.init (mapped * 2);  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: for (int i = 0; i < ln * 2; i++)  	curve [i] = 0.0f;  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	curve [i * 2 + 1] = lpc [i] / (4 * amp);  	curve [i * 2 + 2] = -lpc [i] / (4 * amp);  }  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	curve [i * 2 + 1] = lpc [i] / (4 * amp);  	curve [i * 2 + 2] = -lpc [i] / (4 * amp);  }  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	curve [i * 2 + 1] = lpc [i] / (4 * amp);  	curve [i * 2 + 2] = -lpc [i] / (4 * amp);  }  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	curve [i * 2 + 1] = lpc [i] / (4 * amp);  	curve [i * 2 + 2] = -lpc [i] / (4 * amp);  }  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: for (int i = 0; i < m; i++) {  	curve [i * 2 + 1] = lpc [i] / (4 * amp);  	curve [i * 2 + 2] = -lpc [i] / (4 * amp);  }  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: curve [i * 2 + 1] = lpc [i] / (4 * amp);  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: curve [i * 2 + 1] = lpc [i] / (4 * amp);  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: curve [i * 2 + 2] = -lpc [i] / (4 * amp);  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: curve [i * 2 + 2] = -lpc [i] / (4 * amp);  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: curve [i * 2 + 2] = -lpc [i] / (4 * amp);  
Magic Number,csvorbis,Lpc,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lpc.cs,lpc_to_curve,The following statement contains a magic number: curve [0] = (float)(1.0 / (curve [0] * 2 + unit));  
Magic Number,csvorbis,Lsp,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lsp.cs,lsp_to_curve,The following statement contains a magic number: while (i < n) {  	FloatHack fh = new FloatHack ();  	int k = map [i];  	float p = .7071067812f;  	float q = .7071067812f;  	float w = Lookup.coslook (wdel * k);  	//int ftmp=0;  	int c = (int)((uint)m >> 1);  	for (int j = 0; j < m2; j += 2) {  		q *= lsp [j] - w;  		p *= lsp [j + 1] - w;  	}  	if ((m & 1) != 0) {  		/* odd order filter; slightly assymetric *//* the last coefficient */q *= lsp [m - 1] - w;  		q *= q;  		p *= p * (1.0f - w * w);  	}  	else {  		/* even order filter; still symmetric */q *= q * (1.0f + w);  		p *= p * (1.0f - w);  	}  	//  q=frexp(p+q'&qexp);  	q = p + q;  	fh.fh_float = q;  	int hx = fh.fh_int;  	int ix = 0x7fffffff & hx;  	int qexp = 0;  	if (ix >= 0x7f800000 || (ix == 0)) {  		// 0'inf'nan  	}  	else {  		if (ix < 0x00800000) {  			// subnormal  			q *= 3.3554432000e+07F;  			// 0x4c000000  			fh.fh_float = q;  			hx = fh.fh_int;  			ix = 0x7fffffff & hx;  			qexp = -25;  		}  		qexp += (int)(((uint)ix >> 23) - 126);  		hx = (int)((hx & 0x807fffff) | 0x3f000000);  		fh.fh_int = hx;  		q = fh.fh_float;  	}  	q = Lookup.fromdBlook (amp * Lookup.invsqlook (q) * Lookup.invsq2explook (qexp + m) - ampoffset);  	do {  		curve [i] *= q;  		i++;  	}  	//    do{curve[i++]=q;}  	while (i < n && map [i] == k);  }  
Magic Number,csvorbis,Lsp,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lsp.cs,lsp_to_curve,The following statement contains a magic number: while (i < n) {  	FloatHack fh = new FloatHack ();  	int k = map [i];  	float p = .7071067812f;  	float q = .7071067812f;  	float w = Lookup.coslook (wdel * k);  	//int ftmp=0;  	int c = (int)((uint)m >> 1);  	for (int j = 0; j < m2; j += 2) {  		q *= lsp [j] - w;  		p *= lsp [j + 1] - w;  	}  	if ((m & 1) != 0) {  		/* odd order filter; slightly assymetric *//* the last coefficient */q *= lsp [m - 1] - w;  		q *= q;  		p *= p * (1.0f - w * w);  	}  	else {  		/* even order filter; still symmetric */q *= q * (1.0f + w);  		p *= p * (1.0f - w);  	}  	//  q=frexp(p+q'&qexp);  	q = p + q;  	fh.fh_float = q;  	int hx = fh.fh_int;  	int ix = 0x7fffffff & hx;  	int qexp = 0;  	if (ix >= 0x7f800000 || (ix == 0)) {  		// 0'inf'nan  	}  	else {  		if (ix < 0x00800000) {  			// subnormal  			q *= 3.3554432000e+07F;  			// 0x4c000000  			fh.fh_float = q;  			hx = fh.fh_int;  			ix = 0x7fffffff & hx;  			qexp = -25;  		}  		qexp += (int)(((uint)ix >> 23) - 126);  		hx = (int)((hx & 0x807fffff) | 0x3f000000);  		fh.fh_int = hx;  		q = fh.fh_float;  	}  	q = Lookup.fromdBlook (amp * Lookup.invsqlook (q) * Lookup.invsq2explook (qexp + m) - ampoffset);  	do {  		curve [i] *= q;  		i++;  	}  	//    do{curve[i++]=q;}  	while (i < n && map [i] == k);  }  
Magic Number,csvorbis,Lsp,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lsp.cs,lsp_to_curve,The following statement contains a magic number: while (i < n) {  	FloatHack fh = new FloatHack ();  	int k = map [i];  	float p = .7071067812f;  	float q = .7071067812f;  	float w = Lookup.coslook (wdel * k);  	//int ftmp=0;  	int c = (int)((uint)m >> 1);  	for (int j = 0; j < m2; j += 2) {  		q *= lsp [j] - w;  		p *= lsp [j + 1] - w;  	}  	if ((m & 1) != 0) {  		/* odd order filter; slightly assymetric *//* the last coefficient */q *= lsp [m - 1] - w;  		q *= q;  		p *= p * (1.0f - w * w);  	}  	else {  		/* even order filter; still symmetric */q *= q * (1.0f + w);  		p *= p * (1.0f - w);  	}  	//  q=frexp(p+q'&qexp);  	q = p + q;  	fh.fh_float = q;  	int hx = fh.fh_int;  	int ix = 0x7fffffff & hx;  	int qexp = 0;  	if (ix >= 0x7f800000 || (ix == 0)) {  		// 0'inf'nan  	}  	else {  		if (ix < 0x00800000) {  			// subnormal  			q *= 3.3554432000e+07F;  			// 0x4c000000  			fh.fh_float = q;  			hx = fh.fh_int;  			ix = 0x7fffffff & hx;  			qexp = -25;  		}  		qexp += (int)(((uint)ix >> 23) - 126);  		hx = (int)((hx & 0x807fffff) | 0x3f000000);  		fh.fh_int = hx;  		q = fh.fh_float;  	}  	q = Lookup.fromdBlook (amp * Lookup.invsqlook (q) * Lookup.invsq2explook (qexp + m) - ampoffset);  	do {  		curve [i] *= q;  		i++;  	}  	//    do{curve[i++]=q;}  	while (i < n && map [i] == k);  }  
Magic Number,csvorbis,Lsp,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lsp.cs,lsp_to_curve,The following statement contains a magic number: while (i < n) {  	FloatHack fh = new FloatHack ();  	int k = map [i];  	float p = .7071067812f;  	float q = .7071067812f;  	float w = Lookup.coslook (wdel * k);  	//int ftmp=0;  	int c = (int)((uint)m >> 1);  	for (int j = 0; j < m2; j += 2) {  		q *= lsp [j] - w;  		p *= lsp [j + 1] - w;  	}  	if ((m & 1) != 0) {  		/* odd order filter; slightly assymetric *//* the last coefficient */q *= lsp [m - 1] - w;  		q *= q;  		p *= p * (1.0f - w * w);  	}  	else {  		/* even order filter; still symmetric */q *= q * (1.0f + w);  		p *= p * (1.0f - w);  	}  	//  q=frexp(p+q'&qexp);  	q = p + q;  	fh.fh_float = q;  	int hx = fh.fh_int;  	int ix = 0x7fffffff & hx;  	int qexp = 0;  	if (ix >= 0x7f800000 || (ix == 0)) {  		// 0'inf'nan  	}  	else {  		if (ix < 0x00800000) {  			// subnormal  			q *= 3.3554432000e+07F;  			// 0x4c000000  			fh.fh_float = q;  			hx = fh.fh_int;  			ix = 0x7fffffff & hx;  			qexp = -25;  		}  		qexp += (int)(((uint)ix >> 23) - 126);  		hx = (int)((hx & 0x807fffff) | 0x3f000000);  		fh.fh_int = hx;  		q = fh.fh_float;  	}  	q = Lookup.fromdBlook (amp * Lookup.invsqlook (q) * Lookup.invsq2explook (qexp + m) - ampoffset);  	do {  		curve [i] *= q;  		i++;  	}  	//    do{curve[i++]=q;}  	while (i < n && map [i] == k);  }  
Magic Number,csvorbis,Lsp,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lsp.cs,lsp_to_curve,The following statement contains a magic number: for (int j = 0; j < m2; j += 2) {  	q *= lsp [j] - w;  	p *= lsp [j + 1] - w;  }  
Magic Number,csvorbis,Lsp,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lsp.cs,lsp_to_curve,The following statement contains a magic number: j += 2
Magic Number,csvorbis,Lsp,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lsp.cs,lsp_to_curve,The following statement contains a magic number: if (ix >= 0x7f800000 || (ix == 0)) {  	// 0'inf'nan  }  else {  	if (ix < 0x00800000) {  		// subnormal  		q *= 3.3554432000e+07F;  		// 0x4c000000  		fh.fh_float = q;  		hx = fh.fh_int;  		ix = 0x7fffffff & hx;  		qexp = -25;  	}  	qexp += (int)(((uint)ix >> 23) - 126);  	hx = (int)((hx & 0x807fffff) | 0x3f000000);  	fh.fh_int = hx;  	q = fh.fh_float;  }  
Magic Number,csvorbis,Lsp,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lsp.cs,lsp_to_curve,The following statement contains a magic number: if (ix >= 0x7f800000 || (ix == 0)) {  	// 0'inf'nan  }  else {  	if (ix < 0x00800000) {  		// subnormal  		q *= 3.3554432000e+07F;  		// 0x4c000000  		fh.fh_float = q;  		hx = fh.fh_int;  		ix = 0x7fffffff & hx;  		qexp = -25;  	}  	qexp += (int)(((uint)ix >> 23) - 126);  	hx = (int)((hx & 0x807fffff) | 0x3f000000);  	fh.fh_int = hx;  	q = fh.fh_float;  }  
Magic Number,csvorbis,Lsp,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lsp.cs,lsp_to_curve,The following statement contains a magic number: if (ix >= 0x7f800000 || (ix == 0)) {  	// 0'inf'nan  }  else {  	if (ix < 0x00800000) {  		// subnormal  		q *= 3.3554432000e+07F;  		// 0x4c000000  		fh.fh_float = q;  		hx = fh.fh_int;  		ix = 0x7fffffff & hx;  		qexp = -25;  	}  	qexp += (int)(((uint)ix >> 23) - 126);  	hx = (int)((hx & 0x807fffff) | 0x3f000000);  	fh.fh_int = hx;  	q = fh.fh_float;  }  
Magic Number,csvorbis,Lsp,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lsp.cs,lsp_to_curve,The following statement contains a magic number: if (ix < 0x00800000) {  	// subnormal  	q *= 3.3554432000e+07F;  	// 0x4c000000  	fh.fh_float = q;  	hx = fh.fh_int;  	ix = 0x7fffffff & hx;  	qexp = -25;  }  
Magic Number,csvorbis,Lsp,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lsp.cs,lsp_to_curve,The following statement contains a magic number: qexp = -25;  
Magic Number,csvorbis,Lsp,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lsp.cs,lsp_to_curve,The following statement contains a magic number: qexp += (int)(((uint)ix >> 23) - 126);  
Magic Number,csvorbis,Lsp,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Lsp.cs,lsp_to_curve,The following statement contains a magic number: qexp += (int)(((uint)ix >> 23) - 126);  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: if (info.submaps > 1) {  	opb.write (1' 1);  	opb.write (info.submaps - 1' 4);  }  else {  	opb.write (0' 1);  }  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: opb.write (info.submaps - 1' 4);  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: if (info.coupling_steps > 0) {  	opb.write (1' 1);  	opb.write (info.coupling_steps - 1' 8);  	for (int i = 0; i < info.coupling_steps; i++) {  		opb.write (info.coupling_mag [i]' ilog2 (vi.channels));  		opb.write (info.coupling_ang [i]' ilog2 (vi.channels));  	}  }  else {  	opb.write (0' 1);  }  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: opb.write (info.coupling_steps - 1' 8);  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: opb.write (0' 2);  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: if (info.submaps > 1) {  	for (int i = 0; i < vi.channels; i++)  		opb.write (info.chmuxlist [i]' 4);  }  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: for (int i = 0; i < vi.channels; i++)  	opb.write (info.chmuxlist [i]' 4);  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: opb.write (info.chmuxlist [i]' 4);  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: for (int i = 0; i < info.submaps; i++) {  	opb.write (info.timesubmap [i]' 8);  	opb.write (info.floorsubmap [i]' 8);  	opb.write (info.residuesubmap [i]' 8);  }  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: for (int i = 0; i < info.submaps; i++) {  	opb.write (info.timesubmap [i]' 8);  	opb.write (info.floorsubmap [i]' 8);  	opb.write (info.residuesubmap [i]' 8);  }  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: for (int i = 0; i < info.submaps; i++) {  	opb.write (info.timesubmap [i]' 8);  	opb.write (info.floorsubmap [i]' 8);  	opb.write (info.residuesubmap [i]' 8);  }  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: opb.write (info.timesubmap [i]' 8);  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: opb.write (info.floorsubmap [i]' 8);  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,pack,The following statement contains a magic number: opb.write (info.residuesubmap [i]' 8);  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: if (opb.read (1) != 0) {  	info.submaps = opb.read (4) + 1;  }  else {  	info.submaps = 1;  }  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: info.submaps = opb.read (4) + 1;  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: if (opb.read (1) != 0) {  	info.coupling_steps = opb.read (8) + 1;  	for (int i = 0; i < info.coupling_steps; i++) {  		int testM = info.coupling_mag [i] = opb.read (ilog2 (vi.channels));  		int testA = info.coupling_ang [i] = opb.read (ilog2 (vi.channels));  		if (testM < 0 || testA < 0 || testM == testA || testM >= vi.channels || testA >= vi.channels) {  			//goto err_out;  			info.free ();  			return (null);  		}  	}  }  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: info.coupling_steps = opb.read (8) + 1;  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: if (opb.read (2) > 0) {  	/* 2'3:reserved *///goto err_out;  	info.free ();  	return (null);  }  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: if (info.submaps > 1) {  	for (int i = 0; i < vi.channels; i++) {  		info.chmuxlist [i] = opb.read (4);  		if (info.chmuxlist [i] >= info.submaps) {  			//goto err_out;  			info.free ();  			return (null);  		}  	}  }  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: for (int i = 0; i < vi.channels; i++) {  	info.chmuxlist [i] = opb.read (4);  	if (info.chmuxlist [i] >= info.submaps) {  		//goto err_out;  		info.free ();  		return (null);  	}  }  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: info.chmuxlist [i] = opb.read (4);  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: for (int i = 0; i < info.submaps; i++) {  	info.timesubmap [i] = opb.read (8);  	if (info.timesubmap [i] >= vi.times) {  		//goto err_out;  		info.free ();  		return (null);  	}  	info.floorsubmap [i] = opb.read (8);  	if (info.floorsubmap [i] >= vi.floors) {  		//goto err_out;  		info.free ();  		return (null);  	}  	info.residuesubmap [i] = opb.read (8);  	if (info.residuesubmap [i] >= vi.residues) {  		//goto err_out;  		info.free ();  		return (null);  	}  }  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: for (int i = 0; i < info.submaps; i++) {  	info.timesubmap [i] = opb.read (8);  	if (info.timesubmap [i] >= vi.times) {  		//goto err_out;  		info.free ();  		return (null);  	}  	info.floorsubmap [i] = opb.read (8);  	if (info.floorsubmap [i] >= vi.floors) {  		//goto err_out;  		info.free ();  		return (null);  	}  	info.residuesubmap [i] = opb.read (8);  	if (info.residuesubmap [i] >= vi.residues) {  		//goto err_out;  		info.free ();  		return (null);  	}  }  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: for (int i = 0; i < info.submaps; i++) {  	info.timesubmap [i] = opb.read (8);  	if (info.timesubmap [i] >= vi.times) {  		//goto err_out;  		info.free ();  		return (null);  	}  	info.floorsubmap [i] = opb.read (8);  	if (info.floorsubmap [i] >= vi.floors) {  		//goto err_out;  		info.free ();  		return (null);  	}  	info.residuesubmap [i] = opb.read (8);  	if (info.residuesubmap [i] >= vi.residues) {  		//goto err_out;  		info.free ();  		return (null);  	}  }  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: info.timesubmap [i] = opb.read (8);  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: info.floorsubmap [i] = opb.read (8);  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,unpack,The following statement contains a magic number: info.residuesubmap [i] = opb.read (8);  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,inverse,The following statement contains a magic number: lock (this) {  	//System.err.println("Mapping0.inverse");  	DspState vd = vb.vd;  	Info vi = vd.vi;  	LookMapping0 look = (LookMapping0)l;  	InfoMapping0 info = look.map;  	InfoMode mode = look.mode;  	int n = vb.pcmend = vi.blocksizes [vb.W];  	float[] window = vd.wnd [vb.W] [vb.lW] [vb.nW] [mode.windowtype];  	// float[][] pcmbundle=new float[vi.channels][];  	// int[] nonzero=new int[vi.channels];  	if (pcmbundle == null || pcmbundle.Length < vi.channels) {  		pcmbundle = new float[vi.channels][];  		nonzero = new int[vi.channels];  		zerobundle = new int[vi.channels];  		floormemo = new Object[vi.channels];  	}  	// time domain information decode (note that applying the  	// information would have to happen later; we'll probably add a  	// function entry to the harness for that later  	// NOT IMPLEMENTED  	// recover the spectral envelope; store it in the PCM vector for now   	for (int i = 0; i < vi.channels; i++) {  		float[] pcm = vb.pcm [i];  		int submap = info.chmuxlist [i];  		floormemo [i] = look.floor_func [submap].inverse1 (vb' look.floor_look [submap]' floormemo [i]);  		if (floormemo [i] != null) {  			nonzero [i] = 1;  		}  		else {  			nonzero [i] = 0;  		}  		for (int j = 0; j < n / 2; j++) {  			pcm [j] = 0;  		}  		//_analysis_output("ifloor"'seq+i'pcm'n/2'0'1);  	}  	for (int i = 0; i < info.coupling_steps; i++) {  		if (nonzero [info.coupling_mag [i]] != 0 || nonzero [info.coupling_ang [i]] != 0) {  			nonzero [info.coupling_mag [i]] = 1;  			nonzero [info.coupling_ang [i]] = 1;  		}  	}  	// recover the residue' apply directly to the spectral envelope  	for (int i = 0; i < info.submaps; i++) {  		int ch_in_bundle = 0;  		for (int j = 0; j < vi.channels; j++) {  			if (info.chmuxlist [j] == i) {  				if (nonzero [j] != 0) {  					zerobundle [ch_in_bundle] = 1;  				}  				else {  					zerobundle [ch_in_bundle] = 0;  				}  				pcmbundle [ch_in_bundle++] = vb.pcm [j];  			}  		}  		look.residue_func [i].inverse (vb' look.residue_look [i]' pcmbundle' zerobundle' ch_in_bundle);  	}  	for (int i = info.coupling_steps - 1; i >= 0; i--) {  		float[] pcmM = vb.pcm [info.coupling_mag [i]];  		float[] pcmA = vb.pcm [info.coupling_ang [i]];  		for (int j = 0; j < n / 2; j++) {  			float mag = pcmM [j];  			float ang = pcmA [j];  			if (mag > 0) {  				if (ang > 0) {  					pcmM [j] = mag;  					pcmA [j] = mag - ang;  				}  				else {  					pcmA [j] = mag;  					pcmM [j] = mag + ang;  				}  			}  			else {  				if (ang > 0) {  					pcmM [j] = mag;  					pcmA [j] = mag + ang;  				}  				else {  					pcmA [j] = mag;  					pcmM [j] = mag - ang;  				}  			}  		}  	}  	//    /* compute and apply spectral envelope */  	for (int i = 0; i < vi.channels; i++) {  		float[] pcm = vb.pcm [i];  		int submap = info.chmuxlist [i];  		look.floor_func [submap].inverse2 (vb' look.floor_look [submap]' floormemo [i]' pcm);  	}  	// transform the PCM data; takes PCM vector' vb; modifies PCM vector  	// only MDCT right now....  	for (int i = 0; i < vi.channels; i++) {  		float[] pcm = vb.pcm [i];  		//_analysis_output("out"'seq+i'pcm'n/2'0'0);  		((Mdct)vd.transform [vb.W] [0]).backward (pcm' pcm);  	}  	// now apply the decoded pre-window time information  	// NOT IMPLEMENTED  	// window the data  	for (int i = 0; i < vi.channels; i++) {  		float[] pcm = vb.pcm [i];  		if (nonzero [i] != 0) {  			for (int j = 0; j < n; j++) {  				pcm [j] *= window [j];  			}  		}  		else {  			for (int j = 0; j < n; j++) {  				pcm [j] = 0.0f;  			}  		}  		//_analysis_output("final"'seq++'pcm'n'0'0);  	}  	// now apply the decoded post-window time information  	// NOT IMPLEMENTED  	// all done!  	return (0);  }  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,inverse,The following statement contains a magic number: lock (this) {  	//System.err.println("Mapping0.inverse");  	DspState vd = vb.vd;  	Info vi = vd.vi;  	LookMapping0 look = (LookMapping0)l;  	InfoMapping0 info = look.map;  	InfoMode mode = look.mode;  	int n = vb.pcmend = vi.blocksizes [vb.W];  	float[] window = vd.wnd [vb.W] [vb.lW] [vb.nW] [mode.windowtype];  	// float[][] pcmbundle=new float[vi.channels][];  	// int[] nonzero=new int[vi.channels];  	if (pcmbundle == null || pcmbundle.Length < vi.channels) {  		pcmbundle = new float[vi.channels][];  		nonzero = new int[vi.channels];  		zerobundle = new int[vi.channels];  		floormemo = new Object[vi.channels];  	}  	// time domain information decode (note that applying the  	// information would have to happen later; we'll probably add a  	// function entry to the harness for that later  	// NOT IMPLEMENTED  	// recover the spectral envelope; store it in the PCM vector for now   	for (int i = 0; i < vi.channels; i++) {  		float[] pcm = vb.pcm [i];  		int submap = info.chmuxlist [i];  		floormemo [i] = look.floor_func [submap].inverse1 (vb' look.floor_look [submap]' floormemo [i]);  		if (floormemo [i] != null) {  			nonzero [i] = 1;  		}  		else {  			nonzero [i] = 0;  		}  		for (int j = 0; j < n / 2; j++) {  			pcm [j] = 0;  		}  		//_analysis_output("ifloor"'seq+i'pcm'n/2'0'1);  	}  	for (int i = 0; i < info.coupling_steps; i++) {  		if (nonzero [info.coupling_mag [i]] != 0 || nonzero [info.coupling_ang [i]] != 0) {  			nonzero [info.coupling_mag [i]] = 1;  			nonzero [info.coupling_ang [i]] = 1;  		}  	}  	// recover the residue' apply directly to the spectral envelope  	for (int i = 0; i < info.submaps; i++) {  		int ch_in_bundle = 0;  		for (int j = 0; j < vi.channels; j++) {  			if (info.chmuxlist [j] == i) {  				if (nonzero [j] != 0) {  					zerobundle [ch_in_bundle] = 1;  				}  				else {  					zerobundle [ch_in_bundle] = 0;  				}  				pcmbundle [ch_in_bundle++] = vb.pcm [j];  			}  		}  		look.residue_func [i].inverse (vb' look.residue_look [i]' pcmbundle' zerobundle' ch_in_bundle);  	}  	for (int i = info.coupling_steps - 1; i >= 0; i--) {  		float[] pcmM = vb.pcm [info.coupling_mag [i]];  		float[] pcmA = vb.pcm [info.coupling_ang [i]];  		for (int j = 0; j < n / 2; j++) {  			float mag = pcmM [j];  			float ang = pcmA [j];  			if (mag > 0) {  				if (ang > 0) {  					pcmM [j] = mag;  					pcmA [j] = mag - ang;  				}  				else {  					pcmA [j] = mag;  					pcmM [j] = mag + ang;  				}  			}  			else {  				if (ang > 0) {  					pcmM [j] = mag;  					pcmA [j] = mag + ang;  				}  				else {  					pcmA [j] = mag;  					pcmM [j] = mag - ang;  				}  			}  		}  	}  	//    /* compute and apply spectral envelope */  	for (int i = 0; i < vi.channels; i++) {  		float[] pcm = vb.pcm [i];  		int submap = info.chmuxlist [i];  		look.floor_func [submap].inverse2 (vb' look.floor_look [submap]' floormemo [i]' pcm);  	}  	// transform the PCM data; takes PCM vector' vb; modifies PCM vector  	// only MDCT right now....  	for (int i = 0; i < vi.channels; i++) {  		float[] pcm = vb.pcm [i];  		//_analysis_output("out"'seq+i'pcm'n/2'0'0);  		((Mdct)vd.transform [vb.W] [0]).backward (pcm' pcm);  	}  	// now apply the decoded pre-window time information  	// NOT IMPLEMENTED  	// window the data  	for (int i = 0; i < vi.channels; i++) {  		float[] pcm = vb.pcm [i];  		if (nonzero [i] != 0) {  			for (int j = 0; j < n; j++) {  				pcm [j] *= window [j];  			}  		}  		else {  			for (int j = 0; j < n; j++) {  				pcm [j] = 0.0f;  			}  		}  		//_analysis_output("final"'seq++'pcm'n'0'0);  	}  	// now apply the decoded post-window time information  	// NOT IMPLEMENTED  	// all done!  	return (0);  }  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,inverse,The following statement contains a magic number: for (int i = 0; i < vi.channels; i++) {  	float[] pcm = vb.pcm [i];  	int submap = info.chmuxlist [i];  	floormemo [i] = look.floor_func [submap].inverse1 (vb' look.floor_look [submap]' floormemo [i]);  	if (floormemo [i] != null) {  		nonzero [i] = 1;  	}  	else {  		nonzero [i] = 0;  	}  	for (int j = 0; j < n / 2; j++) {  		pcm [j] = 0;  	}  	//_analysis_output("ifloor"'seq+i'pcm'n/2'0'1);  }  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,inverse,The following statement contains a magic number: for (int j = 0; j < n / 2; j++) {  	pcm [j] = 0;  }  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,inverse,The following statement contains a magic number: for (int i = info.coupling_steps - 1; i >= 0; i--) {  	float[] pcmM = vb.pcm [info.coupling_mag [i]];  	float[] pcmA = vb.pcm [info.coupling_ang [i]];  	for (int j = 0; j < n / 2; j++) {  		float mag = pcmM [j];  		float ang = pcmA [j];  		if (mag > 0) {  			if (ang > 0) {  				pcmM [j] = mag;  				pcmA [j] = mag - ang;  			}  			else {  				pcmA [j] = mag;  				pcmM [j] = mag + ang;  			}  		}  		else {  			if (ang > 0) {  				pcmM [j] = mag;  				pcmA [j] = mag + ang;  			}  			else {  				pcmA [j] = mag;  				pcmM [j] = mag - ang;  			}  		}  	}  }  
Magic Number,csvorbis,Mapping0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mapping0.cs,inverse,The following statement contains a magic number: for (int j = 0; j < n / 2; j++) {  	float mag = pcmM [j];  	float ang = pcmA [j];  	if (mag > 0) {  		if (ang > 0) {  			pcmM [j] = mag;  			pcmA [j] = mag - ang;  		}  		else {  			pcmA [j] = mag;  			pcmM [j] = mag + ang;  		}  	}  	else {  		if (ang > 0) {  			pcmM [j] = mag;  			pcmA [j] = mag + ang;  		}  		else {  			pcmA [j] = mag;  			pcmM [j] = mag - ang;  		}  	}  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: bitrev = new int[n / 4];  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: trig = new float[n + n / 4];  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: log2n = (int)Math.Round (Math.Log (n) / Math.Log (2));  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 4; i++) {  	trig [AE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i));  	trig [AO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i));  	trig [BE + i * 2] = (float)Math.Cos ((Math.PI / (2 * n)) * (2 * i + 1));  	trig [BO + i * 2] = (float)Math.Sin ((Math.PI / (2 * n)) * (2 * i + 1));  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 4; i++) {  	trig [AE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i));  	trig [AO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i));  	trig [BE + i * 2] = (float)Math.Cos ((Math.PI / (2 * n)) * (2 * i + 1));  	trig [BO + i * 2] = (float)Math.Sin ((Math.PI / (2 * n)) * (2 * i + 1));  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 4; i++) {  	trig [AE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i));  	trig [AO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i));  	trig [BE + i * 2] = (float)Math.Cos ((Math.PI / (2 * n)) * (2 * i + 1));  	trig [BO + i * 2] = (float)Math.Sin ((Math.PI / (2 * n)) * (2 * i + 1));  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 4; i++) {  	trig [AE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i));  	trig [AO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i));  	trig [BE + i * 2] = (float)Math.Cos ((Math.PI / (2 * n)) * (2 * i + 1));  	trig [BO + i * 2] = (float)Math.Sin ((Math.PI / (2 * n)) * (2 * i + 1));  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 4; i++) {  	trig [AE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i));  	trig [AO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i));  	trig [BE + i * 2] = (float)Math.Cos ((Math.PI / (2 * n)) * (2 * i + 1));  	trig [BO + i * 2] = (float)Math.Sin ((Math.PI / (2 * n)) * (2 * i + 1));  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 4; i++) {  	trig [AE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i));  	trig [AO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i));  	trig [BE + i * 2] = (float)Math.Cos ((Math.PI / (2 * n)) * (2 * i + 1));  	trig [BO + i * 2] = (float)Math.Sin ((Math.PI / (2 * n)) * (2 * i + 1));  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 4; i++) {  	trig [AE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i));  	trig [AO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i));  	trig [BE + i * 2] = (float)Math.Cos ((Math.PI / (2 * n)) * (2 * i + 1));  	trig [BO + i * 2] = (float)Math.Sin ((Math.PI / (2 * n)) * (2 * i + 1));  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 4; i++) {  	trig [AE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i));  	trig [AO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i));  	trig [BE + i * 2] = (float)Math.Cos ((Math.PI / (2 * n)) * (2 * i + 1));  	trig [BO + i * 2] = (float)Math.Sin ((Math.PI / (2 * n)) * (2 * i + 1));  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 4; i++) {  	trig [AE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i));  	trig [AO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i));  	trig [BE + i * 2] = (float)Math.Cos ((Math.PI / (2 * n)) * (2 * i + 1));  	trig [BO + i * 2] = (float)Math.Sin ((Math.PI / (2 * n)) * (2 * i + 1));  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 4; i++) {  	trig [AE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i));  	trig [AO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i));  	trig [BE + i * 2] = (float)Math.Cos ((Math.PI / (2 * n)) * (2 * i + 1));  	trig [BO + i * 2] = (float)Math.Sin ((Math.PI / (2 * n)) * (2 * i + 1));  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 4; i++) {  	trig [AE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i));  	trig [AO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i));  	trig [BE + i * 2] = (float)Math.Cos ((Math.PI / (2 * n)) * (2 * i + 1));  	trig [BO + i * 2] = (float)Math.Sin ((Math.PI / (2 * n)) * (2 * i + 1));  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: trig [AE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i));  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: trig [AE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i));  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: trig [AO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i));  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: trig [AO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i));  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: trig [BE + i * 2] = (float)Math.Cos ((Math.PI / (2 * n)) * (2 * i + 1));  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: trig [BE + i * 2] = (float)Math.Cos ((Math.PI / (2 * n)) * (2 * i + 1));  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: trig [BE + i * 2] = (float)Math.Cos ((Math.PI / (2 * n)) * (2 * i + 1));  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: trig [BO + i * 2] = (float)Math.Sin ((Math.PI / (2 * n)) * (2 * i + 1));  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: trig [BO + i * 2] = (float)Math.Sin ((Math.PI / (2 * n)) * (2 * i + 1));  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: trig [BO + i * 2] = (float)Math.Sin ((Math.PI / (2 * n)) * (2 * i + 1));  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 8; i++) {  	trig [CE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i + 2));  	trig [CO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i + 2));  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 8; i++) {  	trig [CE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i + 2));  	trig [CO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i + 2));  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 8; i++) {  	trig [CE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i + 2));  	trig [CO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i + 2));  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 8; i++) {  	trig [CE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i + 2));  	trig [CO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i + 2));  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 8; i++) {  	trig [CE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i + 2));  	trig [CO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i + 2));  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 8; i++) {  	trig [CE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i + 2));  	trig [CO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i + 2));  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 8; i++) {  	trig [CE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i + 2));  	trig [CO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i + 2));  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: trig [CE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i + 2));  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: trig [CE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i + 2));  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: trig [CE + i * 2] = (float)Math.Cos ((Math.PI / n) * (4 * i + 2));  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: trig [CO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i + 2));  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: trig [CO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i + 2));  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: trig [CO + i * 2] = (float)-Math.Sin ((Math.PI / n) * (4 * i + 2));  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 8; i++) {  	int acc = 0;  	for (int j = 0; (((uint)msb) >> j) != 0; j++)  		if (((((uint)msb >> j)) & i) != 0)  			acc |= 1 << j;  	bitrev [i * 2] = ((~acc) & mask);  	//	bitrev[i*2]=((~acc)&mask)-1;  	bitrev [i * 2 + 1] = acc;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 8; i++) {  	int acc = 0;  	for (int j = 0; (((uint)msb) >> j) != 0; j++)  		if (((((uint)msb >> j)) & i) != 0)  			acc |= 1 << j;  	bitrev [i * 2] = ((~acc) & mask);  	//	bitrev[i*2]=((~acc)&mask)-1;  	bitrev [i * 2 + 1] = acc;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: for (int i = 0; i < n / 8; i++) {  	int acc = 0;  	for (int j = 0; (((uint)msb) >> j) != 0; j++)  		if (((((uint)msb >> j)) & i) != 0)  			acc |= 1 << j;  	bitrev [i * 2] = ((~acc) & mask);  	//	bitrev[i*2]=((~acc)&mask)-1;  	bitrev [i * 2 + 1] = acc;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: bitrev [i * 2] = ((~acc) & mask);  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,init,The following statement contains a magic number: bitrev [i * 2 + 1] = acc;  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: if (_x.Length < n / 2) {  	_x = new float[n / 2];  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: if (_x.Length < n / 2) {  	_x = new float[n / 2];  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: _x = new float[n / 2];  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: if (_w.Length < n / 2) {  	_w = new float[n / 2];  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: if (_w.Length < n / 2) {  	_w = new float[n / 2];  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: _w = new float[n / 2];  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: for (i = 0; i < n8; i++) {  	A -= 2;  	x [xO++] = -fin [inO + 2] * trig [A + 1] - fin [inO] * trig [A];  	x [xO++] = fin [inO] * trig [A + 1] - fin [inO + 2] * trig [A];  	inO += 4;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: for (i = 0; i < n8; i++) {  	A -= 2;  	x [xO++] = -fin [inO + 2] * trig [A + 1] - fin [inO] * trig [A];  	x [xO++] = fin [inO] * trig [A + 1] - fin [inO + 2] * trig [A];  	inO += 4;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: for (i = 0; i < n8; i++) {  	A -= 2;  	x [xO++] = -fin [inO + 2] * trig [A + 1] - fin [inO] * trig [A];  	x [xO++] = fin [inO] * trig [A + 1] - fin [inO + 2] * trig [A];  	inO += 4;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: for (i = 0; i < n8; i++) {  	A -= 2;  	x [xO++] = -fin [inO + 2] * trig [A + 1] - fin [inO] * trig [A];  	x [xO++] = fin [inO] * trig [A + 1] - fin [inO + 2] * trig [A];  	inO += 4;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: A -= 2;  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: x [xO++] = -fin [inO + 2] * trig [A + 1] - fin [inO] * trig [A];  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: x [xO++] = fin [inO] * trig [A + 1] - fin [inO + 2] * trig [A];  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: inO += 4;  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: inO = n2 - 4;  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: for (i = 0; i < n8; i++) {  	A -= 2;  	x [xO++] = fin [inO] * trig [A + 1] + fin [inO + 2] * trig [A];  	x [xO++] = fin [inO] * trig [A] - fin [inO + 2] * trig [A + 1];  	inO -= 4;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: for (i = 0; i < n8; i++) {  	A -= 2;  	x [xO++] = fin [inO] * trig [A + 1] + fin [inO + 2] * trig [A];  	x [xO++] = fin [inO] * trig [A] - fin [inO + 2] * trig [A + 1];  	inO -= 4;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: for (i = 0; i < n8; i++) {  	A -= 2;  	x [xO++] = fin [inO] * trig [A + 1] + fin [inO + 2] * trig [A];  	x [xO++] = fin [inO] * trig [A] - fin [inO + 2] * trig [A + 1];  	inO -= 4;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: for (i = 0; i < n8; i++) {  	A -= 2;  	x [xO++] = fin [inO] * trig [A + 1] + fin [inO + 2] * trig [A];  	x [xO++] = fin [inO] * trig [A] - fin [inO + 2] * trig [A + 1];  	inO -= 4;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: A -= 2;  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: x [xO++] = fin [inO] * trig [A + 1] + fin [inO + 2] * trig [A];  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: x [xO++] = fin [inO] * trig [A] - fin [inO + 2] * trig [A + 1];  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: inO -= 4;  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: for (int i = 0; i < n4; i++) {  	float temp1 = (xxx [xx] * trig [B + 1] - xxx [xx + 1] * trig [B]);  	float temp2 = -(xxx [xx] * trig [B] + xxx [xx + 1] * trig [B + 1]);  	fout [o1] = -temp1;  	fout [o2] = temp1;  	fout [o3] = temp2;  	fout [o4] = temp2;  	o1++;  	o2--;  	o3++;  	o4--;  	xx += 2;  	B += 2;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: for (int i = 0; i < n4; i++) {  	float temp1 = (xxx [xx] * trig [B + 1] - xxx [xx + 1] * trig [B]);  	float temp2 = -(xxx [xx] * trig [B] + xxx [xx + 1] * trig [B + 1]);  	fout [o1] = -temp1;  	fout [o2] = temp1;  	fout [o3] = temp2;  	fout [o4] = temp2;  	o1++;  	o2--;  	o3++;  	o4--;  	xx += 2;  	B += 2;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: xx += 2;  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,backward,The following statement contains a magic number: B += 2;  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: for (int i = 0; i < n4;) {  	float x0 = x [xA] - x [xB];  	float x1;  	w [w2 + i] = x [xA++] + x [xB++];  	x1 = x [xA] - x [xB];  	A -= 4;  	w [i++] = x0 * trig [A] + x1 * trig [A + 1];  	w [i] = x1 * trig [A] - x0 * trig [A + 1];  	w [w2 + i] = x [xA++] + x [xB++];  	i++;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: A -= 4;  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: for (int i = 0; i < log2n - 3; i++) {  	int k0 = (int)((uint)n >> (i + 2));  	int k1 = 1 << (i + 3);  	int wbase = n2 - 2;  	A = 0;  	float[] temp;  	for (int r = 0; r < ((uint)k0 >> 2); r++) {  		int w1 = wbase;  		w2 = w1 - (k0 >> 1);  		float AEv = trig [A]' wA;  		float AOv = trig [A + 1]' wB;  		wbase -= 2;  		k0++;  		for (int s = 0; s < (2 << i); s++) {  			wB = w [w1] - w [w2];  			x [w1] = w [w1] + w [w2];  			wA = w [++w1] - w [++w2];  			x [w1] = w [w1] + w [w2];  			x [w2] = wA * AEv - wB * AOv;  			x [w2 - 1] = wB * AEv + wA * AOv;  			w1 -= k0;  			w2 -= k0;  		}  		k0--;  		A += k1;  	}  	temp = w;  	w = x;  	x = temp;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: for (int i = 0; i < log2n - 3; i++) {  	int k0 = (int)((uint)n >> (i + 2));  	int k1 = 1 << (i + 3);  	int wbase = n2 - 2;  	A = 0;  	float[] temp;  	for (int r = 0; r < ((uint)k0 >> 2); r++) {  		int w1 = wbase;  		w2 = w1 - (k0 >> 1);  		float AEv = trig [A]' wA;  		float AOv = trig [A + 1]' wB;  		wbase -= 2;  		k0++;  		for (int s = 0; s < (2 << i); s++) {  			wB = w [w1] - w [w2];  			x [w1] = w [w1] + w [w2];  			wA = w [++w1] - w [++w2];  			x [w1] = w [w1] + w [w2];  			x [w2] = wA * AEv - wB * AOv;  			x [w2 - 1] = wB * AEv + wA * AOv;  			w1 -= k0;  			w2 -= k0;  		}  		k0--;  		A += k1;  	}  	temp = w;  	w = x;  	x = temp;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: for (int i = 0; i < log2n - 3; i++) {  	int k0 = (int)((uint)n >> (i + 2));  	int k1 = 1 << (i + 3);  	int wbase = n2 - 2;  	A = 0;  	float[] temp;  	for (int r = 0; r < ((uint)k0 >> 2); r++) {  		int w1 = wbase;  		w2 = w1 - (k0 >> 1);  		float AEv = trig [A]' wA;  		float AOv = trig [A + 1]' wB;  		wbase -= 2;  		k0++;  		for (int s = 0; s < (2 << i); s++) {  			wB = w [w1] - w [w2];  			x [w1] = w [w1] + w [w2];  			wA = w [++w1] - w [++w2];  			x [w1] = w [w1] + w [w2];  			x [w2] = wA * AEv - wB * AOv;  			x [w2 - 1] = wB * AEv + wA * AOv;  			w1 -= k0;  			w2 -= k0;  		}  		k0--;  		A += k1;  	}  	temp = w;  	w = x;  	x = temp;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: for (int i = 0; i < log2n - 3; i++) {  	int k0 = (int)((uint)n >> (i + 2));  	int k1 = 1 << (i + 3);  	int wbase = n2 - 2;  	A = 0;  	float[] temp;  	for (int r = 0; r < ((uint)k0 >> 2); r++) {  		int w1 = wbase;  		w2 = w1 - (k0 >> 1);  		float AEv = trig [A]' wA;  		float AOv = trig [A + 1]' wB;  		wbase -= 2;  		k0++;  		for (int s = 0; s < (2 << i); s++) {  			wB = w [w1] - w [w2];  			x [w1] = w [w1] + w [w2];  			wA = w [++w1] - w [++w2];  			x [w1] = w [w1] + w [w2];  			x [w2] = wA * AEv - wB * AOv;  			x [w2 - 1] = wB * AEv + wA * AOv;  			w1 -= k0;  			w2 -= k0;  		}  		k0--;  		A += k1;  	}  	temp = w;  	w = x;  	x = temp;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: for (int i = 0; i < log2n - 3; i++) {  	int k0 = (int)((uint)n >> (i + 2));  	int k1 = 1 << (i + 3);  	int wbase = n2 - 2;  	A = 0;  	float[] temp;  	for (int r = 0; r < ((uint)k0 >> 2); r++) {  		int w1 = wbase;  		w2 = w1 - (k0 >> 1);  		float AEv = trig [A]' wA;  		float AOv = trig [A + 1]' wB;  		wbase -= 2;  		k0++;  		for (int s = 0; s < (2 << i); s++) {  			wB = w [w1] - w [w2];  			x [w1] = w [w1] + w [w2];  			wA = w [++w1] - w [++w2];  			x [w1] = w [w1] + w [w2];  			x [w2] = wA * AEv - wB * AOv;  			x [w2 - 1] = wB * AEv + wA * AOv;  			w1 -= k0;  			w2 -= k0;  		}  		k0--;  		A += k1;  	}  	temp = w;  	w = x;  	x = temp;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: for (int i = 0; i < log2n - 3; i++) {  	int k0 = (int)((uint)n >> (i + 2));  	int k1 = 1 << (i + 3);  	int wbase = n2 - 2;  	A = 0;  	float[] temp;  	for (int r = 0; r < ((uint)k0 >> 2); r++) {  		int w1 = wbase;  		w2 = w1 - (k0 >> 1);  		float AEv = trig [A]' wA;  		float AOv = trig [A + 1]' wB;  		wbase -= 2;  		k0++;  		for (int s = 0; s < (2 << i); s++) {  			wB = w [w1] - w [w2];  			x [w1] = w [w1] + w [w2];  			wA = w [++w1] - w [++w2];  			x [w1] = w [w1] + w [w2];  			x [w2] = wA * AEv - wB * AOv;  			x [w2 - 1] = wB * AEv + wA * AOv;  			w1 -= k0;  			w2 -= k0;  		}  		k0--;  		A += k1;  	}  	temp = w;  	w = x;  	x = temp;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: for (int i = 0; i < log2n - 3; i++) {  	int k0 = (int)((uint)n >> (i + 2));  	int k1 = 1 << (i + 3);  	int wbase = n2 - 2;  	A = 0;  	float[] temp;  	for (int r = 0; r < ((uint)k0 >> 2); r++) {  		int w1 = wbase;  		w2 = w1 - (k0 >> 1);  		float AEv = trig [A]' wA;  		float AOv = trig [A + 1]' wB;  		wbase -= 2;  		k0++;  		for (int s = 0; s < (2 << i); s++) {  			wB = w [w1] - w [w2];  			x [w1] = w [w1] + w [w2];  			wA = w [++w1] - w [++w2];  			x [w1] = w [w1] + w [w2];  			x [w2] = wA * AEv - wB * AOv;  			x [w2 - 1] = wB * AEv + wA * AOv;  			w1 -= k0;  			w2 -= k0;  		}  		k0--;  		A += k1;  	}  	temp = w;  	w = x;  	x = temp;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: for (int r = 0; r < ((uint)k0 >> 2); r++) {  	int w1 = wbase;  	w2 = w1 - (k0 >> 1);  	float AEv = trig [A]' wA;  	float AOv = trig [A + 1]' wB;  	wbase -= 2;  	k0++;  	for (int s = 0; s < (2 << i); s++) {  		wB = w [w1] - w [w2];  		x [w1] = w [w1] + w [w2];  		wA = w [++w1] - w [++w2];  		x [w1] = w [w1] + w [w2];  		x [w2] = wA * AEv - wB * AOv;  		x [w2 - 1] = wB * AEv + wA * AOv;  		w1 -= k0;  		w2 -= k0;  	}  	k0--;  	A += k1;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: for (int r = 0; r < ((uint)k0 >> 2); r++) {  	int w1 = wbase;  	w2 = w1 - (k0 >> 1);  	float AEv = trig [A]' wA;  	float AOv = trig [A + 1]' wB;  	wbase -= 2;  	k0++;  	for (int s = 0; s < (2 << i); s++) {  		wB = w [w1] - w [w2];  		x [w1] = w [w1] + w [w2];  		wA = w [++w1] - w [++w2];  		x [w1] = w [w1] + w [w2];  		x [w2] = wA * AEv - wB * AOv;  		x [w2 - 1] = wB * AEv + wA * AOv;  		w1 -= k0;  		w2 -= k0;  	}  	k0--;  	A += k1;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: for (int r = 0; r < ((uint)k0 >> 2); r++) {  	int w1 = wbase;  	w2 = w1 - (k0 >> 1);  	float AEv = trig [A]' wA;  	float AOv = trig [A + 1]' wB;  	wbase -= 2;  	k0++;  	for (int s = 0; s < (2 << i); s++) {  		wB = w [w1] - w [w2];  		x [w1] = w [w1] + w [w2];  		wA = w [++w1] - w [++w2];  		x [w1] = w [w1] + w [w2];  		x [w2] = wA * AEv - wB * AOv;  		x [w2 - 1] = wB * AEv + wA * AOv;  		w1 -= k0;  		w2 -= k0;  	}  	k0--;  	A += k1;  }  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: wbase -= 2;  
Magic Number,csvorbis,Mdct,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Mdct.cs,mdct_kernel,The following statement contains a magic number: for (int s = 0; s < (2 << i); s++) {  	wB = w [w1] - w [w2];  	x [w1] = w [w1] + w [w2];  	wA = w [++w1] - w [++w2];  	x [w1] = w [w1] + w [w2];  	x [w2] = wA * AEv - wB * AOv;  	x [w2 - 1] = wB * AEv + wA * AOv;  	w1 -= k0;  	w2 -= k0;  }  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: opb.write (info.begin' 24);  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: opb.write (info.end' 24);  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: opb.write (info.grouping - 1' 24);  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: opb.write (info.partitions - 1' 6);  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: opb.write (info.groupbook' 8);  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: for (int j = 0; j < info.partitions; j++) {  	if (ilog (info.secondstages [j]) > 3) {  		/* yes' this is a minor hack due to not thinking ahead */opb.write (info.secondstages [j]' 3);  		opb.write (1' 1);  		opb.write (info.secondstages [j] >> 3' 5);  	}  	else {  		opb.write (info.secondstages [j]' 4);  		/* trailing zero */}  	acc += icount (info.secondstages [j]);  }  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: for (int j = 0; j < info.partitions; j++) {  	if (ilog (info.secondstages [j]) > 3) {  		/* yes' this is a minor hack due to not thinking ahead */opb.write (info.secondstages [j]' 3);  		opb.write (1' 1);  		opb.write (info.secondstages [j] >> 3' 5);  	}  	else {  		opb.write (info.secondstages [j]' 4);  		/* trailing zero */}  	acc += icount (info.secondstages [j]);  }  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: for (int j = 0; j < info.partitions; j++) {  	if (ilog (info.secondstages [j]) > 3) {  		/* yes' this is a minor hack due to not thinking ahead */opb.write (info.secondstages [j]' 3);  		opb.write (1' 1);  		opb.write (info.secondstages [j] >> 3' 5);  	}  	else {  		opb.write (info.secondstages [j]' 4);  		/* trailing zero */}  	acc += icount (info.secondstages [j]);  }  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: for (int j = 0; j < info.partitions; j++) {  	if (ilog (info.secondstages [j]) > 3) {  		/* yes' this is a minor hack due to not thinking ahead */opb.write (info.secondstages [j]' 3);  		opb.write (1' 1);  		opb.write (info.secondstages [j] >> 3' 5);  	}  	else {  		opb.write (info.secondstages [j]' 4);  		/* trailing zero */}  	acc += icount (info.secondstages [j]);  }  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: for (int j = 0; j < info.partitions; j++) {  	if (ilog (info.secondstages [j]) > 3) {  		/* yes' this is a minor hack due to not thinking ahead */opb.write (info.secondstages [j]' 3);  		opb.write (1' 1);  		opb.write (info.secondstages [j] >> 3' 5);  	}  	else {  		opb.write (info.secondstages [j]' 4);  		/* trailing zero */}  	acc += icount (info.secondstages [j]);  }  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: if (ilog (info.secondstages [j]) > 3) {  	/* yes' this is a minor hack due to not thinking ahead */opb.write (info.secondstages [j]' 3);  	opb.write (1' 1);  	opb.write (info.secondstages [j] >> 3' 5);  }  else {  	opb.write (info.secondstages [j]' 4);  	/* trailing zero */}  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: if (ilog (info.secondstages [j]) > 3) {  	/* yes' this is a minor hack due to not thinking ahead */opb.write (info.secondstages [j]' 3);  	opb.write (1' 1);  	opb.write (info.secondstages [j] >> 3' 5);  }  else {  	opb.write (info.secondstages [j]' 4);  	/* trailing zero */}  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: if (ilog (info.secondstages [j]) > 3) {  	/* yes' this is a minor hack due to not thinking ahead */opb.write (info.secondstages [j]' 3);  	opb.write (1' 1);  	opb.write (info.secondstages [j] >> 3' 5);  }  else {  	opb.write (info.secondstages [j]' 4);  	/* trailing zero */}  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: if (ilog (info.secondstages [j]) > 3) {  	/* yes' this is a minor hack due to not thinking ahead */opb.write (info.secondstages [j]' 3);  	opb.write (1' 1);  	opb.write (info.secondstages [j] >> 3' 5);  }  else {  	opb.write (info.secondstages [j]' 4);  	/* trailing zero */}  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: if (ilog (info.secondstages [j]) > 3) {  	/* yes' this is a minor hack due to not thinking ahead */opb.write (info.secondstages [j]' 3);  	opb.write (1' 1);  	opb.write (info.secondstages [j] >> 3' 5);  }  else {  	opb.write (info.secondstages [j]' 4);  	/* trailing zero */}  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: opb.write (info.secondstages [j]' 3);  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: opb.write (info.secondstages [j] >> 3' 5);  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: opb.write (info.secondstages [j] >> 3' 5);  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: opb.write (info.secondstages [j]' 4);  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: for (int j = 0; j < acc; j++) {  	opb.write (info.booklist [j]' 8);  }  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,pack,The following statement contains a magic number: opb.write (info.booklist [j]' 8);  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: info.begin = opb.read (24);  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: info.end = opb.read (24);  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: info.grouping = opb.read (24) + 1;  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: info.partitions = opb.read (6) + 1;  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: info.groupbook = opb.read (8);  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: for (int j = 0; j < info.partitions; j++) {  	int cascade = opb.read (3);  	if (opb.read (1) != 0) {  		cascade |= (opb.read (5) << 3);  	}  	info.secondstages [j] = cascade;  	acc += icount (cascade);  }  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: for (int j = 0; j < info.partitions; j++) {  	int cascade = opb.read (3);  	if (opb.read (1) != 0) {  		cascade |= (opb.read (5) << 3);  	}  	info.secondstages [j] = cascade;  	acc += icount (cascade);  }  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: for (int j = 0; j < info.partitions; j++) {  	int cascade = opb.read (3);  	if (opb.read (1) != 0) {  		cascade |= (opb.read (5) << 3);  	}  	info.secondstages [j] = cascade;  	acc += icount (cascade);  }  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: if (opb.read (1) != 0) {  	cascade |= (opb.read (5) << 3);  }  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: if (opb.read (1) != 0) {  	cascade |= (opb.read (5) << 3);  }  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: cascade |= (opb.read (5) << 3);  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: cascade |= (opb.read (5) << 3);  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: for (int j = 0; j < acc; j++) {  	info.booklist [j] = opb.read (8);  	//    if(info.booklist[j]==255)info.booklist[j]=-1;  }  
Magic Number,csvorbis,Residue0,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\Residue0.cs,unpack,The following statement contains a magic number: info.booklist [j] = opb.read (8);  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: opb.write (0x564342' 24);  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: opb.write (dim' 16);  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: opb.write (entries' 24);  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: if (ordered) {  	// length ordered.  We only need to say how many codewords of  	// each length.  The actual codewords are generated  	// deterministically  	int count = 0;  	opb.write (1' 1);  	// ordered  	opb.write (lengthlist [0] - 1' 5);  	// 1 to 32  	for (i = 1; i < entries; i++) {  		int _this = lengthlist [i];  		int _last = lengthlist [i - 1];  		if (_this > _last) {  			for (int j = _last; j < _this; j++) {  				opb.write (i - count' ilog (entries - count));  				count = i;  			}  		}  	}  	opb.write (i - count' ilog (entries - count));  }  else {  	// length random.  Again' we don't code the codeword itself' just  	// the length.  This time' though' we have to encode each length  	opb.write (0' 1);  	// unordered  	// algortihmic mapping has use for 'unused entries'' which we tag  	// here.  The algorithmic mapping happens as usual' but the unused  	// entry has no codeword.  	for (i = 0; i < entries; i++) {  		if (lengthlist [i] == 0)  			break;  	}  	if (i == entries) {  		opb.write (0' 1);  		// no unused entries  		for (i = 0; i < entries; i++) {  			opb.write (lengthlist [i] - 1' 5);  		}  	}  	else {  		opb.write (1' 1);  		// we have unused entries; thus we tag  		for (i = 0; i < entries; i++) {  			if (lengthlist [i] == 0) {  				opb.write (0' 1);  			}  			else {  				opb.write (1' 1);  				opb.write (lengthlist [i] - 1' 5);  			}  		}  	}  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: if (ordered) {  	// length ordered.  We only need to say how many codewords of  	// each length.  The actual codewords are generated  	// deterministically  	int count = 0;  	opb.write (1' 1);  	// ordered  	opb.write (lengthlist [0] - 1' 5);  	// 1 to 32  	for (i = 1; i < entries; i++) {  		int _this = lengthlist [i];  		int _last = lengthlist [i - 1];  		if (_this > _last) {  			for (int j = _last; j < _this; j++) {  				opb.write (i - count' ilog (entries - count));  				count = i;  			}  		}  	}  	opb.write (i - count' ilog (entries - count));  }  else {  	// length random.  Again' we don't code the codeword itself' just  	// the length.  This time' though' we have to encode each length  	opb.write (0' 1);  	// unordered  	// algortihmic mapping has use for 'unused entries'' which we tag  	// here.  The algorithmic mapping happens as usual' but the unused  	// entry has no codeword.  	for (i = 0; i < entries; i++) {  		if (lengthlist [i] == 0)  			break;  	}  	if (i == entries) {  		opb.write (0' 1);  		// no unused entries  		for (i = 0; i < entries; i++) {  			opb.write (lengthlist [i] - 1' 5);  		}  	}  	else {  		opb.write (1' 1);  		// we have unused entries; thus we tag  		for (i = 0; i < entries; i++) {  			if (lengthlist [i] == 0) {  				opb.write (0' 1);  			}  			else {  				opb.write (1' 1);  				opb.write (lengthlist [i] - 1' 5);  			}  		}  	}  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: if (ordered) {  	// length ordered.  We only need to say how many codewords of  	// each length.  The actual codewords are generated  	// deterministically  	int count = 0;  	opb.write (1' 1);  	// ordered  	opb.write (lengthlist [0] - 1' 5);  	// 1 to 32  	for (i = 1; i < entries; i++) {  		int _this = lengthlist [i];  		int _last = lengthlist [i - 1];  		if (_this > _last) {  			for (int j = _last; j < _this; j++) {  				opb.write (i - count' ilog (entries - count));  				count = i;  			}  		}  	}  	opb.write (i - count' ilog (entries - count));  }  else {  	// length random.  Again' we don't code the codeword itself' just  	// the length.  This time' though' we have to encode each length  	opb.write (0' 1);  	// unordered  	// algortihmic mapping has use for 'unused entries'' which we tag  	// here.  The algorithmic mapping happens as usual' but the unused  	// entry has no codeword.  	for (i = 0; i < entries; i++) {  		if (lengthlist [i] == 0)  			break;  	}  	if (i == entries) {  		opb.write (0' 1);  		// no unused entries  		for (i = 0; i < entries; i++) {  			opb.write (lengthlist [i] - 1' 5);  		}  	}  	else {  		opb.write (1' 1);  		// we have unused entries; thus we tag  		for (i = 0; i < entries; i++) {  			if (lengthlist [i] == 0) {  				opb.write (0' 1);  			}  			else {  				opb.write (1' 1);  				opb.write (lengthlist [i] - 1' 5);  			}  		}  	}  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: opb.write (lengthlist [0] - 1' 5);  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: if (i == entries) {  	opb.write (0' 1);  	// no unused entries  	for (i = 0; i < entries; i++) {  		opb.write (lengthlist [i] - 1' 5);  	}  }  else {  	opb.write (1' 1);  	// we have unused entries; thus we tag  	for (i = 0; i < entries; i++) {  		if (lengthlist [i] == 0) {  			opb.write (0' 1);  		}  		else {  			opb.write (1' 1);  			opb.write (lengthlist [i] - 1' 5);  		}  	}  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: if (i == entries) {  	opb.write (0' 1);  	// no unused entries  	for (i = 0; i < entries; i++) {  		opb.write (lengthlist [i] - 1' 5);  	}  }  else {  	opb.write (1' 1);  	// we have unused entries; thus we tag  	for (i = 0; i < entries; i++) {  		if (lengthlist [i] == 0) {  			opb.write (0' 1);  		}  		else {  			opb.write (1' 1);  			opb.write (lengthlist [i] - 1' 5);  		}  	}  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: for (i = 0; i < entries; i++) {  	opb.write (lengthlist [i] - 1' 5);  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: opb.write (lengthlist [i] - 1' 5);  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: for (i = 0; i < entries; i++) {  	if (lengthlist [i] == 0) {  		opb.write (0' 1);  	}  	else {  		opb.write (1' 1);  		opb.write (lengthlist [i] - 1' 5);  	}  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: if (lengthlist [i] == 0) {  	opb.write (0' 1);  }  else {  	opb.write (1' 1);  	opb.write (lengthlist [i] - 1' 5);  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: opb.write (lengthlist [i] - 1' 5);  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: opb.write (maptype' 4);  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: switch (maptype) {  case 0:  	// no mapping  	break;  case 1:  case 2:  	// implicitly populated value mapping  	// explicitly populated value mapping  	if (quantlist == null) {  		// no quantlist?  error  		return (-1);  	}  	// values that define the dequantization  	opb.write (q_min' 32);  	opb.write (q_delta' 32);  	opb.write (q_quant - 1' 4);  	opb.write (q_sequencep' 1);  	{  		int quantvals = 0;  		switch (maptype) {  		case 1:  			// a single column of (c->entries/c->dim) quantized values for  			// building a full value list algorithmically (square lattice)  			quantvals = maptype1_quantvals ();  			break;  		case 2:  			// every value (c->entries*c->dim total) specified explicitly  			quantvals = entries * dim;  			break;  		}  		// quantized values  		for (i = 0; i < quantvals; i++) {  			opb.write (Math.Abs (quantlist [i])' q_quant);  		}  	}  	break;  default:  	// error case; we don't have any other map types now  	return (-1);  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: switch (maptype) {  case 0:  	// no mapping  	break;  case 1:  case 2:  	// implicitly populated value mapping  	// explicitly populated value mapping  	if (quantlist == null) {  		// no quantlist?  error  		return (-1);  	}  	// values that define the dequantization  	opb.write (q_min' 32);  	opb.write (q_delta' 32);  	opb.write (q_quant - 1' 4);  	opb.write (q_sequencep' 1);  	{  		int quantvals = 0;  		switch (maptype) {  		case 1:  			// a single column of (c->entries/c->dim) quantized values for  			// building a full value list algorithmically (square lattice)  			quantvals = maptype1_quantvals ();  			break;  		case 2:  			// every value (c->entries*c->dim total) specified explicitly  			quantvals = entries * dim;  			break;  		}  		// quantized values  		for (i = 0; i < quantvals; i++) {  			opb.write (Math.Abs (quantlist [i])' q_quant);  		}  	}  	break;  default:  	// error case; we don't have any other map types now  	return (-1);  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: switch (maptype) {  case 0:  	// no mapping  	break;  case 1:  case 2:  	// implicitly populated value mapping  	// explicitly populated value mapping  	if (quantlist == null) {  		// no quantlist?  error  		return (-1);  	}  	// values that define the dequantization  	opb.write (q_min' 32);  	opb.write (q_delta' 32);  	opb.write (q_quant - 1' 4);  	opb.write (q_sequencep' 1);  	{  		int quantvals = 0;  		switch (maptype) {  		case 1:  			// a single column of (c->entries/c->dim) quantized values for  			// building a full value list algorithmically (square lattice)  			quantvals = maptype1_quantvals ();  			break;  		case 2:  			// every value (c->entries*c->dim total) specified explicitly  			quantvals = entries * dim;  			break;  		}  		// quantized values  		for (i = 0; i < quantvals; i++) {  			opb.write (Math.Abs (quantlist [i])' q_quant);  		}  	}  	break;  default:  	// error case; we don't have any other map types now  	return (-1);  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: switch (maptype) {  case 0:  	// no mapping  	break;  case 1:  case 2:  	// implicitly populated value mapping  	// explicitly populated value mapping  	if (quantlist == null) {  		// no quantlist?  error  		return (-1);  	}  	// values that define the dequantization  	opb.write (q_min' 32);  	opb.write (q_delta' 32);  	opb.write (q_quant - 1' 4);  	opb.write (q_sequencep' 1);  	{  		int quantvals = 0;  		switch (maptype) {  		case 1:  			// a single column of (c->entries/c->dim) quantized values for  			// building a full value list algorithmically (square lattice)  			quantvals = maptype1_quantvals ();  			break;  		case 2:  			// every value (c->entries*c->dim total) specified explicitly  			quantvals = entries * dim;  			break;  		}  		// quantized values  		for (i = 0; i < quantvals; i++) {  			opb.write (Math.Abs (quantlist [i])' q_quant);  		}  	}  	break;  default:  	// error case; we don't have any other map types now  	return (-1);  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: switch (maptype) {  case 0:  	// no mapping  	break;  case 1:  case 2:  	// implicitly populated value mapping  	// explicitly populated value mapping  	if (quantlist == null) {  		// no quantlist?  error  		return (-1);  	}  	// values that define the dequantization  	opb.write (q_min' 32);  	opb.write (q_delta' 32);  	opb.write (q_quant - 1' 4);  	opb.write (q_sequencep' 1);  	{  		int quantvals = 0;  		switch (maptype) {  		case 1:  			// a single column of (c->entries/c->dim) quantized values for  			// building a full value list algorithmically (square lattice)  			quantvals = maptype1_quantvals ();  			break;  		case 2:  			// every value (c->entries*c->dim total) specified explicitly  			quantvals = entries * dim;  			break;  		}  		// quantized values  		for (i = 0; i < quantvals; i++) {  			opb.write (Math.Abs (quantlist [i])' q_quant);  		}  	}  	break;  default:  	// error case; we don't have any other map types now  	return (-1);  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: opb.write (q_min' 32);  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: opb.write (q_delta' 32);  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: opb.write (q_quant - 1' 4);  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following statement contains a magic number: switch (maptype) {  case 1:  	// a single column of (c->entries/c->dim) quantized values for  	// building a full value list algorithmically (square lattice)  	quantvals = maptype1_quantvals ();  	break;  case 2:  	// every value (c->entries*c->dim total) specified explicitly  	quantvals = entries * dim;  	break;  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: if (opb.read (24) != 0x564342) {  	//    goto _eofout;  	clear ();  	return (-1);  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: dim = opb.read (16);  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: entries = opb.read (24);  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: switch (opb.read (1)) {  case 0:  	// unordered  	lengthlist = new int[entries];  	// allocated but unused entries?  	if (opb.read (1) != 0) {  		// yes' unused entries  		for (i = 0; i < entries; i++) {  			if (opb.read (1) != 0) {  				int num = opb.read (5);  				if (num == -1) {  					//            goto _eofout;  					clear ();  					return (-1);  				}  				lengthlist [i] = num + 1;  			}  			else {  				lengthlist [i] = 0;  			}  		}  	}  	else {  		// all entries used; no tagging  		for (i = 0; i < entries; i++) {  			int num = opb.read (5);  			if (num == -1) {  				//          goto _eofout;  				clear ();  				return (-1);  			}  			lengthlist [i] = num + 1;  		}  	}  	break;  case 1:  	// ordered  	{  		int length = opb.read (5) + 1;  		lengthlist = new int[entries];  		for (i = 0; i < entries;) {  			int num = opb.read (ilog (entries - i));  			if (num == -1) {  				//          goto _eofout;  				clear ();  				return (-1);  			}  			for (int j = 0; j < num; j++' i++) {  				lengthlist [i] = length;  			}  			length++;  		}  	}  	break;  default:  	// EOF  	return (-1);  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: switch (opb.read (1)) {  case 0:  	// unordered  	lengthlist = new int[entries];  	// allocated but unused entries?  	if (opb.read (1) != 0) {  		// yes' unused entries  		for (i = 0; i < entries; i++) {  			if (opb.read (1) != 0) {  				int num = opb.read (5);  				if (num == -1) {  					//            goto _eofout;  					clear ();  					return (-1);  				}  				lengthlist [i] = num + 1;  			}  			else {  				lengthlist [i] = 0;  			}  		}  	}  	else {  		// all entries used; no tagging  		for (i = 0; i < entries; i++) {  			int num = opb.read (5);  			if (num == -1) {  				//          goto _eofout;  				clear ();  				return (-1);  			}  			lengthlist [i] = num + 1;  		}  	}  	break;  case 1:  	// ordered  	{  		int length = opb.read (5) + 1;  		lengthlist = new int[entries];  		for (i = 0; i < entries;) {  			int num = opb.read (ilog (entries - i));  			if (num == -1) {  				//          goto _eofout;  				clear ();  				return (-1);  			}  			for (int j = 0; j < num; j++' i++) {  				lengthlist [i] = length;  			}  			length++;  		}  	}  	break;  default:  	// EOF  	return (-1);  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: switch (opb.read (1)) {  case 0:  	// unordered  	lengthlist = new int[entries];  	// allocated but unused entries?  	if (opb.read (1) != 0) {  		// yes' unused entries  		for (i = 0; i < entries; i++) {  			if (opb.read (1) != 0) {  				int num = opb.read (5);  				if (num == -1) {  					//            goto _eofout;  					clear ();  					return (-1);  				}  				lengthlist [i] = num + 1;  			}  			else {  				lengthlist [i] = 0;  			}  		}  	}  	else {  		// all entries used; no tagging  		for (i = 0; i < entries; i++) {  			int num = opb.read (5);  			if (num == -1) {  				//          goto _eofout;  				clear ();  				return (-1);  			}  			lengthlist [i] = num + 1;  		}  	}  	break;  case 1:  	// ordered  	{  		int length = opb.read (5) + 1;  		lengthlist = new int[entries];  		for (i = 0; i < entries;) {  			int num = opb.read (ilog (entries - i));  			if (num == -1) {  				//          goto _eofout;  				clear ();  				return (-1);  			}  			for (int j = 0; j < num; j++' i++) {  				lengthlist [i] = length;  			}  			length++;  		}  	}  	break;  default:  	// EOF  	return (-1);  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: if (opb.read (1) != 0) {  	// yes' unused entries  	for (i = 0; i < entries; i++) {  		if (opb.read (1) != 0) {  			int num = opb.read (5);  			if (num == -1) {  				//            goto _eofout;  				clear ();  				return (-1);  			}  			lengthlist [i] = num + 1;  		}  		else {  			lengthlist [i] = 0;  		}  	}  }  else {  	// all entries used; no tagging  	for (i = 0; i < entries; i++) {  		int num = opb.read (5);  		if (num == -1) {  			//          goto _eofout;  			clear ();  			return (-1);  		}  		lengthlist [i] = num + 1;  	}  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: if (opb.read (1) != 0) {  	// yes' unused entries  	for (i = 0; i < entries; i++) {  		if (opb.read (1) != 0) {  			int num = opb.read (5);  			if (num == -1) {  				//            goto _eofout;  				clear ();  				return (-1);  			}  			lengthlist [i] = num + 1;  		}  		else {  			lengthlist [i] = 0;  		}  	}  }  else {  	// all entries used; no tagging  	for (i = 0; i < entries; i++) {  		int num = opb.read (5);  		if (num == -1) {  			//          goto _eofout;  			clear ();  			return (-1);  		}  		lengthlist [i] = num + 1;  	}  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: for (i = 0; i < entries; i++) {  	if (opb.read (1) != 0) {  		int num = opb.read (5);  		if (num == -1) {  			//            goto _eofout;  			clear ();  			return (-1);  		}  		lengthlist [i] = num + 1;  	}  	else {  		lengthlist [i] = 0;  	}  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: if (opb.read (1) != 0) {  	int num = opb.read (5);  	if (num == -1) {  		//            goto _eofout;  		clear ();  		return (-1);  	}  	lengthlist [i] = num + 1;  }  else {  	lengthlist [i] = 0;  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: for (i = 0; i < entries; i++) {  	int num = opb.read (5);  	if (num == -1) {  		//          goto _eofout;  		clear ();  		return (-1);  	}  	lengthlist [i] = num + 1;  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: switch ((maptype = opb.read (4))) {  case 0:  	// no mapping  	break;  case 1:  case 2:  	// implicitly populated value mapping  	// explicitly populated value mapping  	q_min = opb.read (32);  	q_delta = opb.read (32);  	q_quant = opb.read (4) + 1;  	q_sequencep = opb.read (1);  	{  		int quantvals = 0;  		switch (maptype) {  		case 1:  			quantvals = maptype1_quantvals ();  			break;  		case 2:  			quantvals = entries * dim;  			break;  		}  		// quantized values  		quantlist = new int[quantvals];  		for (i = 0; i < quantvals; i++) {  			quantlist [i] = opb.read (q_quant);  		}  		if (quantlist [quantvals - 1] == -1) {  			//        goto _eofout;  			clear ();  			return (-1);  		}  	}  	break;  default:  	//    goto _eofout;  	clear ();  	return (-1);  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: switch ((maptype = opb.read (4))) {  case 0:  	// no mapping  	break;  case 1:  case 2:  	// implicitly populated value mapping  	// explicitly populated value mapping  	q_min = opb.read (32);  	q_delta = opb.read (32);  	q_quant = opb.read (4) + 1;  	q_sequencep = opb.read (1);  	{  		int quantvals = 0;  		switch (maptype) {  		case 1:  			quantvals = maptype1_quantvals ();  			break;  		case 2:  			quantvals = entries * dim;  			break;  		}  		// quantized values  		quantlist = new int[quantvals];  		for (i = 0; i < quantvals; i++) {  			quantlist [i] = opb.read (q_quant);  		}  		if (quantlist [quantvals - 1] == -1) {  			//        goto _eofout;  			clear ();  			return (-1);  		}  	}  	break;  default:  	//    goto _eofout;  	clear ();  	return (-1);  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: switch ((maptype = opb.read (4))) {  case 0:  	// no mapping  	break;  case 1:  case 2:  	// implicitly populated value mapping  	// explicitly populated value mapping  	q_min = opb.read (32);  	q_delta = opb.read (32);  	q_quant = opb.read (4) + 1;  	q_sequencep = opb.read (1);  	{  		int quantvals = 0;  		switch (maptype) {  		case 1:  			quantvals = maptype1_quantvals ();  			break;  		case 2:  			quantvals = entries * dim;  			break;  		}  		// quantized values  		quantlist = new int[quantvals];  		for (i = 0; i < quantvals; i++) {  			quantlist [i] = opb.read (q_quant);  		}  		if (quantlist [quantvals - 1] == -1) {  			//        goto _eofout;  			clear ();  			return (-1);  		}  	}  	break;  default:  	//    goto _eofout;  	clear ();  	return (-1);  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: switch ((maptype = opb.read (4))) {  case 0:  	// no mapping  	break;  case 1:  case 2:  	// implicitly populated value mapping  	// explicitly populated value mapping  	q_min = opb.read (32);  	q_delta = opb.read (32);  	q_quant = opb.read (4) + 1;  	q_sequencep = opb.read (1);  	{  		int quantvals = 0;  		switch (maptype) {  		case 1:  			quantvals = maptype1_quantvals ();  			break;  		case 2:  			quantvals = entries * dim;  			break;  		}  		// quantized values  		quantlist = new int[quantvals];  		for (i = 0; i < quantvals; i++) {  			quantlist [i] = opb.read (q_quant);  		}  		if (quantlist [quantvals - 1] == -1) {  			//        goto _eofout;  			clear ();  			return (-1);  		}  	}  	break;  default:  	//    goto _eofout;  	clear ();  	return (-1);  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: switch ((maptype = opb.read (4))) {  case 0:  	// no mapping  	break;  case 1:  case 2:  	// implicitly populated value mapping  	// explicitly populated value mapping  	q_min = opb.read (32);  	q_delta = opb.read (32);  	q_quant = opb.read (4) + 1;  	q_sequencep = opb.read (1);  	{  		int quantvals = 0;  		switch (maptype) {  		case 1:  			quantvals = maptype1_quantvals ();  			break;  		case 2:  			quantvals = entries * dim;  			break;  		}  		// quantized values  		quantlist = new int[quantvals];  		for (i = 0; i < quantvals; i++) {  			quantlist [i] = opb.read (q_quant);  		}  		if (quantlist [quantvals - 1] == -1) {  			//        goto _eofout;  			clear ();  			return (-1);  		}  	}  	break;  default:  	//    goto _eofout;  	clear ();  	return (-1);  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: switch ((maptype = opb.read (4))) {  case 0:  	// no mapping  	break;  case 1:  case 2:  	// implicitly populated value mapping  	// explicitly populated value mapping  	q_min = opb.read (32);  	q_delta = opb.read (32);  	q_quant = opb.read (4) + 1;  	q_sequencep = opb.read (1);  	{  		int quantvals = 0;  		switch (maptype) {  		case 1:  			quantvals = maptype1_quantvals ();  			break;  		case 2:  			quantvals = entries * dim;  			break;  		}  		// quantized values  		quantlist = new int[quantvals];  		for (i = 0; i < quantvals; i++) {  			quantlist [i] = opb.read (q_quant);  		}  		if (quantlist [quantvals - 1] == -1) {  			//        goto _eofout;  			clear ();  			return (-1);  		}  	}  	break;  default:  	//    goto _eofout;  	clear ();  	return (-1);  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: q_min = opb.read (32);  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: q_delta = opb.read (32);  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: q_quant = opb.read (4) + 1;  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following statement contains a magic number: switch (maptype) {  case 1:  	quantvals = maptype1_quantvals ();  	break;  case 2:  	quantvals = entries * dim;  	break;  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unquantize,The following statement contains a magic number: if (maptype == 1 || maptype == 2) {  	int quantvals;  	float mindel = float32_unpack (q_min);  	float delta = float32_unpack (q_delta);  	float[] r = new float[entries * dim];  	//System.err.println("q_min="+q_min+"' mindel="+mindel);  	// maptype 1 and 2 both use a quantized value vector' but  	// different sizes  	switch (maptype) {  	case 1:  		// most of the time' entries%dimensions == 0' but we need to be  		// well defined.  We define that the possible vales at each  		// scalar is values == entries/dim.  If entries%dim != 0' we'll  		// have 'too few' values (values*dim<entries)' which means that  		// we'll have 'left over' entries; left over entries use zeroed  		// values (and are wasted).  So don't generate codebooks like that  		quantvals = maptype1_quantvals ();  		for (int j = 0; j < entries; j++) {  			float last = 0.0f;  			int indexdiv = 1;  			for (int k = 0; k < dim; k++) {  				int index = (j / indexdiv) % quantvals;  				float val = quantlist [index];  				val = Math.Abs (val) * delta + mindel + last;  				if (q_sequencep != 0)  					last = val;  				r [j * dim + k] = val;  				indexdiv *= quantvals;  			}  		}  		break;  	case 2:  		for (int j = 0; j < entries; j++) {  			float last = 0.0f;  			for (int k = 0; k < dim; k++) {  				float val = quantlist [j * dim + k];  				//if((j*dim+k)==0){System.err.println(" | 0 -> "+val+" | ");}  				val = Math.Abs (val) * delta + mindel + last;  				if (q_sequencep != 0)  					last = val;  				r [j * dim + k] = val;  				//if((j*dim+k)==0){System.err.println(" $ r[0] -> "+r[0]+" | ");}  			}  		}  		//System.err.println("\nr[0]="+r[0]);  		break;  	default:  		break;  	}  	return (r);  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unquantize,The following statement contains a magic number: if (maptype == 1 || maptype == 2) {  	int quantvals;  	float mindel = float32_unpack (q_min);  	float delta = float32_unpack (q_delta);  	float[] r = new float[entries * dim];  	//System.err.println("q_min="+q_min+"' mindel="+mindel);  	// maptype 1 and 2 both use a quantized value vector' but  	// different sizes  	switch (maptype) {  	case 1:  		// most of the time' entries%dimensions == 0' but we need to be  		// well defined.  We define that the possible vales at each  		// scalar is values == entries/dim.  If entries%dim != 0' we'll  		// have 'too few' values (values*dim<entries)' which means that  		// we'll have 'left over' entries; left over entries use zeroed  		// values (and are wasted).  So don't generate codebooks like that  		quantvals = maptype1_quantvals ();  		for (int j = 0; j < entries; j++) {  			float last = 0.0f;  			int indexdiv = 1;  			for (int k = 0; k < dim; k++) {  				int index = (j / indexdiv) % quantvals;  				float val = quantlist [index];  				val = Math.Abs (val) * delta + mindel + last;  				if (q_sequencep != 0)  					last = val;  				r [j * dim + k] = val;  				indexdiv *= quantvals;  			}  		}  		break;  	case 2:  		for (int j = 0; j < entries; j++) {  			float last = 0.0f;  			for (int k = 0; k < dim; k++) {  				float val = quantlist [j * dim + k];  				//if((j*dim+k)==0){System.err.println(" | 0 -> "+val+" | ");}  				val = Math.Abs (val) * delta + mindel + last;  				if (q_sequencep != 0)  					last = val;  				r [j * dim + k] = val;  				//if((j*dim+k)==0){System.err.println(" $ r[0] -> "+r[0]+" | ");}  			}  		}  		//System.err.println("\nr[0]="+r[0]);  		break;  	default:  		break;  	}  	return (r);  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unquantize,The following statement contains a magic number: switch (maptype) {  case 1:  	// most of the time' entries%dimensions == 0' but we need to be  	// well defined.  We define that the possible vales at each  	// scalar is values == entries/dim.  If entries%dim != 0' we'll  	// have 'too few' values (values*dim<entries)' which means that  	// we'll have 'left over' entries; left over entries use zeroed  	// values (and are wasted).  So don't generate codebooks like that  	quantvals = maptype1_quantvals ();  	for (int j = 0; j < entries; j++) {  		float last = 0.0f;  		int indexdiv = 1;  		for (int k = 0; k < dim; k++) {  			int index = (j / indexdiv) % quantvals;  			float val = quantlist [index];  			val = Math.Abs (val) * delta + mindel + last;  			if (q_sequencep != 0)  				last = val;  			r [j * dim + k] = val;  			indexdiv *= quantvals;  		}  	}  	break;  case 2:  	for (int j = 0; j < entries; j++) {  		float last = 0.0f;  		for (int k = 0; k < dim; k++) {  			float val = quantlist [j * dim + k];  			//if((j*dim+k)==0){System.err.println(" | 0 -> "+val+" | ");}  			val = Math.Abs (val) * delta + mindel + last;  			if (q_sequencep != 0)  				last = val;  			r [j * dim + k] = val;  			//if((j*dim+k)==0){System.err.println(" $ r[0] -> "+r[0]+" | ");}  		}  	}  	//System.err.println("\nr[0]="+r[0]);  	break;  default:  	break;  }  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,float32_pack,The following statement contains a magic number: exp = (int)Math.Floor (Math.Log (val) / Math.Log (2));  
Magic Number,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,ldexp,The following statement contains a magic number: return (float)(foo * Math.Pow (2' e));  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,bisect_forward_serialno,The following statement contains a magic number: while (searched < endsearched) {  	long bisect;  	if (endsearched - searched < CHUNKSIZE) {  		bisect = searched;  	}  	else {  		bisect = (searched + endsearched) / 2;  	}  	seek_helper (bisect);  	ret = get_next_page (page' -1);  	if (ret == OV_EREAD)  		return OV_EREAD;  	if (ret < 0 || page.serialno () != currentno) {  		endsearched = bisect;  		if (ret >= 0)  			next = ret;  	}  	else {  		searched = ret + page.header_len + page.body_len;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,bisect_forward_serialno,The following statement contains a magic number: if (endsearched - searched < CHUNKSIZE) {  	bisect = searched;  }  else {  	bisect = (searched + endsearched) / 2;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,bisect_forward_serialno,The following statement contains a magic number: bisect = (searched + endsearched) / 2;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,bisect_forward_serialno,The following statement contains a magic number: if (searched >= end || ret == -1) {  	links = m + 1;  	offsets = new long[m + 2];  	offsets [m + 1] = searched;  }  else {  	ret = bisect_forward_serialno (next' offset' end' page.serialno ()' m + 1);  	if (ret == OV_EREAD)  		return OV_EREAD;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,bisect_forward_serialno,The following statement contains a magic number: offsets = new long[m + 2];  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,fetch_headers,The following statement contains a magic number: while (i < 3) {  	os.pagein (og_ptr);  	while (i < 3) {  		int result = os.packetout (op);  		if (result == 0)  			break;  		if (result == -1) {  			Console.Error.WriteLine ("Corrupt header in logical bitstream.");  			//goto bail_header;  			vi.clear ();  			vc.clear ();  			os.clear ();  			return -1;  		}  		if (vi.synthesis_headerin (vc' op) != 0) {  			Console.Error.WriteLine ("Illegal header in logical bitstream.");  			//goto bail_header;  			vi.clear ();  			vc.clear ();  			os.clear ();  			return -1;  		}  		i++;  	}  	if (i < 3)  		if (get_next_page (og_ptr' 1) < 0) {  			Console.Error.WriteLine ("Missing header in logical bitstream.");  			//goto bail_header;  			vi.clear ();  			vc.clear ();  			os.clear ();  			return -1;  		}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,fetch_headers,The following statement contains a magic number: while (i < 3) {  	os.pagein (og_ptr);  	while (i < 3) {  		int result = os.packetout (op);  		if (result == 0)  			break;  		if (result == -1) {  			Console.Error.WriteLine ("Corrupt header in logical bitstream.");  			//goto bail_header;  			vi.clear ();  			vc.clear ();  			os.clear ();  			return -1;  		}  		if (vi.synthesis_headerin (vc' op) != 0) {  			Console.Error.WriteLine ("Illegal header in logical bitstream.");  			//goto bail_header;  			vi.clear ();  			vc.clear ();  			os.clear ();  			return -1;  		}  		i++;  	}  	if (i < 3)  		if (get_next_page (og_ptr' 1) < 0) {  			Console.Error.WriteLine ("Missing header in logical bitstream.");  			//goto bail_header;  			vi.clear ();  			vc.clear ();  			os.clear ();  			return -1;  		}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,fetch_headers,The following statement contains a magic number: while (i < 3) {  	os.pagein (og_ptr);  	while (i < 3) {  		int result = os.packetout (op);  		if (result == 0)  			break;  		if (result == -1) {  			Console.Error.WriteLine ("Corrupt header in logical bitstream.");  			//goto bail_header;  			vi.clear ();  			vc.clear ();  			os.clear ();  			return -1;  		}  		if (vi.synthesis_headerin (vc' op) != 0) {  			Console.Error.WriteLine ("Illegal header in logical bitstream.");  			//goto bail_header;  			vi.clear ();  			vc.clear ();  			os.clear ();  			return -1;  		}  		i++;  	}  	if (i < 3)  		if (get_next_page (og_ptr' 1) < 0) {  			Console.Error.WriteLine ("Missing header in logical bitstream.");  			//goto bail_header;  			vi.clear ();  			vc.clear ();  			os.clear ();  			return -1;  		}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,fetch_headers,The following statement contains a magic number: while (i < 3) {  	int result = os.packetout (op);  	if (result == 0)  		break;  	if (result == -1) {  		Console.Error.WriteLine ("Corrupt header in logical bitstream.");  		//goto bail_header;  		vi.clear ();  		vc.clear ();  		os.clear ();  		return -1;  	}  	if (vi.synthesis_headerin (vc' op) != 0) {  		Console.Error.WriteLine ("Illegal header in logical bitstream.");  		//goto bail_header;  		vi.clear ();  		vc.clear ();  		os.clear ();  		return -1;  	}  	i++;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,fetch_headers,The following statement contains a magic number: if (i < 3)  	if (get_next_page (og_ptr' 1) < 0) {  		Console.Error.WriteLine ("Missing header in logical bitstream.");  		//goto bail_header;  		vi.clear ();  		vc.clear ();  		os.clear ();  		return -1;  	}  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,process_packet,The following statement contains a magic number: while (true) {  	// process a packet if we can.  If the machine isn't loaded'  	// neither is a page  	if (decode_ready) {  		Packet op = new Packet ();  		int result = os.packetout (op);  		long granulepos;  		// if(result==-1)return(-1); // hole in the data. For now' swallow  		// and go. We'll need to add a real  		// error code in a bit.  		if (result > 0) {  			// got a packet.  process it  			granulepos = op.granulepos;  			if (vb.synthesis (op) == 0) {  				// lazy check for lazy  				// header handling.  The  				// header packets aren't  				// audio' so if/when we  				// submit them'  				// vorbis_synthesis will  				// reject them  				// suck in the synthesis data and track bitrate  				{  					int oldsamples = vd.synthesis_pcmout (null' null);  					vd.synthesis_blockin (vb);  					samptrack += vd.synthesis_pcmout (null' null) - oldsamples;  					bittrack += op.bytes * 8;  				// update the pcm offset.  				}  				if (granulepos != -1 && op.e_o_s == 0) {  					int link = (skable ? current_link : 0);  					int samples;  					// this packet has a pcm_offset on it (the last packet  					// completed on a page carries the offset) After processing  					// (above)' we know the pcm position of the *last* sample  					// ready to be returned. Find the offset of the *first*  					//   					// As an aside' this trick is inaccurate if we begin  					// reading anew right at the last page; the end-of-stream  					// granulepos declares the last frame in the stream' and the  					// last packet of the last page may be a partial frame.  					// So' we need a previous granulepos from an in-sequence page  					// to have a reference point.  Thus the !op.e_o_s clause above  					samples = vd.synthesis_pcmout (null' null);  					granulepos -= samples;  					for (int i = 0; i < link; i++) {  						granulepos += pcmlengths [i];  					}  					pcm_offset = granulepos;  				}  				return (1);  			}  		}  	}  	if (readp == 0)  		return (0);  	if (get_next_page (og' -1) < 0)  		return (0);  	// eof. leave unitialized  	// bitrate tracking; add the header's bytes here' the body bytes  	// are done by packet above  	bittrack += og.header_len * 8;  	// has our decoding just traversed a bitstream boundary?  	if (decode_ready) {  		if (current_serialno != og.serialno ()) {  			decode_clear ();  		}  	}  	// Do we need to load a new machine before submitting the page?  	// This is different in the seekable and non-seekable cases.    	//   	// In the seekable case' we already have all the header  	// information loaded and cached; we just initialize the machine  	// with it and continue on our merry way.  	//   	// In the non-seekable (streaming) case' we'll only be at a  	// boundary if we just left the previous logical bitstream and  	// we're now nominally at the header of the next bitstream  	if (!decode_ready) {  		int i;  		if (skable) {  			current_serialno = og.serialno ();  			// match the serialno to bitstream section.  We use this rather than  			// offset positions to avoid problems near logical bitstream  			// boundaries  			for (i = 0; i < links; i++) {  				if (serialnos [i] == current_serialno)  					break;  			}  			if (i == links)  				return (-1);  			// sign of a bogus stream.  error out'  			// leave machine uninitialized  			current_link = i;  			os.init (current_serialno);  			os.reset ();  		}  		else {  			// we're streaming  			// fetch the three header packets' build the info struct  			int[] foo = new int[1];  			int ret = fetch_headers (vi [0]' vc [0]' foo' og);  			current_serialno = foo [0];  			if (ret != 0)  				return ret;  			current_link++;  			i = 0;  		}  		make_decode_ready ();  	}  	os.pagein (og);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,process_packet,The following statement contains a magic number: while (true) {  	// process a packet if we can.  If the machine isn't loaded'  	// neither is a page  	if (decode_ready) {  		Packet op = new Packet ();  		int result = os.packetout (op);  		long granulepos;  		// if(result==-1)return(-1); // hole in the data. For now' swallow  		// and go. We'll need to add a real  		// error code in a bit.  		if (result > 0) {  			// got a packet.  process it  			granulepos = op.granulepos;  			if (vb.synthesis (op) == 0) {  				// lazy check for lazy  				// header handling.  The  				// header packets aren't  				// audio' so if/when we  				// submit them'  				// vorbis_synthesis will  				// reject them  				// suck in the synthesis data and track bitrate  				{  					int oldsamples = vd.synthesis_pcmout (null' null);  					vd.synthesis_blockin (vb);  					samptrack += vd.synthesis_pcmout (null' null) - oldsamples;  					bittrack += op.bytes * 8;  				// update the pcm offset.  				}  				if (granulepos != -1 && op.e_o_s == 0) {  					int link = (skable ? current_link : 0);  					int samples;  					// this packet has a pcm_offset on it (the last packet  					// completed on a page carries the offset) After processing  					// (above)' we know the pcm position of the *last* sample  					// ready to be returned. Find the offset of the *first*  					//   					// As an aside' this trick is inaccurate if we begin  					// reading anew right at the last page; the end-of-stream  					// granulepos declares the last frame in the stream' and the  					// last packet of the last page may be a partial frame.  					// So' we need a previous granulepos from an in-sequence page  					// to have a reference point.  Thus the !op.e_o_s clause above  					samples = vd.synthesis_pcmout (null' null);  					granulepos -= samples;  					for (int i = 0; i < link; i++) {  						granulepos += pcmlengths [i];  					}  					pcm_offset = granulepos;  				}  				return (1);  			}  		}  	}  	if (readp == 0)  		return (0);  	if (get_next_page (og' -1) < 0)  		return (0);  	// eof. leave unitialized  	// bitrate tracking; add the header's bytes here' the body bytes  	// are done by packet above  	bittrack += og.header_len * 8;  	// has our decoding just traversed a bitstream boundary?  	if (decode_ready) {  		if (current_serialno != og.serialno ()) {  			decode_clear ();  		}  	}  	// Do we need to load a new machine before submitting the page?  	// This is different in the seekable and non-seekable cases.    	//   	// In the seekable case' we already have all the header  	// information loaded and cached; we just initialize the machine  	// with it and continue on our merry way.  	//   	// In the non-seekable (streaming) case' we'll only be at a  	// boundary if we just left the previous logical bitstream and  	// we're now nominally at the header of the next bitstream  	if (!decode_ready) {  		int i;  		if (skable) {  			current_serialno = og.serialno ();  			// match the serialno to bitstream section.  We use this rather than  			// offset positions to avoid problems near logical bitstream  			// boundaries  			for (i = 0; i < links; i++) {  				if (serialnos [i] == current_serialno)  					break;  			}  			if (i == links)  				return (-1);  			// sign of a bogus stream.  error out'  			// leave machine uninitialized  			current_link = i;  			os.init (current_serialno);  			os.reset ();  		}  		else {  			// we're streaming  			// fetch the three header packets' build the info struct  			int[] foo = new int[1];  			int ret = fetch_headers (vi [0]' vc [0]' foo' og);  			current_serialno = foo [0];  			if (ret != 0)  				return ret;  			current_link++;  			i = 0;  		}  		make_decode_ready ();  	}  	os.pagein (og);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,process_packet,The following statement contains a magic number: if (decode_ready) {  	Packet op = new Packet ();  	int result = os.packetout (op);  	long granulepos;  	// if(result==-1)return(-1); // hole in the data. For now' swallow  	// and go. We'll need to add a real  	// error code in a bit.  	if (result > 0) {  		// got a packet.  process it  		granulepos = op.granulepos;  		if (vb.synthesis (op) == 0) {  			// lazy check for lazy  			// header handling.  The  			// header packets aren't  			// audio' so if/when we  			// submit them'  			// vorbis_synthesis will  			// reject them  			// suck in the synthesis data and track bitrate  			{  				int oldsamples = vd.synthesis_pcmout (null' null);  				vd.synthesis_blockin (vb);  				samptrack += vd.synthesis_pcmout (null' null) - oldsamples;  				bittrack += op.bytes * 8;  			// update the pcm offset.  			}  			if (granulepos != -1 && op.e_o_s == 0) {  				int link = (skable ? current_link : 0);  				int samples;  				// this packet has a pcm_offset on it (the last packet  				// completed on a page carries the offset) After processing  				// (above)' we know the pcm position of the *last* sample  				// ready to be returned. Find the offset of the *first*  				//   				// As an aside' this trick is inaccurate if we begin  				// reading anew right at the last page; the end-of-stream  				// granulepos declares the last frame in the stream' and the  				// last packet of the last page may be a partial frame.  				// So' we need a previous granulepos from an in-sequence page  				// to have a reference point.  Thus the !op.e_o_s clause above  				samples = vd.synthesis_pcmout (null' null);  				granulepos -= samples;  				for (int i = 0; i < link; i++) {  					granulepos += pcmlengths [i];  				}  				pcm_offset = granulepos;  			}  			return (1);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,process_packet,The following statement contains a magic number: if (result > 0) {  	// got a packet.  process it  	granulepos = op.granulepos;  	if (vb.synthesis (op) == 0) {  		// lazy check for lazy  		// header handling.  The  		// header packets aren't  		// audio' so if/when we  		// submit them'  		// vorbis_synthesis will  		// reject them  		// suck in the synthesis data and track bitrate  		{  			int oldsamples = vd.synthesis_pcmout (null' null);  			vd.synthesis_blockin (vb);  			samptrack += vd.synthesis_pcmout (null' null) - oldsamples;  			bittrack += op.bytes * 8;  		// update the pcm offset.  		}  		if (granulepos != -1 && op.e_o_s == 0) {  			int link = (skable ? current_link : 0);  			int samples;  			// this packet has a pcm_offset on it (the last packet  			// completed on a page carries the offset) After processing  			// (above)' we know the pcm position of the *last* sample  			// ready to be returned. Find the offset of the *first*  			//   			// As an aside' this trick is inaccurate if we begin  			// reading anew right at the last page; the end-of-stream  			// granulepos declares the last frame in the stream' and the  			// last packet of the last page may be a partial frame.  			// So' we need a previous granulepos from an in-sequence page  			// to have a reference point.  Thus the !op.e_o_s clause above  			samples = vd.synthesis_pcmout (null' null);  			granulepos -= samples;  			for (int i = 0; i < link; i++) {  				granulepos += pcmlengths [i];  			}  			pcm_offset = granulepos;  		}  		return (1);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,process_packet,The following statement contains a magic number: if (vb.synthesis (op) == 0) {  	// lazy check for lazy  	// header handling.  The  	// header packets aren't  	// audio' so if/when we  	// submit them'  	// vorbis_synthesis will  	// reject them  	// suck in the synthesis data and track bitrate  	{  		int oldsamples = vd.synthesis_pcmout (null' null);  		vd.synthesis_blockin (vb);  		samptrack += vd.synthesis_pcmout (null' null) - oldsamples;  		bittrack += op.bytes * 8;  	// update the pcm offset.  	}  	if (granulepos != -1 && op.e_o_s == 0) {  		int link = (skable ? current_link : 0);  		int samples;  		// this packet has a pcm_offset on it (the last packet  		// completed on a page carries the offset) After processing  		// (above)' we know the pcm position of the *last* sample  		// ready to be returned. Find the offset of the *first*  		//   		// As an aside' this trick is inaccurate if we begin  		// reading anew right at the last page; the end-of-stream  		// granulepos declares the last frame in the stream' and the  		// last packet of the last page may be a partial frame.  		// So' we need a previous granulepos from an in-sequence page  		// to have a reference point.  Thus the !op.e_o_s clause above  		samples = vd.synthesis_pcmout (null' null);  		granulepos -= samples;  		for (int i = 0; i < link; i++) {  			granulepos += pcmlengths [i];  		}  		pcm_offset = granulepos;  	}  	return (1);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,process_packet,The following statement contains a magic number: bittrack += op.bytes * 8;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,process_packet,The following statement contains a magic number: bittrack += og.header_len * 8;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,bitrate,The following statement contains a magic number: if (i < 0) {  	long bits = 0;  	for (int j = 0; j < links; j++) {  		bits += (offsets [j + 1] - dataoffsets [j]) * 8;  	}  	return ((int)Math.Round (bits / time_total (-1)));  }  else {  	if (skable) {  		// return the actual bitrate  		return ((int)Math.Round ((offsets [i + 1] - dataoffsets [i]) * 8 / time_total (i)));  	}  	else {  		// return nominal if set  		if (vi [i].bitrate_nominal > 0) {  			return vi [i].bitrate_nominal;  		}  		else {  			if (vi [i].bitrate_upper > 0) {  				if (vi [i].bitrate_lower > 0) {  					return (vi [i].bitrate_upper + vi [i].bitrate_lower) / 2;  				}  				else {  					return vi [i].bitrate_upper;  				}  			}  			return (-1);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,bitrate,The following statement contains a magic number: if (i < 0) {  	long bits = 0;  	for (int j = 0; j < links; j++) {  		bits += (offsets [j + 1] - dataoffsets [j]) * 8;  	}  	return ((int)Math.Round (bits / time_total (-1)));  }  else {  	if (skable) {  		// return the actual bitrate  		return ((int)Math.Round ((offsets [i + 1] - dataoffsets [i]) * 8 / time_total (i)));  	}  	else {  		// return nominal if set  		if (vi [i].bitrate_nominal > 0) {  			return vi [i].bitrate_nominal;  		}  		else {  			if (vi [i].bitrate_upper > 0) {  				if (vi [i].bitrate_lower > 0) {  					return (vi [i].bitrate_upper + vi [i].bitrate_lower) / 2;  				}  				else {  					return vi [i].bitrate_upper;  				}  			}  			return (-1);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,bitrate,The following statement contains a magic number: if (i < 0) {  	long bits = 0;  	for (int j = 0; j < links; j++) {  		bits += (offsets [j + 1] - dataoffsets [j]) * 8;  	}  	return ((int)Math.Round (bits / time_total (-1)));  }  else {  	if (skable) {  		// return the actual bitrate  		return ((int)Math.Round ((offsets [i + 1] - dataoffsets [i]) * 8 / time_total (i)));  	}  	else {  		// return nominal if set  		if (vi [i].bitrate_nominal > 0) {  			return vi [i].bitrate_nominal;  		}  		else {  			if (vi [i].bitrate_upper > 0) {  				if (vi [i].bitrate_lower > 0) {  					return (vi [i].bitrate_upper + vi [i].bitrate_lower) / 2;  				}  				else {  					return vi [i].bitrate_upper;  				}  			}  			return (-1);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,bitrate,The following statement contains a magic number: for (int j = 0; j < links; j++) {  	bits += (offsets [j + 1] - dataoffsets [j]) * 8;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,bitrate,The following statement contains a magic number: bits += (offsets [j + 1] - dataoffsets [j]) * 8;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,bitrate,The following statement contains a magic number: if (skable) {  	// return the actual bitrate  	return ((int)Math.Round ((offsets [i + 1] - dataoffsets [i]) * 8 / time_total (i)));  }  else {  	// return nominal if set  	if (vi [i].bitrate_nominal > 0) {  		return vi [i].bitrate_nominal;  	}  	else {  		if (vi [i].bitrate_upper > 0) {  			if (vi [i].bitrate_lower > 0) {  				return (vi [i].bitrate_upper + vi [i].bitrate_lower) / 2;  			}  			else {  				return vi [i].bitrate_upper;  			}  		}  		return (-1);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,bitrate,The following statement contains a magic number: if (skable) {  	// return the actual bitrate  	return ((int)Math.Round ((offsets [i + 1] - dataoffsets [i]) * 8 / time_total (i)));  }  else {  	// return nominal if set  	if (vi [i].bitrate_nominal > 0) {  		return vi [i].bitrate_nominal;  	}  	else {  		if (vi [i].bitrate_upper > 0) {  			if (vi [i].bitrate_lower > 0) {  				return (vi [i].bitrate_upper + vi [i].bitrate_lower) / 2;  			}  			else {  				return vi [i].bitrate_upper;  			}  		}  		return (-1);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,bitrate,The following statement contains a magic number: return ((int)Math.Round ((offsets [i + 1] - dataoffsets [i]) * 8 / time_total (i)));  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,bitrate,The following statement contains a magic number: if (vi [i].bitrate_nominal > 0) {  	return vi [i].bitrate_nominal;  }  else {  	if (vi [i].bitrate_upper > 0) {  		if (vi [i].bitrate_lower > 0) {  			return (vi [i].bitrate_upper + vi [i].bitrate_lower) / 2;  		}  		else {  			return vi [i].bitrate_upper;  		}  	}  	return (-1);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,bitrate,The following statement contains a magic number: if (vi [i].bitrate_upper > 0) {  	if (vi [i].bitrate_lower > 0) {  		return (vi [i].bitrate_upper + vi [i].bitrate_lower) / 2;  	}  	else {  		return vi [i].bitrate_upper;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,bitrate,The following statement contains a magic number: if (vi [i].bitrate_lower > 0) {  	return (vi [i].bitrate_upper + vi [i].bitrate_lower) / 2;  }  else {  	return vi [i].bitrate_upper;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,bitrate,The following statement contains a magic number: return (vi [i].bitrate_upper + vi [i].bitrate_lower) / 2;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,pcm_seek,The following statement contains a magic number: while (begin < end) {  	long bisect;  	int ret;  	if (end - begin < CHUNKSIZE) {  		bisect = begin;  	}  	else {  		bisect = (end + begin) / 2;  	}  	seek_helper (bisect);  	ret = get_next_page (og' end - bisect);  	if (ret == -1) {  		end = bisect;  	}  	else {  		long granulepos = og.granulepos ();  		if (granulepos < target) {  			best = ret;  			// raw offset of packet with granulepos  			begin = offset;  			// raw offset of next packet  		}  		else {  			end = bisect;  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,pcm_seek,The following statement contains a magic number: if (end - begin < CHUNKSIZE) {  	bisect = begin;  }  else {  	bisect = (end + begin) / 2;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,pcm_seek,The following statement contains a magic number: bisect = (end + begin) / 2;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: while (true) {  	if (decode_ready) {  		float[][] pcm;  		float[][][] _pcm = new float[1][][];  		int[] _index = new int[getInfo (-1).channels];  		int samples = vd.synthesis_pcmout (_pcm' _index);  		pcm = _pcm [0];  		if (samples != 0) {  			// yay! proceed to pack data into the byte buffer  			int channels = getInfo (-1).channels;  			int bytespersample = word * channels;  			if (samples > length / bytespersample)  				samples = length / bytespersample;  			// a tight loop to pack each size  			{  				int val;  				if (word == 1) {  					int off = (sgned != 0 ? 0 : 128);  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  							if (val > 127)  								val = 127;  							else if (val < -128)  								val = -128;  							buffer [index++] = (byte)(val + off);  						}  					}  				}  				else {  					int off = (sgned != 0 ? 0 : 32768);  					if (host_endian == bigendianp) {  						if (sgned != 0) {  							for (int i = 0; i < channels; i++) {  								// It's faster in this order  								int src = _index [i];  								int dest = i * 2;  								for (int j = 0; j < samples; j++) {  									val = (int)(pcm [i] [src + j] * 32767.0);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)(val);  									buffer [dest + 1] = (byte)((uint)val >> 8);  									dest += bytespersample;  								}  							}  						}  						else {  							for (int i = 0; i < channels; i++) {  								float[] src = pcm [i];  								int dest = i;  								for (int j = 0; j < samples; j++) {  									val = (int)(src [j] * 32768.0 + 0.5);  									if (val > 32767)  										val = 32767;  									else if (val < -32768)  										val = -32768;  									buffer [dest] = (byte)((uint)(val + off) >> 8);  									buffer [dest + 1] = (byte)(val + off);  									dest += channels * 2;  								}  							}  						}  					}  					else if (bigendianp != 0) {  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)((uint)val >> 8);  								buffer [index++] = (byte)val;  							}  						}  					}  					else {  						//int val;  						for (int j = 0; j < samples; j++) {  							for (int i = 0; i < channels; i++) {  								val = (int)(pcm [i] [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								val += off;  								buffer [index++] = (byte)val;  								buffer [index++] = (byte)((uint)val >> 8);  							}  						}  					}  				}  			}  			vd.synthesis_read (samples);  			pcm_offset += samples;  			if (bitstream != null)  				bitstream [0] = current_link;  			return (samples * bytespersample);  		}  	}  	// suck in another packet  	switch (process_packet (1)) {  	case 0:  		return (0);  	case -1:  		return -1;  	default:  		break;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (decode_ready) {  	float[][] pcm;  	float[][][] _pcm = new float[1][][];  	int[] _index = new int[getInfo (-1).channels];  	int samples = vd.synthesis_pcmout (_pcm' _index);  	pcm = _pcm [0];  	if (samples != 0) {  		// yay! proceed to pack data into the byte buffer  		int channels = getInfo (-1).channels;  		int bytespersample = word * channels;  		if (samples > length / bytespersample)  			samples = length / bytespersample;  		// a tight loop to pack each size  		{  			int val;  			if (word == 1) {  				int off = (sgned != 0 ? 0 : 128);  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  						if (val > 127)  							val = 127;  						else if (val < -128)  							val = -128;  						buffer [index++] = (byte)(val + off);  					}  				}  			}  			else {  				int off = (sgned != 0 ? 0 : 32768);  				if (host_endian == bigendianp) {  					if (sgned != 0) {  						for (int i = 0; i < channels; i++) {  							// It's faster in this order  							int src = _index [i];  							int dest = i * 2;  							for (int j = 0; j < samples; j++) {  								val = (int)(pcm [i] [src + j] * 32767.0);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)(val);  								buffer [dest + 1] = (byte)((uint)val >> 8);  								dest += bytespersample;  							}  						}  					}  					else {  						for (int i = 0; i < channels; i++) {  							float[] src = pcm [i];  							int dest = i;  							for (int j = 0; j < samples; j++) {  								val = (int)(src [j] * 32768.0 + 0.5);  								if (val > 32767)  									val = 32767;  								else if (val < -32768)  									val = -32768;  								buffer [dest] = (byte)((uint)(val + off) >> 8);  								buffer [dest + 1] = (byte)(val + off);  								dest += channels * 2;  							}  						}  					}  				}  				else if (bigendianp != 0) {  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)((uint)val >> 8);  							buffer [index++] = (byte)val;  						}  					}  				}  				else {  					//int val;  					for (int j = 0; j < samples; j++) {  						for (int i = 0; i < channels; i++) {  							val = (int)(pcm [i] [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							val += off;  							buffer [index++] = (byte)val;  							buffer [index++] = (byte)((uint)val >> 8);  						}  					}  				}  			}  		}  		vd.synthesis_read (samples);  		pcm_offset += samples;  		if (bitstream != null)  			bitstream [0] = current_link;  		return (samples * bytespersample);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (samples != 0) {  	// yay! proceed to pack data into the byte buffer  	int channels = getInfo (-1).channels;  	int bytespersample = word * channels;  	if (samples > length / bytespersample)  		samples = length / bytespersample;  	// a tight loop to pack each size  	{  		int val;  		if (word == 1) {  			int off = (sgned != 0 ? 0 : 128);  			for (int j = 0; j < samples; j++) {  				for (int i = 0; i < channels; i++) {  					val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  					if (val > 127)  						val = 127;  					else if (val < -128)  						val = -128;  					buffer [index++] = (byte)(val + off);  				}  			}  		}  		else {  			int off = (sgned != 0 ? 0 : 32768);  			if (host_endian == bigendianp) {  				if (sgned != 0) {  					for (int i = 0; i < channels; i++) {  						// It's faster in this order  						int src = _index [i];  						int dest = i * 2;  						for (int j = 0; j < samples; j++) {  							val = (int)(pcm [i] [src + j] * 32767.0);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)(val);  							buffer [dest + 1] = (byte)((uint)val >> 8);  							dest += bytespersample;  						}  					}  				}  				else {  					for (int i = 0; i < channels; i++) {  						float[] src = pcm [i];  						int dest = i;  						for (int j = 0; j < samples; j++) {  							val = (int)(src [j] * 32768.0 + 0.5);  							if (val > 32767)  								val = 32767;  							else if (val < -32768)  								val = -32768;  							buffer [dest] = (byte)((uint)(val + off) >> 8);  							buffer [dest + 1] = (byte)(val + off);  							dest += channels * 2;  						}  					}  				}  			}  			else if (bigendianp != 0) {  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)((uint)val >> 8);  						buffer [index++] = (byte)val;  					}  				}  			}  			else {  				//int val;  				for (int j = 0; j < samples; j++) {  					for (int i = 0; i < channels; i++) {  						val = (int)(pcm [i] [j] * 32768.0 + 0.5);  						if (val > 32767)  							val = 32767;  						else if (val < -32768)  							val = -32768;  						val += off;  						buffer [index++] = (byte)val;  						buffer [index++] = (byte)((uint)val >> 8);  					}  				}  			}  		}  	}  	vd.synthesis_read (samples);  	pcm_offset += samples;  	if (bitstream != null)  		bitstream [0] = current_link;  	return (samples * bytespersample);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (word == 1) {  	int off = (sgned != 0 ? 0 : 128);  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  			if (val > 127)  				val = 127;  			else if (val < -128)  				val = -128;  			buffer [index++] = (byte)(val + off);  		}  	}  }  else {  	int off = (sgned != 0 ? 0 : 32768);  	if (host_endian == bigendianp) {  		if (sgned != 0) {  			for (int i = 0; i < channels; i++) {  				// It's faster in this order  				int src = _index [i];  				int dest = i * 2;  				for (int j = 0; j < samples; j++) {  					val = (int)(pcm [i] [src + j] * 32767.0);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)(val);  					buffer [dest + 1] = (byte)((uint)val >> 8);  					dest += bytespersample;  				}  			}  		}  		else {  			for (int i = 0; i < channels; i++) {  				float[] src = pcm [i];  				int dest = i;  				for (int j = 0; j < samples; j++) {  					val = (int)(src [j] * 32768.0 + 0.5);  					if (val > 32767)  						val = 32767;  					else if (val < -32768)  						val = -32768;  					buffer [dest] = (byte)((uint)(val + off) >> 8);  					buffer [dest + 1] = (byte)(val + off);  					dest += channels * 2;  				}  			}  		}  	}  	else if (bigendianp != 0) {  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)((uint)val >> 8);  				buffer [index++] = (byte)val;  			}  		}  	}  	else {  		//int val;  		for (int j = 0; j < samples; j++) {  			for (int i = 0; i < channels; i++) {  				val = (int)(pcm [i] [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				val += off;  				buffer [index++] = (byte)val;  				buffer [index++] = (byte)((uint)val >> 8);  			}  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  		if (val > 127)  			val = 127;  		else if (val < -128)  			val = -128;  		buffer [index++] = (byte)(val + off);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  		if (val > 127)  			val = 127;  		else if (val < -128)  			val = -128;  		buffer [index++] = (byte)(val + off);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  		if (val > 127)  			val = 127;  		else if (val < -128)  			val = -128;  		buffer [index++] = (byte)(val + off);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  		if (val > 127)  			val = 127;  		else if (val < -128)  			val = -128;  		buffer [index++] = (byte)(val + off);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  		if (val > 127)  			val = 127;  		else if (val < -128)  			val = -128;  		buffer [index++] = (byte)(val + off);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  		if (val > 127)  			val = 127;  		else if (val < -128)  			val = -128;  		buffer [index++] = (byte)(val + off);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  	if (val > 127)  		val = 127;  	else if (val < -128)  		val = -128;  	buffer [index++] = (byte)(val + off);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  	if (val > 127)  		val = 127;  	else if (val < -128)  		val = -128;  	buffer [index++] = (byte)(val + off);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  	if (val > 127)  		val = 127;  	else if (val < -128)  		val = -128;  	buffer [index++] = (byte)(val + off);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  	if (val > 127)  		val = 127;  	else if (val < -128)  		val = -128;  	buffer [index++] = (byte)(val + off);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  	if (val > 127)  		val = 127;  	else if (val < -128)  		val = -128;  	buffer [index++] = (byte)(val + off);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  	if (val > 127)  		val = 127;  	else if (val < -128)  		val = -128;  	buffer [index++] = (byte)(val + off);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: val = (int)(pcm [i] [_index [i] + j] * 128.0 + 0.5);  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 127)  	val = 127;  else if (val < -128)  	val = -128;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 127)  	val = 127;  else if (val < -128)  	val = -128;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 127)  	val = 127;  else if (val < -128)  	val = -128;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 127)  	val = 127;  else if (val < -128)  	val = -128;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: val = 127;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val < -128)  	val = -128;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val < -128)  	val = -128;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: val = -128;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (host_endian == bigendianp) {  	if (sgned != 0) {  		for (int i = 0; i < channels; i++) {  			// It's faster in this order  			int src = _index [i];  			int dest = i * 2;  			for (int j = 0; j < samples; j++) {  				val = (int)(pcm [i] [src + j] * 32767.0);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)(val);  				buffer [dest + 1] = (byte)((uint)val >> 8);  				dest += bytespersample;  			}  		}  	}  	else {  		for (int i = 0; i < channels; i++) {  			float[] src = pcm [i];  			int dest = i;  			for (int j = 0; j < samples; j++) {  				val = (int)(src [j] * 32768.0 + 0.5);  				if (val > 32767)  					val = 32767;  				else if (val < -32768)  					val = -32768;  				buffer [dest] = (byte)((uint)(val + off) >> 8);  				buffer [dest + 1] = (byte)(val + off);  				dest += channels * 2;  			}  		}  	}  }  else if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (sgned != 0) {  	for (int i = 0; i < channels; i++) {  		// It's faster in this order  		int src = _index [i];  		int dest = i * 2;  		for (int j = 0; j < samples; j++) {  			val = (int)(pcm [i] [src + j] * 32767.0);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)(val);  			buffer [dest + 1] = (byte)((uint)val >> 8);  			dest += bytespersample;  		}  	}  }  else {  	for (int i = 0; i < channels; i++) {  		float[] src = pcm [i];  		int dest = i;  		for (int j = 0; j < samples; j++) {  			val = (int)(src [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)((uint)(val + off) >> 8);  			buffer [dest + 1] = (byte)(val + off);  			dest += channels * 2;  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (sgned != 0) {  	for (int i = 0; i < channels; i++) {  		// It's faster in this order  		int src = _index [i];  		int dest = i * 2;  		for (int j = 0; j < samples; j++) {  			val = (int)(pcm [i] [src + j] * 32767.0);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)(val);  			buffer [dest + 1] = (byte)((uint)val >> 8);  			dest += bytespersample;  		}  	}  }  else {  	for (int i = 0; i < channels; i++) {  		float[] src = pcm [i];  		int dest = i;  		for (int j = 0; j < samples; j++) {  			val = (int)(src [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)((uint)(val + off) >> 8);  			buffer [dest + 1] = (byte)(val + off);  			dest += channels * 2;  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (sgned != 0) {  	for (int i = 0; i < channels; i++) {  		// It's faster in this order  		int src = _index [i];  		int dest = i * 2;  		for (int j = 0; j < samples; j++) {  			val = (int)(pcm [i] [src + j] * 32767.0);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)(val);  			buffer [dest + 1] = (byte)((uint)val >> 8);  			dest += bytespersample;  		}  	}  }  else {  	for (int i = 0; i < channels; i++) {  		float[] src = pcm [i];  		int dest = i;  		for (int j = 0; j < samples; j++) {  			val = (int)(src [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)((uint)(val + off) >> 8);  			buffer [dest + 1] = (byte)(val + off);  			dest += channels * 2;  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (sgned != 0) {  	for (int i = 0; i < channels; i++) {  		// It's faster in this order  		int src = _index [i];  		int dest = i * 2;  		for (int j = 0; j < samples; j++) {  			val = (int)(pcm [i] [src + j] * 32767.0);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)(val);  			buffer [dest + 1] = (byte)((uint)val >> 8);  			dest += bytespersample;  		}  	}  }  else {  	for (int i = 0; i < channels; i++) {  		float[] src = pcm [i];  		int dest = i;  		for (int j = 0; j < samples; j++) {  			val = (int)(src [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)((uint)(val + off) >> 8);  			buffer [dest + 1] = (byte)(val + off);  			dest += channels * 2;  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (sgned != 0) {  	for (int i = 0; i < channels; i++) {  		// It's faster in this order  		int src = _index [i];  		int dest = i * 2;  		for (int j = 0; j < samples; j++) {  			val = (int)(pcm [i] [src + j] * 32767.0);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)(val);  			buffer [dest + 1] = (byte)((uint)val >> 8);  			dest += bytespersample;  		}  	}  }  else {  	for (int i = 0; i < channels; i++) {  		float[] src = pcm [i];  		int dest = i;  		for (int j = 0; j < samples; j++) {  			val = (int)(src [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)((uint)(val + off) >> 8);  			buffer [dest + 1] = (byte)(val + off);  			dest += channels * 2;  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (sgned != 0) {  	for (int i = 0; i < channels; i++) {  		// It's faster in this order  		int src = _index [i];  		int dest = i * 2;  		for (int j = 0; j < samples; j++) {  			val = (int)(pcm [i] [src + j] * 32767.0);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)(val);  			buffer [dest + 1] = (byte)((uint)val >> 8);  			dest += bytespersample;  		}  	}  }  else {  	for (int i = 0; i < channels; i++) {  		float[] src = pcm [i];  		int dest = i;  		for (int j = 0; j < samples; j++) {  			val = (int)(src [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)((uint)(val + off) >> 8);  			buffer [dest + 1] = (byte)(val + off);  			dest += channels * 2;  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (sgned != 0) {  	for (int i = 0; i < channels; i++) {  		// It's faster in this order  		int src = _index [i];  		int dest = i * 2;  		for (int j = 0; j < samples; j++) {  			val = (int)(pcm [i] [src + j] * 32767.0);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)(val);  			buffer [dest + 1] = (byte)((uint)val >> 8);  			dest += bytespersample;  		}  	}  }  else {  	for (int i = 0; i < channels; i++) {  		float[] src = pcm [i];  		int dest = i;  		for (int j = 0; j < samples; j++) {  			val = (int)(src [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)((uint)(val + off) >> 8);  			buffer [dest + 1] = (byte)(val + off);  			dest += channels * 2;  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (sgned != 0) {  	for (int i = 0; i < channels; i++) {  		// It's faster in this order  		int src = _index [i];  		int dest = i * 2;  		for (int j = 0; j < samples; j++) {  			val = (int)(pcm [i] [src + j] * 32767.0);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)(val);  			buffer [dest + 1] = (byte)((uint)val >> 8);  			dest += bytespersample;  		}  	}  }  else {  	for (int i = 0; i < channels; i++) {  		float[] src = pcm [i];  		int dest = i;  		for (int j = 0; j < samples; j++) {  			val = (int)(src [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)((uint)(val + off) >> 8);  			buffer [dest + 1] = (byte)(val + off);  			dest += channels * 2;  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (sgned != 0) {  	for (int i = 0; i < channels; i++) {  		// It's faster in this order  		int src = _index [i];  		int dest = i * 2;  		for (int j = 0; j < samples; j++) {  			val = (int)(pcm [i] [src + j] * 32767.0);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)(val);  			buffer [dest + 1] = (byte)((uint)val >> 8);  			dest += bytespersample;  		}  	}  }  else {  	for (int i = 0; i < channels; i++) {  		float[] src = pcm [i];  		int dest = i;  		for (int j = 0; j < samples; j++) {  			val = (int)(src [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)((uint)(val + off) >> 8);  			buffer [dest + 1] = (byte)(val + off);  			dest += channels * 2;  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (sgned != 0) {  	for (int i = 0; i < channels; i++) {  		// It's faster in this order  		int src = _index [i];  		int dest = i * 2;  		for (int j = 0; j < samples; j++) {  			val = (int)(pcm [i] [src + j] * 32767.0);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)(val);  			buffer [dest + 1] = (byte)((uint)val >> 8);  			dest += bytespersample;  		}  	}  }  else {  	for (int i = 0; i < channels; i++) {  		float[] src = pcm [i];  		int dest = i;  		for (int j = 0; j < samples; j++) {  			val = (int)(src [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)((uint)(val + off) >> 8);  			buffer [dest + 1] = (byte)(val + off);  			dest += channels * 2;  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (sgned != 0) {  	for (int i = 0; i < channels; i++) {  		// It's faster in this order  		int src = _index [i];  		int dest = i * 2;  		for (int j = 0; j < samples; j++) {  			val = (int)(pcm [i] [src + j] * 32767.0);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)(val);  			buffer [dest + 1] = (byte)((uint)val >> 8);  			dest += bytespersample;  		}  	}  }  else {  	for (int i = 0; i < channels; i++) {  		float[] src = pcm [i];  		int dest = i;  		for (int j = 0; j < samples; j++) {  			val = (int)(src [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)((uint)(val + off) >> 8);  			buffer [dest + 1] = (byte)(val + off);  			dest += channels * 2;  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (sgned != 0) {  	for (int i = 0; i < channels; i++) {  		// It's faster in this order  		int src = _index [i];  		int dest = i * 2;  		for (int j = 0; j < samples; j++) {  			val = (int)(pcm [i] [src + j] * 32767.0);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)(val);  			buffer [dest + 1] = (byte)((uint)val >> 8);  			dest += bytespersample;  		}  	}  }  else {  	for (int i = 0; i < channels; i++) {  		float[] src = pcm [i];  		int dest = i;  		for (int j = 0; j < samples; j++) {  			val = (int)(src [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)((uint)(val + off) >> 8);  			buffer [dest + 1] = (byte)(val + off);  			dest += channels * 2;  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (sgned != 0) {  	for (int i = 0; i < channels; i++) {  		// It's faster in this order  		int src = _index [i];  		int dest = i * 2;  		for (int j = 0; j < samples; j++) {  			val = (int)(pcm [i] [src + j] * 32767.0);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)(val);  			buffer [dest + 1] = (byte)((uint)val >> 8);  			dest += bytespersample;  		}  	}  }  else {  	for (int i = 0; i < channels; i++) {  		float[] src = pcm [i];  		int dest = i;  		for (int j = 0; j < samples; j++) {  			val = (int)(src [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)((uint)(val + off) >> 8);  			buffer [dest + 1] = (byte)(val + off);  			dest += channels * 2;  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (sgned != 0) {  	for (int i = 0; i < channels; i++) {  		// It's faster in this order  		int src = _index [i];  		int dest = i * 2;  		for (int j = 0; j < samples; j++) {  			val = (int)(pcm [i] [src + j] * 32767.0);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)(val);  			buffer [dest + 1] = (byte)((uint)val >> 8);  			dest += bytespersample;  		}  	}  }  else {  	for (int i = 0; i < channels; i++) {  		float[] src = pcm [i];  		int dest = i;  		for (int j = 0; j < samples; j++) {  			val = (int)(src [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)((uint)(val + off) >> 8);  			buffer [dest + 1] = (byte)(val + off);  			dest += channels * 2;  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (sgned != 0) {  	for (int i = 0; i < channels; i++) {  		// It's faster in this order  		int src = _index [i];  		int dest = i * 2;  		for (int j = 0; j < samples; j++) {  			val = (int)(pcm [i] [src + j] * 32767.0);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)(val);  			buffer [dest + 1] = (byte)((uint)val >> 8);  			dest += bytespersample;  		}  	}  }  else {  	for (int i = 0; i < channels; i++) {  		float[] src = pcm [i];  		int dest = i;  		for (int j = 0; j < samples; j++) {  			val = (int)(src [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			buffer [dest] = (byte)((uint)(val + off) >> 8);  			buffer [dest + 1] = (byte)(val + off);  			dest += channels * 2;  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	// It's faster in this order  	int src = _index [i];  	int dest = i * 2;  	for (int j = 0; j < samples; j++) {  		val = (int)(pcm [i] [src + j] * 32767.0);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		buffer [dest] = (byte)(val);  		buffer [dest + 1] = (byte)((uint)val >> 8);  		dest += bytespersample;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	// It's faster in this order  	int src = _index [i];  	int dest = i * 2;  	for (int j = 0; j < samples; j++) {  		val = (int)(pcm [i] [src + j] * 32767.0);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		buffer [dest] = (byte)(val);  		buffer [dest + 1] = (byte)((uint)val >> 8);  		dest += bytespersample;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	// It's faster in this order  	int src = _index [i];  	int dest = i * 2;  	for (int j = 0; j < samples; j++) {  		val = (int)(pcm [i] [src + j] * 32767.0);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		buffer [dest] = (byte)(val);  		buffer [dest + 1] = (byte)((uint)val >> 8);  		dest += bytespersample;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	// It's faster in this order  	int src = _index [i];  	int dest = i * 2;  	for (int j = 0; j < samples; j++) {  		val = (int)(pcm [i] [src + j] * 32767.0);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		buffer [dest] = (byte)(val);  		buffer [dest + 1] = (byte)((uint)val >> 8);  		dest += bytespersample;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	// It's faster in this order  	int src = _index [i];  	int dest = i * 2;  	for (int j = 0; j < samples; j++) {  		val = (int)(pcm [i] [src + j] * 32767.0);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		buffer [dest] = (byte)(val);  		buffer [dest + 1] = (byte)((uint)val >> 8);  		dest += bytespersample;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	// It's faster in this order  	int src = _index [i];  	int dest = i * 2;  	for (int j = 0; j < samples; j++) {  		val = (int)(pcm [i] [src + j] * 32767.0);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		buffer [dest] = (byte)(val);  		buffer [dest + 1] = (byte)((uint)val >> 8);  		dest += bytespersample;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	// It's faster in this order  	int src = _index [i];  	int dest = i * 2;  	for (int j = 0; j < samples; j++) {  		val = (int)(pcm [i] [src + j] * 32767.0);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		buffer [dest] = (byte)(val);  		buffer [dest + 1] = (byte)((uint)val >> 8);  		dest += bytespersample;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	val = (int)(pcm [i] [src + j] * 32767.0);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	buffer [dest] = (byte)(val);  	buffer [dest + 1] = (byte)((uint)val >> 8);  	dest += bytespersample;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	val = (int)(pcm [i] [src + j] * 32767.0);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	buffer [dest] = (byte)(val);  	buffer [dest + 1] = (byte)((uint)val >> 8);  	dest += bytespersample;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	val = (int)(pcm [i] [src + j] * 32767.0);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	buffer [dest] = (byte)(val);  	buffer [dest + 1] = (byte)((uint)val >> 8);  	dest += bytespersample;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	val = (int)(pcm [i] [src + j] * 32767.0);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	buffer [dest] = (byte)(val);  	buffer [dest + 1] = (byte)((uint)val >> 8);  	dest += bytespersample;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	val = (int)(pcm [i] [src + j] * 32767.0);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	buffer [dest] = (byte)(val);  	buffer [dest + 1] = (byte)((uint)val >> 8);  	dest += bytespersample;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	val = (int)(pcm [i] [src + j] * 32767.0);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	buffer [dest] = (byte)(val);  	buffer [dest + 1] = (byte)((uint)val >> 8);  	dest += bytespersample;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: val = (int)(pcm [i] [src + j] * 32767.0);  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 32767)  	val = 32767;  else if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 32767)  	val = 32767;  else if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 32767)  	val = 32767;  else if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 32767)  	val = 32767;  else if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: val = 32767;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: buffer [dest + 1] = (byte)((uint)val >> 8);  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	float[] src = pcm [i];  	int dest = i;  	for (int j = 0; j < samples; j++) {  		val = (int)(src [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		buffer [dest] = (byte)((uint)(val + off) >> 8);  		buffer [dest + 1] = (byte)(val + off);  		dest += channels * 2;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	float[] src = pcm [i];  	int dest = i;  	for (int j = 0; j < samples; j++) {  		val = (int)(src [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		buffer [dest] = (byte)((uint)(val + off) >> 8);  		buffer [dest + 1] = (byte)(val + off);  		dest += channels * 2;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	float[] src = pcm [i];  	int dest = i;  	for (int j = 0; j < samples; j++) {  		val = (int)(src [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		buffer [dest] = (byte)((uint)(val + off) >> 8);  		buffer [dest + 1] = (byte)(val + off);  		dest += channels * 2;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	float[] src = pcm [i];  	int dest = i;  	for (int j = 0; j < samples; j++) {  		val = (int)(src [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		buffer [dest] = (byte)((uint)(val + off) >> 8);  		buffer [dest + 1] = (byte)(val + off);  		dest += channels * 2;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	float[] src = pcm [i];  	int dest = i;  	for (int j = 0; j < samples; j++) {  		val = (int)(src [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		buffer [dest] = (byte)((uint)(val + off) >> 8);  		buffer [dest + 1] = (byte)(val + off);  		dest += channels * 2;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	float[] src = pcm [i];  	int dest = i;  	for (int j = 0; j < samples; j++) {  		val = (int)(src [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		buffer [dest] = (byte)((uint)(val + off) >> 8);  		buffer [dest + 1] = (byte)(val + off);  		dest += channels * 2;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	float[] src = pcm [i];  	int dest = i;  	for (int j = 0; j < samples; j++) {  		val = (int)(src [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		buffer [dest] = (byte)((uint)(val + off) >> 8);  		buffer [dest + 1] = (byte)(val + off);  		dest += channels * 2;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	float[] src = pcm [i];  	int dest = i;  	for (int j = 0; j < samples; j++) {  		val = (int)(src [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		buffer [dest] = (byte)((uint)(val + off) >> 8);  		buffer [dest + 1] = (byte)(val + off);  		dest += channels * 2;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	val = (int)(src [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	buffer [dest] = (byte)((uint)(val + off) >> 8);  	buffer [dest + 1] = (byte)(val + off);  	dest += channels * 2;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	val = (int)(src [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	buffer [dest] = (byte)((uint)(val + off) >> 8);  	buffer [dest + 1] = (byte)(val + off);  	dest += channels * 2;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	val = (int)(src [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	buffer [dest] = (byte)((uint)(val + off) >> 8);  	buffer [dest + 1] = (byte)(val + off);  	dest += channels * 2;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	val = (int)(src [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	buffer [dest] = (byte)((uint)(val + off) >> 8);  	buffer [dest + 1] = (byte)(val + off);  	dest += channels * 2;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	val = (int)(src [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	buffer [dest] = (byte)((uint)(val + off) >> 8);  	buffer [dest + 1] = (byte)(val + off);  	dest += channels * 2;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	val = (int)(src [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	buffer [dest] = (byte)((uint)(val + off) >> 8);  	buffer [dest + 1] = (byte)(val + off);  	dest += channels * 2;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	val = (int)(src [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	buffer [dest] = (byte)((uint)(val + off) >> 8);  	buffer [dest + 1] = (byte)(val + off);  	dest += channels * 2;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	val = (int)(src [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	buffer [dest] = (byte)((uint)(val + off) >> 8);  	buffer [dest + 1] = (byte)(val + off);  	dest += channels * 2;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: val = (int)(src [j] * 32768.0 + 0.5);  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: val = (int)(src [j] * 32768.0 + 0.5);  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 32767)  	val = 32767;  else if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 32767)  	val = 32767;  else if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 32767)  	val = 32767;  else if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 32767)  	val = 32767;  else if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: val = 32767;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: buffer [dest] = (byte)((uint)(val + off) >> 8);  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: dest += channels * 2;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (bigendianp != 0) {  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)((uint)val >> 8);  			buffer [index++] = (byte)val;  		}  	}  }  else {  	//int val;  	for (int j = 0; j < samples; j++) {  		for (int i = 0; i < channels; i++) {  			val = (int)(pcm [i] [j] * 32768.0 + 0.5);  			if (val > 32767)  				val = 32767;  			else if (val < -32768)  				val = -32768;  			val += off;  			buffer [index++] = (byte)val;  			buffer [index++] = (byte)((uint)val >> 8);  		}  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		val += off;  		buffer [index++] = (byte)((uint)val >> 8);  		buffer [index++] = (byte)val;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		val += off;  		buffer [index++] = (byte)((uint)val >> 8);  		buffer [index++] = (byte)val;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		val += off;  		buffer [index++] = (byte)((uint)val >> 8);  		buffer [index++] = (byte)val;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		val += off;  		buffer [index++] = (byte)((uint)val >> 8);  		buffer [index++] = (byte)val;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		val += off;  		buffer [index++] = (byte)((uint)val >> 8);  		buffer [index++] = (byte)val;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		val += off;  		buffer [index++] = (byte)((uint)val >> 8);  		buffer [index++] = (byte)val;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		val += off;  		buffer [index++] = (byte)((uint)val >> 8);  		buffer [index++] = (byte)val;  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	val += off;  	buffer [index++] = (byte)((uint)val >> 8);  	buffer [index++] = (byte)val;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	val += off;  	buffer [index++] = (byte)((uint)val >> 8);  	buffer [index++] = (byte)val;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	val += off;  	buffer [index++] = (byte)((uint)val >> 8);  	buffer [index++] = (byte)val;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	val += off;  	buffer [index++] = (byte)((uint)val >> 8);  	buffer [index++] = (byte)val;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	val += off;  	buffer [index++] = (byte)((uint)val >> 8);  	buffer [index++] = (byte)val;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	val += off;  	buffer [index++] = (byte)((uint)val >> 8);  	buffer [index++] = (byte)val;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	val += off;  	buffer [index++] = (byte)((uint)val >> 8);  	buffer [index++] = (byte)val;  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: val = (int)(pcm [i] [j] * 32768.0 + 0.5);  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: val = (int)(pcm [i] [j] * 32768.0 + 0.5);  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 32767)  	val = 32767;  else if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 32767)  	val = 32767;  else if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 32767)  	val = 32767;  else if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 32767)  	val = 32767;  else if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: val = 32767;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: buffer [index++] = (byte)((uint)val >> 8);  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		val += off;  		buffer [index++] = (byte)val;  		buffer [index++] = (byte)((uint)val >> 8);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		val += off;  		buffer [index++] = (byte)val;  		buffer [index++] = (byte)((uint)val >> 8);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		val += off;  		buffer [index++] = (byte)val;  		buffer [index++] = (byte)((uint)val >> 8);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		val += off;  		buffer [index++] = (byte)val;  		buffer [index++] = (byte)((uint)val >> 8);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		val += off;  		buffer [index++] = (byte)val;  		buffer [index++] = (byte)((uint)val >> 8);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		val += off;  		buffer [index++] = (byte)val;  		buffer [index++] = (byte)((uint)val >> 8);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int j = 0; j < samples; j++) {  	for (int i = 0; i < channels; i++) {  		val = (int)(pcm [i] [j] * 32768.0 + 0.5);  		if (val > 32767)  			val = 32767;  		else if (val < -32768)  			val = -32768;  		val += off;  		buffer [index++] = (byte)val;  		buffer [index++] = (byte)((uint)val >> 8);  	}  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	val += off;  	buffer [index++] = (byte)val;  	buffer [index++] = (byte)((uint)val >> 8);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	val += off;  	buffer [index++] = (byte)val;  	buffer [index++] = (byte)((uint)val >> 8);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	val += off;  	buffer [index++] = (byte)val;  	buffer [index++] = (byte)((uint)val >> 8);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	val += off;  	buffer [index++] = (byte)val;  	buffer [index++] = (byte)((uint)val >> 8);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	val += off;  	buffer [index++] = (byte)val;  	buffer [index++] = (byte)((uint)val >> 8);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	val += off;  	buffer [index++] = (byte)val;  	buffer [index++] = (byte)((uint)val >> 8);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: for (int i = 0; i < channels; i++) {  	val = (int)(pcm [i] [j] * 32768.0 + 0.5);  	if (val > 32767)  		val = 32767;  	else if (val < -32768)  		val = -32768;  	val += off;  	buffer [index++] = (byte)val;  	buffer [index++] = (byte)((uint)val >> 8);  }  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: val = (int)(pcm [i] [j] * 32768.0 + 0.5);  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: val = (int)(pcm [i] [j] * 32768.0 + 0.5);  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 32767)  	val = 32767;  else if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 32767)  	val = 32767;  else if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 32767)  	val = 32767;  else if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val > 32767)  	val = 32767;  else if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: val = 32767;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: if (val < -32768)  	val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: val = -32768;  
Magic Number,csvorbis,VorbisFile,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\VorbisFile.cs,read,The following statement contains a magic number: buffer [index++] = (byte)((uint)val >> 8);  
Magic Number,Tachycardia.Sound.BGM,OggFile,C:\repos\secred_Tachycardia\src\Sound\Audio\OggFile.cs,OggFile,The following statement contains a magic number: if (m_TagLibFile.Properties.AudioBitrate == 16) {  	m_Format = (m_Info [0].channels) == 1 ? ALFormat.Mono16 : ALFormat.Stereo16;  	// This looks like a fudge' but I've seen it a couple of times (what about the other formats I wonder?)  }  else {  	m_Format = (m_Info [0].channels) == 1 ? ALFormat.Mono8 : ALFormat.Stereo8;  }  
Magic Number,Tachycardia.Sound.BGM,OggPlayer,C:\repos\secred_Tachycardia\src\Sound\Audio\OggPlayer.cs,OggPlayer,The following statement contains a magic number: m_BufferSize = 4096;  
Magic Number,Tachycardia.Sound.BGM,OggPlayer,C:\repos\secred_Tachycardia\src\Sound\Audio\OggPlayer.cs,OggPlayer,The following statement contains a magic number: m_Buffers = new uint[32];  
Magic Number,Tachycardia.Sound.BGM,OggPlayer,C:\repos\secred_Tachycardia\src\Sound\Audio\OggPlayer.cs,Stop,The following statement contains a magic number: lock (OALLocker) {  	AL.SourceStop (m_Source);  	int nBuffers;  	AL.GetSource (m_Source' ALGetSourcei.BuffersQueued' out nBuffers);  	if (nBuffers > 0) {  		AL.SourceUnqueueBuffers ((int)m_Source' nBuffers);  	}  	m_CurrentFile.ResetFile ();  	for (int i = 0; i < m_Buffers.Length; i++)  		AL.DeleteBuffer (ref m_Buffers [i]);  	m_Buffers = new uint[32];  }  
Magic Number,Tachycardia.Sound.BGM,OggPlayer,C:\repos\secred_Tachycardia\src\Sound\Audio\OggPlayer.cs,Stop,The following statement contains a magic number: m_Buffers = new uint[32];  
Magic Number,Tachycardia.Sound.BGM,OggPlayer,C:\repos\secred_Tachycardia\src\Sound\Audio\OggPlayer.cs,PlayThread,The following statement contains a magic number: while (Running) {  	if (m_PlayerState == OggPlayerStatus.Playing) {  		int QueuedBuffers = 0;  		AL.GetSource (m_Source' ALGetSourcei.BuffersQueued' out QueuedBuffers);  		if (ReachedEOF) {  			if (QueuedBuffers > 0) {  			}  			else {  				lock (OALLocker) {  					Running = false;  					if (AL.GetSourceState (m_Source) != ALSourceState.Stopped) {  						AL.SourceStop (m_Source);  					}  					m_CurrentFile.ResetFile ();  					for (int i = 0; i < m_Buffers.Length; i++) {  						AL.DeleteBuffer (ref m_Buffers [i]);  					}  					m_Buffers = new uint[32];  				}  				StateChange (OggPlayerStatus.Stopped' OggPlayerStateChanger.EndOfFile);  				return;  			}  		}  		if ((!ReachedEOF) && (QueuedBuffers > 0) && (AL.GetError () == ALError.NoError))  			if (AL.GetSourceState (m_Source) != ALSourceState.Playing)  				AL.SourcePlay (m_Source);  		int ProcessedBuffers = 0;  		uint BufferRef = 0;  		lock (OALLocker) {  			AL.GetSource (m_Source' ALGetSourcei.BuffersProcessed' out ProcessedBuffers);  		}  		if (ProcessedBuffers >= 32)  			UnderRun = true;  		else  			UnderRun = false;  		while (ProcessedBuffers > 0) {  			OggBufferSegment obs;  			lock (OALLocker) {  				AL.SourceUnqueueBuffers (m_Source' 1' ref BufferRef);  				if (ReachedEOF) {  					--ProcessedBuffers;  					continue;  				}  				// If we're at the EOF loop to the next buffer here - we don't want to be trying to fill any more  				obs = m_CurrentFile.GetBufferSegment (m_BufferSize);  				// Get chunk of tasty buffer data with the configured segment  			}  			if (obs.ReturnValue > 0) {  				lock (OALLocker) {  					AL.BufferData ((int)BufferRef' m_CurrentFile.Format' obs.Buffer' obs.ReturnValue' obs.RateHz);  					AL.SourceQueueBuffers (m_Source' 1' ref BufferRef);  				}  			}  			else {  				if (obs.ReturnValue == 0) {  					ReachedEOF = true;  					break;  				}  				else {  					lock (OALLocker) {  						m_PlayerState = OggPlayerStatus.Error;  						AL.SourceStop (m_Source);  						Running = false;  					}  					break;  				}  			}  			if (AL.GetError () != ALError.NoError) {  				StateChange (OggPlayerStatus.Error' OggPlayerStateChanger.Error);  				lock (OALLocker) {  					AL.SourceStop (m_Source);  				}  				Running = false;  				break;  			}  			--ProcessedBuffers;  		}  		if (UnderRun) {  			lock (OALLocker) {  				AL.SourcePlay (m_Source);  			}  		}  	}  	else if (m_PlayerState == OggPlayerStatus.Paused) {  	}  	else {  		Running = false;  	}  	Thread.Sleep (10);  }  
Magic Number,Tachycardia.Sound.BGM,OggPlayer,C:\repos\secred_Tachycardia\src\Sound\Audio\OggPlayer.cs,PlayThread,The following statement contains a magic number: while (Running) {  	if (m_PlayerState == OggPlayerStatus.Playing) {  		int QueuedBuffers = 0;  		AL.GetSource (m_Source' ALGetSourcei.BuffersQueued' out QueuedBuffers);  		if (ReachedEOF) {  			if (QueuedBuffers > 0) {  			}  			else {  				lock (OALLocker) {  					Running = false;  					if (AL.GetSourceState (m_Source) != ALSourceState.Stopped) {  						AL.SourceStop (m_Source);  					}  					m_CurrentFile.ResetFile ();  					for (int i = 0; i < m_Buffers.Length; i++) {  						AL.DeleteBuffer (ref m_Buffers [i]);  					}  					m_Buffers = new uint[32];  				}  				StateChange (OggPlayerStatus.Stopped' OggPlayerStateChanger.EndOfFile);  				return;  			}  		}  		if ((!ReachedEOF) && (QueuedBuffers > 0) && (AL.GetError () == ALError.NoError))  			if (AL.GetSourceState (m_Source) != ALSourceState.Playing)  				AL.SourcePlay (m_Source);  		int ProcessedBuffers = 0;  		uint BufferRef = 0;  		lock (OALLocker) {  			AL.GetSource (m_Source' ALGetSourcei.BuffersProcessed' out ProcessedBuffers);  		}  		if (ProcessedBuffers >= 32)  			UnderRun = true;  		else  			UnderRun = false;  		while (ProcessedBuffers > 0) {  			OggBufferSegment obs;  			lock (OALLocker) {  				AL.SourceUnqueueBuffers (m_Source' 1' ref BufferRef);  				if (ReachedEOF) {  					--ProcessedBuffers;  					continue;  				}  				// If we're at the EOF loop to the next buffer here - we don't want to be trying to fill any more  				obs = m_CurrentFile.GetBufferSegment (m_BufferSize);  				// Get chunk of tasty buffer data with the configured segment  			}  			if (obs.ReturnValue > 0) {  				lock (OALLocker) {  					AL.BufferData ((int)BufferRef' m_CurrentFile.Format' obs.Buffer' obs.ReturnValue' obs.RateHz);  					AL.SourceQueueBuffers (m_Source' 1' ref BufferRef);  				}  			}  			else {  				if (obs.ReturnValue == 0) {  					ReachedEOF = true;  					break;  				}  				else {  					lock (OALLocker) {  						m_PlayerState = OggPlayerStatus.Error;  						AL.SourceStop (m_Source);  						Running = false;  					}  					break;  				}  			}  			if (AL.GetError () != ALError.NoError) {  				StateChange (OggPlayerStatus.Error' OggPlayerStateChanger.Error);  				lock (OALLocker) {  					AL.SourceStop (m_Source);  				}  				Running = false;  				break;  			}  			--ProcessedBuffers;  		}  		if (UnderRun) {  			lock (OALLocker) {  				AL.SourcePlay (m_Source);  			}  		}  	}  	else if (m_PlayerState == OggPlayerStatus.Paused) {  	}  	else {  		Running = false;  	}  	Thread.Sleep (10);  }  
Magic Number,Tachycardia.Sound.BGM,OggPlayer,C:\repos\secred_Tachycardia\src\Sound\Audio\OggPlayer.cs,PlayThread,The following statement contains a magic number: while (Running) {  	if (m_PlayerState == OggPlayerStatus.Playing) {  		int QueuedBuffers = 0;  		AL.GetSource (m_Source' ALGetSourcei.BuffersQueued' out QueuedBuffers);  		if (ReachedEOF) {  			if (QueuedBuffers > 0) {  			}  			else {  				lock (OALLocker) {  					Running = false;  					if (AL.GetSourceState (m_Source) != ALSourceState.Stopped) {  						AL.SourceStop (m_Source);  					}  					m_CurrentFile.ResetFile ();  					for (int i = 0; i < m_Buffers.Length; i++) {  						AL.DeleteBuffer (ref m_Buffers [i]);  					}  					m_Buffers = new uint[32];  				}  				StateChange (OggPlayerStatus.Stopped' OggPlayerStateChanger.EndOfFile);  				return;  			}  		}  		if ((!ReachedEOF) && (QueuedBuffers > 0) && (AL.GetError () == ALError.NoError))  			if (AL.GetSourceState (m_Source) != ALSourceState.Playing)  				AL.SourcePlay (m_Source);  		int ProcessedBuffers = 0;  		uint BufferRef = 0;  		lock (OALLocker) {  			AL.GetSource (m_Source' ALGetSourcei.BuffersProcessed' out ProcessedBuffers);  		}  		if (ProcessedBuffers >= 32)  			UnderRun = true;  		else  			UnderRun = false;  		while (ProcessedBuffers > 0) {  			OggBufferSegment obs;  			lock (OALLocker) {  				AL.SourceUnqueueBuffers (m_Source' 1' ref BufferRef);  				if (ReachedEOF) {  					--ProcessedBuffers;  					continue;  				}  				// If we're at the EOF loop to the next buffer here - we don't want to be trying to fill any more  				obs = m_CurrentFile.GetBufferSegment (m_BufferSize);  				// Get chunk of tasty buffer data with the configured segment  			}  			if (obs.ReturnValue > 0) {  				lock (OALLocker) {  					AL.BufferData ((int)BufferRef' m_CurrentFile.Format' obs.Buffer' obs.ReturnValue' obs.RateHz);  					AL.SourceQueueBuffers (m_Source' 1' ref BufferRef);  				}  			}  			else {  				if (obs.ReturnValue == 0) {  					ReachedEOF = true;  					break;  				}  				else {  					lock (OALLocker) {  						m_PlayerState = OggPlayerStatus.Error;  						AL.SourceStop (m_Source);  						Running = false;  					}  					break;  				}  			}  			if (AL.GetError () != ALError.NoError) {  				StateChange (OggPlayerStatus.Error' OggPlayerStateChanger.Error);  				lock (OALLocker) {  					AL.SourceStop (m_Source);  				}  				Running = false;  				break;  			}  			--ProcessedBuffers;  		}  		if (UnderRun) {  			lock (OALLocker) {  				AL.SourcePlay (m_Source);  			}  		}  	}  	else if (m_PlayerState == OggPlayerStatus.Paused) {  	}  	else {  		Running = false;  	}  	Thread.Sleep (10);  }  
Magic Number,Tachycardia.Sound.BGM,OggPlayer,C:\repos\secred_Tachycardia\src\Sound\Audio\OggPlayer.cs,PlayThread,The following statement contains a magic number: if (m_PlayerState == OggPlayerStatus.Playing) {  	int QueuedBuffers = 0;  	AL.GetSource (m_Source' ALGetSourcei.BuffersQueued' out QueuedBuffers);  	if (ReachedEOF) {  		if (QueuedBuffers > 0) {  		}  		else {  			lock (OALLocker) {  				Running = false;  				if (AL.GetSourceState (m_Source) != ALSourceState.Stopped) {  					AL.SourceStop (m_Source);  				}  				m_CurrentFile.ResetFile ();  				for (int i = 0; i < m_Buffers.Length; i++) {  					AL.DeleteBuffer (ref m_Buffers [i]);  				}  				m_Buffers = new uint[32];  			}  			StateChange (OggPlayerStatus.Stopped' OggPlayerStateChanger.EndOfFile);  			return;  		}  	}  	if ((!ReachedEOF) && (QueuedBuffers > 0) && (AL.GetError () == ALError.NoError))  		if (AL.GetSourceState (m_Source) != ALSourceState.Playing)  			AL.SourcePlay (m_Source);  	int ProcessedBuffers = 0;  	uint BufferRef = 0;  	lock (OALLocker) {  		AL.GetSource (m_Source' ALGetSourcei.BuffersProcessed' out ProcessedBuffers);  	}  	if (ProcessedBuffers >= 32)  		UnderRun = true;  	else  		UnderRun = false;  	while (ProcessedBuffers > 0) {  		OggBufferSegment obs;  		lock (OALLocker) {  			AL.SourceUnqueueBuffers (m_Source' 1' ref BufferRef);  			if (ReachedEOF) {  				--ProcessedBuffers;  				continue;  			}  			// If we're at the EOF loop to the next buffer here - we don't want to be trying to fill any more  			obs = m_CurrentFile.GetBufferSegment (m_BufferSize);  			// Get chunk of tasty buffer data with the configured segment  		}  		if (obs.ReturnValue > 0) {  			lock (OALLocker) {  				AL.BufferData ((int)BufferRef' m_CurrentFile.Format' obs.Buffer' obs.ReturnValue' obs.RateHz);  				AL.SourceQueueBuffers (m_Source' 1' ref BufferRef);  			}  		}  		else {  			if (obs.ReturnValue == 0) {  				ReachedEOF = true;  				break;  			}  			else {  				lock (OALLocker) {  					m_PlayerState = OggPlayerStatus.Error;  					AL.SourceStop (m_Source);  					Running = false;  				}  				break;  			}  		}  		if (AL.GetError () != ALError.NoError) {  			StateChange (OggPlayerStatus.Error' OggPlayerStateChanger.Error);  			lock (OALLocker) {  				AL.SourceStop (m_Source);  			}  			Running = false;  			break;  		}  		--ProcessedBuffers;  	}  	if (UnderRun) {  		lock (OALLocker) {  			AL.SourcePlay (m_Source);  		}  	}  }  else if (m_PlayerState == OggPlayerStatus.Paused) {  }  else {  	Running = false;  }  
Magic Number,Tachycardia.Sound.BGM,OggPlayer,C:\repos\secred_Tachycardia\src\Sound\Audio\OggPlayer.cs,PlayThread,The following statement contains a magic number: if (m_PlayerState == OggPlayerStatus.Playing) {  	int QueuedBuffers = 0;  	AL.GetSource (m_Source' ALGetSourcei.BuffersQueued' out QueuedBuffers);  	if (ReachedEOF) {  		if (QueuedBuffers > 0) {  		}  		else {  			lock (OALLocker) {  				Running = false;  				if (AL.GetSourceState (m_Source) != ALSourceState.Stopped) {  					AL.SourceStop (m_Source);  				}  				m_CurrentFile.ResetFile ();  				for (int i = 0; i < m_Buffers.Length; i++) {  					AL.DeleteBuffer (ref m_Buffers [i]);  				}  				m_Buffers = new uint[32];  			}  			StateChange (OggPlayerStatus.Stopped' OggPlayerStateChanger.EndOfFile);  			return;  		}  	}  	if ((!ReachedEOF) && (QueuedBuffers > 0) && (AL.GetError () == ALError.NoError))  		if (AL.GetSourceState (m_Source) != ALSourceState.Playing)  			AL.SourcePlay (m_Source);  	int ProcessedBuffers = 0;  	uint BufferRef = 0;  	lock (OALLocker) {  		AL.GetSource (m_Source' ALGetSourcei.BuffersProcessed' out ProcessedBuffers);  	}  	if (ProcessedBuffers >= 32)  		UnderRun = true;  	else  		UnderRun = false;  	while (ProcessedBuffers > 0) {  		OggBufferSegment obs;  		lock (OALLocker) {  			AL.SourceUnqueueBuffers (m_Source' 1' ref BufferRef);  			if (ReachedEOF) {  				--ProcessedBuffers;  				continue;  			}  			// If we're at the EOF loop to the next buffer here - we don't want to be trying to fill any more  			obs = m_CurrentFile.GetBufferSegment (m_BufferSize);  			// Get chunk of tasty buffer data with the configured segment  		}  		if (obs.ReturnValue > 0) {  			lock (OALLocker) {  				AL.BufferData ((int)BufferRef' m_CurrentFile.Format' obs.Buffer' obs.ReturnValue' obs.RateHz);  				AL.SourceQueueBuffers (m_Source' 1' ref BufferRef);  			}  		}  		else {  			if (obs.ReturnValue == 0) {  				ReachedEOF = true;  				break;  			}  			else {  				lock (OALLocker) {  					m_PlayerState = OggPlayerStatus.Error;  					AL.SourceStop (m_Source);  					Running = false;  				}  				break;  			}  		}  		if (AL.GetError () != ALError.NoError) {  			StateChange (OggPlayerStatus.Error' OggPlayerStateChanger.Error);  			lock (OALLocker) {  				AL.SourceStop (m_Source);  			}  			Running = false;  			break;  		}  		--ProcessedBuffers;  	}  	if (UnderRun) {  		lock (OALLocker) {  			AL.SourcePlay (m_Source);  		}  	}  }  else if (m_PlayerState == OggPlayerStatus.Paused) {  }  else {  	Running = false;  }  
Magic Number,Tachycardia.Sound.BGM,OggPlayer,C:\repos\secred_Tachycardia\src\Sound\Audio\OggPlayer.cs,PlayThread,The following statement contains a magic number: if (ReachedEOF) {  	if (QueuedBuffers > 0) {  	}  	else {  		lock (OALLocker) {  			Running = false;  			if (AL.GetSourceState (m_Source) != ALSourceState.Stopped) {  				AL.SourceStop (m_Source);  			}  			m_CurrentFile.ResetFile ();  			for (int i = 0; i < m_Buffers.Length; i++) {  				AL.DeleteBuffer (ref m_Buffers [i]);  			}  			m_Buffers = new uint[32];  		}  		StateChange (OggPlayerStatus.Stopped' OggPlayerStateChanger.EndOfFile);  		return;  	}  }  
Magic Number,Tachycardia.Sound.BGM,OggPlayer,C:\repos\secred_Tachycardia\src\Sound\Audio\OggPlayer.cs,PlayThread,The following statement contains a magic number: if (QueuedBuffers > 0) {  }  else {  	lock (OALLocker) {  		Running = false;  		if (AL.GetSourceState (m_Source) != ALSourceState.Stopped) {  			AL.SourceStop (m_Source);  		}  		m_CurrentFile.ResetFile ();  		for (int i = 0; i < m_Buffers.Length; i++) {  			AL.DeleteBuffer (ref m_Buffers [i]);  		}  		m_Buffers = new uint[32];  	}  	StateChange (OggPlayerStatus.Stopped' OggPlayerStateChanger.EndOfFile);  	return;  }  
Magic Number,Tachycardia.Sound.BGM,OggPlayer,C:\repos\secred_Tachycardia\src\Sound\Audio\OggPlayer.cs,PlayThread,The following statement contains a magic number: lock (OALLocker) {  	Running = false;  	if (AL.GetSourceState (m_Source) != ALSourceState.Stopped) {  		AL.SourceStop (m_Source);  	}  	m_CurrentFile.ResetFile ();  	for (int i = 0; i < m_Buffers.Length; i++) {  		AL.DeleteBuffer (ref m_Buffers [i]);  	}  	m_Buffers = new uint[32];  }  
Magic Number,Tachycardia.Sound.BGM,OggPlayer,C:\repos\secred_Tachycardia\src\Sound\Audio\OggPlayer.cs,PlayThread,The following statement contains a magic number: m_Buffers = new uint[32];  
Magic Number,Tachycardia.Sound.BGM,OggPlayer,C:\repos\secred_Tachycardia\src\Sound\Audio\OggPlayer.cs,PlayThread,The following statement contains a magic number: if (ProcessedBuffers >= 32)  	UnderRun = true;  else  	UnderRun = false;  
Magic Number,Tachycardia.Sound.BGM,OggPlayer,C:\repos\secred_Tachycardia\src\Sound\Audio\OggPlayer.cs,PlayThread,The following statement contains a magic number: Thread.Sleep (10);  
Magic Number,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,Listener,The following statement contains a magic number: temp [2] = at.z;  
Magic Number,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,Listener,The following statement contains a magic number: temp [3] = up.x;  
Magic Number,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,Listener,The following statement contains a magic number: temp [4] = up.y;  
Magic Number,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,Listener,The following statement contains a magic number: temp [5] = up.z;  
Magic Number,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,GetListener,The following statement contains a magic number: unsafe {  	fixed (float* ptr = &pinned [0]) {  		GetListener (param' ptr);  		at.x = pinned [0];  		at.y = pinned [1];  		at.z = pinned [2];  		up.x = pinned [3];  		up.y = pinned [4];  		up.z = pinned [5];  	}  }  
Magic Number,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,GetListener,The following statement contains a magic number: unsafe {  	fixed (float* ptr = &pinned [0]) {  		GetListener (param' ptr);  		at.x = pinned [0];  		at.y = pinned [1];  		at.z = pinned [2];  		up.x = pinned [3];  		up.y = pinned [4];  		up.z = pinned [5];  	}  }  
Magic Number,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,GetListener,The following statement contains a magic number: unsafe {  	fixed (float* ptr = &pinned [0]) {  		GetListener (param' ptr);  		at.x = pinned [0];  		at.y = pinned [1];  		at.z = pinned [2];  		up.x = pinned [3];  		up.y = pinned [4];  		up.z = pinned [5];  	}  }  
Magic Number,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,GetListener,The following statement contains a magic number: unsafe {  	fixed (float* ptr = &pinned [0]) {  		GetListener (param' ptr);  		at.x = pinned [0];  		at.y = pinned [1];  		at.z = pinned [2];  		up.x = pinned [3];  		up.y = pinned [4];  		up.z = pinned [5];  	}  }  
Magic Number,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,GetListener,The following statement contains a magic number: fixed (float* ptr = &pinned [0]) {  	GetListener (param' ptr);  	at.x = pinned [0];  	at.y = pinned [1];  	at.z = pinned [2];  	up.x = pinned [3];  	up.y = pinned [4];  	up.z = pinned [5];  }  
Magic Number,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,GetListener,The following statement contains a magic number: fixed (float* ptr = &pinned [0]) {  	GetListener (param' ptr);  	at.x = pinned [0];  	at.y = pinned [1];  	at.z = pinned [2];  	up.x = pinned [3];  	up.y = pinned [4];  	up.z = pinned [5];  }  
Magic Number,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,GetListener,The following statement contains a magic number: fixed (float* ptr = &pinned [0]) {  	GetListener (param' ptr);  	at.x = pinned [0];  	at.y = pinned [1];  	at.z = pinned [2];  	up.x = pinned [3];  	up.y = pinned [4];  	up.z = pinned [5];  }  
Magic Number,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,GetListener,The following statement contains a magic number: fixed (float* ptr = &pinned [0]) {  	GetListener (param' ptr);  	at.x = pinned [0];  	at.y = pinned [1];  	at.z = pinned [2];  	up.x = pinned [3];  	up.y = pinned [4];  	up.z = pinned [5];  }  
Magic Number,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,GetListener,The following statement contains a magic number: at.z = pinned [2];  
Magic Number,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,GetListener,The following statement contains a magic number: up.x = pinned [3];  
Magic Number,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,GetListener,The following statement contains a magic number: up.y = pinned [4];  
Magic Number,OpenTK.Audio.OpenAL,AL,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\AL.cs,GetListener,The following statement contains a magic number: up.z = pinned [5];  
Magic Number,OpenTK.Audio.OpenAL,EffectsExtension,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\EffectsExtension.cs,GetEffect,The following statement contains a magic number: unsafe {  	fixed (float* ptr = &values.x) {  		Imported_alGetEffectfv (eid' param' ptr);  		values.x = ptr [0];  		values.y = ptr [1];  		values.z = ptr [2];  	}  }  
Magic Number,OpenTK.Audio.OpenAL,EffectsExtension,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\EffectsExtension.cs,GetEffect,The following statement contains a magic number: fixed (float* ptr = &values.x) {  	Imported_alGetEffectfv (eid' param' ptr);  	values.x = ptr [0];  	values.y = ptr [1];  	values.z = ptr [2];  }  
Magic Number,OpenTK.Audio.OpenAL,EffectsExtension,C:\repos\secred_Tachycardia\src\Sound\Audio\OpenAL\AL\EffectsExtension.cs,GetEffect,The following statement contains a magic number: values.z = ptr [2];  
Magic Number,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,Find,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  	last_occurrence [i] = pattern.Count;  
Magic Number,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,RFind,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  	first_occurrence [i] = pattern.Count;  
Magic Number,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,ToUInt,The following statement contains a magic number: for (int i = 0; i <= last; i++) {  	int offset = mostSignificantByteFirst ? last - i : i;  	sum |= (uint)this [i] << (offset * 8);  }  
Magic Number,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,ToUInt,The following statement contains a magic number: sum |= (uint)this [i] << (offset * 8);  
Magic Number,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,ToUShort,The following statement contains a magic number: for (int i = 0; i <= last; i++) {  	int offset = mostSignificantByteFirst ? last - i : i;  	sum |= (ushort)(this [i] << (offset * 8));  }  
Magic Number,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,ToUShort,The following statement contains a magic number: sum |= (ushort)(this [i] << (offset * 8));  
Magic Number,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,ToULong,The following statement contains a magic number: for (int i = 0; i <= last; i++) {  	int offset = mostSignificantByteFirst ? last - i : i;  	sum |= (ulong)this [i] << (offset * 8);  }  
Magic Number,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,ToULong,The following statement contains a magic number: sum |= (ulong)this [i] << (offset * 8);  
Magic Number,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,FromUInt,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int offset = mostSignificantByteFirst ? 3 - i : i;  	vector.Add ((byte)(value >> (offset * 8) & 0xFF));  }  
Magic Number,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,FromUInt,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int offset = mostSignificantByteFirst ? 3 - i : i;  	vector.Add ((byte)(value >> (offset * 8) & 0xFF));  }  
Magic Number,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,FromUInt,The following statement contains a magic number: for (int i = 0; i < 4; i++) {  	int offset = mostSignificantByteFirst ? 3 - i : i;  	vector.Add ((byte)(value >> (offset * 8) & 0xFF));  }  
Magic Number,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,FromUInt,The following statement contains a magic number: vector.Add ((byte)(value >> (offset * 8) & 0xFF));  
Magic Number,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,FromUShort,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	int offset = mostSignificantByteFirst ? 1 - i : i;  	vector.Add ((byte)(value >> (offset * 8) & 0xFF));  }  
Magic Number,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,FromUShort,The following statement contains a magic number: for (int i = 0; i < 2; i++) {  	int offset = mostSignificantByteFirst ? 1 - i : i;  	vector.Add ((byte)(value >> (offset * 8) & 0xFF));  }  
Magic Number,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,FromUShort,The following statement contains a magic number: vector.Add ((byte)(value >> (offset * 8) & 0xFF));  
Magic Number,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,FromULong,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int offset = mostSignificantByteFirst ? 7 - i : i;  	vector.Add ((byte)(value >> (offset * 8) & 0xFF));  }  
Magic Number,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,FromULong,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int offset = mostSignificantByteFirst ? 7 - i : i;  	vector.Add ((byte)(value >> (offset * 8) & 0xFF));  }  
Magic Number,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,FromULong,The following statement contains a magic number: for (int i = 0; i < 8; i++) {  	int offset = mostSignificantByteFirst ? 7 - i : i;  	vector.Add ((byte)(value >> (offset * 8) & 0xFF));  }  
Magic Number,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,FromULong,The following statement contains a magic number: vector.Add ((byte)(value >> (offset * 8) & 0xFF));  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,Render,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	data [i + 22] = checksum [i];  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,Render,The following statement contains a magic number: for (int i = 0; i < 4; i++)  	data [i + 22] = checksum [i];  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,Render,The following statement contains a magic number: data [i + 22] = checksum [i];  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: while (position < file.Length - 27) {  	PageHeader header = new PageHeader (file' position);  	int size = (int)(header.Size + header.DataSize);  	if (shiftTable.ContainsKey (header.StreamSerialNumber) && shiftTable [header.StreamSerialNumber] != 0) {  		file.Seek (position);  		ByteVector page_data = file.ReadBlock (size);  		ByteVector new_data = ByteVector.FromUInt ((uint)(header.PageSequenceNumber + shiftTable [header.StreamSerialNumber])' false);  		for (int i = 18; i < 22; i++)  			page_data [i] = new_data [i - 18];  		for (int i = 22; i < 26; i++)  			page_data [i] = 0;  		new_data.Add (ByteVector.FromUInt (page_data.Checksum' false));  		file.Seek (position + 18);  		file.WriteBlock (new_data);  	}  	position += size;  }  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: while (position < file.Length - 27) {  	PageHeader header = new PageHeader (file' position);  	int size = (int)(header.Size + header.DataSize);  	if (shiftTable.ContainsKey (header.StreamSerialNumber) && shiftTable [header.StreamSerialNumber] != 0) {  		file.Seek (position);  		ByteVector page_data = file.ReadBlock (size);  		ByteVector new_data = ByteVector.FromUInt ((uint)(header.PageSequenceNumber + shiftTable [header.StreamSerialNumber])' false);  		for (int i = 18; i < 22; i++)  			page_data [i] = new_data [i - 18];  		for (int i = 22; i < 26; i++)  			page_data [i] = 0;  		new_data.Add (ByteVector.FromUInt (page_data.Checksum' false));  		file.Seek (position + 18);  		file.WriteBlock (new_data);  	}  	position += size;  }  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: while (position < file.Length - 27) {  	PageHeader header = new PageHeader (file' position);  	int size = (int)(header.Size + header.DataSize);  	if (shiftTable.ContainsKey (header.StreamSerialNumber) && shiftTable [header.StreamSerialNumber] != 0) {  		file.Seek (position);  		ByteVector page_data = file.ReadBlock (size);  		ByteVector new_data = ByteVector.FromUInt ((uint)(header.PageSequenceNumber + shiftTable [header.StreamSerialNumber])' false);  		for (int i = 18; i < 22; i++)  			page_data [i] = new_data [i - 18];  		for (int i = 22; i < 26; i++)  			page_data [i] = 0;  		new_data.Add (ByteVector.FromUInt (page_data.Checksum' false));  		file.Seek (position + 18);  		file.WriteBlock (new_data);  	}  	position += size;  }  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: while (position < file.Length - 27) {  	PageHeader header = new PageHeader (file' position);  	int size = (int)(header.Size + header.DataSize);  	if (shiftTable.ContainsKey (header.StreamSerialNumber) && shiftTable [header.StreamSerialNumber] != 0) {  		file.Seek (position);  		ByteVector page_data = file.ReadBlock (size);  		ByteVector new_data = ByteVector.FromUInt ((uint)(header.PageSequenceNumber + shiftTable [header.StreamSerialNumber])' false);  		for (int i = 18; i < 22; i++)  			page_data [i] = new_data [i - 18];  		for (int i = 22; i < 26; i++)  			page_data [i] = 0;  		new_data.Add (ByteVector.FromUInt (page_data.Checksum' false));  		file.Seek (position + 18);  		file.WriteBlock (new_data);  	}  	position += size;  }  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: while (position < file.Length - 27) {  	PageHeader header = new PageHeader (file' position);  	int size = (int)(header.Size + header.DataSize);  	if (shiftTable.ContainsKey (header.StreamSerialNumber) && shiftTable [header.StreamSerialNumber] != 0) {  		file.Seek (position);  		ByteVector page_data = file.ReadBlock (size);  		ByteVector new_data = ByteVector.FromUInt ((uint)(header.PageSequenceNumber + shiftTable [header.StreamSerialNumber])' false);  		for (int i = 18; i < 22; i++)  			page_data [i] = new_data [i - 18];  		for (int i = 22; i < 26; i++)  			page_data [i] = 0;  		new_data.Add (ByteVector.FromUInt (page_data.Checksum' false));  		file.Seek (position + 18);  		file.WriteBlock (new_data);  	}  	position += size;  }  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: while (position < file.Length - 27) {  	PageHeader header = new PageHeader (file' position);  	int size = (int)(header.Size + header.DataSize);  	if (shiftTable.ContainsKey (header.StreamSerialNumber) && shiftTable [header.StreamSerialNumber] != 0) {  		file.Seek (position);  		ByteVector page_data = file.ReadBlock (size);  		ByteVector new_data = ByteVector.FromUInt ((uint)(header.PageSequenceNumber + shiftTable [header.StreamSerialNumber])' false);  		for (int i = 18; i < 22; i++)  			page_data [i] = new_data [i - 18];  		for (int i = 22; i < 26; i++)  			page_data [i] = 0;  		new_data.Add (ByteVector.FromUInt (page_data.Checksum' false));  		file.Seek (position + 18);  		file.WriteBlock (new_data);  	}  	position += size;  }  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: while (position < file.Length - 27) {  	PageHeader header = new PageHeader (file' position);  	int size = (int)(header.Size + header.DataSize);  	if (shiftTable.ContainsKey (header.StreamSerialNumber) && shiftTable [header.StreamSerialNumber] != 0) {  		file.Seek (position);  		ByteVector page_data = file.ReadBlock (size);  		ByteVector new_data = ByteVector.FromUInt ((uint)(header.PageSequenceNumber + shiftTable [header.StreamSerialNumber])' false);  		for (int i = 18; i < 22; i++)  			page_data [i] = new_data [i - 18];  		for (int i = 22; i < 26; i++)  			page_data [i] = 0;  		new_data.Add (ByteVector.FromUInt (page_data.Checksum' false));  		file.Seek (position + 18);  		file.WriteBlock (new_data);  	}  	position += size;  }  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: if (shiftTable.ContainsKey (header.StreamSerialNumber) && shiftTable [header.StreamSerialNumber] != 0) {  	file.Seek (position);  	ByteVector page_data = file.ReadBlock (size);  	ByteVector new_data = ByteVector.FromUInt ((uint)(header.PageSequenceNumber + shiftTable [header.StreamSerialNumber])' false);  	for (int i = 18; i < 22; i++)  		page_data [i] = new_data [i - 18];  	for (int i = 22; i < 26; i++)  		page_data [i] = 0;  	new_data.Add (ByteVector.FromUInt (page_data.Checksum' false));  	file.Seek (position + 18);  	file.WriteBlock (new_data);  }  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: if (shiftTable.ContainsKey (header.StreamSerialNumber) && shiftTable [header.StreamSerialNumber] != 0) {  	file.Seek (position);  	ByteVector page_data = file.ReadBlock (size);  	ByteVector new_data = ByteVector.FromUInt ((uint)(header.PageSequenceNumber + shiftTable [header.StreamSerialNumber])' false);  	for (int i = 18; i < 22; i++)  		page_data [i] = new_data [i - 18];  	for (int i = 22; i < 26; i++)  		page_data [i] = 0;  	new_data.Add (ByteVector.FromUInt (page_data.Checksum' false));  	file.Seek (position + 18);  	file.WriteBlock (new_data);  }  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: if (shiftTable.ContainsKey (header.StreamSerialNumber) && shiftTable [header.StreamSerialNumber] != 0) {  	file.Seek (position);  	ByteVector page_data = file.ReadBlock (size);  	ByteVector new_data = ByteVector.FromUInt ((uint)(header.PageSequenceNumber + shiftTable [header.StreamSerialNumber])' false);  	for (int i = 18; i < 22; i++)  		page_data [i] = new_data [i - 18];  	for (int i = 22; i < 26; i++)  		page_data [i] = 0;  	new_data.Add (ByteVector.FromUInt (page_data.Checksum' false));  	file.Seek (position + 18);  	file.WriteBlock (new_data);  }  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: if (shiftTable.ContainsKey (header.StreamSerialNumber) && shiftTable [header.StreamSerialNumber] != 0) {  	file.Seek (position);  	ByteVector page_data = file.ReadBlock (size);  	ByteVector new_data = ByteVector.FromUInt ((uint)(header.PageSequenceNumber + shiftTable [header.StreamSerialNumber])' false);  	for (int i = 18; i < 22; i++)  		page_data [i] = new_data [i - 18];  	for (int i = 22; i < 26; i++)  		page_data [i] = 0;  	new_data.Add (ByteVector.FromUInt (page_data.Checksum' false));  	file.Seek (position + 18);  	file.WriteBlock (new_data);  }  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: if (shiftTable.ContainsKey (header.StreamSerialNumber) && shiftTable [header.StreamSerialNumber] != 0) {  	file.Seek (position);  	ByteVector page_data = file.ReadBlock (size);  	ByteVector new_data = ByteVector.FromUInt ((uint)(header.PageSequenceNumber + shiftTable [header.StreamSerialNumber])' false);  	for (int i = 18; i < 22; i++)  		page_data [i] = new_data [i - 18];  	for (int i = 22; i < 26; i++)  		page_data [i] = 0;  	new_data.Add (ByteVector.FromUInt (page_data.Checksum' false));  	file.Seek (position + 18);  	file.WriteBlock (new_data);  }  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: if (shiftTable.ContainsKey (header.StreamSerialNumber) && shiftTable [header.StreamSerialNumber] != 0) {  	file.Seek (position);  	ByteVector page_data = file.ReadBlock (size);  	ByteVector new_data = ByteVector.FromUInt ((uint)(header.PageSequenceNumber + shiftTable [header.StreamSerialNumber])' false);  	for (int i = 18; i < 22; i++)  		page_data [i] = new_data [i - 18];  	for (int i = 22; i < 26; i++)  		page_data [i] = 0;  	new_data.Add (ByteVector.FromUInt (page_data.Checksum' false));  	file.Seek (position + 18);  	file.WriteBlock (new_data);  }  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: for (int i = 18; i < 22; i++)  	page_data [i] = new_data [i - 18];  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: for (int i = 18; i < 22; i++)  	page_data [i] = new_data [i - 18];  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: for (int i = 18; i < 22; i++)  	page_data [i] = new_data [i - 18];  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: page_data [i] = new_data [i - 18];  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: for (int i = 22; i < 26; i++)  	page_data [i] = 0;  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: for (int i = 22; i < 26; i++)  	page_data [i] = 0;  
Magic Number,TagLib.Ogg,Page,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Page.cs,OverwriteSequenceNumbers,The following statement contains a magic number: file.Seek (position + 18);  
Magic Number,TagLib.Ogg,PageHeader,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: if (position < 0 || position > file.Length - 27)  	throw new ArgumentOutOfRangeException ("position");  
Magic Number,TagLib.Ogg,PageHeader,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: if (data.Count < 27 || !data.StartsWith ("OggS"))  	System.Console.WriteLine ("Error reading page header");  
Magic Number,TagLib.Ogg,PageHeader,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: version = data [4];  
Magic Number,TagLib.Ogg,PageHeader,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: this.flags = (PageFlags)data [5];  
Magic Number,TagLib.Ogg,PageHeader,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: absolute_granular_position = data.Mid (6' 8).ToULong (false);  
Magic Number,TagLib.Ogg,PageHeader,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: absolute_granular_position = data.Mid (6' 8).ToULong (false);  
Magic Number,TagLib.Ogg,PageHeader,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: stream_serial_number = data.Mid (14' 4).ToUInt (false);  
Magic Number,TagLib.Ogg,PageHeader,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: stream_serial_number = data.Mid (14' 4).ToUInt (false);  
Magic Number,TagLib.Ogg,PageHeader,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: page_sequence_number = data.Mid (18' 4).ToUInt (false);  
Magic Number,TagLib.Ogg,PageHeader,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: page_sequence_number = data.Mid (18' 4).ToUInt (false);  
Magic Number,TagLib.Ogg,PageHeader,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: size = (uint)(27 + page_segment_count);  
Magic Number,TagLib.Ogg,PageHeader,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: for (int i = 0; i < page_segment_count; i++) {  	data_size += page_segments [i];  	packet_size += page_segments [i];  	if (page_segments [i] < 255) {  		packet_sizes.Add (packet_size);  		packet_size = 0;  	}  }  
Magic Number,TagLib.Ogg,PageHeader,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\PageHeader.cs,PageHeader,The following statement contains a magic number: if (page_segments [i] < 255) {  	packet_sizes.Add (packet_size);  	packet_size = 0;  }  
Magic Number,TagLib.Ogg,PageHeader,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\PageHeader.cs,Render,The following statement contains a magic number: data.Add (new ByteVector (4' 0));  
Magic Number,TagLib.Ogg.Codecs,Theora,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Codecs\Theora.cs,ReadPacket,The following statement contains a magic number: if (comment_data == null) {  	if (type == 0x80)  		header = new HeaderPacket (packet);  	else if (type == 0x81)  		comment_data = packet.Mid (7);  	else  		return true;  }  
Magic Number,TagLib.Ogg.Codecs,Theora,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Codecs\Theora.cs,ReadPacket,The following statement contains a magic number: if (type == 0x80)  	header = new HeaderPacket (packet);  else if (type == 0x81)  	comment_data = packet.Mid (7);  else  	return true;  
Magic Number,TagLib.Ogg.Codecs,Theora,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Codecs\Theora.cs,ReadPacket,The following statement contains a magic number: if (type == 0x81)  	comment_data = packet.Mid (7);  else  	return true;  
Magic Number,TagLib.Ogg.Codecs,Theora,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Codecs\Theora.cs,ReadPacket,The following statement contains a magic number: comment_data = packet.Mid (7);  
Magic Number,TagLib.Ogg.Codecs,Vorbis,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Codecs\Vorbis.cs,ReadPacket,The following statement contains a magic number: if (comment_data == null) {  	if (type == 1)  		header = new HeaderPacket (packet);  	else if (type == 3)  		comment_data = packet.Mid (7);  	else  		return true;  }  
Magic Number,TagLib.Ogg.Codecs,Vorbis,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Codecs\Vorbis.cs,ReadPacket,The following statement contains a magic number: if (comment_data == null) {  	if (type == 1)  		header = new HeaderPacket (packet);  	else if (type == 3)  		comment_data = packet.Mid (7);  	else  		return true;  }  
Magic Number,TagLib.Ogg.Codecs,Vorbis,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Codecs\Vorbis.cs,ReadPacket,The following statement contains a magic number: if (type == 1)  	header = new HeaderPacket (packet);  else if (type == 3)  	comment_data = packet.Mid (7);  else  	return true;  
Magic Number,TagLib.Ogg.Codecs,Vorbis,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Codecs\Vorbis.cs,ReadPacket,The following statement contains a magic number: if (type == 1)  	header = new HeaderPacket (packet);  else if (type == 3)  	comment_data = packet.Mid (7);  else  	return true;  
Magic Number,TagLib.Ogg.Codecs,Vorbis,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Codecs\Vorbis.cs,ReadPacket,The following statement contains a magic number: if (type == 3)  	comment_data = packet.Mid (7);  else  	return true;  
Magic Number,TagLib.Ogg.Codecs,Vorbis,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Codecs\Vorbis.cs,ReadPacket,The following statement contains a magic number: if (type == 3)  	comment_data = packet.Mid (7);  else  	return true;  
Magic Number,TagLib.Ogg.Codecs,Vorbis,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\Ogg\Codecs\Vorbis.cs,ReadPacket,The following statement contains a magic number: comment_data = packet.Mid (7);  
Magic Number,Tachycardia.Sound,SoundDict,C:\repos\secred_Tachycardia\src\Sound\SoundDict.cs,SoundDict,The following statement contains a magic number: m_channels = 8;  
Magic Number,Tachycardia.Sound,SoundDict,C:\repos\secred_Tachycardia\src\Sound\SoundDict.cs,LoadWave,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader (stream)) {  	// RIFF header  	string signature = new string (reader.ReadChars (4));  	if (signature != "RIFF")  		throw new NotSupportedException ("Specified stream is not a wave file.");  	int riff_chunck_size = reader.ReadInt32 ();  	string format = new string (reader.ReadChars (4));  	if (format != "WAVE")  		throw new NotSupportedException ("Specified stream is not a wave file.");  	// WAVE header  	string format_signature = new string (reader.ReadChars (4));  	if (format_signature != "fmt ")  		throw new NotSupportedException ("Specified wave file is not supported.");  	int format_chunk_size = reader.ReadInt32 ();  	int audio_format = reader.ReadInt16 ();  	int num_channels = reader.ReadInt16 ();  	int sample_rate = reader.ReadInt32 ();  	int byte_rate = reader.ReadInt32 ();  	int block_align = reader.ReadInt16 ();  	int bits_per_sample = reader.ReadInt16 ();  	string data_signature = new string (reader.ReadChars (4));  	if (data_signature != "data")  		throw new NotSupportedException ("Specified wave file is not supported.");  	int data_chunk_size = reader.ReadInt32 ();  	channels = num_channels;  	bits = bits_per_sample;  	rate = sample_rate;  	return reader.ReadBytes ((int)reader.BaseStream.Length);  }  
Magic Number,Tachycardia.Sound,SoundDict,C:\repos\secred_Tachycardia\src\Sound\SoundDict.cs,LoadWave,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader (stream)) {  	// RIFF header  	string signature = new string (reader.ReadChars (4));  	if (signature != "RIFF")  		throw new NotSupportedException ("Specified stream is not a wave file.");  	int riff_chunck_size = reader.ReadInt32 ();  	string format = new string (reader.ReadChars (4));  	if (format != "WAVE")  		throw new NotSupportedException ("Specified stream is not a wave file.");  	// WAVE header  	string format_signature = new string (reader.ReadChars (4));  	if (format_signature != "fmt ")  		throw new NotSupportedException ("Specified wave file is not supported.");  	int format_chunk_size = reader.ReadInt32 ();  	int audio_format = reader.ReadInt16 ();  	int num_channels = reader.ReadInt16 ();  	int sample_rate = reader.ReadInt32 ();  	int byte_rate = reader.ReadInt32 ();  	int block_align = reader.ReadInt16 ();  	int bits_per_sample = reader.ReadInt16 ();  	string data_signature = new string (reader.ReadChars (4));  	if (data_signature != "data")  		throw new NotSupportedException ("Specified wave file is not supported.");  	int data_chunk_size = reader.ReadInt32 ();  	channels = num_channels;  	bits = bits_per_sample;  	rate = sample_rate;  	return reader.ReadBytes ((int)reader.BaseStream.Length);  }  
Magic Number,Tachycardia.Sound,SoundDict,C:\repos\secred_Tachycardia\src\Sound\SoundDict.cs,LoadWave,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader (stream)) {  	// RIFF header  	string signature = new string (reader.ReadChars (4));  	if (signature != "RIFF")  		throw new NotSupportedException ("Specified stream is not a wave file.");  	int riff_chunck_size = reader.ReadInt32 ();  	string format = new string (reader.ReadChars (4));  	if (format != "WAVE")  		throw new NotSupportedException ("Specified stream is not a wave file.");  	// WAVE header  	string format_signature = new string (reader.ReadChars (4));  	if (format_signature != "fmt ")  		throw new NotSupportedException ("Specified wave file is not supported.");  	int format_chunk_size = reader.ReadInt32 ();  	int audio_format = reader.ReadInt16 ();  	int num_channels = reader.ReadInt16 ();  	int sample_rate = reader.ReadInt32 ();  	int byte_rate = reader.ReadInt32 ();  	int block_align = reader.ReadInt16 ();  	int bits_per_sample = reader.ReadInt16 ();  	string data_signature = new string (reader.ReadChars (4));  	if (data_signature != "data")  		throw new NotSupportedException ("Specified wave file is not supported.");  	int data_chunk_size = reader.ReadInt32 ();  	channels = num_channels;  	bits = bits_per_sample;  	rate = sample_rate;  	return reader.ReadBytes ((int)reader.BaseStream.Length);  }  
Magic Number,Tachycardia.Sound,SoundDict,C:\repos\secred_Tachycardia\src\Sound\SoundDict.cs,LoadWave,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader (stream)) {  	// RIFF header  	string signature = new string (reader.ReadChars (4));  	if (signature != "RIFF")  		throw new NotSupportedException ("Specified stream is not a wave file.");  	int riff_chunck_size = reader.ReadInt32 ();  	string format = new string (reader.ReadChars (4));  	if (format != "WAVE")  		throw new NotSupportedException ("Specified stream is not a wave file.");  	// WAVE header  	string format_signature = new string (reader.ReadChars (4));  	if (format_signature != "fmt ")  		throw new NotSupportedException ("Specified wave file is not supported.");  	int format_chunk_size = reader.ReadInt32 ();  	int audio_format = reader.ReadInt16 ();  	int num_channels = reader.ReadInt16 ();  	int sample_rate = reader.ReadInt32 ();  	int byte_rate = reader.ReadInt32 ();  	int block_align = reader.ReadInt16 ();  	int bits_per_sample = reader.ReadInt16 ();  	string data_signature = new string (reader.ReadChars (4));  	if (data_signature != "data")  		throw new NotSupportedException ("Specified wave file is not supported.");  	int data_chunk_size = reader.ReadInt32 ();  	channels = num_channels;  	bits = bits_per_sample;  	rate = sample_rate;  	return reader.ReadBytes ((int)reader.BaseStream.Length);  }  
Magic Number,Tachycardia.Sound,SoundDict,C:\repos\secred_Tachycardia\src\Sound\SoundDict.cs,GetSoundFormat,The following statement contains a magic number: switch (channels) {  case 1:  	return bits == 8 ? ALFormat.Mono8 : ALFormat.Mono16;  case 2:  	return bits == 8 ? ALFormat.Stereo8 : ALFormat.Stereo16;  default:  	throw new NotSupportedException ("The specified sound format is not supported.");  }  
Magic Number,Tachycardia.Sound,SoundDict,C:\repos\secred_Tachycardia\src\Sound\SoundDict.cs,GetSoundFormat,The following statement contains a magic number: switch (channels) {  case 1:  	return bits == 8 ? ALFormat.Mono8 : ALFormat.Mono16;  case 2:  	return bits == 8 ? ALFormat.Stereo8 : ALFormat.Stereo16;  default:  	throw new NotSupportedException ("The specified sound format is not supported.");  }  
Magic Number,Tachycardia.Sound,SoundDict,C:\repos\secred_Tachycardia\src\Sound\SoundDict.cs,GetSoundFormat,The following statement contains a magic number: switch (channels) {  case 1:  	return bits == 8 ? ALFormat.Mono8 : ALFormat.Mono16;  case 2:  	return bits == 8 ? ALFormat.Stereo8 : ALFormat.Stereo16;  default:  	throw new NotSupportedException ("The specified sound format is not supported.");  }  
Magic Number,Tachycardia.Sound,SoundDict,C:\repos\secred_Tachycardia\src\Sound\SoundDict.cs,GetSoundFormat,The following statement contains a magic number: return bits == 8 ? ALFormat.Mono8 : ALFormat.Mono16;  
Magic Number,Tachycardia.Sound,SoundDict,C:\repos\secred_Tachycardia\src\Sound\SoundDict.cs,GetSoundFormat,The following statement contains a magic number: return bits == 8 ? ALFormat.Stereo8 : ALFormat.Stereo16;  
Magic Number,Tachycardia.Sound,SoundDict,C:\repos\secred_Tachycardia\src\Sound\SoundDict.cs,Update,The following statement contains a magic number: temp [2] = w.z;  
Magic Number,Tachycardia.Sound,SoundDict,C:\repos\secred_Tachycardia\src\Sound\SoundDict.cs,Update,The following statement contains a magic number: temp [3] = u.x;  
Magic Number,Tachycardia.Sound,SoundDict,C:\repos\secred_Tachycardia\src\Sound\SoundDict.cs,Update,The following statement contains a magic number: temp [4] = u.y;  
Magic Number,Tachycardia.Sound,SoundDict,C:\repos\secred_Tachycardia\src\Sound\SoundDict.cs,Update,The following statement contains a magic number: temp [5] = u.z;  
Magic Number,Tachycardia.Sound,SoundDict,C:\repos\secred_Tachycardia\src\Sound\SoundDict.cs,Update,The following statement contains a magic number: if (m_Player.m_Control.m_bBoost && m_Pulse < 165)  	m_Pulse += 0.1f;  else if (m_Pulse > 83)  	m_Pulse -= 0.1f;  
Magic Number,Tachycardia.Sound,SoundDict,C:\repos\secred_Tachycardia\src\Sound\SoundDict.cs,Update,The following statement contains a magic number: if (m_Player.m_Control.m_bBoost && m_Pulse < 165)  	m_Pulse += 0.1f;  else if (m_Pulse > 83)  	m_Pulse -= 0.1f;  
Magic Number,Tachycardia.Sound,SoundDict,C:\repos\secred_Tachycardia\src\Sound\SoundDict.cs,Update,The following statement contains a magic number: if (m_Pulse > 83)  	m_Pulse -= 0.1f;  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,ParseVector2,The following statement contains a magic number: if (list.Count < 2)  	return null;  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,ParseVector3,The following statement contains a magic number: if (list.Count < 3)  	return null;  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,ParseVector3,The following statement contains a magic number: if (ParseFloat (list [0]' ref value.x) != null) {  	if (ParseFloat (list [1]' ref value.y) != null) {  		if (ParseFloat (list [2]' ref value.z) != null)  			return prev;  	}  }  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,ParseVector3,The following statement contains a magic number: if (ParseFloat (list [1]' ref value.y) != null) {  	if (ParseFloat (list [2]' ref value.z) != null)  		return prev;  }  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,ParseVector3,The following statement contains a magic number: if (ParseFloat (list [2]' ref value.z) != null)  	return prev;  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,ParseVector4,The following statement contains a magic number: if (ParseFloat (list [0]' ref value.x) != null) {  	if (ParseFloat (list [1]' ref value.y) != null) {  		if (ParseFloat (list [2]' ref value.z) != null) {  			if (ParseFloat (list [3]' ref value.w) != null)  				return prev;  		}  	}  }  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,ParseVector4,The following statement contains a magic number: if (ParseFloat (list [0]' ref value.x) != null) {  	if (ParseFloat (list [1]' ref value.y) != null) {  		if (ParseFloat (list [2]' ref value.z) != null) {  			if (ParseFloat (list [3]' ref value.w) != null)  				return prev;  		}  	}  }  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,ParseVector4,The following statement contains a magic number: if (ParseFloat (list [1]' ref value.y) != null) {  	if (ParseFloat (list [2]' ref value.z) != null) {  		if (ParseFloat (list [3]' ref value.w) != null)  			return prev;  	}  }  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,ParseVector4,The following statement contains a magic number: if (ParseFloat (list [1]' ref value.y) != null) {  	if (ParseFloat (list [2]' ref value.z) != null) {  		if (ParseFloat (list [3]' ref value.w) != null)  			return prev;  	}  }  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,ParseVector4,The following statement contains a magic number: if (ParseFloat (list [2]' ref value.z) != null) {  	if (ParseFloat (list [3]' ref value.w) != null)  		return prev;  }  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,ParseVector4,The following statement contains a magic number: if (ParseFloat (list [2]' ref value.z) != null) {  	if (ParseFloat (list [3]' ref value.w) != null)  		return prev;  }  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,ParseVector4,The following statement contains a magic number: if (ParseFloat (list [3]' ref value.w) != null)  	return prev;  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,OnInvokeParseArg,The following statement contains a magic number: if (i < e.args.Length) {  	if (e.args [i].Length >= 2 && e.args [i] [0] == '-' && e.args [i] [1] != '-') {  		string arg = e.args [i];  		if (_aliases.ContainsKey (arg))  			arg = _aliases [arg];  		if (_main.ContainsKey (arg)) {  			ArgEvent evt = new ArgEvent ();  			evt.subArgs = new Dictionary<string' List<string>> ();  			evt.parameters = null;  			evt.name = arg.Substring (1);  			++i;  			if (i < e.args.Length && e.args [i] [0] != '-') {  				evt.parameters = new List<string> ();  				do {  					evt.parameters.Add (e.args [i]);  					++i;  				}  				while (i < e.args.Length && e.args [i] [0] != '-');  			}  			while (i < e.args.Length && e.args [i].StartsWith ("--"))  				OnInvokeParseSubArg (ref e' ref i' ref evt' arg);  			_main [arg] (evt);  		}  		else {  			p.UnrecognisedArg (arg' i);  			++i;  		}  	}  	else {  		p.BadSyntax (i);  		++i;  	}  }  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,OnInvokeParseArg,The following statement contains a magic number: if (e.args [i].Length >= 2 && e.args [i] [0] == '-' && e.args [i] [1] != '-') {  	string arg = e.args [i];  	if (_aliases.ContainsKey (arg))  		arg = _aliases [arg];  	if (_main.ContainsKey (arg)) {  		ArgEvent evt = new ArgEvent ();  		evt.subArgs = new Dictionary<string' List<string>> ();  		evt.parameters = null;  		evt.name = arg.Substring (1);  		++i;  		if (i < e.args.Length && e.args [i] [0] != '-') {  			evt.parameters = new List<string> ();  			do {  				evt.parameters.Add (e.args [i]);  				++i;  			}  			while (i < e.args.Length && e.args [i] [0] != '-');  		}  		while (i < e.args.Length && e.args [i].StartsWith ("--"))  			OnInvokeParseSubArg (ref e' ref i' ref evt' arg);  		_main [arg] (evt);  	}  	else {  		p.UnrecognisedArg (arg' i);  		++i;  	}  }  else {  	p.BadSyntax (i);  	++i;  }  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,OnInvokeParseSubArg,The following statement contains a magic number: if (i < e.args.Length) {  	if (e.args [i].StartsWith ("--")) {  		if (e.args [i].Length >= 3) {  			if (_subs [argName].Contains (e.args [i])) {  				string sub = e.args [i];  				List<string> list = new List<string> ();  				++i;  				while (i < e.args.Length && e.args [i] [0] != '-') {  					list.Add (e.args [i]);  					++i;  				}  				evt.subArgs.Add (sub.Substring (2)' list);  			}  			else {  				p.UnrecognisedSubArg (argName' e.args [i]);  				++i;  			}  		}  		else {  			p.EmptyArg (i);  			++i;  		}  	}  	else {  		p.BadSyntax (i);  		++i;  	}  }  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,OnInvokeParseSubArg,The following statement contains a magic number: if (i < e.args.Length) {  	if (e.args [i].StartsWith ("--")) {  		if (e.args [i].Length >= 3) {  			if (_subs [argName].Contains (e.args [i])) {  				string sub = e.args [i];  				List<string> list = new List<string> ();  				++i;  				while (i < e.args.Length && e.args [i] [0] != '-') {  					list.Add (e.args [i]);  					++i;  				}  				evt.subArgs.Add (sub.Substring (2)' list);  			}  			else {  				p.UnrecognisedSubArg (argName' e.args [i]);  				++i;  			}  		}  		else {  			p.EmptyArg (i);  			++i;  		}  	}  	else {  		p.BadSyntax (i);  		++i;  	}  }  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,OnInvokeParseSubArg,The following statement contains a magic number: if (e.args [i].StartsWith ("--")) {  	if (e.args [i].Length >= 3) {  		if (_subs [argName].Contains (e.args [i])) {  			string sub = e.args [i];  			List<string> list = new List<string> ();  			++i;  			while (i < e.args.Length && e.args [i] [0] != '-') {  				list.Add (e.args [i]);  				++i;  			}  			evt.subArgs.Add (sub.Substring (2)' list);  		}  		else {  			p.UnrecognisedSubArg (argName' e.args [i]);  			++i;  		}  	}  	else {  		p.EmptyArg (i);  		++i;  	}  }  else {  	p.BadSyntax (i);  	++i;  }  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,OnInvokeParseSubArg,The following statement contains a magic number: if (e.args [i].StartsWith ("--")) {  	if (e.args [i].Length >= 3) {  		if (_subs [argName].Contains (e.args [i])) {  			string sub = e.args [i];  			List<string> list = new List<string> ();  			++i;  			while (i < e.args.Length && e.args [i] [0] != '-') {  				list.Add (e.args [i]);  				++i;  			}  			evt.subArgs.Add (sub.Substring (2)' list);  		}  		else {  			p.UnrecognisedSubArg (argName' e.args [i]);  			++i;  		}  	}  	else {  		p.EmptyArg (i);  		++i;  	}  }  else {  	p.BadSyntax (i);  	++i;  }  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,OnInvokeParseSubArg,The following statement contains a magic number: if (e.args [i].Length >= 3) {  	if (_subs [argName].Contains (e.args [i])) {  		string sub = e.args [i];  		List<string> list = new List<string> ();  		++i;  		while (i < e.args.Length && e.args [i] [0] != '-') {  			list.Add (e.args [i]);  			++i;  		}  		evt.subArgs.Add (sub.Substring (2)' list);  	}  	else {  		p.UnrecognisedSubArg (argName' e.args [i]);  		++i;  	}  }  else {  	p.EmptyArg (i);  	++i;  }  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,OnInvokeParseSubArg,The following statement contains a magic number: if (e.args [i].Length >= 3) {  	if (_subs [argName].Contains (e.args [i])) {  		string sub = e.args [i];  		List<string> list = new List<string> ();  		++i;  		while (i < e.args.Length && e.args [i] [0] != '-') {  			list.Add (e.args [i]);  			++i;  		}  		evt.subArgs.Add (sub.Substring (2)' list);  	}  	else {  		p.UnrecognisedSubArg (argName' e.args [i]);  		++i;  	}  }  else {  	p.EmptyArg (i);  	++i;  }  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,OnInvokeParseSubArg,The following statement contains a magic number: if (_subs [argName].Contains (e.args [i])) {  	string sub = e.args [i];  	List<string> list = new List<string> ();  	++i;  	while (i < e.args.Length && e.args [i] [0] != '-') {  		list.Add (e.args [i]);  		++i;  	}  	evt.subArgs.Add (sub.Substring (2)' list);  }  else {  	p.UnrecognisedSubArg (argName' e.args [i]);  	++i;  }  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,OnInvokeParseSubArg,The following statement contains a magic number: evt.subArgs.Add (sub.Substring (2)' list);  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,OnTabGetLastArg,The following statement contains a magic number: for (int i = e.args.Length - 1; i > 0; i--)  	if (e.args [i] == "-")  		return null;  	else if (e.args [i].Length >= 2 && e.args [i] [0] == '-' && e.args [i] [1] != '-')  		return e.args [i];  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,OnTabGetLastArg,The following statement contains a magic number: if (e.args [i] == "-")  	return null;  else if (e.args [i].Length >= 2 && e.args [i] [0] == '-' && e.args [i] [1] != '-')  	return e.args [i];  
Magic Number,Tachycardia.Tools.Commands,Command,C:\repos\secred_Tachycardia\src\Tools\Commands\Command.cs,OnTabGetLastArg,The following statement contains a magic number: if (e.args [i].Length >= 2 && e.args [i] [0] == '-' && e.args [i] [1] != '-')  	return e.args [i];  
Magic Number,Tachycardia.Tools,ConsoleParser,C:\repos\secred_Tachycardia\src\Tools\ConsoleParser.cs,OnInsert,The following statement contains a magic number: Console.CursorSize = _ins ? 100 : 25;  
Magic Number,Tachycardia.Tools,ConsoleParser,C:\repos\secred_Tachycardia\src\Tools\ConsoleParser.cs,OnInsert,The following statement contains a magic number: Console.CursorSize = _ins ? 100 : 25;  
Magic Number,Helper,DotSceneLoader,C:\repos\secred_Tachycardia\src\Tools\DotSceneLoader.cs,parseVector3line,The following statement contains a magic number: return new Vector3 (ParseFloat (parameters [0])' ParseFloat (parameters [1])' ParseFloat (parameters [2]));  
Missing Default,Tachycardia,Character,C:\repos\secred_Tachycardia\src\Player\Character.cs,Update,The following switch statement is missing a default case: switch (m_Control.m_State) {  case PlayerController.CharacterState.IDLE:  	walkAnimation.Enabled = false;  	idleAnimation.Enabled = true;  	idleAnimation.Loop = true;  	idleAnimation.AddTime (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector);  	break;  case PlayerController.CharacterState.WALK:  	idleAnimation.Enabled = false;  	walkAnimation.Enabled = true;  	walkAnimation.Loop = true;  	walkAnimation.AddTime (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector);  	if (walkAnimation.TimePosition / walkAnimation.Length > 0.5f && (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.5f || (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.0f) {  		Core.Singleton.SoundDict.Play ("player/step_gravel_0" + new Random ().Next (1' 4) + ".wav"' m_Control.m_MainBody.Position);  	}  	break;  case PlayerController.CharacterState.RUN:  	idleAnimation.Enabled = false;  	walkAnimation.Enabled = true;  	walkAnimation.Loop = true;  	walkAnimation.AddTime (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector);  	if (walkAnimation.TimePosition / walkAnimation.Length > 0.5f && (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.5f || (walkAnimation.TimePosition - (Core.m_FixedTime * m_Control.m_MainBody.Velocity.Length * animationCorrector)) / walkAnimation.Length < 0.0f) {  		Core.Singleton.SoundDict.Play ("player/step_gravel_0" + new Random ().Next (1' 4) + ".wav"' m_Control.m_MainBody.Position);  	}  	break;  }  
Missing Default,Tachycardia,GameState,C:\repos\secred_Tachycardia\src\States\GameState.cs,KeyPressed,The following switch statement is missing a default case: switch (keyEventRef.key) {  case MOIS.KeyCode.KC_ESCAPE:  	PopState ();  	break;  case MOIS.KeyCode.KC_1:  	Core.Singleton.GameCamera.Cam1 ();  	break;  case MOIS.KeyCode.KC_2:  	Core.Singleton.GameCamera.Cam2 ();  	break;  case MOIS.KeyCode.KC_3:  	Core.Singleton.GameCamera.Cam3 ();  	break;  case MOIS.KeyCode.KC_4:  	Core.Singleton.GameCamera.Cam4 ();  	break;  /* controler */case MOIS.KeyCode.KC_W:  	m_Player.m_Control.ForwardButtonPressed ();  	break;  case MOIS.KeyCode.KC_S:  	m_Player.m_Control.BackwardButtonPressed ();  	break;  case MOIS.KeyCode.KC_A:  	m_Player.m_Control.LeftButtonPressed ();  	break;  case MOIS.KeyCode.KC_D:  	m_Player.m_Control.RightButtonPressed ();  	break;  case MOIS.KeyCode.KC_LSHIFT:  	m_Player.m_Control.BoostButtonPressed ();  	break;  case MOIS.KeyCode.KC_SPACE:  	m_Player.m_Control.JumpButtonPressed ();  	break;  case MOIS.KeyCode.KC_C:  	m_Player.m_Control.CrouchButtonPressed ();  	break;  case MOIS.KeyCode.KC_X:  	Console.WriteLine ("Pozycja X = " + Core.Singleton.Camera.Position.x + " Y = " + Core.Singleton.Camera.Position.y + " Z  = " + Core.Singleton.Camera.Position.z);  	break;  }  
Missing Default,Tachycardia,GameState,C:\repos\secred_Tachycardia\src\States\GameState.cs,KeyReleased,The following switch statement is missing a default case: switch (keyEventRef.key) {  /* Klawisze dla controlera */case MOIS.KeyCode.KC_W:  	m_Player.m_Control.ForwardButtonReleased ();  	break;  case MOIS.KeyCode.KC_S:  	m_Player.m_Control.BackwardButtonReleased ();  	break;  case MOIS.KeyCode.KC_A:  	m_Player.m_Control.LeftButtonReleased ();  	break;  case MOIS.KeyCode.KC_D:  	m_Player.m_Control.RightButtonReleased ();  	break;  case MOIS.KeyCode.KC_LSHIFT:  	m_Player.m_Control.BoostButtonReleased ();  	break;  }  
Missing Default,Tachycardia,IntroState,C:\repos\secred_Tachycardia\src\States\IntroState.cs,KeyPressed,The following switch statement is missing a default case: switch (keyEventRef.key) {  case MOIS.KeyCode.KC_SPACE:  	PushState ("Game");  	break;  case MOIS.KeyCode.KC_ESCAPE:  	if (Core.Singleton.Keyboard.IsKeyDown (MOIS.KeyCode.KC_RSHIFT))  		PopState ();  	break;  }  
Missing Default,Tachycardia.Objects,Trigger,C:\repos\secred_Tachycardia\src\Objects\Logic\Trigger.cs,Trigger,The following switch statement is missing a default case: switch (_shapename) {  case "box":  	m_collision = new MogreNewt.CollisionPrimitives.Box (Core.Singleton.NewtonWorld' _shapesize' new Mogre.Quaternion (new Mogre.Radian (1.57f)' new Mogre.Vector3 (0' 0' 1))' Core.Singleton.GetUniqueBodyId ());  	break;  case "ellipsoid":  	m_collision = new MogreNewt.CollisionPrimitives.Ellipsoid (Core.Singleton.NewtonWorld' _shapesize' new Mogre.Quaternion (new Mogre.Radian (1.57f)' new Mogre.Vector3 (0' 0' 1))' Core.Singleton.GetUniqueBodyId ());  	break;  }  
Missing Default,csvorbis,CodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\CodeBook.cs,besterror,The following switch statement is missing a default case: switch (addmul) {  case 0:  	for (int i = 0' o = 0; i < dim; i++' o += step)  		a [o] -= valuelist [bestt * dim + i];  	break;  case 1:  	for (int i = 0' o = 0; i < dim; i++' o += step) {  		float val = valuelist [bestt * dim + i];  		if (val == 0) {  			a [o] = 0;  		}  		else {  			a [o] /= val;  		}  	}  	break;  }  
Missing Default,csvorbis,DspState,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\DspState.cs,synthesis_blockin,The following switch statement is missing a default case: switch (W) {  case 0:  	beginSl = 0;  	endSl = vi.blocksizes [0] / 2;  	break;  case 1:  	beginSl = vi.blocksizes [1] / 4 - vi.blocksizes [lW] / 4;  	endSl = beginSl + vi.blocksizes [lW] / 2;  	break;  }  
Missing Default,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,pack,The following switch statement is missing a default case: switch (maptype) {  case 1:  	// a single column of (c->entries/c->dim) quantized values for  	// building a full value list algorithmically (square lattice)  	quantvals = maptype1_quantvals ();  	break;  case 2:  	// every value (c->entries*c->dim total) specified explicitly  	quantvals = entries * dim;  	break;  }  
Missing Default,csvorbis,StaticCodeBook,C:\repos\secred_Tachycardia\src\Sound\Audio\csvorbis\StaticCodeBook.cs,unpack,The following switch statement is missing a default case: switch (maptype) {  case 1:  	quantvals = maptype1_quantvals ();  	break;  case 2:  	quantvals = entries * dim;  	break;  }  
Missing Default,TagLib,ByteVector,C:\repos\secred_Tachycardia\src\Sound\Audio\TagLibSharp\ByteVector.cs,StringTypeToEncoding,The following switch statement is missing a default case: switch (type) {  case StringType.UTF16:  	// If we have a BOM' return the appropriate  	// encoding. Otherwise' assume we're reading  	// from a string that was already identified. In  	// that case' the encoding will be stored as  	// last_utf16_encoding.  	if (bom == null)  		return last_utf16_encoding;  	if (bom [0] == 0xFF && bom [1] == 0xFE)  		return last_utf16_encoding = Encoding.Unicode;  	if (bom [1] == 0xFF && bom [0] == 0xFE)  		return last_utf16_encoding = Encoding.BigEndianUnicode;  	return last_utf16_encoding;  case StringType.UTF16BE:  	return Encoding.BigEndianUnicode;  case StringType.UTF8:  	return Encoding.UTF8;  case StringType.UTF16LE:  	return Encoding.Unicode;  }  
