Implementation smell,Namespace,Class,File,Method,Description
Long Method,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The method has 87 lines of code.
Long Method,Bike.Parser,Lexer,D:\newReposJune17\buunguyen_bike\src\Bike\Parser\Lexer.cs,NextToken,The method has 90 lines of code.
Complex Method,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AssignSwitch,Cyclomatic complexity of the method is 19
Complex Method,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,GetFirstObjectFromMember,Cyclomatic complexity of the method is 9
Complex Method,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,Cyclomatic complexity of the method is 15
Complex Method,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptObjectPassThrough,Cyclomatic complexity of the method is 13
Complex Method,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,Walk,Cyclomatic complexity of the method is 8
Complex Method,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,Walk,Cyclomatic complexity of the method is 22
Complex Method,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,Walk,Cyclomatic complexity of the method is 13
Complex Method,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,Walk,Cyclomatic complexity of the method is 7
Complex Method,Bike.Parser,Lexer,D:\newReposJune17\buunguyen_bike\src\Bike\Parser\Lexer.cs,NextToken,Cyclomatic complexity of the method is 58
Complex Method,Bike.Parser,Lexer,D:\newReposJune17\buunguyen_bike\src\Bike\Parser\Lexer.cs,Minus,Cyclomatic complexity of the method is 7
Complex Method,Bike.Parser,Lexer,D:\newReposJune17\buunguyen_bike\src\Bike\Parser\Lexer.cs,Escape,Cyclomatic complexity of the method is 10
Complex Method,Bike.Parser,Parser,D:\newReposJune17\buunguyen_bike\src\Bike\Parser\Parser.cs,ParseFormalParameterList,Cyclomatic complexity of the method is 7
Complex Method,Bike.Parser,Parser,D:\newReposJune17\buunguyen_bike\src\Bike\Parser\Parser.cs,ParseStatement,Cyclomatic complexity of the method is 15
Complex Method,Bike.Parser,Parser,D:\newReposJune17\buunguyen_bike\src\Bike\Parser\Parser.cs,ParseLeftHandSideExpression,Cyclomatic complexity of the method is 16
Complex Method,Bike.Parser,Parser,D:\newReposJune17\buunguyen_bike\src\Bike\Parser\Parser.cs,ParseMemberExpressionSuffix,Cyclomatic complexity of the method is 15
Complex Method,Bike.Parser,Parser,D:\newReposJune17\buunguyen_bike\src\Bike\Parser\Parser.cs,ParsePrimaryExpression,Cyclomatic complexity of the method is 9
Long Parameter List,Bike.Interpreter.Builtin,BikeFunction,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Builtin\BikeFunction.cs,BikeFunction,The method has 5 parameters.
Long Parameter List,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AssignSwitch,The method has 6 parameters.
Long Parameter List,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,PerformAssign,The method has 4 parameters.
Long Parameter List,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptObjectPassThrough,The method has 4 parameters.
Long Parameter List,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptArrayIndex,The method has 4 parameters.
Long Parameter List,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptStringIndexGetter,The method has 4 parameters.
Long Parameter List,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,PerformInvocation,The method has 4 parameters.
Long Parameter List,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,CallInstanceFunction,The method has 4 parameters.
Long Parameter List,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,CallStaticFunction,The method has 4 parameters.
Long Parameter List,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AddHandler,The method has 5 parameters.
Long Parameter List,Bike.Interpreter,InterpretationContext,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Context\InterpretationContext.cs,OpenScopeFor,The method has 5 parameters.
Long Parameter List,Bike.Interpreter,InterpretationContext,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Context\InterpretationContext.cs,OpenScopeFor,The method has 5 parameters.
Long Parameter List,Bike.Interpreter,ScopeStack,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Scope\ScopeStack.cs,OpenScopeFor,The method has 5 parameters.
Long Parameter List,Bike.Interpreter,ScopeStack,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Scope\ScopeStack.cs,OpenScopeFor,The method has 5 parameters.
Long Parameter List,Bike.Interpreter,ScopeFrame,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Scope\ScopeFrame.cs,ScopeFrame,The method has 4 parameters.
Long Parameter List,Bike.Interpreter,ScopeFrame,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Scope\ScopeFrame.cs,ScopeFrame,The method has 5 parameters.
Long Statement,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,Walk,The length of the statement  "		var suffixes = node.Variable is MemberExpression ? ((MemberExpression)node.Variable).Suffixes : ((CallExpression)node.Variable).Suffixes; " is 137.
Long Statement,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,Walk,The length of the statement  "		var secondLastObject = node.Variable is MemberExpression ? Member ((MemberExpression)node.Variable' suffixes.ExceptLast ()) : Call ((CallExpression)node.Variable' suffixes.ExceptLast ()); " is 187.
Long Statement,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,Walk,The length of the statement  "		var lvThunk = (Func<object>)(() => node.Variable is MemberExpression ? Member ((MemberExpression)node.Variable' suffixes) : Call ((CallExpression)node.Variable' suffixes)); " is 172.
Long Statement,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The length of the statement  "	if (currentSuffix is PropertyReferenceSuffix || currentSuffix is IndexSuffix || currentSuffix is TypeDescriptorSuffix) { " is 120.
Long Statement,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptObjectPassThrough,The length of the statement  "					result = System.Threading.Monitor.TryEnter (args [0]' (int)(decimal)InterpretationContext.Instance.Interpreter.MarshallToClr (args [1])); " is 137.
Long Statement,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,CreateInstance,The length of the statement  "	return PerformInvocation (type' "ctor"' args' innerArgs => type.CreateInstance (InstanceFlags' innerArgs)' innerArgs => type.TryCreateInstanceWithValues (TryConvert' InstanceFlags' innerArgs)); " is 193.
Long Statement,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,CallInstanceFunction,The length of the statement  "	return PerformInvocation (target' funcName' args' innerArgs => target.WrapIfValueType ().CallMethod (typeParams' funcName' InstanceFlags' innerArgs)' innerArgs => target.TryCallMethodWithValues (TryConvert' funcName' typeParams' InstanceFlags' innerArgs)); " is 256.
Long Statement,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,CallInstanceFunction,The length of the statement  "	return PerformInvocation (target' funcName' args' innerArgs => target.WrapIfValueType ().CallMethod (funcName' InstanceFlags' innerArgs)' innerArgs => target.TryCallMethodWithValues (TryConvert' funcName' InstanceFlags' innerArgs)); " is 232.
Long Statement,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,CallStaticFunction,The length of the statement  "	return PerformInvocation (type' funcName' args' innerArgs => type.CallMethod (typeParams' funcName' StaticFlags' innerArgs)' innerArgs => type.TryCallMethodWithValues (TryConvert' funcName' typeParams' StaticFlags' innerArgs)); " is 227.
Long Statement,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,CallStaticFunction,The length of the statement  "	return PerformInvocation (type' funcName' args' innerArgs => type.CallMethod (funcName' StaticFlags' innerArgs)' innerArgs => type.TryCallMethodWithValues (TryConvert' funcName' StaticFlags' innerArgs)' innerArgs => type.GetType ().GetMethod (funcName).Invoke (type' args)); " is 274.
Long Statement,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,GetInstanceProperty,The length of the statement  "	throw ErrorFactory.CreateClrError (string.Format ("Cannot resolve field or property {0} of type {1}"' propName' target.GetType ())); " is 132.
Long Statement,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,SetInstanceProperty,The length of the statement  "	throw ErrorFactory.CreateClrError (string.Format ("Cannot resolve field or property {0} of type {1}"' propName' target.GetType ())); " is 132.
Long Statement,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,GetStaticProperty,The length of the statement  "	throw ErrorFactory.CreateClrError (string.Format ("Cannot resolve static field or property {0} of type {1}"' propName' type)); " is 126.
Long Statement,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,SetStaticProperty,The length of the statement  "	throw ErrorFactory.CreateClrError (string.Format ("Cannot resolve static field or property {0} of type {1}"' propName' type)); " is 126.
Long Statement,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,Walk,The length of the statement  "	var error = (throwable is Exception) ? ErrorFactory.CreateClrError ((Exception)throwable) : ErrorFactory.CreateTypeError ("Can only throw Bike.Object or CLR's Exception"); " is 171.
Long Statement,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AddHandler,The length of the statement  "	var delegateType = isStatic ? ((Type)target).AddHandler (name' invoker.Callback) : target.AddHandler (name' invoker.Callback); " is 126.
Long Statement,Bike.Interpreter,InterpreterHelper,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.StaticHelper.cs,Arguments,The length of the statement  "	return indexSuffix.Expression is Expression ? ((Expression)indexSuffix.Expression).AssignmentExpressions.Select (e => e.Accept (interpreter)).ToArray () : new[] { " is 162.
Long Statement,Bike.Parser,Lexer,D:\newReposJune17\buunguyen_bike\src\Bike\Parser\Lexer.cs,Identifier,The length of the statement  "	} while (Char.IsLetter ((char)currentChar) || Char.IsDigit ((char)currentChar) || currentChar == '_' || currentChar == '$'); " is 124.
Long Statement,Bike.Parser,Parser,D:\newReposJune17\buunguyen_bike\src\Bike\Parser\Parser.cs,ParseRelationalExpression,The length of the statement  "	if (Next ().IsNot (TokenType.LessThan) && Next ().IsNot (TokenType.LessThanOrEqual) && Next ().IsNot (TokenType.GreaterThan) && Next ().IsNot (TokenType.GreaterThanOrEqual) && Next ().IsNot (TokenType.Is)) " is 205.
Long Statement,Bike.Parser,Parser,D:\newReposJune17\buunguyen_bike\src\Bike\Parser\Parser.cs,ParseUnaryExpression,The length of the statement  "	if (token.Is (TokenType.DoublePlus) || token.Is (TokenType.DoubleMinus) || token.Is (TokenType.Plus) || token.Is (TokenType.Minus) || token.Is (TokenType.Not)) { " is 161.
Long Statement,Bike.Parser,Parser,D:\newReposJune17\buunguyen_bike\src\Bike\Parser\Parser.cs,ParsePrimitiveLiteral,The length of the statement  "	if (!token.Is (TokenType.Null) && !token.Is (TokenType.True) && !token.Is (TokenType.False) && !token.Is (TokenType.String) && !token.Is (TokenType.Number)) " is 156.
Long Statement,Bike.Parser,ParseException,D:\newReposJune17\buunguyen_bike\src\Bike\Parser\ParseException.cs,ToString,The length of the statement  "	return new StringBuilder ().Append (GetType ().Name).Append (": ").Append (Message).AppendLine ().AppendFormat ("   in {0}:line {1}"' Location.FilePath' Location.Line).AppendLine ().ToString (); " is 194.
Complex Conditional,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptObjectPassThrough,The conditional expression  "funcName == "Enter" || funcName == "Exit" || funcName == "Wait" || funcName == "Pulse" || funcName == "PulseAll""  is complex.
Complex Conditional,Bike.Parser,Lexer,D:\newReposJune17\buunguyen_bike\src\Bike\Parser\Lexer.cs,Next,The conditional expression  "currentChar == '\r' || (currentChar == '\n' && (previousChar == Eof || previousChar != '\r'))"  is complex.
Complex Conditional,Bike.Parser,Lexer,D:\newReposJune17\buunguyen_bike\src\Bike\Parser\Lexer.cs,Identifier,The conditional expression  "Char.IsLetter ((char)currentChar) || Char.IsDigit ((char)currentChar) || currentChar == '_' || currentChar == '$'"  is complex.
Complex Conditional,Bike.Parser,Parser,D:\newReposJune17\buunguyen_bike\src\Bike\Parser\Parser.cs,ParseRelationalExpression,The conditional expression  "Next ().IsNot (TokenType.LessThan) && Next ().IsNot (TokenType.LessThanOrEqual) && Next ().IsNot (TokenType.GreaterThan) && Next ().IsNot (TokenType.GreaterThanOrEqual) && Next ().IsNot (TokenType.Is)"  is complex.
Complex Conditional,Bike.Parser,Parser,D:\newReposJune17\buunguyen_bike\src\Bike\Parser\Parser.cs,ParseUnaryExpression,The conditional expression  "token.Is (TokenType.DoublePlus) || token.Is (TokenType.DoubleMinus) || token.Is (TokenType.Plus) || token.Is (TokenType.Minus) || token.Is (TokenType.Not)"  is complex.
Complex Conditional,Bike.Parser,Parser,D:\newReposJune17\buunguyen_bike\src\Bike\Parser\Parser.cs,ParsePrimitiveLiteral,The conditional expression  "!token.Is (TokenType.Null) && !token.Is (TokenType.True) && !token.Is (TokenType.False) && !token.Is (TokenType.String) && !token.Is (TokenType.Number)"  is complex.
Magic Number,Bike.Ast,FormalParameter,D:\newReposJune17\buunguyen_bike\src\Bike\Ast\Declarations\FormalParameter.cs,GetHashCode,The following statement contains a magic number: return 31 * IsParams.GetHashCode () + Identifier.GetHashCode ();  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,GetFirstObjectFromMember,The following statement contains a magic number: if (memberExp is Identifier) {  	var id = ((Identifier)memberExp).Value;  	if (Context.CurrentFrame.Exist (id))  		return Context.CurrentFrame.Resolve (id);  	// TODO handle nested type  	// propably CLR type  	if (!(suffixes [0] is TypeDescriptorSuffix) && Context.IsClrType (id))  		return Context.LoadTypeFromName (id);  	// start with namespace?  attempt further  	for (int i = 0; i < suffixes.Count; i++) {  		var suffix = suffixes [i];  		if (suffix is IndexSuffix)  			break;  		if (suffix is TypeDescriptorSuffix) {  			var typeParams = (Type[])suffix.Accept (this);  			suffixes.RemoveRange (0' i + 1);  			return Context.LoadTypeFromName (id' typeParams);  		}  		id += "." + suffix.SuffixValue (this);  		if (i < suffixes.Count - 1 && (suffixes [i + 1] is TypeDescriptorSuffix)) {  			var typeParams = (Type[])suffixes [i + 1].Accept (this);  			suffixes.RemoveRange (0' i + 2);  			return Context.LoadTypeFromName (id' typeParams);  		}  		if (Context.IsClrType (id)) {  			suffixes.RemoveRange (0' i + 1);  			return Context.LoadTypeFromName (id);  		}  	}  	if (id.IndexOf ('.') >= 0)  		id = id.Substring (0' id.IndexOf ('.'));  	throw ErrorFactory.CreateNotDefinedError (id);  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,GetFirstObjectFromMember,The following statement contains a magic number: for (int i = 0; i < suffixes.Count; i++) {  	var suffix = suffixes [i];  	if (suffix is IndexSuffix)  		break;  	if (suffix is TypeDescriptorSuffix) {  		var typeParams = (Type[])suffix.Accept (this);  		suffixes.RemoveRange (0' i + 1);  		return Context.LoadTypeFromName (id' typeParams);  	}  	id += "." + suffix.SuffixValue (this);  	if (i < suffixes.Count - 1 && (suffixes [i + 1] is TypeDescriptorSuffix)) {  		var typeParams = (Type[])suffixes [i + 1].Accept (this);  		suffixes.RemoveRange (0' i + 2);  		return Context.LoadTypeFromName (id' typeParams);  	}  	if (Context.IsClrType (id)) {  		suffixes.RemoveRange (0' i + 1);  		return Context.LoadTypeFromName (id);  	}  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,GetFirstObjectFromMember,The following statement contains a magic number: if (i < suffixes.Count - 1 && (suffixes [i + 1] is TypeDescriptorSuffix)) {  	var typeParams = (Type[])suffixes [i + 1].Accept (this);  	suffixes.RemoveRange (0' i + 2);  	return Context.LoadTypeFromName (id' typeParams);  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,GetFirstObjectFromMember,The following statement contains a magic number: suffixes.RemoveRange (0' i + 2);  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentSuffix is PropertyReferenceSuffix || currentSuffix is IndexSuffix || currentSuffix is TypeDescriptorSuffix) {  	if (currentTarget is BikeObject) {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = ((BikeObject)currentTarget).Resolve (currentSuffixStr);  	} else if (currentTarget is Type)// Static context  	 {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		// Static generic call  		if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  			var typeParams = (Type[])suffixes [1].Accept (this);  			var args = GetArgumentValues ((Arguments)suffixes [2]);  			previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ().ExceptFirst ();  		} // Static method or delegate  		else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  			try {  				// delegate?  				previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  			} catch (BikeObject bo) {  				if (!ErrorFactory.IsClrError (bo))  					throw;  				// method?  invoke immediately to avoid saving MethodInfo  				var args = GetArgumentValues ((Arguments)suffixes [1]);  				previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  				suffixes = suffixes.ExceptFirst ();  			}  		} else// .NET static property' invoke immediately  		 {  			previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  		}  	} // Must be .NET generic instance method  	else if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var typeParams = (Type[])suffixes [1].Accept (this);  		var args = GetArgumentValues ((Arguments)suffixes [2]);  		previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ().ExceptFirst ();  	} // .NET instance method or delegate  	else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  		try {  			// delegate?  			var currentSuffixStr = currentSuffix.SuffixValue (this);  			previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  		} catch (BikeObject bo) {  			if (!ErrorFactory.IsClrError (bo))  				throw;  			// method?  			var currentSuffixStr = currentSuffix.SuffixValue (this);  			var args = GetArgumentValues ((Arguments)suffixes [1]);  			previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ();  		}  	} // .NET instance property  	else if (currentSuffix is PropertyReferenceSuffix) {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} // .NET indexer  	else {  		previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  	}  	return AccessOneByOne (previousTarget' currentTarget' suffixes.ExceptFirst ());  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentSuffix is PropertyReferenceSuffix || currentSuffix is IndexSuffix || currentSuffix is TypeDescriptorSuffix) {  	if (currentTarget is BikeObject) {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = ((BikeObject)currentTarget).Resolve (currentSuffixStr);  	} else if (currentTarget is Type)// Static context  	 {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		// Static generic call  		if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  			var typeParams = (Type[])suffixes [1].Accept (this);  			var args = GetArgumentValues ((Arguments)suffixes [2]);  			previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ().ExceptFirst ();  		} // Static method or delegate  		else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  			try {  				// delegate?  				previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  			} catch (BikeObject bo) {  				if (!ErrorFactory.IsClrError (bo))  					throw;  				// method?  invoke immediately to avoid saving MethodInfo  				var args = GetArgumentValues ((Arguments)suffixes [1]);  				previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  				suffixes = suffixes.ExceptFirst ();  			}  		} else// .NET static property' invoke immediately  		 {  			previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  		}  	} // Must be .NET generic instance method  	else if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var typeParams = (Type[])suffixes [1].Accept (this);  		var args = GetArgumentValues ((Arguments)suffixes [2]);  		previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ().ExceptFirst ();  	} // .NET instance method or delegate  	else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  		try {  			// delegate?  			var currentSuffixStr = currentSuffix.SuffixValue (this);  			previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  		} catch (BikeObject bo) {  			if (!ErrorFactory.IsClrError (bo))  				throw;  			// method?  			var currentSuffixStr = currentSuffix.SuffixValue (this);  			var args = GetArgumentValues ((Arguments)suffixes [1]);  			previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ();  		}  	} // .NET instance property  	else if (currentSuffix is PropertyReferenceSuffix) {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} // .NET indexer  	else {  		previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  	}  	return AccessOneByOne (previousTarget' currentTarget' suffixes.ExceptFirst ());  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentSuffix is PropertyReferenceSuffix || currentSuffix is IndexSuffix || currentSuffix is TypeDescriptorSuffix) {  	if (currentTarget is BikeObject) {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = ((BikeObject)currentTarget).Resolve (currentSuffixStr);  	} else if (currentTarget is Type)// Static context  	 {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		// Static generic call  		if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  			var typeParams = (Type[])suffixes [1].Accept (this);  			var args = GetArgumentValues ((Arguments)suffixes [2]);  			previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ().ExceptFirst ();  		} // Static method or delegate  		else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  			try {  				// delegate?  				previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  			} catch (BikeObject bo) {  				if (!ErrorFactory.IsClrError (bo))  					throw;  				// method?  invoke immediately to avoid saving MethodInfo  				var args = GetArgumentValues ((Arguments)suffixes [1]);  				previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  				suffixes = suffixes.ExceptFirst ();  			}  		} else// .NET static property' invoke immediately  		 {  			previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  		}  	} // Must be .NET generic instance method  	else if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var typeParams = (Type[])suffixes [1].Accept (this);  		var args = GetArgumentValues ((Arguments)suffixes [2]);  		previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ().ExceptFirst ();  	} // .NET instance method or delegate  	else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  		try {  			// delegate?  			var currentSuffixStr = currentSuffix.SuffixValue (this);  			previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  		} catch (BikeObject bo) {  			if (!ErrorFactory.IsClrError (bo))  				throw;  			// method?  			var currentSuffixStr = currentSuffix.SuffixValue (this);  			var args = GetArgumentValues ((Arguments)suffixes [1]);  			previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ();  		}  	} // .NET instance property  	else if (currentSuffix is PropertyReferenceSuffix) {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} // .NET indexer  	else {  		previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  	}  	return AccessOneByOne (previousTarget' currentTarget' suffixes.ExceptFirst ());  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentSuffix is PropertyReferenceSuffix || currentSuffix is IndexSuffix || currentSuffix is TypeDescriptorSuffix) {  	if (currentTarget is BikeObject) {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = ((BikeObject)currentTarget).Resolve (currentSuffixStr);  	} else if (currentTarget is Type)// Static context  	 {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		// Static generic call  		if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  			var typeParams = (Type[])suffixes [1].Accept (this);  			var args = GetArgumentValues ((Arguments)suffixes [2]);  			previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ().ExceptFirst ();  		} // Static method or delegate  		else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  			try {  				// delegate?  				previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  			} catch (BikeObject bo) {  				if (!ErrorFactory.IsClrError (bo))  					throw;  				// method?  invoke immediately to avoid saving MethodInfo  				var args = GetArgumentValues ((Arguments)suffixes [1]);  				previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  				suffixes = suffixes.ExceptFirst ();  			}  		} else// .NET static property' invoke immediately  		 {  			previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  		}  	} // Must be .NET generic instance method  	else if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var typeParams = (Type[])suffixes [1].Accept (this);  		var args = GetArgumentValues ((Arguments)suffixes [2]);  		previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ().ExceptFirst ();  	} // .NET instance method or delegate  	else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  		try {  			// delegate?  			var currentSuffixStr = currentSuffix.SuffixValue (this);  			previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  		} catch (BikeObject bo) {  			if (!ErrorFactory.IsClrError (bo))  				throw;  			// method?  			var currentSuffixStr = currentSuffix.SuffixValue (this);  			var args = GetArgumentValues ((Arguments)suffixes [1]);  			previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ();  		}  	} // .NET instance property  	else if (currentSuffix is PropertyReferenceSuffix) {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} // .NET indexer  	else {  		previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  	}  	return AccessOneByOne (previousTarget' currentTarget' suffixes.ExceptFirst ());  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentSuffix is PropertyReferenceSuffix || currentSuffix is IndexSuffix || currentSuffix is TypeDescriptorSuffix) {  	if (currentTarget is BikeObject) {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = ((BikeObject)currentTarget).Resolve (currentSuffixStr);  	} else if (currentTarget is Type)// Static context  	 {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		// Static generic call  		if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  			var typeParams = (Type[])suffixes [1].Accept (this);  			var args = GetArgumentValues ((Arguments)suffixes [2]);  			previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ().ExceptFirst ();  		} // Static method or delegate  		else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  			try {  				// delegate?  				previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  			} catch (BikeObject bo) {  				if (!ErrorFactory.IsClrError (bo))  					throw;  				// method?  invoke immediately to avoid saving MethodInfo  				var args = GetArgumentValues ((Arguments)suffixes [1]);  				previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  				suffixes = suffixes.ExceptFirst ();  			}  		} else// .NET static property' invoke immediately  		 {  			previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  		}  	} // Must be .NET generic instance method  	else if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var typeParams = (Type[])suffixes [1].Accept (this);  		var args = GetArgumentValues ((Arguments)suffixes [2]);  		previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ().ExceptFirst ();  	} // .NET instance method or delegate  	else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  		try {  			// delegate?  			var currentSuffixStr = currentSuffix.SuffixValue (this);  			previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  		} catch (BikeObject bo) {  			if (!ErrorFactory.IsClrError (bo))  				throw;  			// method?  			var currentSuffixStr = currentSuffix.SuffixValue (this);  			var args = GetArgumentValues ((Arguments)suffixes [1]);  			previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ();  		}  	} // .NET instance property  	else if (currentSuffix is PropertyReferenceSuffix) {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} // .NET indexer  	else {  		previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  	}  	return AccessOneByOne (previousTarget' currentTarget' suffixes.ExceptFirst ());  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentSuffix is PropertyReferenceSuffix || currentSuffix is IndexSuffix || currentSuffix is TypeDescriptorSuffix) {  	if (currentTarget is BikeObject) {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = ((BikeObject)currentTarget).Resolve (currentSuffixStr);  	} else if (currentTarget is Type)// Static context  	 {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		// Static generic call  		if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  			var typeParams = (Type[])suffixes [1].Accept (this);  			var args = GetArgumentValues ((Arguments)suffixes [2]);  			previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ().ExceptFirst ();  		} // Static method or delegate  		else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  			try {  				// delegate?  				previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  			} catch (BikeObject bo) {  				if (!ErrorFactory.IsClrError (bo))  					throw;  				// method?  invoke immediately to avoid saving MethodInfo  				var args = GetArgumentValues ((Arguments)suffixes [1]);  				previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  				suffixes = suffixes.ExceptFirst ();  			}  		} else// .NET static property' invoke immediately  		 {  			previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  		}  	} // Must be .NET generic instance method  	else if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var typeParams = (Type[])suffixes [1].Accept (this);  		var args = GetArgumentValues ((Arguments)suffixes [2]);  		previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ().ExceptFirst ();  	} // .NET instance method or delegate  	else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  		try {  			// delegate?  			var currentSuffixStr = currentSuffix.SuffixValue (this);  			previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  		} catch (BikeObject bo) {  			if (!ErrorFactory.IsClrError (bo))  				throw;  			// method?  			var currentSuffixStr = currentSuffix.SuffixValue (this);  			var args = GetArgumentValues ((Arguments)suffixes [1]);  			previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ();  		}  	} // .NET instance property  	else if (currentSuffix is PropertyReferenceSuffix) {  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} // .NET indexer  	else {  		previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  	}  	return AccessOneByOne (previousTarget' currentTarget' suffixes.ExceptFirst ());  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentTarget is BikeObject) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = ((BikeObject)currentTarget).Resolve (currentSuffixStr);  } else if (currentTarget is Type)// Static context   {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	// Static generic call  	if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  		var typeParams = (Type[])suffixes [1].Accept (this);  		var args = GetArgumentValues ((Arguments)suffixes [2]);  		previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ().ExceptFirst ();  	} // Static method or delegate  	else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  		try {  			// delegate?  			previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  		} catch (BikeObject bo) {  			if (!ErrorFactory.IsClrError (bo))  				throw;  			// method?  invoke immediately to avoid saving MethodInfo  			var args = GetArgumentValues ((Arguments)suffixes [1]);  			previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ();  		}  	} else// .NET static property' invoke immediately  	 {  		previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  	}  } // Must be .NET generic instance method  else if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	var typeParams = (Type[])suffixes [1].Accept (this);  	var args = GetArgumentValues ((Arguments)suffixes [2]);  	previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  	suffixes = suffixes.ExceptFirst ().ExceptFirst ();  } // .NET instance method or delegate  else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  	try {  		// delegate?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} catch (BikeObject bo) {  		if (!ErrorFactory.IsClrError (bo))  			throw;  		// method?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var args = GetArgumentValues ((Arguments)suffixes [1]);  		previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ();  	}  } // .NET instance property  else if (currentSuffix is PropertyReferenceSuffix) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  } // .NET indexer  else {  	previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentTarget is BikeObject) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = ((BikeObject)currentTarget).Resolve (currentSuffixStr);  } else if (currentTarget is Type)// Static context   {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	// Static generic call  	if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  		var typeParams = (Type[])suffixes [1].Accept (this);  		var args = GetArgumentValues ((Arguments)suffixes [2]);  		previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ().ExceptFirst ();  	} // Static method or delegate  	else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  		try {  			// delegate?  			previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  		} catch (BikeObject bo) {  			if (!ErrorFactory.IsClrError (bo))  				throw;  			// method?  invoke immediately to avoid saving MethodInfo  			var args = GetArgumentValues ((Arguments)suffixes [1]);  			previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ();  		}  	} else// .NET static property' invoke immediately  	 {  		previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  	}  } // Must be .NET generic instance method  else if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	var typeParams = (Type[])suffixes [1].Accept (this);  	var args = GetArgumentValues ((Arguments)suffixes [2]);  	previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  	suffixes = suffixes.ExceptFirst ().ExceptFirst ();  } // .NET instance method or delegate  else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  	try {  		// delegate?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} catch (BikeObject bo) {  		if (!ErrorFactory.IsClrError (bo))  			throw;  		// method?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var args = GetArgumentValues ((Arguments)suffixes [1]);  		previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ();  	}  } // .NET instance property  else if (currentSuffix is PropertyReferenceSuffix) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  } // .NET indexer  else {  	previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentTarget is BikeObject) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = ((BikeObject)currentTarget).Resolve (currentSuffixStr);  } else if (currentTarget is Type)// Static context   {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	// Static generic call  	if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  		var typeParams = (Type[])suffixes [1].Accept (this);  		var args = GetArgumentValues ((Arguments)suffixes [2]);  		previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ().ExceptFirst ();  	} // Static method or delegate  	else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  		try {  			// delegate?  			previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  		} catch (BikeObject bo) {  			if (!ErrorFactory.IsClrError (bo))  				throw;  			// method?  invoke immediately to avoid saving MethodInfo  			var args = GetArgumentValues ((Arguments)suffixes [1]);  			previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ();  		}  	} else// .NET static property' invoke immediately  	 {  		previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  	}  } // Must be .NET generic instance method  else if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	var typeParams = (Type[])suffixes [1].Accept (this);  	var args = GetArgumentValues ((Arguments)suffixes [2]);  	previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  	suffixes = suffixes.ExceptFirst ().ExceptFirst ();  } // .NET instance method or delegate  else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  	try {  		// delegate?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} catch (BikeObject bo) {  		if (!ErrorFactory.IsClrError (bo))  			throw;  		// method?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var args = GetArgumentValues ((Arguments)suffixes [1]);  		previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ();  	}  } // .NET instance property  else if (currentSuffix is PropertyReferenceSuffix) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  } // .NET indexer  else {  	previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentTarget is BikeObject) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = ((BikeObject)currentTarget).Resolve (currentSuffixStr);  } else if (currentTarget is Type)// Static context   {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	// Static generic call  	if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  		var typeParams = (Type[])suffixes [1].Accept (this);  		var args = GetArgumentValues ((Arguments)suffixes [2]);  		previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ().ExceptFirst ();  	} // Static method or delegate  	else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  		try {  			// delegate?  			previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  		} catch (BikeObject bo) {  			if (!ErrorFactory.IsClrError (bo))  				throw;  			// method?  invoke immediately to avoid saving MethodInfo  			var args = GetArgumentValues ((Arguments)suffixes [1]);  			previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ();  		}  	} else// .NET static property' invoke immediately  	 {  		previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  	}  } // Must be .NET generic instance method  else if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	var typeParams = (Type[])suffixes [1].Accept (this);  	var args = GetArgumentValues ((Arguments)suffixes [2]);  	previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  	suffixes = suffixes.ExceptFirst ().ExceptFirst ();  } // .NET instance method or delegate  else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  	try {  		// delegate?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} catch (BikeObject bo) {  		if (!ErrorFactory.IsClrError (bo))  			throw;  		// method?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var args = GetArgumentValues ((Arguments)suffixes [1]);  		previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ();  	}  } // .NET instance property  else if (currentSuffix is PropertyReferenceSuffix) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  } // .NET indexer  else {  	previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentTarget is BikeObject) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = ((BikeObject)currentTarget).Resolve (currentSuffixStr);  } else if (currentTarget is Type)// Static context   {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	// Static generic call  	if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  		var typeParams = (Type[])suffixes [1].Accept (this);  		var args = GetArgumentValues ((Arguments)suffixes [2]);  		previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ().ExceptFirst ();  	} // Static method or delegate  	else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  		try {  			// delegate?  			previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  		} catch (BikeObject bo) {  			if (!ErrorFactory.IsClrError (bo))  				throw;  			// method?  invoke immediately to avoid saving MethodInfo  			var args = GetArgumentValues ((Arguments)suffixes [1]);  			previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ();  		}  	} else// .NET static property' invoke immediately  	 {  		previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  	}  } // Must be .NET generic instance method  else if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	var typeParams = (Type[])suffixes [1].Accept (this);  	var args = GetArgumentValues ((Arguments)suffixes [2]);  	previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  	suffixes = suffixes.ExceptFirst ().ExceptFirst ();  } // .NET instance method or delegate  else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  	try {  		// delegate?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} catch (BikeObject bo) {  		if (!ErrorFactory.IsClrError (bo))  			throw;  		// method?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var args = GetArgumentValues ((Arguments)suffixes [1]);  		previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ();  	}  } // .NET instance property  else if (currentSuffix is PropertyReferenceSuffix) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  } // .NET indexer  else {  	previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentTarget is BikeObject) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = ((BikeObject)currentTarget).Resolve (currentSuffixStr);  } else if (currentTarget is Type)// Static context   {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	// Static generic call  	if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  		var typeParams = (Type[])suffixes [1].Accept (this);  		var args = GetArgumentValues ((Arguments)suffixes [2]);  		previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ().ExceptFirst ();  	} // Static method or delegate  	else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  		try {  			// delegate?  			previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  		} catch (BikeObject bo) {  			if (!ErrorFactory.IsClrError (bo))  				throw;  			// method?  invoke immediately to avoid saving MethodInfo  			var args = GetArgumentValues ((Arguments)suffixes [1]);  			previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ();  		}  	} else// .NET static property' invoke immediately  	 {  		previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  	}  } // Must be .NET generic instance method  else if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	var typeParams = (Type[])suffixes [1].Accept (this);  	var args = GetArgumentValues ((Arguments)suffixes [2]);  	previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  	suffixes = suffixes.ExceptFirst ().ExceptFirst ();  } // .NET instance method or delegate  else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  	try {  		// delegate?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} catch (BikeObject bo) {  		if (!ErrorFactory.IsClrError (bo))  			throw;  		// method?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var args = GetArgumentValues ((Arguments)suffixes [1]);  		previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ();  	}  } // .NET instance property  else if (currentSuffix is PropertyReferenceSuffix) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  } // .NET indexer  else {  	previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentTarget is Type)// Static context   {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	// Static generic call  	if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  		var typeParams = (Type[])suffixes [1].Accept (this);  		var args = GetArgumentValues ((Arguments)suffixes [2]);  		previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ().ExceptFirst ();  	} // Static method or delegate  	else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  		try {  			// delegate?  			previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  		} catch (BikeObject bo) {  			if (!ErrorFactory.IsClrError (bo))  				throw;  			// method?  invoke immediately to avoid saving MethodInfo  			var args = GetArgumentValues ((Arguments)suffixes [1]);  			previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ();  		}  	} else// .NET static property' invoke immediately  	 {  		previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  	}  } // Must be .NET generic instance method  else if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	var typeParams = (Type[])suffixes [1].Accept (this);  	var args = GetArgumentValues ((Arguments)suffixes [2]);  	previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  	suffixes = suffixes.ExceptFirst ().ExceptFirst ();  } // .NET instance method or delegate  else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  	try {  		// delegate?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} catch (BikeObject bo) {  		if (!ErrorFactory.IsClrError (bo))  			throw;  		// method?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var args = GetArgumentValues ((Arguments)suffixes [1]);  		previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ();  	}  } // .NET instance property  else if (currentSuffix is PropertyReferenceSuffix) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  } // .NET indexer  else {  	previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentTarget is Type)// Static context   {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	// Static generic call  	if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  		var typeParams = (Type[])suffixes [1].Accept (this);  		var args = GetArgumentValues ((Arguments)suffixes [2]);  		previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ().ExceptFirst ();  	} // Static method or delegate  	else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  		try {  			// delegate?  			previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  		} catch (BikeObject bo) {  			if (!ErrorFactory.IsClrError (bo))  				throw;  			// method?  invoke immediately to avoid saving MethodInfo  			var args = GetArgumentValues ((Arguments)suffixes [1]);  			previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ();  		}  	} else// .NET static property' invoke immediately  	 {  		previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  	}  } // Must be .NET generic instance method  else if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	var typeParams = (Type[])suffixes [1].Accept (this);  	var args = GetArgumentValues ((Arguments)suffixes [2]);  	previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  	suffixes = suffixes.ExceptFirst ().ExceptFirst ();  } // .NET instance method or delegate  else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  	try {  		// delegate?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} catch (BikeObject bo) {  		if (!ErrorFactory.IsClrError (bo))  			throw;  		// method?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var args = GetArgumentValues ((Arguments)suffixes [1]);  		previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ();  	}  } // .NET instance property  else if (currentSuffix is PropertyReferenceSuffix) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  } // .NET indexer  else {  	previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentTarget is Type)// Static context   {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	// Static generic call  	if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  		var typeParams = (Type[])suffixes [1].Accept (this);  		var args = GetArgumentValues ((Arguments)suffixes [2]);  		previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ().ExceptFirst ();  	} // Static method or delegate  	else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  		try {  			// delegate?  			previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  		} catch (BikeObject bo) {  			if (!ErrorFactory.IsClrError (bo))  				throw;  			// method?  invoke immediately to avoid saving MethodInfo  			var args = GetArgumentValues ((Arguments)suffixes [1]);  			previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ();  		}  	} else// .NET static property' invoke immediately  	 {  		previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  	}  } // Must be .NET generic instance method  else if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	var typeParams = (Type[])suffixes [1].Accept (this);  	var args = GetArgumentValues ((Arguments)suffixes [2]);  	previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  	suffixes = suffixes.ExceptFirst ().ExceptFirst ();  } // .NET instance method or delegate  else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  	try {  		// delegate?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} catch (BikeObject bo) {  		if (!ErrorFactory.IsClrError (bo))  			throw;  		// method?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var args = GetArgumentValues ((Arguments)suffixes [1]);  		previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ();  	}  } // .NET instance property  else if (currentSuffix is PropertyReferenceSuffix) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  } // .NET indexer  else {  	previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentTarget is Type)// Static context   {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	// Static generic call  	if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  		var typeParams = (Type[])suffixes [1].Accept (this);  		var args = GetArgumentValues ((Arguments)suffixes [2]);  		previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ().ExceptFirst ();  	} // Static method or delegate  	else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  		try {  			// delegate?  			previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  		} catch (BikeObject bo) {  			if (!ErrorFactory.IsClrError (bo))  				throw;  			// method?  invoke immediately to avoid saving MethodInfo  			var args = GetArgumentValues ((Arguments)suffixes [1]);  			previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ();  		}  	} else// .NET static property' invoke immediately  	 {  		previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  	}  } // Must be .NET generic instance method  else if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	var typeParams = (Type[])suffixes [1].Accept (this);  	var args = GetArgumentValues ((Arguments)suffixes [2]);  	previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  	suffixes = suffixes.ExceptFirst ().ExceptFirst ();  } // .NET instance method or delegate  else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  	try {  		// delegate?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} catch (BikeObject bo) {  		if (!ErrorFactory.IsClrError (bo))  			throw;  		// method?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var args = GetArgumentValues ((Arguments)suffixes [1]);  		previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ();  	}  } // .NET instance property  else if (currentSuffix is PropertyReferenceSuffix) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  } // .NET indexer  else {  	previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentTarget is Type)// Static context   {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	// Static generic call  	if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  		var typeParams = (Type[])suffixes [1].Accept (this);  		var args = GetArgumentValues ((Arguments)suffixes [2]);  		previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ().ExceptFirst ();  	} // Static method or delegate  	else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  		try {  			// delegate?  			previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  		} catch (BikeObject bo) {  			if (!ErrorFactory.IsClrError (bo))  				throw;  			// method?  invoke immediately to avoid saving MethodInfo  			var args = GetArgumentValues ((Arguments)suffixes [1]);  			previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ();  		}  	} else// .NET static property' invoke immediately  	 {  		previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  	}  } // Must be .NET generic instance method  else if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	var typeParams = (Type[])suffixes [1].Accept (this);  	var args = GetArgumentValues ((Arguments)suffixes [2]);  	previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  	suffixes = suffixes.ExceptFirst ().ExceptFirst ();  } // .NET instance method or delegate  else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  	try {  		// delegate?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} catch (BikeObject bo) {  		if (!ErrorFactory.IsClrError (bo))  			throw;  		// method?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var args = GetArgumentValues ((Arguments)suffixes [1]);  		previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ();  	}  } // .NET instance property  else if (currentSuffix is PropertyReferenceSuffix) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  } // .NET indexer  else {  	previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentTarget is Type)// Static context   {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	// Static generic call  	if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  		var typeParams = (Type[])suffixes [1].Accept (this);  		var args = GetArgumentValues ((Arguments)suffixes [2]);  		previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ().ExceptFirst ();  	} // Static method or delegate  	else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  		try {  			// delegate?  			previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  		} catch (BikeObject bo) {  			if (!ErrorFactory.IsClrError (bo))  				throw;  			// method?  invoke immediately to avoid saving MethodInfo  			var args = GetArgumentValues ((Arguments)suffixes [1]);  			previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  			suffixes = suffixes.ExceptFirst ();  		}  	} else// .NET static property' invoke immediately  	 {  		previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  	}  } // Must be .NET generic instance method  else if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	var typeParams = (Type[])suffixes [1].Accept (this);  	var args = GetArgumentValues ((Arguments)suffixes [2]);  	previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  	suffixes = suffixes.ExceptFirst ().ExceptFirst ();  } // .NET instance method or delegate  else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  	try {  		// delegate?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} catch (BikeObject bo) {  		if (!ErrorFactory.IsClrError (bo))  			throw;  		// method?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var args = GetArgumentValues ((Arguments)suffixes [1]);  		previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ();  	}  } // .NET instance property  else if (currentSuffix is PropertyReferenceSuffix) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  } // .NET indexer  else {  	previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  	var typeParams = (Type[])suffixes [1].Accept (this);  	var args = GetArgumentValues ((Arguments)suffixes [2]);  	previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  	suffixes = suffixes.ExceptFirst ().ExceptFirst ();  } // Static method or delegate  else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  	try {  		// delegate?  		previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  	} catch (BikeObject bo) {  		if (!ErrorFactory.IsClrError (bo))  			throw;  		// method?  invoke immediately to avoid saving MethodInfo  		var args = GetArgumentValues ((Arguments)suffixes [1]);  		previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ();  	}  } else// .NET static property' invoke immediately   {  	previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  	var typeParams = (Type[])suffixes [1].Accept (this);  	var args = GetArgumentValues ((Arguments)suffixes [2]);  	previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  	suffixes = suffixes.ExceptFirst ().ExceptFirst ();  } // Static method or delegate  else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  	try {  		// delegate?  		previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  	} catch (BikeObject bo) {  		if (!ErrorFactory.IsClrError (bo))  			throw;  		// method?  invoke immediately to avoid saving MethodInfo  		var args = GetArgumentValues ((Arguments)suffixes [1]);  		previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ();  	}  } else// .NET static property' invoke immediately   {  	previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  	var typeParams = (Type[])suffixes [1].Accept (this);  	var args = GetArgumentValues ((Arguments)suffixes [2]);  	previousTarget = CallStaticFunction ((Type)currentTarget' typeParams' currentSuffixStr' args);  	suffixes = suffixes.ExceptFirst ().ExceptFirst ();  } // Static method or delegate  else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  	try {  		// delegate?  		previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  	} catch (BikeObject bo) {  		if (!ErrorFactory.IsClrError (bo))  			throw;  		// method?  invoke immediately to avoid saving MethodInfo  		var args = GetArgumentValues ((Arguments)suffixes [1]);  		previousTarget = CallStaticFunction ((Type)currentTarget' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ();  	}  } else// .NET static property' invoke immediately   {  	previousTarget = GetStaticProperty ((Type)currentTarget' currentSuffixStr);  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	var typeParams = (Type[])suffixes [1].Accept (this);  	var args = GetArgumentValues ((Arguments)suffixes [2]);  	previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  	suffixes = suffixes.ExceptFirst ().ExceptFirst ();  } // .NET instance method or delegate  else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  	try {  		// delegate?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} catch (BikeObject bo) {  		if (!ErrorFactory.IsClrError (bo))  			throw;  		// method?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var args = GetArgumentValues ((Arguments)suffixes [1]);  		previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ();  	}  } // .NET instance property  else if (currentSuffix is PropertyReferenceSuffix) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  } // .NET indexer  else {  	previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	var typeParams = (Type[])suffixes [1].Accept (this);  	var args = GetArgumentValues ((Arguments)suffixes [2]);  	previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  	suffixes = suffixes.ExceptFirst ().ExceptFirst ();  } // .NET instance method or delegate  else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  	try {  		// delegate?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} catch (BikeObject bo) {  		if (!ErrorFactory.IsClrError (bo))  			throw;  		// method?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var args = GetArgumentValues ((Arguments)suffixes [1]);  		previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ();  	}  } // .NET instance property  else if (currentSuffix is PropertyReferenceSuffix) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  } // .NET indexer  else {  	previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (suffixes.Count > 2 && suffixes [1] is TypeDescriptorSuffix && suffixes [2] is Arguments) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	var typeParams = (Type[])suffixes [1].Accept (this);  	var args = GetArgumentValues ((Arguments)suffixes [2]);  	previousTarget = CallInstanceFunction (currentTarget' typeParams' currentSuffixStr' args);  	suffixes = suffixes.ExceptFirst ().ExceptFirst ();  } // .NET instance method or delegate  else if (suffixes.Count > 1 && suffixes [1] is Arguments) {  	try {  		// delegate?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  	} catch (BikeObject bo) {  		if (!ErrorFactory.IsClrError (bo))  			throw;  		// method?  		var currentSuffixStr = currentSuffix.SuffixValue (this);  		var args = GetArgumentValues ((Arguments)suffixes [1]);  		previousTarget = CallInstanceFunction (currentTarget' currentSuffixStr' args);  		suffixes = suffixes.ExceptFirst ();  	}  } // .NET instance property  else if (currentSuffix is PropertyReferenceSuffix) {  	var currentSuffixStr = currentSuffix.SuffixValue (this);  	previousTarget = GetInstanceProperty (currentTarget' currentSuffixStr);  } // .NET indexer  else {  	previousTarget = GetInstanceIndexer (currentTarget' currentSuffix.Arguments (this));  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptObjectPassThrough,The following statement contains a magic number: if (target is Type) {  	if ((Type)target == typeof(System.Runtime.CompilerServices.RuntimeHelpers)) {  		if (funcName == "Equals") {  			if (args == null || args.Length != 2)  				throw ErrorFactory.CreateClrError ("Equals() expect 2 arguments");  			// Forwards to RuntimeHelpers.Equals() doesn't work under Mac OSX's Mono  			result = args [0] == args [1];  			return true;  		}  		if (funcName == "GetHashCode") {  			if (args == null || args.Length != 1)  				throw ErrorFactory.CreateClrError ("GetHashCode() expect 1 argument");  			result = System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode (args [0]);  			return true;  		}  	} else if ((Type)target == typeof(System.Threading.Monitor)) {  		if (funcName == "Enter" || funcName == "Exit" || funcName == "Wait" || funcName == "Pulse" || funcName == "PulseAll") {  			if (args == null || args.Length != 1)  				throw ErrorFactory.CreateClrError (string.Format ("Monitor.{0}() expect 1 argument"' funcName));  			result = typeof(System.Threading.Monitor).CallMethod (funcName' args [0]);  			return true;  		}  		if (funcName == "TryEnter") {  			if (args == null || (args.Length < 1 || args.Length > 2))  				throw ErrorFactory.CreateClrError (string.Format ("Monitor.{0}() expect 1 or 2 arguments"' funcName));  			if (args.Length == 1)  				result = System.Threading.Monitor.TryEnter (args [0]);  			else  				result = System.Threading.Monitor.TryEnter (args [0]' (int)(decimal)InterpretationContext.Instance.Interpreter.MarshallToClr (args [1]));  			return true;  		}  	}  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptObjectPassThrough,The following statement contains a magic number: if (target is Type) {  	if ((Type)target == typeof(System.Runtime.CompilerServices.RuntimeHelpers)) {  		if (funcName == "Equals") {  			if (args == null || args.Length != 2)  				throw ErrorFactory.CreateClrError ("Equals() expect 2 arguments");  			// Forwards to RuntimeHelpers.Equals() doesn't work under Mac OSX's Mono  			result = args [0] == args [1];  			return true;  		}  		if (funcName == "GetHashCode") {  			if (args == null || args.Length != 1)  				throw ErrorFactory.CreateClrError ("GetHashCode() expect 1 argument");  			result = System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode (args [0]);  			return true;  		}  	} else if ((Type)target == typeof(System.Threading.Monitor)) {  		if (funcName == "Enter" || funcName == "Exit" || funcName == "Wait" || funcName == "Pulse" || funcName == "PulseAll") {  			if (args == null || args.Length != 1)  				throw ErrorFactory.CreateClrError (string.Format ("Monitor.{0}() expect 1 argument"' funcName));  			result = typeof(System.Threading.Monitor).CallMethod (funcName' args [0]);  			return true;  		}  		if (funcName == "TryEnter") {  			if (args == null || (args.Length < 1 || args.Length > 2))  				throw ErrorFactory.CreateClrError (string.Format ("Monitor.{0}() expect 1 or 2 arguments"' funcName));  			if (args.Length == 1)  				result = System.Threading.Monitor.TryEnter (args [0]);  			else  				result = System.Threading.Monitor.TryEnter (args [0]' (int)(decimal)InterpretationContext.Instance.Interpreter.MarshallToClr (args [1]));  			return true;  		}  	}  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptObjectPassThrough,The following statement contains a magic number: if ((Type)target == typeof(System.Runtime.CompilerServices.RuntimeHelpers)) {  	if (funcName == "Equals") {  		if (args == null || args.Length != 2)  			throw ErrorFactory.CreateClrError ("Equals() expect 2 arguments");  		// Forwards to RuntimeHelpers.Equals() doesn't work under Mac OSX's Mono  		result = args [0] == args [1];  		return true;  	}  	if (funcName == "GetHashCode") {  		if (args == null || args.Length != 1)  			throw ErrorFactory.CreateClrError ("GetHashCode() expect 1 argument");  		result = System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode (args [0]);  		return true;  	}  } else if ((Type)target == typeof(System.Threading.Monitor)) {  	if (funcName == "Enter" || funcName == "Exit" || funcName == "Wait" || funcName == "Pulse" || funcName == "PulseAll") {  		if (args == null || args.Length != 1)  			throw ErrorFactory.CreateClrError (string.Format ("Monitor.{0}() expect 1 argument"' funcName));  		result = typeof(System.Threading.Monitor).CallMethod (funcName' args [0]);  		return true;  	}  	if (funcName == "TryEnter") {  		if (args == null || (args.Length < 1 || args.Length > 2))  			throw ErrorFactory.CreateClrError (string.Format ("Monitor.{0}() expect 1 or 2 arguments"' funcName));  		if (args.Length == 1)  			result = System.Threading.Monitor.TryEnter (args [0]);  		else  			result = System.Threading.Monitor.TryEnter (args [0]' (int)(decimal)InterpretationContext.Instance.Interpreter.MarshallToClr (args [1]));  		return true;  	}  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptObjectPassThrough,The following statement contains a magic number: if ((Type)target == typeof(System.Runtime.CompilerServices.RuntimeHelpers)) {  	if (funcName == "Equals") {  		if (args == null || args.Length != 2)  			throw ErrorFactory.CreateClrError ("Equals() expect 2 arguments");  		// Forwards to RuntimeHelpers.Equals() doesn't work under Mac OSX's Mono  		result = args [0] == args [1];  		return true;  	}  	if (funcName == "GetHashCode") {  		if (args == null || args.Length != 1)  			throw ErrorFactory.CreateClrError ("GetHashCode() expect 1 argument");  		result = System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode (args [0]);  		return true;  	}  } else if ((Type)target == typeof(System.Threading.Monitor)) {  	if (funcName == "Enter" || funcName == "Exit" || funcName == "Wait" || funcName == "Pulse" || funcName == "PulseAll") {  		if (args == null || args.Length != 1)  			throw ErrorFactory.CreateClrError (string.Format ("Monitor.{0}() expect 1 argument"' funcName));  		result = typeof(System.Threading.Monitor).CallMethod (funcName' args [0]);  		return true;  	}  	if (funcName == "TryEnter") {  		if (args == null || (args.Length < 1 || args.Length > 2))  			throw ErrorFactory.CreateClrError (string.Format ("Monitor.{0}() expect 1 or 2 arguments"' funcName));  		if (args.Length == 1)  			result = System.Threading.Monitor.TryEnter (args [0]);  		else  			result = System.Threading.Monitor.TryEnter (args [0]' (int)(decimal)InterpretationContext.Instance.Interpreter.MarshallToClr (args [1]));  		return true;  	}  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptObjectPassThrough,The following statement contains a magic number: if (funcName == "Equals") {  	if (args == null || args.Length != 2)  		throw ErrorFactory.CreateClrError ("Equals() expect 2 arguments");  	// Forwards to RuntimeHelpers.Equals() doesn't work under Mac OSX's Mono  	result = args [0] == args [1];  	return true;  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptObjectPassThrough,The following statement contains a magic number: if (args == null || args.Length != 2)  	throw ErrorFactory.CreateClrError ("Equals() expect 2 arguments");  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptObjectPassThrough,The following statement contains a magic number: if ((Type)target == typeof(System.Threading.Monitor)) {  	if (funcName == "Enter" || funcName == "Exit" || funcName == "Wait" || funcName == "Pulse" || funcName == "PulseAll") {  		if (args == null || args.Length != 1)  			throw ErrorFactory.CreateClrError (string.Format ("Monitor.{0}() expect 1 argument"' funcName));  		result = typeof(System.Threading.Monitor).CallMethod (funcName' args [0]);  		return true;  	}  	if (funcName == "TryEnter") {  		if (args == null || (args.Length < 1 || args.Length > 2))  			throw ErrorFactory.CreateClrError (string.Format ("Monitor.{0}() expect 1 or 2 arguments"' funcName));  		if (args.Length == 1)  			result = System.Threading.Monitor.TryEnter (args [0]);  		else  			result = System.Threading.Monitor.TryEnter (args [0]' (int)(decimal)InterpretationContext.Instance.Interpreter.MarshallToClr (args [1]));  		return true;  	}  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptObjectPassThrough,The following statement contains a magic number: if (funcName == "TryEnter") {  	if (args == null || (args.Length < 1 || args.Length > 2))  		throw ErrorFactory.CreateClrError (string.Format ("Monitor.{0}() expect 1 or 2 arguments"' funcName));  	if (args.Length == 1)  		result = System.Threading.Monitor.TryEnter (args [0]);  	else  		result = System.Threading.Monitor.TryEnter (args [0]' (int)(decimal)InterpretationContext.Instance.Interpreter.MarshallToClr (args [1]));  	return true;  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptObjectPassThrough,The following statement contains a magic number: if (args == null || (args.Length < 1 || args.Length > 2))  	throw ErrorFactory.CreateClrError (string.Format ("Monitor.{0}() expect 1 or 2 arguments"' funcName));  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptArrayIndex,The following statement contains a magic number: if (target is Array) {  	if (funcName == IndexerGetterName) {  		if (args.Length != 1)  			throw ErrorFactory.CreateClrError ("Invalid number of indexer arguments");  		int index = args [0] is BikeNumber ? (int)((BikeNumber)args [0]).Value : (int)(decimal)args [0];  		result = ((Array)target).GetValue (index);  		return true;  	}  	if (funcName == IndexerSetterName) {  		if (args.Length != 2)  			throw ErrorFactory.CreateClrError ("Invalid number of indexer arguments");  		int index = args [0] is BikeNumber ? (int)((BikeNumber)args [0]).Value : (int)(decimal)args [0];  		object value = InterpretationContext.Instance.Interpreter.MarshallToClr (args [1]);  		((Array)target).SetValue (value' index);  		result = null;  		return true;  	}  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptArrayIndex,The following statement contains a magic number: if (funcName == IndexerSetterName) {  	if (args.Length != 2)  		throw ErrorFactory.CreateClrError ("Invalid number of indexer arguments");  	int index = args [0] is BikeNumber ? (int)((BikeNumber)args [0]).Value : (int)(decimal)args [0];  	object value = InterpretationContext.Instance.Interpreter.MarshallToClr (args [1]);  	((Array)target).SetValue (value' index);  	result = null;  	return true;  }  
Magic Number,Bike.Interpreter,Interpreter,D:\newReposJune17\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptArrayIndex,The following statement contains a magic number: if (args.Length != 2)  	throw ErrorFactory.CreateClrError ("Invalid number of indexer arguments");  
