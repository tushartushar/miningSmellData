Implementation smell,Namespace,Class,File,Method,Description
Long Method,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The method has 122 lines of code.
Complex Method,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,GetFirstObjectFromMember,Cyclomatic complexity of the method is 11
Complex Method,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,MarshallToBike,Cyclomatic complexity of the method is 8
Complex Method,Bike.Interpreter,TypeCompatibilityRule,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Interop.Conversion.cs,Convert,Cyclomatic complexity of the method is 8
Long Parameter List,Bike.Interpreter.Builtin,BikeFunction,C:\repos\buunguyen_bike\src\Bike\Interpreter\Builtin\BikeFunction.cs,BikeFunction,The method has 5 parameters. Parameters: node' funcName' parameters' body' boundScope
Long Parameter List,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AssignSwitch,The method has 6 parameters. Parameters: operator' target' suffix' lvThunk' rvThunk' staticDotNetAssign
Long Parameter List,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AddHandler,The method has 5 parameters. Parameters: target' name' bikeFunc' interpreter' isStatic
Long Parameter List,Bike.Interpreter,InterpretationContext,C:\repos\buunguyen_bike\src\Bike\Interpreter\Context\InterpretationContext.cs,OpenScopeFor,The method has 5 parameters. Parameters: body' when' withInit' parentScope' func
Long Parameter List,Bike.Interpreter,InterpretationContext,C:\repos\buunguyen_bike\src\Bike\Interpreter\Context\InterpretationContext.cs,OpenScopeFor,The method has 5 parameters. Parameters: body' when' withInit' parentScope' func
Long Parameter List,Bike.Interpreter,ScopeStack,C:\repos\buunguyen_bike\src\Bike\Interpreter\Scope\ScopeStack.cs,OpenScopeFor,The method has 5 parameters. Parameters: body' when' withInit' parentScope' func
Long Parameter List,Bike.Interpreter,ScopeStack,C:\repos\buunguyen_bike\src\Bike\Interpreter\Scope\ScopeStack.cs,OpenScopeFor,The method has 5 parameters. Parameters: body' when' withInit' parentScope' func
Long Parameter List,Bike.Interpreter,ScopeFrame,C:\repos\buunguyen_bike\src\Bike\Interpreter\Scope\ScopeFrame.cs,ScopeFrame,The method has 5 parameters. Parameters: location' func' global' parent' caller
Long Statement,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,GetInstanceProperty,The length of the statement  "            throw ErrorFactory.CreateClrError(string.Format("Cannot resolve field or property {0} of type {1}"' propName' target.GetType())); " is 129.
Long Statement,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,SetInstanceProperty,The length of the statement  "            throw ErrorFactory.CreateClrError(string.Format("Cannot resolve field or property {0} of type {1}"' propName' target.GetType())); " is 129.
Long Statement,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,GetStaticProperty,The length of the statement  "			throw ErrorFactory.CreateClrError(string.Format("Cannot resolve static field or property {0} of type {1}"' propName' type)); " is 124.
Long Statement,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,SetStaticProperty,The length of the statement  "            throw ErrorFactory.CreateClrError(string.Format("Cannot resolve static field or property {0} of type {1}"' propName' type)); " is 124.
Complex Conditional,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptObjectPassThrough,The conditional expression  "funcName == "Enter" || funcName == "Exit" ||                           funcName == "Wait" || funcName == "Pulse" || funcName == "PulseAll""  is complex.
Complex Conditional,Bike.Interpreter,TypeCompatibilityRule,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Interop.Conversion.cs,Convert,The conditional expression  "targetType == typeof(char) && !(value is char) && (!(value is string) || ((string)value).Length != 1)"  is complex.
Complex Conditional,Bike.Parser,Lexer,C:\repos\buunguyen_bike\src\Bike\Parser\Lexer.cs,Next,The conditional expression  "currentChar == '\r' ||                       (currentChar == '\n' && (previousChar == Eof || previousChar != '\r'))"  is complex.
Complex Conditional,Bike.Parser,Lexer,C:\repos\buunguyen_bike\src\Bike\Parser\Lexer.cs,Whitespace,The conditional expression  "currentChar == ' ' ||                     currentChar == '\t' ||                     currentChar == '\r' ||                     currentChar == '\n'"  is complex.
Complex Conditional,Bike.Parser,Parser,C:\repos\buunguyen_bike\src\Bike\Parser\Parser.cs,ParseRelationalExpression,The conditional expression  "Next().IsNot(TokenType.LessThan) &&                  Next().IsNot(TokenType.LessThanOrEqual) &&                  Next().IsNot(TokenType.GreaterThan) &&                  Next().IsNot(TokenType.GreaterThanOrEqual) &&                  Next().IsNot(TokenType.Is)"  is complex.
Complex Conditional,Bike.Parser,Parser,C:\repos\buunguyen_bike\src\Bike\Parser\Parser.cs,ParseUnaryExpression,The conditional expression  "token.Is(TokenType.DoublePlus) ||                   token.Is(TokenType.DoubleMinus) ||                   token.Is(TokenType.Plus) ||                   token.Is(TokenType.Minus) ||                   token.Is(TokenType.Not)"  is complex.
Complex Conditional,Bike.Parser,Parser,C:\repos\buunguyen_bike\src\Bike\Parser\Parser.cs,ParsePrimitiveLiteral,The conditional expression  "!token.Is(TokenType.Null) &&                  !token.Is(TokenType.True) &&                  !token.Is(TokenType.False) &&                  !token.Is(TokenType.String) &&                  !token.Is(TokenType.Number)"  is complex.
Magic Number,Bike.Ast,FormalParameter,C:\repos\buunguyen_bike\src\Bike\Ast\Declarations\FormalParameter.cs,GetHashCode,The following statement contains a magic number: return 31*IsParams.GetHashCode() + Identifier.GetHashCode();
Magic Number,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,GetFirstObjectFromMember,The following statement contains a magic number: if (memberExp is Identifier)  			{  				var id = ((Identifier)memberExp).Value;  				if (Context.CurrentFrame.Exist(id))  					return Context.CurrentFrame.Resolve(id);    				// TODO handle nested type  				// propably CLR type  				if (!(suffixes[0] is TypeDescriptorSuffix) && Context.IsClrType(id))  					return Context.LoadTypeFromName(id);    				// start with namespace?  attempt further  				for (int i = 0; i < suffixes.Count; i++)  				{  					var suffix = suffixes[i];  					if (suffix is IndexSuffix)  						break;    					if (suffix is TypeDescriptorSuffix)  					{  						var typeParams = (Type[])suffix.Accept(this);  						suffixes.RemoveRange(0' i + 1);  						return Context.LoadTypeFromName(id' typeParams);  					}    					id += "." + suffix.SuffixValue(this);  					if (i < suffixes.Count - 1 && (suffixes[i + 1] is TypeDescriptorSuffix))  					{  						var typeParams = (Type[])suffixes[i + 1].Accept(this);  						suffixes.RemoveRange(0' i + 2);  						return Context.LoadTypeFromName(id' typeParams);  					}    					if (Context.IsClrType(id))  					{  						suffixes.RemoveRange(0' i + 1);  						return Context.LoadTypeFromName(id);  					}  				}                    if (id.IndexOf('.') >= 0)                      id = id.Substring(0' id.IndexOf('.'));  				throw ErrorFactory.CreateNotDefinedError(id);  			}
Magic Number,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentSuffix is PropertyReferenceSuffix ||   				currentSuffix is IndexSuffix ||   				currentSuffix is TypeDescriptorSuffix)  			{  				if (currentTarget is BikeObject)  				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);  					previousTarget = ((BikeObject)currentTarget).Resolve(currentSuffixStr);  				}  				else if (currentTarget is Type) // Static context  				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);    					// Static generic call  					if (suffixes.Count > 2 &&  						suffixes[1] is TypeDescriptorSuffix &&  						suffixes[2] is Arguments  						)  					{  						var typeParams = (Type[])suffixes[1].Accept(this);  						var args = GetArgumentValues((Arguments)suffixes[2]);  						previousTarget = CallStaticFunction((Type)currentTarget' typeParams' currentSuffixStr' args);  						suffixes = suffixes.ExceptFirst().ExceptFirst();  					}    					// Static method or delegate  					else if (suffixes.Count > 1 && suffixes[1] is Arguments)  					{  						try  						{  							// delegate?  							previousTarget = GetStaticProperty((Type)currentTarget' currentSuffixStr);  						}  						catch (BikeObject bo)  						{  							if (!ErrorFactory.IsClrError(bo))  								throw;  							// method?  invoke immediately to avoid saving MethodInfo  							var args = GetArgumentValues((Arguments)suffixes[1]);  							previousTarget = CallStaticFunction((Type)currentTarget' currentSuffixStr' args);  							suffixes = suffixes.ExceptFirst();  						}  					}  					else // .NET static property' invoke immediately  					{  						previousTarget = GetStaticProperty((Type)currentTarget' currentSuffixStr);  					}  				}    				// Must be .NET generic instance method  				else if (suffixes.Count > 2 &&  						suffixes[1] is TypeDescriptorSuffix &&  						suffixes[2] is Arguments)  				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);  					var typeParams = (Type[])suffixes[1].Accept(this);  					var args = GetArgumentValues((Arguments)suffixes[2]);  					previousTarget = CallInstanceFunction(currentTarget' typeParams' currentSuffixStr' args);  					suffixes = suffixes.ExceptFirst().ExceptFirst();  				}    				// .NET instance method or delegate  				else if (suffixes.Count > 1 && suffixes[1] is Arguments)  				{  					try  					{  						// delegate?  						var currentSuffixStr = currentSuffix.SuffixValue(this);  						previousTarget = GetInstanceProperty(currentTarget' currentSuffixStr);  					}  					catch (BikeObject bo)  					{  						if (!ErrorFactory.IsClrError(bo))  							throw;  						// method?  						var currentSuffixStr = currentSuffix.SuffixValue(this);  						var args = GetArgumentValues((Arguments)suffixes[1]);  						previousTarget = CallInstanceFunction(currentTarget' currentSuffixStr' args);  						suffixes = suffixes.ExceptFirst();  					}  				}                    // .NET instance property  				else if (currentSuffix is PropertyReferenceSuffix)   				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);  					previousTarget = GetInstanceProperty(currentTarget' currentSuffixStr);  				}                    // .NET indexer  				else   				{  					previousTarget = GetInstanceIndexer(currentTarget' currentSuffix.Arguments(this));  				}  				return AccessOneByOne(previousTarget' currentTarget' suffixes.ExceptFirst());  			}
Magic Number,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentSuffix is PropertyReferenceSuffix ||   				currentSuffix is IndexSuffix ||   				currentSuffix is TypeDescriptorSuffix)  			{  				if (currentTarget is BikeObject)  				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);  					previousTarget = ((BikeObject)currentTarget).Resolve(currentSuffixStr);  				}  				else if (currentTarget is Type) // Static context  				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);    					// Static generic call  					if (suffixes.Count > 2 &&  						suffixes[1] is TypeDescriptorSuffix &&  						suffixes[2] is Arguments  						)  					{  						var typeParams = (Type[])suffixes[1].Accept(this);  						var args = GetArgumentValues((Arguments)suffixes[2]);  						previousTarget = CallStaticFunction((Type)currentTarget' typeParams' currentSuffixStr' args);  						suffixes = suffixes.ExceptFirst().ExceptFirst();  					}    					// Static method or delegate  					else if (suffixes.Count > 1 && suffixes[1] is Arguments)  					{  						try  						{  							// delegate?  							previousTarget = GetStaticProperty((Type)currentTarget' currentSuffixStr);  						}  						catch (BikeObject bo)  						{  							if (!ErrorFactory.IsClrError(bo))  								throw;  							// method?  invoke immediately to avoid saving MethodInfo  							var args = GetArgumentValues((Arguments)suffixes[1]);  							previousTarget = CallStaticFunction((Type)currentTarget' currentSuffixStr' args);  							suffixes = suffixes.ExceptFirst();  						}  					}  					else // .NET static property' invoke immediately  					{  						previousTarget = GetStaticProperty((Type)currentTarget' currentSuffixStr);  					}  				}    				// Must be .NET generic instance method  				else if (suffixes.Count > 2 &&  						suffixes[1] is TypeDescriptorSuffix &&  						suffixes[2] is Arguments)  				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);  					var typeParams = (Type[])suffixes[1].Accept(this);  					var args = GetArgumentValues((Arguments)suffixes[2]);  					previousTarget = CallInstanceFunction(currentTarget' typeParams' currentSuffixStr' args);  					suffixes = suffixes.ExceptFirst().ExceptFirst();  				}    				// .NET instance method or delegate  				else if (suffixes.Count > 1 && suffixes[1] is Arguments)  				{  					try  					{  						// delegate?  						var currentSuffixStr = currentSuffix.SuffixValue(this);  						previousTarget = GetInstanceProperty(currentTarget' currentSuffixStr);  					}  					catch (BikeObject bo)  					{  						if (!ErrorFactory.IsClrError(bo))  							throw;  						// method?  						var currentSuffixStr = currentSuffix.SuffixValue(this);  						var args = GetArgumentValues((Arguments)suffixes[1]);  						previousTarget = CallInstanceFunction(currentTarget' currentSuffixStr' args);  						suffixes = suffixes.ExceptFirst();  					}  				}                    // .NET instance property  				else if (currentSuffix is PropertyReferenceSuffix)   				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);  					previousTarget = GetInstanceProperty(currentTarget' currentSuffixStr);  				}                    // .NET indexer  				else   				{  					previousTarget = GetInstanceIndexer(currentTarget' currentSuffix.Arguments(this));  				}  				return AccessOneByOne(previousTarget' currentTarget' suffixes.ExceptFirst());  			}
Magic Number,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentSuffix is PropertyReferenceSuffix ||   				currentSuffix is IndexSuffix ||   				currentSuffix is TypeDescriptorSuffix)  			{  				if (currentTarget is BikeObject)  				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);  					previousTarget = ((BikeObject)currentTarget).Resolve(currentSuffixStr);  				}  				else if (currentTarget is Type) // Static context  				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);    					// Static generic call  					if (suffixes.Count > 2 &&  						suffixes[1] is TypeDescriptorSuffix &&  						suffixes[2] is Arguments  						)  					{  						var typeParams = (Type[])suffixes[1].Accept(this);  						var args = GetArgumentValues((Arguments)suffixes[2]);  						previousTarget = CallStaticFunction((Type)currentTarget' typeParams' currentSuffixStr' args);  						suffixes = suffixes.ExceptFirst().ExceptFirst();  					}    					// Static method or delegate  					else if (suffixes.Count > 1 && suffixes[1] is Arguments)  					{  						try  						{  							// delegate?  							previousTarget = GetStaticProperty((Type)currentTarget' currentSuffixStr);  						}  						catch (BikeObject bo)  						{  							if (!ErrorFactory.IsClrError(bo))  								throw;  							// method?  invoke immediately to avoid saving MethodInfo  							var args = GetArgumentValues((Arguments)suffixes[1]);  							previousTarget = CallStaticFunction((Type)currentTarget' currentSuffixStr' args);  							suffixes = suffixes.ExceptFirst();  						}  					}  					else // .NET static property' invoke immediately  					{  						previousTarget = GetStaticProperty((Type)currentTarget' currentSuffixStr);  					}  				}    				// Must be .NET generic instance method  				else if (suffixes.Count > 2 &&  						suffixes[1] is TypeDescriptorSuffix &&  						suffixes[2] is Arguments)  				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);  					var typeParams = (Type[])suffixes[1].Accept(this);  					var args = GetArgumentValues((Arguments)suffixes[2]);  					previousTarget = CallInstanceFunction(currentTarget' typeParams' currentSuffixStr' args);  					suffixes = suffixes.ExceptFirst().ExceptFirst();  				}    				// .NET instance method or delegate  				else if (suffixes.Count > 1 && suffixes[1] is Arguments)  				{  					try  					{  						// delegate?  						var currentSuffixStr = currentSuffix.SuffixValue(this);  						previousTarget = GetInstanceProperty(currentTarget' currentSuffixStr);  					}  					catch (BikeObject bo)  					{  						if (!ErrorFactory.IsClrError(bo))  							throw;  						// method?  						var currentSuffixStr = currentSuffix.SuffixValue(this);  						var args = GetArgumentValues((Arguments)suffixes[1]);  						previousTarget = CallInstanceFunction(currentTarget' currentSuffixStr' args);  						suffixes = suffixes.ExceptFirst();  					}  				}                    // .NET instance property  				else if (currentSuffix is PropertyReferenceSuffix)   				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);  					previousTarget = GetInstanceProperty(currentTarget' currentSuffixStr);  				}                    // .NET indexer  				else   				{  					previousTarget = GetInstanceIndexer(currentTarget' currentSuffix.Arguments(this));  				}  				return AccessOneByOne(previousTarget' currentTarget' suffixes.ExceptFirst());  			}
Magic Number,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentSuffix is PropertyReferenceSuffix ||   				currentSuffix is IndexSuffix ||   				currentSuffix is TypeDescriptorSuffix)  			{  				if (currentTarget is BikeObject)  				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);  					previousTarget = ((BikeObject)currentTarget).Resolve(currentSuffixStr);  				}  				else if (currentTarget is Type) // Static context  				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);    					// Static generic call  					if (suffixes.Count > 2 &&  						suffixes[1] is TypeDescriptorSuffix &&  						suffixes[2] is Arguments  						)  					{  						var typeParams = (Type[])suffixes[1].Accept(this);  						var args = GetArgumentValues((Arguments)suffixes[2]);  						previousTarget = CallStaticFunction((Type)currentTarget' typeParams' currentSuffixStr' args);  						suffixes = suffixes.ExceptFirst().ExceptFirst();  					}    					// Static method or delegate  					else if (suffixes.Count > 1 && suffixes[1] is Arguments)  					{  						try  						{  							// delegate?  							previousTarget = GetStaticProperty((Type)currentTarget' currentSuffixStr);  						}  						catch (BikeObject bo)  						{  							if (!ErrorFactory.IsClrError(bo))  								throw;  							// method?  invoke immediately to avoid saving MethodInfo  							var args = GetArgumentValues((Arguments)suffixes[1]);  							previousTarget = CallStaticFunction((Type)currentTarget' currentSuffixStr' args);  							suffixes = suffixes.ExceptFirst();  						}  					}  					else // .NET static property' invoke immediately  					{  						previousTarget = GetStaticProperty((Type)currentTarget' currentSuffixStr);  					}  				}    				// Must be .NET generic instance method  				else if (suffixes.Count > 2 &&  						suffixes[1] is TypeDescriptorSuffix &&  						suffixes[2] is Arguments)  				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);  					var typeParams = (Type[])suffixes[1].Accept(this);  					var args = GetArgumentValues((Arguments)suffixes[2]);  					previousTarget = CallInstanceFunction(currentTarget' typeParams' currentSuffixStr' args);  					suffixes = suffixes.ExceptFirst().ExceptFirst();  				}    				// .NET instance method or delegate  				else if (suffixes.Count > 1 && suffixes[1] is Arguments)  				{  					try  					{  						// delegate?  						var currentSuffixStr = currentSuffix.SuffixValue(this);  						previousTarget = GetInstanceProperty(currentTarget' currentSuffixStr);  					}  					catch (BikeObject bo)  					{  						if (!ErrorFactory.IsClrError(bo))  							throw;  						// method?  						var currentSuffixStr = currentSuffix.SuffixValue(this);  						var args = GetArgumentValues((Arguments)suffixes[1]);  						previousTarget = CallInstanceFunction(currentTarget' currentSuffixStr' args);  						suffixes = suffixes.ExceptFirst();  					}  				}                    // .NET instance property  				else if (currentSuffix is PropertyReferenceSuffix)   				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);  					previousTarget = GetInstanceProperty(currentTarget' currentSuffixStr);  				}                    // .NET indexer  				else   				{  					previousTarget = GetInstanceIndexer(currentTarget' currentSuffix.Arguments(this));  				}  				return AccessOneByOne(previousTarget' currentTarget' suffixes.ExceptFirst());  			}
Magic Number,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentSuffix is PropertyReferenceSuffix ||   				currentSuffix is IndexSuffix ||   				currentSuffix is TypeDescriptorSuffix)  			{  				if (currentTarget is BikeObject)  				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);  					previousTarget = ((BikeObject)currentTarget).Resolve(currentSuffixStr);  				}  				else if (currentTarget is Type) // Static context  				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);    					// Static generic call  					if (suffixes.Count > 2 &&  						suffixes[1] is TypeDescriptorSuffix &&  						suffixes[2] is Arguments  						)  					{  						var typeParams = (Type[])suffixes[1].Accept(this);  						var args = GetArgumentValues((Arguments)suffixes[2]);  						previousTarget = CallStaticFunction((Type)currentTarget' typeParams' currentSuffixStr' args);  						suffixes = suffixes.ExceptFirst().ExceptFirst();  					}    					// Static method or delegate  					else if (suffixes.Count > 1 && suffixes[1] is Arguments)  					{  						try  						{  							// delegate?  							previousTarget = GetStaticProperty((Type)currentTarget' currentSuffixStr);  						}  						catch (BikeObject bo)  						{  							if (!ErrorFactory.IsClrError(bo))  								throw;  							// method?  invoke immediately to avoid saving MethodInfo  							var args = GetArgumentValues((Arguments)suffixes[1]);  							previousTarget = CallStaticFunction((Type)currentTarget' currentSuffixStr' args);  							suffixes = suffixes.ExceptFirst();  						}  					}  					else // .NET static property' invoke immediately  					{  						previousTarget = GetStaticProperty((Type)currentTarget' currentSuffixStr);  					}  				}    				// Must be .NET generic instance method  				else if (suffixes.Count > 2 &&  						suffixes[1] is TypeDescriptorSuffix &&  						suffixes[2] is Arguments)  				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);  					var typeParams = (Type[])suffixes[1].Accept(this);  					var args = GetArgumentValues((Arguments)suffixes[2]);  					previousTarget = CallInstanceFunction(currentTarget' typeParams' currentSuffixStr' args);  					suffixes = suffixes.ExceptFirst().ExceptFirst();  				}    				// .NET instance method or delegate  				else if (suffixes.Count > 1 && suffixes[1] is Arguments)  				{  					try  					{  						// delegate?  						var currentSuffixStr = currentSuffix.SuffixValue(this);  						previousTarget = GetInstanceProperty(currentTarget' currentSuffixStr);  					}  					catch (BikeObject bo)  					{  						if (!ErrorFactory.IsClrError(bo))  							throw;  						// method?  						var currentSuffixStr = currentSuffix.SuffixValue(this);  						var args = GetArgumentValues((Arguments)suffixes[1]);  						previousTarget = CallInstanceFunction(currentTarget' currentSuffixStr' args);  						suffixes = suffixes.ExceptFirst();  					}  				}                    // .NET instance property  				else if (currentSuffix is PropertyReferenceSuffix)   				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);  					previousTarget = GetInstanceProperty(currentTarget' currentSuffixStr);  				}                    // .NET indexer  				else   				{  					previousTarget = GetInstanceIndexer(currentTarget' currentSuffix.Arguments(this));  				}  				return AccessOneByOne(previousTarget' currentTarget' suffixes.ExceptFirst());  			}
Magic Number,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,AccessOneByOne,The following statement contains a magic number: if (currentSuffix is PropertyReferenceSuffix ||   				currentSuffix is IndexSuffix ||   				currentSuffix is TypeDescriptorSuffix)  			{  				if (currentTarget is BikeObject)  				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);  					previousTarget = ((BikeObject)currentTarget).Resolve(currentSuffixStr);  				}  				else if (currentTarget is Type) // Static context  				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);    					// Static generic call  					if (suffixes.Count > 2 &&  						suffixes[1] is TypeDescriptorSuffix &&  						suffixes[2] is Arguments  						)  					{  						var typeParams = (Type[])suffixes[1].Accept(this);  						var args = GetArgumentValues((Arguments)suffixes[2]);  						previousTarget = CallStaticFunction((Type)currentTarget' typeParams' currentSuffixStr' args);  						suffixes = suffixes.ExceptFirst().ExceptFirst();  					}    					// Static method or delegate  					else if (suffixes.Count > 1 && suffixes[1] is Arguments)  					{  						try  						{  							// delegate?  							previousTarget = GetStaticProperty((Type)currentTarget' currentSuffixStr);  						}  						catch (BikeObject bo)  						{  							if (!ErrorFactory.IsClrError(bo))  								throw;  							// method?  invoke immediately to avoid saving MethodInfo  							var args = GetArgumentValues((Arguments)suffixes[1]);  							previousTarget = CallStaticFunction((Type)currentTarget' currentSuffixStr' args);  							suffixes = suffixes.ExceptFirst();  						}  					}  					else // .NET static property' invoke immediately  					{  						previousTarget = GetStaticProperty((Type)currentTarget' currentSuffixStr);  					}  				}    				// Must be .NET generic instance method  				else if (suffixes.Count > 2 &&  						suffixes[1] is TypeDescriptorSuffix &&  						suffixes[2] is Arguments)  				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);  					var typeParams = (Type[])suffixes[1].Accept(this);  					var args = GetArgumentValues((Arguments)suffixes[2]);  					previousTarget = CallInstanceFunction(currentTarget' typeParams' currentSuffixStr' args);  					suffixes = suffixes.ExceptFirst().ExceptFirst();  				}    				// .NET instance method or delegate  				else if (suffixes.Count > 1 && suffixes[1] is Arguments)  				{  					try  					{  						// delegate?  						var currentSuffixStr = currentSuffix.SuffixValue(this);  						previousTarget = GetInstanceProperty(currentTarget' currentSuffixStr);  					}  					catch (BikeObject bo)  					{  						if (!ErrorFactory.IsClrError(bo))  							throw;  						// method?  						var currentSuffixStr = currentSuffix.SuffixValue(this);  						var args = GetArgumentValues((Arguments)suffixes[1]);  						previousTarget = CallInstanceFunction(currentTarget' currentSuffixStr' args);  						suffixes = suffixes.ExceptFirst();  					}  				}                    // .NET instance property  				else if (currentSuffix is PropertyReferenceSuffix)   				{  					var currentSuffixStr = currentSuffix.SuffixValue(this);  					previousTarget = GetInstanceProperty(currentTarget' currentSuffixStr);  				}                    // .NET indexer  				else   				{  					previousTarget = GetInstanceIndexer(currentTarget' currentSuffix.Arguments(this));  				}  				return AccessOneByOne(previousTarget' currentTarget' suffixes.ExceptFirst());  			}
Magic Number,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptObjectPassThrough,The following statement contains a magic number: if (target is Type)              {                  if ((Type)target == typeof(System.Runtime.CompilerServices.RuntimeHelpers))                  {                      if (funcName == "Equals")                      {                          if (args == null || args.Length != 2)                              throw ErrorFactory.CreateClrError("Equals() expect 2 arguments");  						  						// Forwards to RuntimeHelpers.Equals() doesn't work under Mac OSX's Mono  						result = args[0] == args[1];                          return true;                      }                      if (funcName == "GetHashCode")                      {                          if (args == null || args.Length != 1)                              throw ErrorFactory.CreateClrError("GetHashCode() expect 1 argument");                          result = System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(args[0]);                          return true;                      }                  }                  else if ((Type)target == typeof(System.Threading.Monitor))                  {                      if (funcName == "Enter" || funcName == "Exit" ||                           funcName == "Wait" || funcName == "Pulse" || funcName == "PulseAll")                      {                          if (args == null || args.Length != 1)                              throw ErrorFactory.CreateClrError(string.Format("Monitor.{0}() expect 1 argument"' funcName));                          result = typeof(System.Threading.Monitor).CallMethod(funcName' args[0]);                          return true;                      }                      if (funcName == "TryEnter")                      {                          if (args == null || (args.Length < 1 || args.Length > 2))                              throw ErrorFactory.CreateClrError(string.Format("Monitor.{0}() expect 1 or 2 arguments"' funcName));                          if (args.Length == 1)                              result = System.Threading.Monitor.TryEnter(args[0]);                          else                              result = System.Threading.Monitor.TryEnter(args[0]'                                   (int)(decimal)InterpretationContext.Instance.Interpreter                                  .MarshallToClr(args[1]));                          return true;                      }                  }              }
Magic Number,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptObjectPassThrough,The following statement contains a magic number: if (target is Type)              {                  if ((Type)target == typeof(System.Runtime.CompilerServices.RuntimeHelpers))                  {                      if (funcName == "Equals")                      {                          if (args == null || args.Length != 2)                              throw ErrorFactory.CreateClrError("Equals() expect 2 arguments");  						  						// Forwards to RuntimeHelpers.Equals() doesn't work under Mac OSX's Mono  						result = args[0] == args[1];                          return true;                      }                      if (funcName == "GetHashCode")                      {                          if (args == null || args.Length != 1)                              throw ErrorFactory.CreateClrError("GetHashCode() expect 1 argument");                          result = System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(args[0]);                          return true;                      }                  }                  else if ((Type)target == typeof(System.Threading.Monitor))                  {                      if (funcName == "Enter" || funcName == "Exit" ||                           funcName == "Wait" || funcName == "Pulse" || funcName == "PulseAll")                      {                          if (args == null || args.Length != 1)                              throw ErrorFactory.CreateClrError(string.Format("Monitor.{0}() expect 1 argument"' funcName));                          result = typeof(System.Threading.Monitor).CallMethod(funcName' args[0]);                          return true;                      }                      if (funcName == "TryEnter")                      {                          if (args == null || (args.Length < 1 || args.Length > 2))                              throw ErrorFactory.CreateClrError(string.Format("Monitor.{0}() expect 1 or 2 arguments"' funcName));                          if (args.Length == 1)                              result = System.Threading.Monitor.TryEnter(args[0]);                          else                              result = System.Threading.Monitor.TryEnter(args[0]'                                   (int)(decimal)InterpretationContext.Instance.Interpreter                                  .MarshallToClr(args[1]));                          return true;                      }                  }              }
Magic Number,Bike.Interpreter,Interpreter,C:\repos\buunguyen_bike\src\Bike\Interpreter\Interpreter.Assignment.cs,InterceptArrayIndex,The following statement contains a magic number: if (target is Array)              {                  if (funcName == IndexerGetterName)                  {                      if (args.Length != 1)                          throw ErrorFactory.CreateClrError("Invalid number of indexer arguments");                      int index = args[0] is BikeNumber                                      ? (int) ((BikeNumber) args[0]).Value                                      : (int) (decimal) args[0];                      result = ((Array)target).GetValue(index);                      return true;                  }                  if (funcName == IndexerSetterName)                  {                      if (args.Length != 2)                          throw ErrorFactory.CreateClrError("Invalid number of indexer arguments");                      int index = args[0] is BikeNumber                                      ? (int)((BikeNumber)args[0]).Value                                      : (int)(decimal)args[0];                      object value = InterpretationContext.Instance.Interpreter.MarshallToClr(args[1]);                      ((Array)target).SetValue(value' index);                      result = null;                      return true;                  }              }
