Implementation smell,Namespace,Class,File,Method,Description
Long Method,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncrypMemoryStreamAsync,The method has 145 lines of code.
Long Method,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStreamAsync,The method has 150 lines of code.
Long Method,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileStreamWithStreamAsync,The method has 125 lines of code.
Long Method,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The method has 172 lines of code.
Long Method,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The method has 122 lines of code.
Long Method,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptMemoryStreamAsync,The method has 124 lines of code.
Complex Method,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncrypMemoryStreamAsync,Cyclomatic complexity of the method is 10
Complex Method,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStreamAsync,Cyclomatic complexity of the method is 10
Long Parameter List,StreamCryptor.Model,EncryptedFileHeader,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Model\EncryptedFileHeader.cs,EncryptedFileHeader,The method has 7 parameters. Parameters: currentVersion' nonceLength' chunkBaseNonceLength' unencryptedFileLength' senderPrivateKey' senderPublicKey' recipientPublicKey
Long Parameter List,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileChunk,The method has 5 parameters. Parameters: unencryptedChunk' chunkNumber' baseNonce' ephemeralKey' isLast
Long Parameter List,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStream,The method has 5 parameters. Parameters: senderKeyPair' inputFile' outputFolder' fileExtension' maskFileName
Long Parameter List,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStream,The method has 6 parameters. Parameters: senderKeyPair' recipientPublicKey' inputFile' outputFolder' fileExtension' maskFileName
Long Parameter List,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStream,The method has 7 parameters. Parameters: senderPrivateKey' senderPublicKey' recipientPublicKey' inputFile' outputFolder' fileExtension' maskFileName
Long Parameter List,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncrypMemoryStreamAsync,The method has 10 parameters. Parameters: senderPrivateKey' senderPublicKey' recipientPublicKey' filename' inputStream' outputFolder' fileExtension' maskFileName' encryptionProgress' cancellationToken
Long Parameter List,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStreamAsync,The method has 7 parameters. Parameters: senderKeyPair' inputFile' encryptionProgress' outputFolder' fileExtension' maskFileName' cancellationToken
Long Parameter List,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStreamAsync,The method has 8 parameters. Parameters: senderKeyPair' recipientPublicKey' inputFile' encryptionProgress' outputFolder' fileExtension' maskFileName' cancellationToken
Long Parameter List,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStreamAsync,The method has 9 parameters. Parameters: senderPrivateKey' senderPublicKey' recipientPublicKey' inputFile' encryptionProgress' outputFolder' fileExtension' maskFileName' cancellationToken
Long Parameter List,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileStreamWithStreamAsync,The method has 10 parameters. Parameters: senderPrivateKey' senderPublicKey' recipientPublicKey' inputStream' outputFolder' originalFileName' encryptionProgress' fileExtension' maskFileName' cancellationToken
Long Parameter List,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The method has 6 parameters. Parameters: keyPair' inputFile' outputFolder' decryptionProgress' overWrite' cancellationToken
Long Parameter List,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The method has 6 parameters. Parameters: recipientPrivateKey' inputFile' outputFolder' decryptionProgress' overWrite' cancellationToken
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,GetChunkNonce,The length of the statement  "                throw new ArgumentOutOfRangeException("chunkNumber"' string.Format("chunkNumber must be {0} or positive."' CHUNK_MIN_NUMBER)); " is 126.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStream,The length of the statement  "                var task = Task.Run(async () => await EncryptFileWithStreamAsync(senderKeyPair.PrivateKey' senderKeyPair.PublicKey' senderKeyPair.PublicKey' inputFile' null' outputFolder' fileExtension' maskFileName).ConfigureAwait(false)); " is 224.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStream,The length of the statement  "                var task = Task.Run(async () => await EncryptFileWithStreamAsync(senderKeyPair.PrivateKey' senderKeyPair.PublicKey' recipientPublicKey' inputFile' null' outputFolder' fileExtension' maskFileName).ConfigureAwait(false)); " is 219.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStream,The length of the statement  "                var task = Task.Run(async () => await EncryptFileWithStreamAsync(senderPrivateKey' senderPublicKey' recipientPublicKey' inputFile' null' outputFolder' fileExtension' maskFileName).ConfigureAwait(false)); " is 203.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStream,The length of the statement  "                var task = Task.Run(async () => await DecryptFileWithStreamAsync(keyPair.PrivateKey' inputFile' outputFolder' null' overWrite).ConfigureAwait(false)); " is 150.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStream,The length of the statement  "                var task = Task.Run(async () => await DecryptFileWithStreamAsync(recipientPrivateKey' inputFile' outputFolder' null' overWrite).ConfigureAwait(false)); " is 151.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncrypMemoryStreamAsync,The length of the statement  "                throw new ArgumentOutOfRangeException("filename"' string.Format("filename name must be smaller {0} in length."' MAX_FILENAME_LENGTH)); " is 134.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStreamAsync,The length of the statement  "            return await EncryptFileWithStreamAsync(senderKeyPair.PrivateKey' senderKeyPair.PublicKey' senderKeyPair.PublicKey' inputFile' encryptionProgress' outputFolder' fileExtension' maskFileName' cancellationToken).ConfigureAwait(false); " is 231.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStreamAsync,The length of the statement  "            return await EncryptFileWithStreamAsync(senderKeyPair.PrivateKey' senderKeyPair.PublicKey' recipientPublicKey' inputFile' encryptionProgress' outputFolder' fileExtension' maskFileName' cancellationToken).ConfigureAwait(false); " is 226.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStreamAsync,The length of the statement  "                throw new ArgumentOutOfRangeException("inputFile"' string.Format("inputFile name must be smaller {0} in length."' MAX_FILENAME_LENGTH)); " is 136.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStreamAsync,The length of the statement  "                        bytesRead = await fileStreamUnencrypted.ReadAsync(unencryptedChunk' 0' CHUNK_LENGTH' cancellationToken).ConfigureAwait(false); " is 126.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStreamAsync,The length of the statement  "                                encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' true); " is 146.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStreamAsync,The length of the statement  "                                    encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' true); " is 146.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStreamAsync,The length of the statement  "                                    encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' false); " is 147.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStreamAsync,The length of the statement  "                                args.ProgressPercentage = (int)(encryptedFileHeader.UnencryptedFileLength <= 0 ? 0 : (100 * overallBytesRead) / encryptedFileHeader.UnencryptedFileLength); " is 155.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStreamAsync,The length of the statement  "                            encryptedFileFooter.SetFooterChecksum(BitConverter.GetBytes(chunkNumber)' BitConverter.GetBytes(overallChunkLength)' encryptedFileHeader.UnencryptedEphemeralKey' FOOTER_CHECKSUM_LENGTH); " is 186.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileStreamWithStreamAsync,The length of the statement  "								encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' true); " is 146.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileStreamWithStreamAsync,The length of the statement  "									encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' true); " is 146.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileStreamWithStreamAsync,The length of the statement  "									encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' false); " is 147.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileStreamWithStreamAsync,The length of the statement  "								args.ProgressPercentage = (int)(encryptedFileHeader.UnencryptedFileLength <= 0 ? 0 : (100 * overallBytesRead) / encryptedFileHeader.UnencryptedFileLength); " is 155.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileStreamWithStreamAsync,The length of the statement  "							encryptedFileFooter.SetFooterChecksum(BitConverter.GetBytes(chunkNumber)' BitConverter.GetBytes(overallChunkLength)' encryptedFileHeader.UnencryptedEphemeralKey' FOOTER_CHECKSUM_LENGTH); " is 186.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The length of the statement  "            return await DecryptFileWithStreamAsync(keyPair.PrivateKey' inputFile' outputFolder' decryptionProgress' overWrite' cancellationToken).ConfigureAwait(false); " is 157.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The length of the statement  "                    EncryptedFileHeader encryptedFileHeader = Serializer.DeserializeWithLengthPrefix<EncryptedFileHeader>(fileStreamEncrypted' PrefixStyle.Base128' 1); " is 147.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The length of the statement  "                    byte[] ephemeralKey = PublicKeyBox.Open(encryptedFileHeader.Key' encryptedFileHeader.EphemeralNonce' recipientPrivateKey' encryptedFileHeader.SenderPublicKey); " is 159.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The length of the statement  "                        byte[] decryptedPaddedFileName = SecretBox.Open(encryptedFileHeader.Filename' encryptedFileHeader.FilenameNonce' Utils.GetEphemeralEncryptionKey(ephemeralKey)); " is 160.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The length of the statement  "                            while ((encryptedFileChunk = Serializer.DeserializeWithLengthPrefix<EncryptedFileChunk>(fileStreamEncrypted' PrefixStyle.Base128' 2)) != null) " is 142.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The length of the statement  "                                    args.ProgressPercentage = (int)(encryptedFileHeader.UnencryptedFileLength <= 0 ? 0 : (100 * overallBytesRead) / encryptedFileHeader.UnencryptedFileLength); " is 155.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The length of the statement  "                        encryptedFileFooter = Serializer.DeserializeWithLengthPrefix<EncryptedFileFooter>(fileStreamEncrypted' PrefixStyle.Base128' 3); " is 127.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The length of the statement  "                        encryptedFileFooter.ValidateFooterChecksum(BitConverter.GetBytes(chunkNumber)' BitConverter.GetBytes(overallChunkLength)' ephemeralKey' FOOTER_CHECKSUM_LENGTH); " is 160.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The length of the statement  "            return await DecryptFileWithStreamAsync(keyPair.PrivateKey' inputFile' decryptionProgress' cancellationToken).ConfigureAwait(false); " is 132.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The length of the statement  "                    encryptedFileHeader = Serializer.DeserializeWithLengthPrefix<EncryptedFileHeader>(fileStreamEncrypted' PrefixStyle.Base128' 1); " is 127.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The length of the statement  "                    byte[] ephemeralKey = PublicKeyBox.Open(encryptedFileHeader.Key' encryptedFileHeader.EphemeralNonce' recipientPrivateKey' encryptedFileHeader.SenderPublicKey); " is 159.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The length of the statement  "                        byte[] encryptedPaddedFileName = SecretBox.Open(encryptedFileHeader.Filename' encryptedFileHeader.FilenameNonce' Utils.GetEphemeralEncryptionKey(ephemeralKey)); " is 160.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The length of the statement  "                            while ((encryptedFileChunk = Serializer.DeserializeWithLengthPrefix<EncryptedFileChunk>(fileStreamEncrypted' PrefixStyle.Base128' 2)) != null) " is 142.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The length of the statement  "                                    args.ProgressPercentage = (int)(encryptedFileHeader.UnencryptedFileLength <= 0 ? 0 : (100 * overallBytesRead) / encryptedFileHeader.UnencryptedFileLength); " is 155.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The length of the statement  "                        encryptedFileFooter = Serializer.DeserializeWithLengthPrefix<EncryptedFileFooter>(fileStreamEncrypted' PrefixStyle.Base128' 3); " is 127.
Long Statement,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The length of the statement  "                        encryptedFileFooter.ValidateFooterChecksum(BitConverter.GetBytes(chunkNumber)' BitConverter.GetBytes(overallChunkLength)' ephemeralKey' FOOTER_CHECKSUM_LENGTH); " is 160.
Magic Number,StreamCryptor.Helper,Utils,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Helper\Utils.cs,GetEphemeralEncryptionKey,The following statement contains a magic number: return ArrayHelpers.SubArray(ephemeralKey' 0' 32);
Magic Number,StreamCryptor.Helper,Utils,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Helper\Utils.cs,GetEphemeralHashKey,The following statement contains a magic number: return ArrayHelpers.SubArray(ephemeralKey' 32);
Magic Number,StreamCryptor.Helper,Utils,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Helper\Utils.cs,IntegerToLittleEndian,The following statement contains a magic number: var le = new byte[8];
Magic Number,StreamCryptor.Helper,Utils,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Helper\Utils.cs,IntegerToLittleEndian,The following statement contains a magic number: le[1] = (byte) (((uint) data >> 8) & 0xFF);
Magic Number,StreamCryptor.Helper,Utils,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Helper\Utils.cs,IntegerToLittleEndian,The following statement contains a magic number: le[2] = (byte) (((uint) data >> 16) & 0xFF);
Magic Number,StreamCryptor.Helper,Utils,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Helper\Utils.cs,IntegerToLittleEndian,The following statement contains a magic number: le[2] = (byte) (((uint) data >> 16) & 0xFF);
Magic Number,StreamCryptor.Helper,Utils,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Helper\Utils.cs,IntegerToLittleEndian,The following statement contains a magic number: le[3] = (byte) (((uint) data >> 24) & 0xFF);
Magic Number,StreamCryptor.Helper,Utils,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Helper\Utils.cs,IntegerToLittleEndian,The following statement contains a magic number: le[3] = (byte) (((uint) data >> 24) & 0xFF);
Magic Number,StreamCryptor.Helper,Utils,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Helper\Utils.cs,GetRandomFileName,The following statement contains a magic number: var array = new string[54]              {                  "0"' "2"' "3"' "4"' "5"' "6"' "8"' "9"'                  "a"' "b"' "c"' "d"' "e"' "f"' "g"' "h"' "j"' "k"' "m"' "n"' "p"' "q"' "r"' "s"' "t"' "u"' "v"' "w"' "x"' "y"' "z"'                  "A"' "B"' "C"' "D"' "E"' "F"' "G"' "H"' "J"' "K"' "L"' "M"' "N"' "P"' "R"' "S"' "T"' "U"' "V"' "W"' "X"' "Y"' "Z"              };
Magic Number,StreamCryptor.Helper,Utils,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Helper\Utils.cs,StringToPaddedByteArray,The following statement contains a magic number: if (str.Length > 256)              {                  throw new ArgumentOutOfRangeException("str"' "str must be <= 256 chars");              }
Magic Number,StreamCryptor.Helper,Utils,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Helper\Utils.cs,StringToPaddedByteArray,The following statement contains a magic number: if (paddingLength > 256)              {                  throw new ArgumentOutOfRangeException("paddingLength"' "paddingLength must be <= 256");              }
Magic Number,StreamCryptor.Helper,Utils,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Helper\Utils.cs,AddPkcs7Padding,The following statement contains a magic number: if (data.Length > 256)              {                  throw new ArgumentOutOfRangeException("data"' "data must be <= 256 in length");              }
Magic Number,StreamCryptor.Helper,Utils,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Helper\Utils.cs,AddPkcs7Padding,The following statement contains a magic number: if (paddingLength > 256)              {                  throw new ArgumentOutOfRangeException("paddingLength"' "paddingLength must be <= 256");              }
Magic Number,StreamCryptor.Model,EncryptedFileHeader,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Model\EncryptedFileHeader.cs,EncryptedFileHeader,The following statement contains a magic number: UnencryptedEphemeralKey = SodiumCore.GetRandomBytes(64);
Magic Number,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,GetChunkNonce,The following statement contains a magic number: if (isLastChunkInStream)                  concatNonce[23] |= 0x80;
Magic Number,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncrypMemoryStreamAsync,The following statement contains a magic number: using (FileStream fileStreamEncrypted = File.OpenWrite(outputFullPath))              {                    //initialize our file header for encryption                  EncryptedFileHeader encryptedFileHeader = new EncryptedFileHeader(                      CURRENT_VERSION' NONCE_LENGTH' CHUNK_BASE_NONCE_LENGTH' inputStream.Length'                      senderPrivateKey' senderPublicKey' recipientPublicKey);                  //protect and set the file name to the header                  encryptedFileHeader.ProtectFileName(filename' MAX_FILENAME_LENGTH);                  //generate and set the checksum to validate our file header on decryption                  encryptedFileHeader.SetHeaderChecksum(HEADER_CHECKSUM_LENGTH);                  //write the file header to the stream                  Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileHeader' PrefixStyle.Base128' 1);                  //we start at chunk number 0                  int chunkNumber = CHUNK_COUNT_START;                  //used to calculate the footer checksum                  long overallChunkLength = 0;                  //used for progress reporting                  long overallBytesRead = 0;                  int bytesRead;                  do                  {                      //cancel the task if requested                      cancellationToken.ThrowIfCancellationRequested();                      //start reading the unencrypted file in chunks of the given length: CHUNK_LENGTH                      byte[] unencryptedChunk = new byte[CHUNK_LENGTH];                      bytesRead =                          await inputStream.ReadAsync(unencryptedChunk' 0' CHUNK_LENGTH' cancellationToken).ConfigureAwait(false);                      //check if there is still some work                      if (bytesRead != 0)                      {                          //prepare the EncryptedFileChunk                          EncryptedFileChunk encryptedFileChunk = new EncryptedFileChunk();                          byte[] readedBytes = new byte[bytesRead];                          //cut unreaded bytes                          Array.Copy(unencryptedChunk' readedBytes' bytesRead);                          //check if the file is smaller or equal the CHUNK_LENGTH                          if (encryptedFileHeader.UnencryptedFileLength <= CHUNK_LENGTH)                          {                              //so we have the one and only chunk                              encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce'                                  encryptedFileHeader.UnencryptedEphemeralKey' true);                          }                          else                          {                              //let`s check if this chunk is smaller than the given CHUNK_LENGTH                              if (bytesRead < CHUNK_LENGTH)                              {                                  //it`s the last chunk in the stream                                  encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce'                                      encryptedFileHeader.UnencryptedEphemeralKey' true);                              }                              else                              {                                  //it`s a full chunk                                  encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce'                                      encryptedFileHeader.UnencryptedEphemeralKey' false);                              }                          }                          overallChunkLength += encryptedFileChunk.Chunk.Length;                          //write encryptedFileChunk to the output stream                          Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileChunk' PrefixStyle.Base128' 2);                          //increment for the next chunk                          chunkNumber++;                          overallBytesRead += bytesRead;                          //report status                          if (encryptionProgress != null)                          {                              var args = new StreamCryptorTaskAsyncProgress();                              args.ProgressPercentage =                                  (int)                                      (encryptedFileHeader.UnencryptedFileLength <= 0                                          ? 0                                          : (100 * overallBytesRead) / encryptedFileHeader.UnencryptedFileLength);                              encryptionProgress.Report(args);                          }                      }                      else                      {                          //Prepare the EncryptedFileFooter for encryption.                          EncryptedFileFooter encryptedFileFooter = new EncryptedFileFooter();                          //generate the FooterChecksum                          encryptedFileFooter.SetFooterChecksum(BitConverter.GetBytes(chunkNumber)'                              BitConverter.GetBytes(overallChunkLength)' encryptedFileHeader.UnencryptedEphemeralKey' FOOTER_CHECKSUM_LENGTH);                          //put the footer to the stream                          Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileFooter' PrefixStyle.Base128' 3);                      }                  } while (bytesRead != 0);                }
Magic Number,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncrypMemoryStreamAsync,The following statement contains a magic number: using (FileStream fileStreamEncrypted = File.OpenWrite(outputFullPath))              {                    //initialize our file header for encryption                  EncryptedFileHeader encryptedFileHeader = new EncryptedFileHeader(                      CURRENT_VERSION' NONCE_LENGTH' CHUNK_BASE_NONCE_LENGTH' inputStream.Length'                      senderPrivateKey' senderPublicKey' recipientPublicKey);                  //protect and set the file name to the header                  encryptedFileHeader.ProtectFileName(filename' MAX_FILENAME_LENGTH);                  //generate and set the checksum to validate our file header on decryption                  encryptedFileHeader.SetHeaderChecksum(HEADER_CHECKSUM_LENGTH);                  //write the file header to the stream                  Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileHeader' PrefixStyle.Base128' 1);                  //we start at chunk number 0                  int chunkNumber = CHUNK_COUNT_START;                  //used to calculate the footer checksum                  long overallChunkLength = 0;                  //used for progress reporting                  long overallBytesRead = 0;                  int bytesRead;                  do                  {                      //cancel the task if requested                      cancellationToken.ThrowIfCancellationRequested();                      //start reading the unencrypted file in chunks of the given length: CHUNK_LENGTH                      byte[] unencryptedChunk = new byte[CHUNK_LENGTH];                      bytesRead =                          await inputStream.ReadAsync(unencryptedChunk' 0' CHUNK_LENGTH' cancellationToken).ConfigureAwait(false);                      //check if there is still some work                      if (bytesRead != 0)                      {                          //prepare the EncryptedFileChunk                          EncryptedFileChunk encryptedFileChunk = new EncryptedFileChunk();                          byte[] readedBytes = new byte[bytesRead];                          //cut unreaded bytes                          Array.Copy(unencryptedChunk' readedBytes' bytesRead);                          //check if the file is smaller or equal the CHUNK_LENGTH                          if (encryptedFileHeader.UnencryptedFileLength <= CHUNK_LENGTH)                          {                              //so we have the one and only chunk                              encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce'                                  encryptedFileHeader.UnencryptedEphemeralKey' true);                          }                          else                          {                              //let`s check if this chunk is smaller than the given CHUNK_LENGTH                              if (bytesRead < CHUNK_LENGTH)                              {                                  //it`s the last chunk in the stream                                  encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce'                                      encryptedFileHeader.UnencryptedEphemeralKey' true);                              }                              else                              {                                  //it`s a full chunk                                  encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce'                                      encryptedFileHeader.UnencryptedEphemeralKey' false);                              }                          }                          overallChunkLength += encryptedFileChunk.Chunk.Length;                          //write encryptedFileChunk to the output stream                          Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileChunk' PrefixStyle.Base128' 2);                          //increment for the next chunk                          chunkNumber++;                          overallBytesRead += bytesRead;                          //report status                          if (encryptionProgress != null)                          {                              var args = new StreamCryptorTaskAsyncProgress();                              args.ProgressPercentage =                                  (int)                                      (encryptedFileHeader.UnencryptedFileLength <= 0                                          ? 0                                          : (100 * overallBytesRead) / encryptedFileHeader.UnencryptedFileLength);                              encryptionProgress.Report(args);                          }                      }                      else                      {                          //Prepare the EncryptedFileFooter for encryption.                          EncryptedFileFooter encryptedFileFooter = new EncryptedFileFooter();                          //generate the FooterChecksum                          encryptedFileFooter.SetFooterChecksum(BitConverter.GetBytes(chunkNumber)'                              BitConverter.GetBytes(overallChunkLength)' encryptedFileHeader.UnencryptedEphemeralKey' FOOTER_CHECKSUM_LENGTH);                          //put the footer to the stream                          Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileFooter' PrefixStyle.Base128' 3);                      }                  } while (bytesRead != 0);                }
Magic Number,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncrypMemoryStreamAsync,The following statement contains a magic number: using (FileStream fileStreamEncrypted = File.OpenWrite(outputFullPath))              {                    //initialize our file header for encryption                  EncryptedFileHeader encryptedFileHeader = new EncryptedFileHeader(                      CURRENT_VERSION' NONCE_LENGTH' CHUNK_BASE_NONCE_LENGTH' inputStream.Length'                      senderPrivateKey' senderPublicKey' recipientPublicKey);                  //protect and set the file name to the header                  encryptedFileHeader.ProtectFileName(filename' MAX_FILENAME_LENGTH);                  //generate and set the checksum to validate our file header on decryption                  encryptedFileHeader.SetHeaderChecksum(HEADER_CHECKSUM_LENGTH);                  //write the file header to the stream                  Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileHeader' PrefixStyle.Base128' 1);                  //we start at chunk number 0                  int chunkNumber = CHUNK_COUNT_START;                  //used to calculate the footer checksum                  long overallChunkLength = 0;                  //used for progress reporting                  long overallBytesRead = 0;                  int bytesRead;                  do                  {                      //cancel the task if requested                      cancellationToken.ThrowIfCancellationRequested();                      //start reading the unencrypted file in chunks of the given length: CHUNK_LENGTH                      byte[] unencryptedChunk = new byte[CHUNK_LENGTH];                      bytesRead =                          await inputStream.ReadAsync(unencryptedChunk' 0' CHUNK_LENGTH' cancellationToken).ConfigureAwait(false);                      //check if there is still some work                      if (bytesRead != 0)                      {                          //prepare the EncryptedFileChunk                          EncryptedFileChunk encryptedFileChunk = new EncryptedFileChunk();                          byte[] readedBytes = new byte[bytesRead];                          //cut unreaded bytes                          Array.Copy(unencryptedChunk' readedBytes' bytesRead);                          //check if the file is smaller or equal the CHUNK_LENGTH                          if (encryptedFileHeader.UnencryptedFileLength <= CHUNK_LENGTH)                          {                              //so we have the one and only chunk                              encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce'                                  encryptedFileHeader.UnencryptedEphemeralKey' true);                          }                          else                          {                              //let`s check if this chunk is smaller than the given CHUNK_LENGTH                              if (bytesRead < CHUNK_LENGTH)                              {                                  //it`s the last chunk in the stream                                  encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce'                                      encryptedFileHeader.UnencryptedEphemeralKey' true);                              }                              else                              {                                  //it`s a full chunk                                  encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce'                                      encryptedFileHeader.UnencryptedEphemeralKey' false);                              }                          }                          overallChunkLength += encryptedFileChunk.Chunk.Length;                          //write encryptedFileChunk to the output stream                          Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileChunk' PrefixStyle.Base128' 2);                          //increment for the next chunk                          chunkNumber++;                          overallBytesRead += bytesRead;                          //report status                          if (encryptionProgress != null)                          {                              var args = new StreamCryptorTaskAsyncProgress();                              args.ProgressPercentage =                                  (int)                                      (encryptedFileHeader.UnencryptedFileLength <= 0                                          ? 0                                          : (100 * overallBytesRead) / encryptedFileHeader.UnencryptedFileLength);                              encryptionProgress.Report(args);                          }                      }                      else                      {                          //Prepare the EncryptedFileFooter for encryption.                          EncryptedFileFooter encryptedFileFooter = new EncryptedFileFooter();                          //generate the FooterChecksum                          encryptedFileFooter.SetFooterChecksum(BitConverter.GetBytes(chunkNumber)'                              BitConverter.GetBytes(overallChunkLength)' encryptedFileHeader.UnencryptedEphemeralKey' FOOTER_CHECKSUM_LENGTH);                          //put the footer to the stream                          Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileFooter' PrefixStyle.Base128' 3);                      }                  } while (bytesRead != 0);                }
Magic Number,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStreamAsync,The following statement contains a magic number: using (FileStream fileStreamEncrypted = File.OpenWrite(outputFullPath))              {                  using (FileStream fileStreamUnencrypted = File.OpenRead(inputFile))                  {                      //initialize our file header for encryption                      EncryptedFileHeader encryptedFileHeader = new EncryptedFileHeader(                          CURRENT_VERSION' NONCE_LENGTH' CHUNK_BASE_NONCE_LENGTH' fileStreamUnencrypted.Length'                           senderPrivateKey' senderPublicKey' recipientPublicKey);                      //protect and set the file name to the header                      encryptedFileHeader.ProtectFileName(inputFileInfo.Name' MAX_FILENAME_LENGTH);                      //generate and set the checksum to validate our file header on decryption                      encryptedFileHeader.SetHeaderChecksum(HEADER_CHECKSUM_LENGTH);                      //write the file header to the stream                      Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileHeader' PrefixStyle.Base128' 1);                      //we start at chunk number 0                      int chunkNumber = CHUNK_COUNT_START;                      //used to calculate the footer checksum                      long overallChunkLength = 0;                      //used for progress reporting                      long overallBytesRead = 0;                      int bytesRead;                      do                      {                          //cancel the task if requested                          cancellationToken.ThrowIfCancellationRequested();                          //start reading the unencrypted file in chunks of the given length: CHUNK_LENGTH                          byte[] unencryptedChunk = new byte[CHUNK_LENGTH];                          bytesRead = await fileStreamUnencrypted.ReadAsync(unencryptedChunk' 0' CHUNK_LENGTH' cancellationToken).ConfigureAwait(false);                          //check if there is still some work                          if (bytesRead != 0)                          {                              //prepare the EncryptedFileChunk                              EncryptedFileChunk encryptedFileChunk = new EncryptedFileChunk();                              byte[] readedBytes = new byte[bytesRead];                              //cut unreaded bytes                              Array.Copy(unencryptedChunk' readedBytes' bytesRead);                              //check if the file is smaller or equal the CHUNK_LENGTH                              if (encryptedFileHeader.UnencryptedFileLength <= CHUNK_LENGTH)                              {                                  //so we have the one and only chunk                                  encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' true);                              }                              else                              {                                  //let`s check if this chunk is smaller than the given CHUNK_LENGTH                                  if (bytesRead < CHUNK_LENGTH)                                  {                                      //it`s the last chunk in the stream                                      encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' true);                                  }                                  else                                  {                                      //it`s a full chunk                                      encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' false);                                  }                              }                              overallChunkLength += encryptedFileChunk.Chunk.Length;                              //write encryptedFileChunk to the output stream                              Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileChunk' PrefixStyle.Base128' 2);                              //increment for the next chunk                              chunkNumber++;                              overallBytesRead += bytesRead;                              //report status                              if (encryptionProgress != null)                              {                                  var args = new StreamCryptorTaskAsyncProgress();                                  args.ProgressPercentage = (int)(encryptedFileHeader.UnencryptedFileLength <= 0 ? 0 : (100 * overallBytesRead) / encryptedFileHeader.UnencryptedFileLength);                                  encryptionProgress.Report(args);                              }                          }                          else                          {                              //Prepare the EncryptedFileFooter for encryption.                              EncryptedFileFooter encryptedFileFooter = new EncryptedFileFooter();                              //generate the FooterChecksum                              encryptedFileFooter.SetFooterChecksum(BitConverter.GetBytes(chunkNumber)' BitConverter.GetBytes(overallChunkLength)' encryptedFileHeader.UnencryptedEphemeralKey' FOOTER_CHECKSUM_LENGTH);                              //put the footer to the stream                              Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileFooter' PrefixStyle.Base128' 3);                          }                      } while (bytesRead != 0);                  }              }
Magic Number,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStreamAsync,The following statement contains a magic number: using (FileStream fileStreamEncrypted = File.OpenWrite(outputFullPath))              {                  using (FileStream fileStreamUnencrypted = File.OpenRead(inputFile))                  {                      //initialize our file header for encryption                      EncryptedFileHeader encryptedFileHeader = new EncryptedFileHeader(                          CURRENT_VERSION' NONCE_LENGTH' CHUNK_BASE_NONCE_LENGTH' fileStreamUnencrypted.Length'                           senderPrivateKey' senderPublicKey' recipientPublicKey);                      //protect and set the file name to the header                      encryptedFileHeader.ProtectFileName(inputFileInfo.Name' MAX_FILENAME_LENGTH);                      //generate and set the checksum to validate our file header on decryption                      encryptedFileHeader.SetHeaderChecksum(HEADER_CHECKSUM_LENGTH);                      //write the file header to the stream                      Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileHeader' PrefixStyle.Base128' 1);                      //we start at chunk number 0                      int chunkNumber = CHUNK_COUNT_START;                      //used to calculate the footer checksum                      long overallChunkLength = 0;                      //used for progress reporting                      long overallBytesRead = 0;                      int bytesRead;                      do                      {                          //cancel the task if requested                          cancellationToken.ThrowIfCancellationRequested();                          //start reading the unencrypted file in chunks of the given length: CHUNK_LENGTH                          byte[] unencryptedChunk = new byte[CHUNK_LENGTH];                          bytesRead = await fileStreamUnencrypted.ReadAsync(unencryptedChunk' 0' CHUNK_LENGTH' cancellationToken).ConfigureAwait(false);                          //check if there is still some work                          if (bytesRead != 0)                          {                              //prepare the EncryptedFileChunk                              EncryptedFileChunk encryptedFileChunk = new EncryptedFileChunk();                              byte[] readedBytes = new byte[bytesRead];                              //cut unreaded bytes                              Array.Copy(unencryptedChunk' readedBytes' bytesRead);                              //check if the file is smaller or equal the CHUNK_LENGTH                              if (encryptedFileHeader.UnencryptedFileLength <= CHUNK_LENGTH)                              {                                  //so we have the one and only chunk                                  encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' true);                              }                              else                              {                                  //let`s check if this chunk is smaller than the given CHUNK_LENGTH                                  if (bytesRead < CHUNK_LENGTH)                                  {                                      //it`s the last chunk in the stream                                      encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' true);                                  }                                  else                                  {                                      //it`s a full chunk                                      encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' false);                                  }                              }                              overallChunkLength += encryptedFileChunk.Chunk.Length;                              //write encryptedFileChunk to the output stream                              Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileChunk' PrefixStyle.Base128' 2);                              //increment for the next chunk                              chunkNumber++;                              overallBytesRead += bytesRead;                              //report status                              if (encryptionProgress != null)                              {                                  var args = new StreamCryptorTaskAsyncProgress();                                  args.ProgressPercentage = (int)(encryptedFileHeader.UnencryptedFileLength <= 0 ? 0 : (100 * overallBytesRead) / encryptedFileHeader.UnencryptedFileLength);                                  encryptionProgress.Report(args);                              }                          }                          else                          {                              //Prepare the EncryptedFileFooter for encryption.                              EncryptedFileFooter encryptedFileFooter = new EncryptedFileFooter();                              //generate the FooterChecksum                              encryptedFileFooter.SetFooterChecksum(BitConverter.GetBytes(chunkNumber)' BitConverter.GetBytes(overallChunkLength)' encryptedFileHeader.UnencryptedEphemeralKey' FOOTER_CHECKSUM_LENGTH);                              //put the footer to the stream                              Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileFooter' PrefixStyle.Base128' 3);                          }                      } while (bytesRead != 0);                  }              }
Magic Number,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileWithStreamAsync,The following statement contains a magic number: using (FileStream fileStreamEncrypted = File.OpenWrite(outputFullPath))              {                  using (FileStream fileStreamUnencrypted = File.OpenRead(inputFile))                  {                      //initialize our file header for encryption                      EncryptedFileHeader encryptedFileHeader = new EncryptedFileHeader(                          CURRENT_VERSION' NONCE_LENGTH' CHUNK_BASE_NONCE_LENGTH' fileStreamUnencrypted.Length'                           senderPrivateKey' senderPublicKey' recipientPublicKey);                      //protect and set the file name to the header                      encryptedFileHeader.ProtectFileName(inputFileInfo.Name' MAX_FILENAME_LENGTH);                      //generate and set the checksum to validate our file header on decryption                      encryptedFileHeader.SetHeaderChecksum(HEADER_CHECKSUM_LENGTH);                      //write the file header to the stream                      Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileHeader' PrefixStyle.Base128' 1);                      //we start at chunk number 0                      int chunkNumber = CHUNK_COUNT_START;                      //used to calculate the footer checksum                      long overallChunkLength = 0;                      //used for progress reporting                      long overallBytesRead = 0;                      int bytesRead;                      do                      {                          //cancel the task if requested                          cancellationToken.ThrowIfCancellationRequested();                          //start reading the unencrypted file in chunks of the given length: CHUNK_LENGTH                          byte[] unencryptedChunk = new byte[CHUNK_LENGTH];                          bytesRead = await fileStreamUnencrypted.ReadAsync(unencryptedChunk' 0' CHUNK_LENGTH' cancellationToken).ConfigureAwait(false);                          //check if there is still some work                          if (bytesRead != 0)                          {                              //prepare the EncryptedFileChunk                              EncryptedFileChunk encryptedFileChunk = new EncryptedFileChunk();                              byte[] readedBytes = new byte[bytesRead];                              //cut unreaded bytes                              Array.Copy(unencryptedChunk' readedBytes' bytesRead);                              //check if the file is smaller or equal the CHUNK_LENGTH                              if (encryptedFileHeader.UnencryptedFileLength <= CHUNK_LENGTH)                              {                                  //so we have the one and only chunk                                  encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' true);                              }                              else                              {                                  //let`s check if this chunk is smaller than the given CHUNK_LENGTH                                  if (bytesRead < CHUNK_LENGTH)                                  {                                      //it`s the last chunk in the stream                                      encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' true);                                  }                                  else                                  {                                      //it`s a full chunk                                      encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' false);                                  }                              }                              overallChunkLength += encryptedFileChunk.Chunk.Length;                              //write encryptedFileChunk to the output stream                              Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileChunk' PrefixStyle.Base128' 2);                              //increment for the next chunk                              chunkNumber++;                              overallBytesRead += bytesRead;                              //report status                              if (encryptionProgress != null)                              {                                  var args = new StreamCryptorTaskAsyncProgress();                                  args.ProgressPercentage = (int)(encryptedFileHeader.UnencryptedFileLength <= 0 ? 0 : (100 * overallBytesRead) / encryptedFileHeader.UnencryptedFileLength);                                  encryptionProgress.Report(args);                              }                          }                          else                          {                              //Prepare the EncryptedFileFooter for encryption.                              EncryptedFileFooter encryptedFileFooter = new EncryptedFileFooter();                              //generate the FooterChecksum                              encryptedFileFooter.SetFooterChecksum(BitConverter.GetBytes(chunkNumber)' BitConverter.GetBytes(overallChunkLength)' encryptedFileHeader.UnencryptedEphemeralKey' FOOTER_CHECKSUM_LENGTH);                              //put the footer to the stream                              Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileFooter' PrefixStyle.Base128' 3);                          }                      } while (bytesRead != 0);                  }              }
Magic Number,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileStreamWithStreamAsync,The following statement contains a magic number: using (FileStream fileStreamEncrypted = File.OpenWrite(outputFullPath))  			{  				  					//initialize our file header for encryption  					EncryptedFileHeader encryptedFileHeader = new EncryptedFileHeader(  						CURRENT_VERSION' NONCE_LENGTH' CHUNK_BASE_NONCE_LENGTH' inputStream.Length'  						senderPrivateKey' senderPublicKey' recipientPublicKey);  					//protect and set the file name to the header  					encryptedFileHeader.ProtectFileName(originalFileName' MAX_FILENAME_LENGTH);  					//generate and set the checksum to validate our file header on decryption  					encryptedFileHeader.SetHeaderChecksum(HEADER_CHECKSUM_LENGTH);  					//write the file header to the stream  					Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileHeader' PrefixStyle.Base128' 1);  					//we start at chunk number 0  					int chunkNumber = CHUNK_COUNT_START;  					//used to calculate the footer checksum  					long overallChunkLength = 0;  					//used for progress reporting  					long overallBytesRead = 0;  					int bytesRead;  					do  					{  						//cancel the task if requested  						cancellationToken.ThrowIfCancellationRequested();  						//start reading the unencrypted file in chunks of the given length: CHUNK_LENGTH  						byte[] unencryptedChunk = new byte[CHUNK_LENGTH];  						bytesRead = await inputStream.ReadAsync(unencryptedChunk' 0' CHUNK_LENGTH' cancellationToken).ConfigureAwait(false);  						//check if there is still some work  						if (bytesRead != 0)  						{  							//prepare the EncryptedFileChunk  							EncryptedFileChunk encryptedFileChunk = new EncryptedFileChunk();  							byte[] readedBytes = new byte[bytesRead];  							//cut unreaded bytes  							Array.Copy(unencryptedChunk' readedBytes' bytesRead);  							//check if the file is smaller or equal the CHUNK_LENGTH  							if (encryptedFileHeader.UnencryptedFileLength <= CHUNK_LENGTH)  							{  								//so we have the one and only chunk  								encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' true);  							}  							else  							{  								//let`s check if this chunk is smaller than the given CHUNK_LENGTH  								if (bytesRead < CHUNK_LENGTH)  								{  									//it`s the last chunk in the stream  									encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' true);  								}  								else  								{  									//it`s a full chunk  									encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' false);  								}  							}  							overallChunkLength += encryptedFileChunk.Chunk.Length;  							//write encryptedFileChunk to the output stream  							Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileChunk' PrefixStyle.Base128' 2);  							//increment for the next chunk  							chunkNumber++;  							overallBytesRead += bytesRead;  							//report status  							if (encryptionProgress != null)  							{  								var args = new StreamCryptorTaskAsyncProgress();  								args.ProgressPercentage = (int)(encryptedFileHeader.UnencryptedFileLength <= 0 ? 0 : (100 * overallBytesRead) / encryptedFileHeader.UnencryptedFileLength);  								encryptionProgress.Report(args);  							}  						}  						else  						{  							//Prepare the EncryptedFileFooter for encryption.  							EncryptedFileFooter encryptedFileFooter = new EncryptedFileFooter();  							//generate the FooterChecksum  							encryptedFileFooter.SetFooterChecksum(BitConverter.GetBytes(chunkNumber)' BitConverter.GetBytes(overallChunkLength)' encryptedFileHeader.UnencryptedEphemeralKey' FOOTER_CHECKSUM_LENGTH);  							//put the footer to the stream  							Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileFooter' PrefixStyle.Base128' 3);  						}  					} while (bytesRead != 0);  				  			}
Magic Number,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileStreamWithStreamAsync,The following statement contains a magic number: using (FileStream fileStreamEncrypted = File.OpenWrite(outputFullPath))  			{  				  					//initialize our file header for encryption  					EncryptedFileHeader encryptedFileHeader = new EncryptedFileHeader(  						CURRENT_VERSION' NONCE_LENGTH' CHUNK_BASE_NONCE_LENGTH' inputStream.Length'  						senderPrivateKey' senderPublicKey' recipientPublicKey);  					//protect and set the file name to the header  					encryptedFileHeader.ProtectFileName(originalFileName' MAX_FILENAME_LENGTH);  					//generate and set the checksum to validate our file header on decryption  					encryptedFileHeader.SetHeaderChecksum(HEADER_CHECKSUM_LENGTH);  					//write the file header to the stream  					Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileHeader' PrefixStyle.Base128' 1);  					//we start at chunk number 0  					int chunkNumber = CHUNK_COUNT_START;  					//used to calculate the footer checksum  					long overallChunkLength = 0;  					//used for progress reporting  					long overallBytesRead = 0;  					int bytesRead;  					do  					{  						//cancel the task if requested  						cancellationToken.ThrowIfCancellationRequested();  						//start reading the unencrypted file in chunks of the given length: CHUNK_LENGTH  						byte[] unencryptedChunk = new byte[CHUNK_LENGTH];  						bytesRead = await inputStream.ReadAsync(unencryptedChunk' 0' CHUNK_LENGTH' cancellationToken).ConfigureAwait(false);  						//check if there is still some work  						if (bytesRead != 0)  						{  							//prepare the EncryptedFileChunk  							EncryptedFileChunk encryptedFileChunk = new EncryptedFileChunk();  							byte[] readedBytes = new byte[bytesRead];  							//cut unreaded bytes  							Array.Copy(unencryptedChunk' readedBytes' bytesRead);  							//check if the file is smaller or equal the CHUNK_LENGTH  							if (encryptedFileHeader.UnencryptedFileLength <= CHUNK_LENGTH)  							{  								//so we have the one and only chunk  								encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' true);  							}  							else  							{  								//let`s check if this chunk is smaller than the given CHUNK_LENGTH  								if (bytesRead < CHUNK_LENGTH)  								{  									//it`s the last chunk in the stream  									encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' true);  								}  								else  								{  									//it`s a full chunk  									encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' false);  								}  							}  							overallChunkLength += encryptedFileChunk.Chunk.Length;  							//write encryptedFileChunk to the output stream  							Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileChunk' PrefixStyle.Base128' 2);  							//increment for the next chunk  							chunkNumber++;  							overallBytesRead += bytesRead;  							//report status  							if (encryptionProgress != null)  							{  								var args = new StreamCryptorTaskAsyncProgress();  								args.ProgressPercentage = (int)(encryptedFileHeader.UnencryptedFileLength <= 0 ? 0 : (100 * overallBytesRead) / encryptedFileHeader.UnencryptedFileLength);  								encryptionProgress.Report(args);  							}  						}  						else  						{  							//Prepare the EncryptedFileFooter for encryption.  							EncryptedFileFooter encryptedFileFooter = new EncryptedFileFooter();  							//generate the FooterChecksum  							encryptedFileFooter.SetFooterChecksum(BitConverter.GetBytes(chunkNumber)' BitConverter.GetBytes(overallChunkLength)' encryptedFileHeader.UnencryptedEphemeralKey' FOOTER_CHECKSUM_LENGTH);  							//put the footer to the stream  							Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileFooter' PrefixStyle.Base128' 3);  						}  					} while (bytesRead != 0);  				  			}
Magic Number,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,EncryptFileStreamWithStreamAsync,The following statement contains a magic number: using (FileStream fileStreamEncrypted = File.OpenWrite(outputFullPath))  			{  				  					//initialize our file header for encryption  					EncryptedFileHeader encryptedFileHeader = new EncryptedFileHeader(  						CURRENT_VERSION' NONCE_LENGTH' CHUNK_BASE_NONCE_LENGTH' inputStream.Length'  						senderPrivateKey' senderPublicKey' recipientPublicKey);  					//protect and set the file name to the header  					encryptedFileHeader.ProtectFileName(originalFileName' MAX_FILENAME_LENGTH);  					//generate and set the checksum to validate our file header on decryption  					encryptedFileHeader.SetHeaderChecksum(HEADER_CHECKSUM_LENGTH);  					//write the file header to the stream  					Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileHeader' PrefixStyle.Base128' 1);  					//we start at chunk number 0  					int chunkNumber = CHUNK_COUNT_START;  					//used to calculate the footer checksum  					long overallChunkLength = 0;  					//used for progress reporting  					long overallBytesRead = 0;  					int bytesRead;  					do  					{  						//cancel the task if requested  						cancellationToken.ThrowIfCancellationRequested();  						//start reading the unencrypted file in chunks of the given length: CHUNK_LENGTH  						byte[] unencryptedChunk = new byte[CHUNK_LENGTH];  						bytesRead = await inputStream.ReadAsync(unencryptedChunk' 0' CHUNK_LENGTH' cancellationToken).ConfigureAwait(false);  						//check if there is still some work  						if (bytesRead != 0)  						{  							//prepare the EncryptedFileChunk  							EncryptedFileChunk encryptedFileChunk = new EncryptedFileChunk();  							byte[] readedBytes = new byte[bytesRead];  							//cut unreaded bytes  							Array.Copy(unencryptedChunk' readedBytes' bytesRead);  							//check if the file is smaller or equal the CHUNK_LENGTH  							if (encryptedFileHeader.UnencryptedFileLength <= CHUNK_LENGTH)  							{  								//so we have the one and only chunk  								encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' true);  							}  							else  							{  								//let`s check if this chunk is smaller than the given CHUNK_LENGTH  								if (bytesRead < CHUNK_LENGTH)  								{  									//it`s the last chunk in the stream  									encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' true);  								}  								else  								{  									//it`s a full chunk  									encryptedFileChunk = EncryptFileChunk(readedBytes' chunkNumber' encryptedFileHeader.BaseNonce' encryptedFileHeader.UnencryptedEphemeralKey' false);  								}  							}  							overallChunkLength += encryptedFileChunk.Chunk.Length;  							//write encryptedFileChunk to the output stream  							Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileChunk' PrefixStyle.Base128' 2);  							//increment for the next chunk  							chunkNumber++;  							overallBytesRead += bytesRead;  							//report status  							if (encryptionProgress != null)  							{  								var args = new StreamCryptorTaskAsyncProgress();  								args.ProgressPercentage = (int)(encryptedFileHeader.UnencryptedFileLength <= 0 ? 0 : (100 * overallBytesRead) / encryptedFileHeader.UnencryptedFileLength);  								encryptionProgress.Report(args);  							}  						}  						else  						{  							//Prepare the EncryptedFileFooter for encryption.  							EncryptedFileFooter encryptedFileFooter = new EncryptedFileFooter();  							//generate the FooterChecksum  							encryptedFileFooter.SetFooterChecksum(BitConverter.GetBytes(chunkNumber)' BitConverter.GetBytes(overallChunkLength)' encryptedFileHeader.UnencryptedEphemeralKey' FOOTER_CHECKSUM_LENGTH);  							//put the footer to the stream  							Serializer.SerializeWithLengthPrefix(fileStreamEncrypted' encryptedFileFooter' PrefixStyle.Base128' 3);  						}  					} while (bytesRead != 0);  				  			}
Magic Number,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The following statement contains a magic number: try              {                  //validate the recipientPrivateKey                  if (recipientPrivateKey == null || recipientPrivateKey.Length != ASYNC_KEY_LENGTH)                  {                      throw new ArgumentOutOfRangeException("recipientPrivateKey"' "invalid recipientPrivateKey");                  }                  //validate the inputFile                  if (string.IsNullOrEmpty(inputFile))                  {                      throw new ArgumentOutOfRangeException("inputFile"' (inputFile == null) ? 0 : inputFile.Length'                        string.Format("inputFile must be greater {0} in length."' 0));                  }                  if (!File.Exists(inputFile))                  {                      throw new FileNotFoundException("inputFile"' "inputFile could not be found.");                  }                  //validate the outputFolder                  if (string.IsNullOrEmpty(outputFolder) || !Directory.Exists(outputFolder))                  {                      throw new DirectoryNotFoundException("outputFolder must exist");                  }                    if (outputFolder.IndexOfAny(Path.GetInvalidPathChars()) > -1)                      throw new ArgumentException("The given path to the output folder contains invalid characters!");                    //get a tmp name                  tmpFile = Utils.GetRandomFileName(MASKED_FILENAME_LENGTH' TEMP_FILE_EXTENSION);                  tmpFullPath = Path.Combine(outputFolder' tmpFile);                  using (FileStream fileStreamEncrypted = File.OpenRead(inputFile))                  {                      //first read the file header                      EncryptedFileHeader encryptedFileHeader = Serializer.DeserializeWithLengthPrefix<EncryptedFileHeader>(fileStreamEncrypted' PrefixStyle.Base128' 1);                      if (encryptedFileHeader == null)                      {                          throw new BadFileHeaderException("Missing file header: maybe not a StreamCryptor encrypted file");                      }                      //decrypt the ephemeral key with our public box                       byte[] ephemeralKey = PublicKeyBox.Open(encryptedFileHeader.Key' encryptedFileHeader.EphemeralNonce' recipientPrivateKey' encryptedFileHeader.SenderPublicKey);                      //validate our file header                      encryptedFileHeader.ValidateHeaderChecksum(ephemeralKey' HEADER_CHECKSUM_LENGTH);                      //check file header for compatibility                      if ((encryptedFileHeader.Version >= MIN_VERSION) && (encryptedFileHeader.BaseNonce.Length == CHUNK_BASE_NONCE_LENGTH))                      {                          long overallChunkLength = 0;                          long overallBytesRead = 0;                          //restore the original file name                          byte[] decryptedPaddedFileName = SecretBox.Open(encryptedFileHeader.Filename' encryptedFileHeader.FilenameNonce' Utils.GetEphemeralEncryptionKey(ephemeralKey));                          //remove the padding                          outputFile = Utils.PaddedByteArrayToString(decryptedPaddedFileName);                          //check the decrypted outputFile name for invalid characters to prevent directory traversal                          if (outputFile.IndexOfAny(Path.GetInvalidFileNameChars()) > -1)                              throw new ArgumentException("The given name of the decrypted output filename contains invalid characters!");                            outputFullPath = Path.Combine(outputFolder' outputFile);                          //check for the correct result of Path.Combine                          if (!outputFullPath.StartsWith(outputFolder))                              throw new ArgumentException("The given output path seems to be bad!");                            //keep the position for the footer                          long fileStreamEncryptedPosition = 0;                          int chunkNumber = CHUNK_COUNT_START;                          //write the file to the tmpFullPath                          using (FileStream fileStreamUnencrypted = File.OpenWrite(tmpFullPath))                          {                              //start reading the chunks                              EncryptedFileChunk encryptedFileChunk = new EncryptedFileChunk();                              while ((encryptedFileChunk = Serializer.DeserializeWithLengthPrefix<EncryptedFileChunk>(fileStreamEncrypted' PrefixStyle.Base128' 2)) != null)                              {                                  //cancel the task if requested                                  cancellationToken.ThrowIfCancellationRequested();                                  //indicates if ChunkIsLast was found' to prepend more than one last chnunks.                                  bool isLastChunkFound = false;                                  byte[] chunkNonce = new byte[NONCE_LENGTH];                                  //check if this is the last chunk                                  if (encryptedFileChunk.ChunkIsLast)                                  {                                      if (!isLastChunkFound)                                      {                                          //last                                          chunkNonce = GetChunkNonce(encryptedFileHeader.BaseNonce' chunkNumber' true);                                          isLastChunkFound = true;                                      }                                      else                                      {                                          throw new BadLastFileChunkException("there are more than one last chunk' file could be damaged or manipulated!");                                      }                                  }                                  else                                  {                                      //there will propably come more                                      chunkNonce = GetChunkNonce(encryptedFileHeader.BaseNonce' chunkNumber' false);                                  }                                  //check the current chunk checksum                                  encryptedFileChunk.ValidateChunkChecksum(ephemeralKey' CHUNK_CHECKSUM_LENGTH);                                  byte[] decrypted = SecretBox.Open(encryptedFileChunk.Chunk' chunkNonce' Utils.GetEphemeralEncryptionKey(ephemeralKey));                                  await fileStreamUnencrypted.WriteAsync(decrypted' 0' decrypted.Length' cancellationToken).ConfigureAwait(false);                                  overallBytesRead += (long)decrypted.Length;                                  chunkNumber++;                                  overallChunkLength += encryptedFileChunk.ChunkLength;                                  fileStreamEncryptedPosition = fileStreamEncrypted.Position;                                  //report status                                  if (decryptionProgress != null)                                  {                                      var args = new StreamCryptorTaskAsyncProgress();                                      args.ProgressPercentage = (int)(encryptedFileHeader.UnencryptedFileLength <= 0 ? 0 : (100 * overallBytesRead) / encryptedFileHeader.UnencryptedFileLength);                                      decryptionProgress.Report(args);                                  }                              }                          }                          //set the last position                          fileStreamEncrypted.Position = fileStreamEncryptedPosition;                          //prepare the EncryptedFileFooter                          EncryptedFileFooter encryptedFileFooter = new EncryptedFileFooter();                          //get the file footer and validate him                          encryptedFileFooter = Serializer.DeserializeWithLengthPrefix<EncryptedFileFooter>(fileStreamEncrypted' PrefixStyle.Base128' 3);                          if (encryptedFileFooter == null)                          {                              throw new BadFileFooterException("Missing file footer: file could be damaged or manipulated!");                          }                          //validate the footer checksum                          encryptedFileFooter.ValidateFooterChecksum(BitConverter.GetBytes(chunkNumber)' BitConverter.GetBytes(overallChunkLength)' ephemeralKey' FOOTER_CHECKSUM_LENGTH);                      }                      else                      {                          throw new BadFileHeaderException("Incompatible file header: maybe different library version!");                      }                      //check the produced output for the correct length                      if (encryptedFileHeader.UnencryptedFileLength == new FileInfo(tmpFullPath).Length)                      {                          //check if the new output file already exists                          if (File.Exists(outputFullPath))                          {                              if (!overWrite)                              {                                  //we don`t overwrite the file                                  throw new IOException("Decrypted file aleary exits' won`t overwrite");                              }                              else                              {                                  //just delete the output file' so we can write a new one                                  File.Delete(outputFullPath);                              }                          }                          File.Move(tmpFullPath' outputFullPath);                      }                      else                      {                          //File is not valid (return null)                          outputFile = null;                          File.Delete(tmpFullPath);                      }                  }              }              catch (AggregateException ex)              {                  //delete the temp file                  File.Delete(tmpFullPath);                  //and throw the exception                  ExceptionDispatchInfo.Capture(ex).Throw();              }              catch (OperationCanceledException ex)              {                  //delete the temp file                  File.Delete(tmpFullPath);                  //and throw the exception                  ExceptionDispatchInfo.Capture(ex).Throw();              }
Magic Number,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The following statement contains a magic number: try              {                  //validate the recipientPrivateKey                  if (recipientPrivateKey == null || recipientPrivateKey.Length != ASYNC_KEY_LENGTH)                  {                      throw new ArgumentOutOfRangeException("recipientPrivateKey"' "invalid recipientPrivateKey");                  }                  //validate the inputFile                  if (string.IsNullOrEmpty(inputFile))                  {                      throw new ArgumentOutOfRangeException("inputFile"' (inputFile == null) ? 0 : inputFile.Length'                        string.Format("inputFile must be greater {0} in length."' 0));                  }                  if (!File.Exists(inputFile))                  {                      throw new FileNotFoundException("inputFile"' "inputFile could not be found.");                  }                  //validate the outputFolder                  if (string.IsNullOrEmpty(outputFolder) || !Directory.Exists(outputFolder))                  {                      throw new DirectoryNotFoundException("outputFolder must exist");                  }                    if (outputFolder.IndexOfAny(Path.GetInvalidPathChars()) > -1)                      throw new ArgumentException("The given path to the output folder contains invalid characters!");                    //get a tmp name                  tmpFile = Utils.GetRandomFileName(MASKED_FILENAME_LENGTH' TEMP_FILE_EXTENSION);                  tmpFullPath = Path.Combine(outputFolder' tmpFile);                  using (FileStream fileStreamEncrypted = File.OpenRead(inputFile))                  {                      //first read the file header                      EncryptedFileHeader encryptedFileHeader = Serializer.DeserializeWithLengthPrefix<EncryptedFileHeader>(fileStreamEncrypted' PrefixStyle.Base128' 1);                      if (encryptedFileHeader == null)                      {                          throw new BadFileHeaderException("Missing file header: maybe not a StreamCryptor encrypted file");                      }                      //decrypt the ephemeral key with our public box                       byte[] ephemeralKey = PublicKeyBox.Open(encryptedFileHeader.Key' encryptedFileHeader.EphemeralNonce' recipientPrivateKey' encryptedFileHeader.SenderPublicKey);                      //validate our file header                      encryptedFileHeader.ValidateHeaderChecksum(ephemeralKey' HEADER_CHECKSUM_LENGTH);                      //check file header for compatibility                      if ((encryptedFileHeader.Version >= MIN_VERSION) && (encryptedFileHeader.BaseNonce.Length == CHUNK_BASE_NONCE_LENGTH))                      {                          long overallChunkLength = 0;                          long overallBytesRead = 0;                          //restore the original file name                          byte[] decryptedPaddedFileName = SecretBox.Open(encryptedFileHeader.Filename' encryptedFileHeader.FilenameNonce' Utils.GetEphemeralEncryptionKey(ephemeralKey));                          //remove the padding                          outputFile = Utils.PaddedByteArrayToString(decryptedPaddedFileName);                          //check the decrypted outputFile name for invalid characters to prevent directory traversal                          if (outputFile.IndexOfAny(Path.GetInvalidFileNameChars()) > -1)                              throw new ArgumentException("The given name of the decrypted output filename contains invalid characters!");                            outputFullPath = Path.Combine(outputFolder' outputFile);                          //check for the correct result of Path.Combine                          if (!outputFullPath.StartsWith(outputFolder))                              throw new ArgumentException("The given output path seems to be bad!");                            //keep the position for the footer                          long fileStreamEncryptedPosition = 0;                          int chunkNumber = CHUNK_COUNT_START;                          //write the file to the tmpFullPath                          using (FileStream fileStreamUnencrypted = File.OpenWrite(tmpFullPath))                          {                              //start reading the chunks                              EncryptedFileChunk encryptedFileChunk = new EncryptedFileChunk();                              while ((encryptedFileChunk = Serializer.DeserializeWithLengthPrefix<EncryptedFileChunk>(fileStreamEncrypted' PrefixStyle.Base128' 2)) != null)                              {                                  //cancel the task if requested                                  cancellationToken.ThrowIfCancellationRequested();                                  //indicates if ChunkIsLast was found' to prepend more than one last chnunks.                                  bool isLastChunkFound = false;                                  byte[] chunkNonce = new byte[NONCE_LENGTH];                                  //check if this is the last chunk                                  if (encryptedFileChunk.ChunkIsLast)                                  {                                      if (!isLastChunkFound)                                      {                                          //last                                          chunkNonce = GetChunkNonce(encryptedFileHeader.BaseNonce' chunkNumber' true);                                          isLastChunkFound = true;                                      }                                      else                                      {                                          throw new BadLastFileChunkException("there are more than one last chunk' file could be damaged or manipulated!");                                      }                                  }                                  else                                  {                                      //there will propably come more                                      chunkNonce = GetChunkNonce(encryptedFileHeader.BaseNonce' chunkNumber' false);                                  }                                  //check the current chunk checksum                                  encryptedFileChunk.ValidateChunkChecksum(ephemeralKey' CHUNK_CHECKSUM_LENGTH);                                  byte[] decrypted = SecretBox.Open(encryptedFileChunk.Chunk' chunkNonce' Utils.GetEphemeralEncryptionKey(ephemeralKey));                                  await fileStreamUnencrypted.WriteAsync(decrypted' 0' decrypted.Length' cancellationToken).ConfigureAwait(false);                                  overallBytesRead += (long)decrypted.Length;                                  chunkNumber++;                                  overallChunkLength += encryptedFileChunk.ChunkLength;                                  fileStreamEncryptedPosition = fileStreamEncrypted.Position;                                  //report status                                  if (decryptionProgress != null)                                  {                                      var args = new StreamCryptorTaskAsyncProgress();                                      args.ProgressPercentage = (int)(encryptedFileHeader.UnencryptedFileLength <= 0 ? 0 : (100 * overallBytesRead) / encryptedFileHeader.UnencryptedFileLength);                                      decryptionProgress.Report(args);                                  }                              }                          }                          //set the last position                          fileStreamEncrypted.Position = fileStreamEncryptedPosition;                          //prepare the EncryptedFileFooter                          EncryptedFileFooter encryptedFileFooter = new EncryptedFileFooter();                          //get the file footer and validate him                          encryptedFileFooter = Serializer.DeserializeWithLengthPrefix<EncryptedFileFooter>(fileStreamEncrypted' PrefixStyle.Base128' 3);                          if (encryptedFileFooter == null)                          {                              throw new BadFileFooterException("Missing file footer: file could be damaged or manipulated!");                          }                          //validate the footer checksum                          encryptedFileFooter.ValidateFooterChecksum(BitConverter.GetBytes(chunkNumber)' BitConverter.GetBytes(overallChunkLength)' ephemeralKey' FOOTER_CHECKSUM_LENGTH);                      }                      else                      {                          throw new BadFileHeaderException("Incompatible file header: maybe different library version!");                      }                      //check the produced output for the correct length                      if (encryptedFileHeader.UnencryptedFileLength == new FileInfo(tmpFullPath).Length)                      {                          //check if the new output file already exists                          if (File.Exists(outputFullPath))                          {                              if (!overWrite)                              {                                  //we don`t overwrite the file                                  throw new IOException("Decrypted file aleary exits' won`t overwrite");                              }                              else                              {                                  //just delete the output file' so we can write a new one                                  File.Delete(outputFullPath);                              }                          }                          File.Move(tmpFullPath' outputFullPath);                      }                      else                      {                          //File is not valid (return null)                          outputFile = null;                          File.Delete(tmpFullPath);                      }                  }              }              catch (AggregateException ex)              {                  //delete the temp file                  File.Delete(tmpFullPath);                  //and throw the exception                  ExceptionDispatchInfo.Capture(ex).Throw();              }              catch (OperationCanceledException ex)              {                  //delete the temp file                  File.Delete(tmpFullPath);                  //and throw the exception                  ExceptionDispatchInfo.Capture(ex).Throw();              }
Magic Number,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The following statement contains a magic number: try              {                  //validate the recipientPrivateKey                  if (recipientPrivateKey == null || recipientPrivateKey.Length != ASYNC_KEY_LENGTH)                  {                      throw new ArgumentOutOfRangeException("recipientPrivateKey"' "invalid recipientPrivateKey");                  }                  //validate the inputFile                  if (string.IsNullOrEmpty(inputFile))                  {                      throw new ArgumentOutOfRangeException("inputFile"' (inputFile == null) ? 0 : inputFile.Length'                        string.Format("inputFile must be greater {0} in length."' 0));                  }                  if (!File.Exists(inputFile))                  {                      throw new FileNotFoundException("inputFile"' "inputFile could not be found.");                  }                  //validate the outputFolder                  if (string.IsNullOrEmpty(outputFolder) || !Directory.Exists(outputFolder))                  {                      throw new DirectoryNotFoundException("outputFolder must exist");                  }                    if (outputFolder.IndexOfAny(Path.GetInvalidPathChars()) > -1)                      throw new ArgumentException("The given path to the output folder contains invalid characters!");                    //get a tmp name                  tmpFile = Utils.GetRandomFileName(MASKED_FILENAME_LENGTH' TEMP_FILE_EXTENSION);                  tmpFullPath = Path.Combine(outputFolder' tmpFile);                  using (FileStream fileStreamEncrypted = File.OpenRead(inputFile))                  {                      //first read the file header                      EncryptedFileHeader encryptedFileHeader = Serializer.DeserializeWithLengthPrefix<EncryptedFileHeader>(fileStreamEncrypted' PrefixStyle.Base128' 1);                      if (encryptedFileHeader == null)                      {                          throw new BadFileHeaderException("Missing file header: maybe not a StreamCryptor encrypted file");                      }                      //decrypt the ephemeral key with our public box                       byte[] ephemeralKey = PublicKeyBox.Open(encryptedFileHeader.Key' encryptedFileHeader.EphemeralNonce' recipientPrivateKey' encryptedFileHeader.SenderPublicKey);                      //validate our file header                      encryptedFileHeader.ValidateHeaderChecksum(ephemeralKey' HEADER_CHECKSUM_LENGTH);                      //check file header for compatibility                      if ((encryptedFileHeader.Version >= MIN_VERSION) && (encryptedFileHeader.BaseNonce.Length == CHUNK_BASE_NONCE_LENGTH))                      {                          long overallChunkLength = 0;                          long overallBytesRead = 0;                          //restore the original file name                          byte[] decryptedPaddedFileName = SecretBox.Open(encryptedFileHeader.Filename' encryptedFileHeader.FilenameNonce' Utils.GetEphemeralEncryptionKey(ephemeralKey));                          //remove the padding                          outputFile = Utils.PaddedByteArrayToString(decryptedPaddedFileName);                          //check the decrypted outputFile name for invalid characters to prevent directory traversal                          if (outputFile.IndexOfAny(Path.GetInvalidFileNameChars()) > -1)                              throw new ArgumentException("The given name of the decrypted output filename contains invalid characters!");                            outputFullPath = Path.Combine(outputFolder' outputFile);                          //check for the correct result of Path.Combine                          if (!outputFullPath.StartsWith(outputFolder))                              throw new ArgumentException("The given output path seems to be bad!");                            //keep the position for the footer                          long fileStreamEncryptedPosition = 0;                          int chunkNumber = CHUNK_COUNT_START;                          //write the file to the tmpFullPath                          using (FileStream fileStreamUnencrypted = File.OpenWrite(tmpFullPath))                          {                              //start reading the chunks                              EncryptedFileChunk encryptedFileChunk = new EncryptedFileChunk();                              while ((encryptedFileChunk = Serializer.DeserializeWithLengthPrefix<EncryptedFileChunk>(fileStreamEncrypted' PrefixStyle.Base128' 2)) != null)                              {                                  //cancel the task if requested                                  cancellationToken.ThrowIfCancellationRequested();                                  //indicates if ChunkIsLast was found' to prepend more than one last chnunks.                                  bool isLastChunkFound = false;                                  byte[] chunkNonce = new byte[NONCE_LENGTH];                                  //check if this is the last chunk                                  if (encryptedFileChunk.ChunkIsLast)                                  {                                      if (!isLastChunkFound)                                      {                                          //last                                          chunkNonce = GetChunkNonce(encryptedFileHeader.BaseNonce' chunkNumber' true);                                          isLastChunkFound = true;                                      }                                      else                                      {                                          throw new BadLastFileChunkException("there are more than one last chunk' file could be damaged or manipulated!");                                      }                                  }                                  else                                  {                                      //there will propably come more                                      chunkNonce = GetChunkNonce(encryptedFileHeader.BaseNonce' chunkNumber' false);                                  }                                  //check the current chunk checksum                                  encryptedFileChunk.ValidateChunkChecksum(ephemeralKey' CHUNK_CHECKSUM_LENGTH);                                  byte[] decrypted = SecretBox.Open(encryptedFileChunk.Chunk' chunkNonce' Utils.GetEphemeralEncryptionKey(ephemeralKey));                                  await fileStreamUnencrypted.WriteAsync(decrypted' 0' decrypted.Length' cancellationToken).ConfigureAwait(false);                                  overallBytesRead += (long)decrypted.Length;                                  chunkNumber++;                                  overallChunkLength += encryptedFileChunk.ChunkLength;                                  fileStreamEncryptedPosition = fileStreamEncrypted.Position;                                  //report status                                  if (decryptionProgress != null)                                  {                                      var args = new StreamCryptorTaskAsyncProgress();                                      args.ProgressPercentage = (int)(encryptedFileHeader.UnencryptedFileLength <= 0 ? 0 : (100 * overallBytesRead) / encryptedFileHeader.UnencryptedFileLength);                                      decryptionProgress.Report(args);                                  }                              }                          }                          //set the last position                          fileStreamEncrypted.Position = fileStreamEncryptedPosition;                          //prepare the EncryptedFileFooter                          EncryptedFileFooter encryptedFileFooter = new EncryptedFileFooter();                          //get the file footer and validate him                          encryptedFileFooter = Serializer.DeserializeWithLengthPrefix<EncryptedFileFooter>(fileStreamEncrypted' PrefixStyle.Base128' 3);                          if (encryptedFileFooter == null)                          {                              throw new BadFileFooterException("Missing file footer: file could be damaged or manipulated!");                          }                          //validate the footer checksum                          encryptedFileFooter.ValidateFooterChecksum(BitConverter.GetBytes(chunkNumber)' BitConverter.GetBytes(overallChunkLength)' ephemeralKey' FOOTER_CHECKSUM_LENGTH);                      }                      else                      {                          throw new BadFileHeaderException("Incompatible file header: maybe different library version!");                      }                      //check the produced output for the correct length                      if (encryptedFileHeader.UnencryptedFileLength == new FileInfo(tmpFullPath).Length)                      {                          //check if the new output file already exists                          if (File.Exists(outputFullPath))                          {                              if (!overWrite)                              {                                  //we don`t overwrite the file                                  throw new IOException("Decrypted file aleary exits' won`t overwrite");                              }                              else                              {                                  //just delete the output file' so we can write a new one                                  File.Delete(outputFullPath);                              }                          }                          File.Move(tmpFullPath' outputFullPath);                      }                      else                      {                          //File is not valid (return null)                          outputFile = null;                          File.Delete(tmpFullPath);                      }                  }              }              catch (AggregateException ex)              {                  //delete the temp file                  File.Delete(tmpFullPath);                  //and throw the exception                  ExceptionDispatchInfo.Capture(ex).Throw();              }              catch (OperationCanceledException ex)              {                  //delete the temp file                  File.Delete(tmpFullPath);                  //and throw the exception                  ExceptionDispatchInfo.Capture(ex).Throw();              }
Magic Number,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The following statement contains a magic number: try              {                  //validate the recipientPrivateKey                  if (recipientPrivateKey == null || recipientPrivateKey.Length != ASYNC_KEY_LENGTH)                  {                      throw new ArgumentOutOfRangeException("recipientPrivateKey"' "invalid recipientPrivateKey");                  }                  //validate the inputFile                  if (string.IsNullOrEmpty(inputFile))                  {                      throw new ArgumentOutOfRangeException("inputFile"' (inputFile == null) ? 0 : inputFile.Length'                        string.Format("inputFile must be greater {0} in length."' 0));                  }                  if (!File.Exists(inputFile))                  {                      throw new FileNotFoundException("inputFile"' "inputFile could not be found.");                  }                    using (FileStream fileStreamEncrypted = File.OpenRead(inputFile))                  {                      //first read the file header                      EncryptedFileHeader encryptedFileHeader = new EncryptedFileHeader();                      encryptedFileHeader = Serializer.DeserializeWithLengthPrefix<EncryptedFileHeader>(fileStreamEncrypted' PrefixStyle.Base128' 1);                      //decrypt the ephemeral key with our public box                       byte[] ephemeralKey = PublicKeyBox.Open(encryptedFileHeader.Key' encryptedFileHeader.EphemeralNonce' recipientPrivateKey' encryptedFileHeader.SenderPublicKey);                      //validate our file header                      encryptedFileHeader.ValidateHeaderChecksum(ephemeralKey' HEADER_CHECKSUM_LENGTH);                      //check file header for compatibility                      if ((encryptedFileHeader.Version >= MIN_VERSION) && (encryptedFileHeader.BaseNonce.Length == CHUNK_BASE_NONCE_LENGTH))                      {                          long overallChunkLength = 0;                          long overallBytesRead = 0;                          //restore the original file name                          byte[] encryptedPaddedFileName = SecretBox.Open(encryptedFileHeader.Filename' encryptedFileHeader.FilenameNonce' Utils.GetEphemeralEncryptionKey(ephemeralKey));                          //remove the padding                          decryptedFile.FileName = Utils.PaddedByteArrayToString(encryptedPaddedFileName);                          //keep the position for the footer                          long fileStreamEncryptedPosition = 0;                          int chunkNumber = CHUNK_COUNT_START;                          //write the file to the tmpFullPath                          using (MemoryStream fileStreamUnencrypted = new MemoryStream())                          {                              //start reading the chunks                              EncryptedFileChunk encryptedFileChunk = new EncryptedFileChunk();                              while ((encryptedFileChunk = Serializer.DeserializeWithLengthPrefix<EncryptedFileChunk>(fileStreamEncrypted' PrefixStyle.Base128' 2)) != null)                              {                                  //cancel the task if requested                                  cancellationToken.ThrowIfCancellationRequested();                                  //indicates if ChunkIsLast was found' to prepend more than one last chnunks.                                  bool isLastChunkFound = false;                                  byte[] chunkNonce = new byte[NONCE_LENGTH];                                  //check if this is the last chunk                                  if (encryptedFileChunk.ChunkIsLast)                                  {                                      if (!isLastChunkFound)                                      {                                          //last                                          chunkNonce = GetChunkNonce(encryptedFileHeader.BaseNonce' chunkNumber' true);                                          isLastChunkFound = true;                                      }                                      else                                      {                                          throw new BadLastFileChunkException("there are more than one last chunk' file could be damaged or manipulated!");                                      }                                  }                                  else                                  {                                      //there will propably come more                                      chunkNonce = GetChunkNonce(encryptedFileHeader.BaseNonce' chunkNumber);                                  }                                  //check the current chunk checksum                                  encryptedFileChunk.ValidateChunkChecksum(ephemeralKey' CHUNK_CHECKSUM_LENGTH);                                  byte[] decrypted = SecretBox.Open(encryptedFileChunk.Chunk' chunkNonce' Utils.GetEphemeralEncryptionKey(ephemeralKey));                                  await fileStreamUnencrypted.WriteAsync(decrypted' 0' decrypted.Length' cancellationToken).ConfigureAwait(false);                                  overallBytesRead += (long)decrypted.Length;                                  chunkNumber++;                                  overallChunkLength += encryptedFileChunk.ChunkLength;                                  fileStreamEncryptedPosition = fileStreamEncrypted.Position;                                  //report status                                  if (decryptionProgress != null)                                  {                                      var args = new StreamCryptorTaskAsyncProgress();                                      args.ProgressPercentage = (int)(encryptedFileHeader.UnencryptedFileLength <= 0 ? 0 : (100 * overallBytesRead) / encryptedFileHeader.UnencryptedFileLength);                                      decryptionProgress.Report(args);                                  }                              }                              decryptedFile.FileData = fileStreamUnencrypted.ToArray();                              decryptedFile.FileSize = decryptedFile.FileData.Length;                          }                          //set the last position                          fileStreamEncrypted.Position = fileStreamEncryptedPosition;                          //prepare the EncryptedFileFooter                          EncryptedFileFooter encryptedFileFooter = new EncryptedFileFooter();                          //get the file footer and validate him                          encryptedFileFooter = Serializer.DeserializeWithLengthPrefix<EncryptedFileFooter>(fileStreamEncrypted' PrefixStyle.Base128' 3);                          if (encryptedFileFooter == null)                          {                              throw new BadFileFooterException("Missing file footer: file could be damaged or manipulated!");                          }                          //validate the footer checksum                          encryptedFileFooter.ValidateFooterChecksum(BitConverter.GetBytes(chunkNumber)' BitConverter.GetBytes(overallChunkLength)' ephemeralKey' FOOTER_CHECKSUM_LENGTH);                      }                      else                      {                          throw new BadFileHeaderException("Incompatible file header: maybe different library version!");                      }                      //check the produced output for the correct length                      if (encryptedFileHeader.UnencryptedFileLength != decryptedFile.FileSize)                      {                          //File is not valid (return null)                          decryptedFile = null;                      }                  }              }              catch (AggregateException ex)              {                  //and throw the exception                  ExceptionDispatchInfo.Capture(ex).Throw();              }
Magic Number,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The following statement contains a magic number: try              {                  //validate the recipientPrivateKey                  if (recipientPrivateKey == null || recipientPrivateKey.Length != ASYNC_KEY_LENGTH)                  {                      throw new ArgumentOutOfRangeException("recipientPrivateKey"' "invalid recipientPrivateKey");                  }                  //validate the inputFile                  if (string.IsNullOrEmpty(inputFile))                  {                      throw new ArgumentOutOfRangeException("inputFile"' (inputFile == null) ? 0 : inputFile.Length'                        string.Format("inputFile must be greater {0} in length."' 0));                  }                  if (!File.Exists(inputFile))                  {                      throw new FileNotFoundException("inputFile"' "inputFile could not be found.");                  }                    using (FileStream fileStreamEncrypted = File.OpenRead(inputFile))                  {                      //first read the file header                      EncryptedFileHeader encryptedFileHeader = new EncryptedFileHeader();                      encryptedFileHeader = Serializer.DeserializeWithLengthPrefix<EncryptedFileHeader>(fileStreamEncrypted' PrefixStyle.Base128' 1);                      //decrypt the ephemeral key with our public box                       byte[] ephemeralKey = PublicKeyBox.Open(encryptedFileHeader.Key' encryptedFileHeader.EphemeralNonce' recipientPrivateKey' encryptedFileHeader.SenderPublicKey);                      //validate our file header                      encryptedFileHeader.ValidateHeaderChecksum(ephemeralKey' HEADER_CHECKSUM_LENGTH);                      //check file header for compatibility                      if ((encryptedFileHeader.Version >= MIN_VERSION) && (encryptedFileHeader.BaseNonce.Length == CHUNK_BASE_NONCE_LENGTH))                      {                          long overallChunkLength = 0;                          long overallBytesRead = 0;                          //restore the original file name                          byte[] encryptedPaddedFileName = SecretBox.Open(encryptedFileHeader.Filename' encryptedFileHeader.FilenameNonce' Utils.GetEphemeralEncryptionKey(ephemeralKey));                          //remove the padding                          decryptedFile.FileName = Utils.PaddedByteArrayToString(encryptedPaddedFileName);                          //keep the position for the footer                          long fileStreamEncryptedPosition = 0;                          int chunkNumber = CHUNK_COUNT_START;                          //write the file to the tmpFullPath                          using (MemoryStream fileStreamUnencrypted = new MemoryStream())                          {                              //start reading the chunks                              EncryptedFileChunk encryptedFileChunk = new EncryptedFileChunk();                              while ((encryptedFileChunk = Serializer.DeserializeWithLengthPrefix<EncryptedFileChunk>(fileStreamEncrypted' PrefixStyle.Base128' 2)) != null)                              {                                  //cancel the task if requested                                  cancellationToken.ThrowIfCancellationRequested();                                  //indicates if ChunkIsLast was found' to prepend more than one last chnunks.                                  bool isLastChunkFound = false;                                  byte[] chunkNonce = new byte[NONCE_LENGTH];                                  //check if this is the last chunk                                  if (encryptedFileChunk.ChunkIsLast)                                  {                                      if (!isLastChunkFound)                                      {                                          //last                                          chunkNonce = GetChunkNonce(encryptedFileHeader.BaseNonce' chunkNumber' true);                                          isLastChunkFound = true;                                      }                                      else                                      {                                          throw new BadLastFileChunkException("there are more than one last chunk' file could be damaged or manipulated!");                                      }                                  }                                  else                                  {                                      //there will propably come more                                      chunkNonce = GetChunkNonce(encryptedFileHeader.BaseNonce' chunkNumber);                                  }                                  //check the current chunk checksum                                  encryptedFileChunk.ValidateChunkChecksum(ephemeralKey' CHUNK_CHECKSUM_LENGTH);                                  byte[] decrypted = SecretBox.Open(encryptedFileChunk.Chunk' chunkNonce' Utils.GetEphemeralEncryptionKey(ephemeralKey));                                  await fileStreamUnencrypted.WriteAsync(decrypted' 0' decrypted.Length' cancellationToken).ConfigureAwait(false);                                  overallBytesRead += (long)decrypted.Length;                                  chunkNumber++;                                  overallChunkLength += encryptedFileChunk.ChunkLength;                                  fileStreamEncryptedPosition = fileStreamEncrypted.Position;                                  //report status                                  if (decryptionProgress != null)                                  {                                      var args = new StreamCryptorTaskAsyncProgress();                                      args.ProgressPercentage = (int)(encryptedFileHeader.UnencryptedFileLength <= 0 ? 0 : (100 * overallBytesRead) / encryptedFileHeader.UnencryptedFileLength);                                      decryptionProgress.Report(args);                                  }                              }                              decryptedFile.FileData = fileStreamUnencrypted.ToArray();                              decryptedFile.FileSize = decryptedFile.FileData.Length;                          }                          //set the last position                          fileStreamEncrypted.Position = fileStreamEncryptedPosition;                          //prepare the EncryptedFileFooter                          EncryptedFileFooter encryptedFileFooter = new EncryptedFileFooter();                          //get the file footer and validate him                          encryptedFileFooter = Serializer.DeserializeWithLengthPrefix<EncryptedFileFooter>(fileStreamEncrypted' PrefixStyle.Base128' 3);                          if (encryptedFileFooter == null)                          {                              throw new BadFileFooterException("Missing file footer: file could be damaged or manipulated!");                          }                          //validate the footer checksum                          encryptedFileFooter.ValidateFooterChecksum(BitConverter.GetBytes(chunkNumber)' BitConverter.GetBytes(overallChunkLength)' ephemeralKey' FOOTER_CHECKSUM_LENGTH);                      }                      else                      {                          throw new BadFileHeaderException("Incompatible file header: maybe different library version!");                      }                      //check the produced output for the correct length                      if (encryptedFileHeader.UnencryptedFileLength != decryptedFile.FileSize)                      {                          //File is not valid (return null)                          decryptedFile = null;                      }                  }              }              catch (AggregateException ex)              {                  //and throw the exception                  ExceptionDispatchInfo.Capture(ex).Throw();              }
Magic Number,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptFileWithStreamAsync,The following statement contains a magic number: try              {                  //validate the recipientPrivateKey                  if (recipientPrivateKey == null || recipientPrivateKey.Length != ASYNC_KEY_LENGTH)                  {                      throw new ArgumentOutOfRangeException("recipientPrivateKey"' "invalid recipientPrivateKey");                  }                  //validate the inputFile                  if (string.IsNullOrEmpty(inputFile))                  {                      throw new ArgumentOutOfRangeException("inputFile"' (inputFile == null) ? 0 : inputFile.Length'                        string.Format("inputFile must be greater {0} in length."' 0));                  }                  if (!File.Exists(inputFile))                  {                      throw new FileNotFoundException("inputFile"' "inputFile could not be found.");                  }                    using (FileStream fileStreamEncrypted = File.OpenRead(inputFile))                  {                      //first read the file header                      EncryptedFileHeader encryptedFileHeader = new EncryptedFileHeader();                      encryptedFileHeader = Serializer.DeserializeWithLengthPrefix<EncryptedFileHeader>(fileStreamEncrypted' PrefixStyle.Base128' 1);                      //decrypt the ephemeral key with our public box                       byte[] ephemeralKey = PublicKeyBox.Open(encryptedFileHeader.Key' encryptedFileHeader.EphemeralNonce' recipientPrivateKey' encryptedFileHeader.SenderPublicKey);                      //validate our file header                      encryptedFileHeader.ValidateHeaderChecksum(ephemeralKey' HEADER_CHECKSUM_LENGTH);                      //check file header for compatibility                      if ((encryptedFileHeader.Version >= MIN_VERSION) && (encryptedFileHeader.BaseNonce.Length == CHUNK_BASE_NONCE_LENGTH))                      {                          long overallChunkLength = 0;                          long overallBytesRead = 0;                          //restore the original file name                          byte[] encryptedPaddedFileName = SecretBox.Open(encryptedFileHeader.Filename' encryptedFileHeader.FilenameNonce' Utils.GetEphemeralEncryptionKey(ephemeralKey));                          //remove the padding                          decryptedFile.FileName = Utils.PaddedByteArrayToString(encryptedPaddedFileName);                          //keep the position for the footer                          long fileStreamEncryptedPosition = 0;                          int chunkNumber = CHUNK_COUNT_START;                          //write the file to the tmpFullPath                          using (MemoryStream fileStreamUnencrypted = new MemoryStream())                          {                              //start reading the chunks                              EncryptedFileChunk encryptedFileChunk = new EncryptedFileChunk();                              while ((encryptedFileChunk = Serializer.DeserializeWithLengthPrefix<EncryptedFileChunk>(fileStreamEncrypted' PrefixStyle.Base128' 2)) != null)                              {                                  //cancel the task if requested                                  cancellationToken.ThrowIfCancellationRequested();                                  //indicates if ChunkIsLast was found' to prepend more than one last chnunks.                                  bool isLastChunkFound = false;                                  byte[] chunkNonce = new byte[NONCE_LENGTH];                                  //check if this is the last chunk                                  if (encryptedFileChunk.ChunkIsLast)                                  {                                      if (!isLastChunkFound)                                      {                                          //last                                          chunkNonce = GetChunkNonce(encryptedFileHeader.BaseNonce' chunkNumber' true);                                          isLastChunkFound = true;                                      }                                      else                                      {                                          throw new BadLastFileChunkException("there are more than one last chunk' file could be damaged or manipulated!");                                      }                                  }                                  else                                  {                                      //there will propably come more                                      chunkNonce = GetChunkNonce(encryptedFileHeader.BaseNonce' chunkNumber);                                  }                                  //check the current chunk checksum                                  encryptedFileChunk.ValidateChunkChecksum(ephemeralKey' CHUNK_CHECKSUM_LENGTH);                                  byte[] decrypted = SecretBox.Open(encryptedFileChunk.Chunk' chunkNonce' Utils.GetEphemeralEncryptionKey(ephemeralKey));                                  await fileStreamUnencrypted.WriteAsync(decrypted' 0' decrypted.Length' cancellationToken).ConfigureAwait(false);                                  overallBytesRead += (long)decrypted.Length;                                  chunkNumber++;                                  overallChunkLength += encryptedFileChunk.ChunkLength;                                  fileStreamEncryptedPosition = fileStreamEncrypted.Position;                                  //report status                                  if (decryptionProgress != null)                                  {                                      var args = new StreamCryptorTaskAsyncProgress();                                      args.ProgressPercentage = (int)(encryptedFileHeader.UnencryptedFileLength <= 0 ? 0 : (100 * overallBytesRead) / encryptedFileHeader.UnencryptedFileLength);                                      decryptionProgress.Report(args);                                  }                              }                              decryptedFile.FileData = fileStreamUnencrypted.ToArray();                              decryptedFile.FileSize = decryptedFile.FileData.Length;                          }                          //set the last position                          fileStreamEncrypted.Position = fileStreamEncryptedPosition;                          //prepare the EncryptedFileFooter                          EncryptedFileFooter encryptedFileFooter = new EncryptedFileFooter();                          //get the file footer and validate him                          encryptedFileFooter = Serializer.DeserializeWithLengthPrefix<EncryptedFileFooter>(fileStreamEncrypted' PrefixStyle.Base128' 3);                          if (encryptedFileFooter == null)                          {                              throw new BadFileFooterException("Missing file footer: file could be damaged or manipulated!");                          }                          //validate the footer checksum                          encryptedFileFooter.ValidateFooterChecksum(BitConverter.GetBytes(chunkNumber)' BitConverter.GetBytes(overallChunkLength)' ephemeralKey' FOOTER_CHECKSUM_LENGTH);                      }                      else                      {                          throw new BadFileHeaderException("Incompatible file header: maybe different library version!");                      }                      //check the produced output for the correct length                      if (encryptedFileHeader.UnencryptedFileLength != decryptedFile.FileSize)                      {                          //File is not valid (return null)                          decryptedFile = null;                      }                  }              }              catch (AggregateException ex)              {                  //and throw the exception                  ExceptionDispatchInfo.Capture(ex).Throw();              }
Magic Number,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptMemoryStreamAsync,The following statement contains a magic number: try  		    {  			    //validate the recipientPrivateKey  			    if (recipientPrivateKey == null || recipientPrivateKey.Length != ASYNC_KEY_LENGTH)  			    {  				    throw new ArgumentOutOfRangeException("recipientPrivateKey"' "invalid recipientPrivateKey");  			    }    			    //first read the file header  			    EncryptedFileHeader encryptedFileHeader = new EncryptedFileHeader();  			    encryptedFileHeader = Serializer.DeserializeWithLengthPrefix<EncryptedFileHeader>(inputStream'  				    PrefixStyle.Base128' 1);  			    //decrypt the ephemeral key with our public box   			    byte[] ephemeralKey = PublicKeyBox.Open(encryptedFileHeader.Key' encryptedFileHeader.EphemeralNonce'  				    recipientPrivateKey' encryptedFileHeader.SenderPublicKey);  			    //validate our file header  			    encryptedFileHeader.ValidateHeaderChecksum(ephemeralKey' HEADER_CHECKSUM_LENGTH);  			    //check file header for compatibility  			    if ((encryptedFileHeader.Version >= MIN_VERSION) &&  			        (encryptedFileHeader.BaseNonce.Length == CHUNK_BASE_NONCE_LENGTH))  			    {  				    long overallChunkLength = 0;  				    long overallBytesRead = 0;  				    //restore the original file name  				    byte[] encryptedPaddedFileName = SecretBox.Open(encryptedFileHeader.Filename' encryptedFileHeader.FilenameNonce'  					    Utils.GetEphemeralEncryptionKey(ephemeralKey));  				    //remove the padding  				    decryptedFile.FileName = Utils.PaddedByteArrayToString(encryptedPaddedFileName);  				    //keep the position for the footer  				    long fileStreamEncryptedPosition = 0;  				    int chunkNumber = CHUNK_COUNT_START;  				    //write the file to the tmpFullPath  				    using (MemoryStream fileStreamUnencrypted = new MemoryStream())  				    {  					    //start reading the chunks  					    EncryptedFileChunk encryptedFileChunk = new EncryptedFileChunk();  					    while (  						    (encryptedFileChunk =  							    Serializer.DeserializeWithLengthPrefix<EncryptedFileChunk>(inputStream' PrefixStyle.Base128' 2)) != null)  					    {  						    //cancel the task if requested  						    cancellationToken.ThrowIfCancellationRequested();  						    //indicates if ChunkIsLast was found' to prepend more than one last chnunks.  						    bool isLastChunkFound = false;  						    byte[] chunkNonce = new byte[NONCE_LENGTH];  						    //check if this is the last chunk  						    if (encryptedFileChunk.ChunkIsLast)  						    {  							    if (!isLastChunkFound)  							    {  								    //last  								    chunkNonce = GetChunkNonce(encryptedFileHeader.BaseNonce' chunkNumber' true);  								    isLastChunkFound = true;  							    }  							    else  							    {  								    throw new BadLastFileChunkException(  									    "there are more than one last chunk' file could be damaged or manipulated!");  							    }  						    }  						    else  						    {  							    //there will propably come more  							    chunkNonce = GetChunkNonce(encryptedFileHeader.BaseNonce' chunkNumber);  						    }  						    //check the current chunk checksum  						    encryptedFileChunk.ValidateChunkChecksum(ephemeralKey' CHUNK_CHECKSUM_LENGTH);  						    byte[] decrypted = SecretBox.Open(encryptedFileChunk.Chunk' chunkNonce'  							    Utils.GetEphemeralEncryptionKey(ephemeralKey));  						    await  							    fileStreamUnencrypted.WriteAsync(decrypted' 0' decrypted.Length' cancellationToken).ConfigureAwait(false);  						    overallBytesRead += (long) decrypted.Length;  						    chunkNumber++;  						    overallChunkLength += encryptedFileChunk.ChunkLength;  						    fileStreamEncryptedPosition = inputStream.Position;  						    //report status  						    if (decryptionProgress != null)  						    {  							    var args = new StreamCryptorTaskAsyncProgress();  							    args.ProgressPercentage =  								    (int)  									    (encryptedFileHeader.UnencryptedFileLength <= 0  										    ? 0  										    : (100*overallBytesRead)/encryptedFileHeader.UnencryptedFileLength);  							    decryptionProgress.Report(args);  						    }  					    }  					    decryptedFile.FileData = fileStreamUnencrypted.ToArray();  					    decryptedFile.FileSize = decryptedFile.FileData.Length;  				    }  				    //set the last position  				    inputStream.Position = fileStreamEncryptedPosition;  				    //prepare the EncryptedFileFooter  				    EncryptedFileFooter encryptedFileFooter = new EncryptedFileFooter();  				    //get the file footer and validate him  				    encryptedFileFooter = Serializer.DeserializeWithLengthPrefix<EncryptedFileFooter>(inputStream'  					    PrefixStyle.Base128' 3);  				    if (encryptedFileFooter == null)  				    {  					    throw new BadFileFooterException("Missing file footer: file could be damaged or manipulated!");  				    }  				    //validate the footer checksum  				    encryptedFileFooter.ValidateFooterChecksum(BitConverter.GetBytes(chunkNumber)'  					    BitConverter.GetBytes(overallChunkLength)' ephemeralKey' FOOTER_CHECKSUM_LENGTH);  			    }  			    else  			    {  				    throw new BadFileHeaderException("Incompatible file header: maybe different library version!");  			    }  			    //check the produced output for the correct length  			    if (encryptedFileHeader.UnencryptedFileLength != decryptedFile.FileSize)  			    {  				    //File is not valid (return null)  				    decryptedFile = null;  			    }    		    }  		    catch (AggregateException ex)  		    {  			    //and throw the exception  			    ExceptionDispatchInfo.Capture(ex).Throw();  		    }
Magic Number,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptMemoryStreamAsync,The following statement contains a magic number: try  		    {  			    //validate the recipientPrivateKey  			    if (recipientPrivateKey == null || recipientPrivateKey.Length != ASYNC_KEY_LENGTH)  			    {  				    throw new ArgumentOutOfRangeException("recipientPrivateKey"' "invalid recipientPrivateKey");  			    }    			    //first read the file header  			    EncryptedFileHeader encryptedFileHeader = new EncryptedFileHeader();  			    encryptedFileHeader = Serializer.DeserializeWithLengthPrefix<EncryptedFileHeader>(inputStream'  				    PrefixStyle.Base128' 1);  			    //decrypt the ephemeral key with our public box   			    byte[] ephemeralKey = PublicKeyBox.Open(encryptedFileHeader.Key' encryptedFileHeader.EphemeralNonce'  				    recipientPrivateKey' encryptedFileHeader.SenderPublicKey);  			    //validate our file header  			    encryptedFileHeader.ValidateHeaderChecksum(ephemeralKey' HEADER_CHECKSUM_LENGTH);  			    //check file header for compatibility  			    if ((encryptedFileHeader.Version >= MIN_VERSION) &&  			        (encryptedFileHeader.BaseNonce.Length == CHUNK_BASE_NONCE_LENGTH))  			    {  				    long overallChunkLength = 0;  				    long overallBytesRead = 0;  				    //restore the original file name  				    byte[] encryptedPaddedFileName = SecretBox.Open(encryptedFileHeader.Filename' encryptedFileHeader.FilenameNonce'  					    Utils.GetEphemeralEncryptionKey(ephemeralKey));  				    //remove the padding  				    decryptedFile.FileName = Utils.PaddedByteArrayToString(encryptedPaddedFileName);  				    //keep the position for the footer  				    long fileStreamEncryptedPosition = 0;  				    int chunkNumber = CHUNK_COUNT_START;  				    //write the file to the tmpFullPath  				    using (MemoryStream fileStreamUnencrypted = new MemoryStream())  				    {  					    //start reading the chunks  					    EncryptedFileChunk encryptedFileChunk = new EncryptedFileChunk();  					    while (  						    (encryptedFileChunk =  							    Serializer.DeserializeWithLengthPrefix<EncryptedFileChunk>(inputStream' PrefixStyle.Base128' 2)) != null)  					    {  						    //cancel the task if requested  						    cancellationToken.ThrowIfCancellationRequested();  						    //indicates if ChunkIsLast was found' to prepend more than one last chnunks.  						    bool isLastChunkFound = false;  						    byte[] chunkNonce = new byte[NONCE_LENGTH];  						    //check if this is the last chunk  						    if (encryptedFileChunk.ChunkIsLast)  						    {  							    if (!isLastChunkFound)  							    {  								    //last  								    chunkNonce = GetChunkNonce(encryptedFileHeader.BaseNonce' chunkNumber' true);  								    isLastChunkFound = true;  							    }  							    else  							    {  								    throw new BadLastFileChunkException(  									    "there are more than one last chunk' file could be damaged or manipulated!");  							    }  						    }  						    else  						    {  							    //there will propably come more  							    chunkNonce = GetChunkNonce(encryptedFileHeader.BaseNonce' chunkNumber);  						    }  						    //check the current chunk checksum  						    encryptedFileChunk.ValidateChunkChecksum(ephemeralKey' CHUNK_CHECKSUM_LENGTH);  						    byte[] decrypted = SecretBox.Open(encryptedFileChunk.Chunk' chunkNonce'  							    Utils.GetEphemeralEncryptionKey(ephemeralKey));  						    await  							    fileStreamUnencrypted.WriteAsync(decrypted' 0' decrypted.Length' cancellationToken).ConfigureAwait(false);  						    overallBytesRead += (long) decrypted.Length;  						    chunkNumber++;  						    overallChunkLength += encryptedFileChunk.ChunkLength;  						    fileStreamEncryptedPosition = inputStream.Position;  						    //report status  						    if (decryptionProgress != null)  						    {  							    var args = new StreamCryptorTaskAsyncProgress();  							    args.ProgressPercentage =  								    (int)  									    (encryptedFileHeader.UnencryptedFileLength <= 0  										    ? 0  										    : (100*overallBytesRead)/encryptedFileHeader.UnencryptedFileLength);  							    decryptionProgress.Report(args);  						    }  					    }  					    decryptedFile.FileData = fileStreamUnencrypted.ToArray();  					    decryptedFile.FileSize = decryptedFile.FileData.Length;  				    }  				    //set the last position  				    inputStream.Position = fileStreamEncryptedPosition;  				    //prepare the EncryptedFileFooter  				    EncryptedFileFooter encryptedFileFooter = new EncryptedFileFooter();  				    //get the file footer and validate him  				    encryptedFileFooter = Serializer.DeserializeWithLengthPrefix<EncryptedFileFooter>(inputStream'  					    PrefixStyle.Base128' 3);  				    if (encryptedFileFooter == null)  				    {  					    throw new BadFileFooterException("Missing file footer: file could be damaged or manipulated!");  				    }  				    //validate the footer checksum  				    encryptedFileFooter.ValidateFooterChecksum(BitConverter.GetBytes(chunkNumber)'  					    BitConverter.GetBytes(overallChunkLength)' ephemeralKey' FOOTER_CHECKSUM_LENGTH);  			    }  			    else  			    {  				    throw new BadFileHeaderException("Incompatible file header: maybe different library version!");  			    }  			    //check the produced output for the correct length  			    if (encryptedFileHeader.UnencryptedFileLength != decryptedFile.FileSize)  			    {  				    //File is not valid (return null)  				    decryptedFile = null;  			    }    		    }  		    catch (AggregateException ex)  		    {  			    //and throw the exception  			    ExceptionDispatchInfo.Capture(ex).Throw();  		    }
Magic Number,StreamCryptor,Cryptor,C:\repos\bitbeans_StreamCryptor\StreamCryptor\Cryptor.cs,DecryptMemoryStreamAsync,The following statement contains a magic number: try  		    {  			    //validate the recipientPrivateKey  			    if (recipientPrivateKey == null || recipientPrivateKey.Length != ASYNC_KEY_LENGTH)  			    {  				    throw new ArgumentOutOfRangeException("recipientPrivateKey"' "invalid recipientPrivateKey");  			    }    			    //first read the file header  			    EncryptedFileHeader encryptedFileHeader = new EncryptedFileHeader();  			    encryptedFileHeader = Serializer.DeserializeWithLengthPrefix<EncryptedFileHeader>(inputStream'  				    PrefixStyle.Base128' 1);  			    //decrypt the ephemeral key with our public box   			    byte[] ephemeralKey = PublicKeyBox.Open(encryptedFileHeader.Key' encryptedFileHeader.EphemeralNonce'  				    recipientPrivateKey' encryptedFileHeader.SenderPublicKey);  			    //validate our file header  			    encryptedFileHeader.ValidateHeaderChecksum(ephemeralKey' HEADER_CHECKSUM_LENGTH);  			    //check file header for compatibility  			    if ((encryptedFileHeader.Version >= MIN_VERSION) &&  			        (encryptedFileHeader.BaseNonce.Length == CHUNK_BASE_NONCE_LENGTH))  			    {  				    long overallChunkLength = 0;  				    long overallBytesRead = 0;  				    //restore the original file name  				    byte[] encryptedPaddedFileName = SecretBox.Open(encryptedFileHeader.Filename' encryptedFileHeader.FilenameNonce'  					    Utils.GetEphemeralEncryptionKey(ephemeralKey));  				    //remove the padding  				    decryptedFile.FileName = Utils.PaddedByteArrayToString(encryptedPaddedFileName);  				    //keep the position for the footer  				    long fileStreamEncryptedPosition = 0;  				    int chunkNumber = CHUNK_COUNT_START;  				    //write the file to the tmpFullPath  				    using (MemoryStream fileStreamUnencrypted = new MemoryStream())  				    {  					    //start reading the chunks  					    EncryptedFileChunk encryptedFileChunk = new EncryptedFileChunk();  					    while (  						    (encryptedFileChunk =  							    Serializer.DeserializeWithLengthPrefix<EncryptedFileChunk>(inputStream' PrefixStyle.Base128' 2)) != null)  					    {  						    //cancel the task if requested  						    cancellationToken.ThrowIfCancellationRequested();  						    //indicates if ChunkIsLast was found' to prepend more than one last chnunks.  						    bool isLastChunkFound = false;  						    byte[] chunkNonce = new byte[NONCE_LENGTH];  						    //check if this is the last chunk  						    if (encryptedFileChunk.ChunkIsLast)  						    {  							    if (!isLastChunkFound)  							    {  								    //last  								    chunkNonce = GetChunkNonce(encryptedFileHeader.BaseNonce' chunkNumber' true);  								    isLastChunkFound = true;  							    }  							    else  							    {  								    throw new BadLastFileChunkException(  									    "there are more than one last chunk' file could be damaged or manipulated!");  							    }  						    }  						    else  						    {  							    //there will propably come more  							    chunkNonce = GetChunkNonce(encryptedFileHeader.BaseNonce' chunkNumber);  						    }  						    //check the current chunk checksum  						    encryptedFileChunk.ValidateChunkChecksum(ephemeralKey' CHUNK_CHECKSUM_LENGTH);  						    byte[] decrypted = SecretBox.Open(encryptedFileChunk.Chunk' chunkNonce'  							    Utils.GetEphemeralEncryptionKey(ephemeralKey));  						    await  							    fileStreamUnencrypted.WriteAsync(decrypted' 0' decrypted.Length' cancellationToken).ConfigureAwait(false);  						    overallBytesRead += (long) decrypted.Length;  						    chunkNumber++;  						    overallChunkLength += encryptedFileChunk.ChunkLength;  						    fileStreamEncryptedPosition = inputStream.Position;  						    //report status  						    if (decryptionProgress != null)  						    {  							    var args = new StreamCryptorTaskAsyncProgress();  							    args.ProgressPercentage =  								    (int)  									    (encryptedFileHeader.UnencryptedFileLength <= 0  										    ? 0  										    : (100*overallBytesRead)/encryptedFileHeader.UnencryptedFileLength);  							    decryptionProgress.Report(args);  						    }  					    }  					    decryptedFile.FileData = fileStreamUnencrypted.ToArray();  					    decryptedFile.FileSize = decryptedFile.FileData.Length;  				    }  				    //set the last position  				    inputStream.Position = fileStreamEncryptedPosition;  				    //prepare the EncryptedFileFooter  				    EncryptedFileFooter encryptedFileFooter = new EncryptedFileFooter();  				    //get the file footer and validate him  				    encryptedFileFooter = Serializer.DeserializeWithLengthPrefix<EncryptedFileFooter>(inputStream'  					    PrefixStyle.Base128' 3);  				    if (encryptedFileFooter == null)  				    {  					    throw new BadFileFooterException("Missing file footer: file could be damaged or manipulated!");  				    }  				    //validate the footer checksum  				    encryptedFileFooter.ValidateFooterChecksum(BitConverter.GetBytes(chunkNumber)'  					    BitConverter.GetBytes(overallChunkLength)' ephemeralKey' FOOTER_CHECKSUM_LENGTH);  			    }  			    else  			    {  				    throw new BadFileHeaderException("Incompatible file header: maybe different library version!");  			    }  			    //check the produced output for the correct length  			    if (encryptedFileHeader.UnencryptedFileLength != decryptedFile.FileSize)  			    {  				    //File is not valid (return null)  				    decryptedFile = null;  			    }    		    }  		    catch (AggregateException ex)  		    {  			    //and throw the exception  			    ExceptionDispatchInfo.Capture(ex).Throw();  		    }
