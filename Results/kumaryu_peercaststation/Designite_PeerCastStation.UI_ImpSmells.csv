Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,PeerCastStation.UI.PortMapper,MappedPort,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatDeviceDiscoverer.cs,MappedPort,The method has 5 parameters. Parameters: device' protocol' internal_port' external_port' expiration
Long Parameter List,PeerCastStation.UI.PortMapper,UPnPServiceDescription,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\UPnPDevice.cs,UPnPServiceDescription,The method has 8 parameters. Parameters: device_name' device_type' udn' service_id' service_type' control_url' event_sub_url' scpd_url
Long Statement,PeerCastStation.UI,AppCastReader,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\AppCastReader.cs,GetDateTimeValue,The length of the statement  "      if (!DateTime.TryParse(GetStringValue(src)' System.Globalization.DateTimeFormatInfo.InvariantInfo' System.Globalization.DateTimeStyles.None' out result)) { " is 155.
Long Statement,PeerCastStation.UI,AppCastReader,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\AppCastReader.cs,ParseResponse,The length of the statement  "        using (var s=new System.IO.Compression.GZipStream(new System.IO.MemoryStream(body)' System.IO.Compression.CompressionMode.Decompress)) { " is 136.
Long Statement,PeerCastStation.UI,AppCastReader,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\AppCastReader.cs,ParseResponse,The length of the statement  "        using (var s=new System.IO.Compression.DeflateStream(new System.IO.MemoryStream(body)' System.IO.Compression.CompressionMode.Decompress)) { " is 139.
Long Statement,PeerCastStation.UI.PortMapper,UPnPService,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\UPnPDevice.cs,SendActionAsync,The length of the statement  "        logger.Debug("Sending UPnP Action {0} to {1}"' this.ServiceDescription.ServiceType+"#"+action' this.ServiceDescription.ControlUrl); " is 131.
Long Statement,PeerCastStation.UI.PortMapper,WANCommonInterfaceConfigService,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\UPnPDevice.cs,GetCommonLinkProperties,The length of the statement  "      if (result.Parameters.TryGetValue("NewLayer1UpstreamMaxBitRate"' out value)) Int32.TryParse(value' out layer1_upstream_max_bitrate); " is 132.
Long Statement,PeerCastStation.UI.PortMapper,WANCommonInterfaceConfigService,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\UPnPDevice.cs,GetCommonLinkProperties,The length of the statement  "      if (result.Parameters.TryGetValue("NewLayer1DownstreamMaxBitRate"' out value)) Int32.TryParse(value' out layer1_downstream_max_bitrate); " is 136.
Long Statement,PeerCastStation.UI.PortMapper,WANCommonInterfaceConfigService,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\UPnPDevice.cs,GetCommonLinkProperties,The length of the statement  "      return new CommonLinkProperties(wan_access_type' layer1_upstream_max_bitrate' layer1_downstream_max_bitrate' physical_link_status); " is 131.
Long Statement,PeerCastStation.UI.PortMapper,SSDPDiscoverer,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\UPnPDevice.cs,SSDPAsync,The length of the statement  "            var response = System.Text.Encoding.ASCII.GetString(result.Buffer).Split(new string[] { "\r\n" }' StringSplitOptions.None); " is 123.
Long Statement,PeerCastStation.UI.PortMapper,SSDPDiscoverer,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\UPnPDevice.cs,GetUPnPServiceAsync,The length of the statement  "            return new UPnPServiceDescription(friendly_name' device_type' udn' service_id' service_type' control_url' event_sub_url' scpd_url); " is 131.
Empty Catch Block,PeerCastStation.UI,Updater,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\Updater.cs,InplaceUpdate,The method has an empty catch block.
Empty Catch Block,PeerCastStation.UI,Updater,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\Updater.cs,InplaceUpdate,The method has an empty catch block.
Empty Catch Block,PeerCastStation.UI,Updater,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\Updater.cs,InplaceUpdate,The method has an empty catch block.
Empty Catch Block,PeerCastStation.UI,AppCastReader,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\AppCastReader.cs,ParseAppCast,The method has an empty catch block.
Empty Catch Block,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,MapAsyncInternal,The method has an empty catch block.
Empty Catch Block,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,MapAsyncInternal,The method has an empty catch block.
Empty Catch Block,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,UnmapAsync,The method has an empty catch block.
Empty Catch Block,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,GetExternalAddressAsync,The method has an empty catch block.
Empty Catch Block,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,GetExternalAddressAsync,The method has an empty catch block.
Magic Number,PeerCastStation.UI,PortMapperMonitor,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapperPlugin.cs,Dispose,The following statement contains a magic number: cancelSource.CancelAfter(1000);
Magic Number,PeerCastStation.UI,PortMapperMonitor,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapperPlugin.cs,AddPortOnDevice,The following statement contains a magic number: device.MapAsync(MappingProtocol.TCP' port' TimeSpan.FromSeconds(7200)' cancelSource.Token);
Magic Number,PeerCastStation.UI,PortMapperMonitor,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapperPlugin.cs,AddPortOnDevice,The following statement contains a magic number: device.MapAsync(MappingProtocol.UDP' port' TimeSpan.FromSeconds(7200)' cancelSource.Token);
Magic Number,PeerCastStation.UI,PortMapperMonitor,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapperPlugin.cs,OnTimer,The following statement contains a magic number: lock (ports) {          var current_ports = peerCast.OutputListeners            .Where(listener  => (listener.GlobalOutputAccepts & OutputStreamType.All)!=0)            .Select(listener => listener.LocalEndPoint.Port).ToArray();          var added_ports    = current_ports.Except(ports).ToArray();          var removed_ports  = ports.Except(current_ports).ToArray();          var existing_ports = current_ports.Intersect(ports).ToArray();          foreach (var port in removed_ports) {            RemovePort(port);          }          foreach (var port in added_ports) {            AddPort(port);          }          if (renewTimer.ElapsedMilliseconds>=60000) {            foreach (var port in existing_ports) {              RenewPort(port);            }            renewTimer.Restart();          }          ports = current_ports;        }
Magic Number,PeerCastStation.UI,UISettings,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\UISettings.cs,AddBroadcastHistory,The following statement contains a magic number: BroadcastHistory = fav.Concat(Enumerable.Repeat(info' 1).Concat(others.Take(19))).ToArray();
Magic Number,PeerCastStation.UI,YPChannelList,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\YPChannelList.cs,UpdateAsync,The following statement contains a magic number: if (updateTimer.IsRunning && updateTimer.ElapsedMilliseconds<18000) return Channels;
Magic Number,PeerCastStation.UI,YPChannelList,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\YPChannelList.cs,UpdateAsync,The following statement contains a magic number: updateCancel = new CancellationTokenSource(5000);
Magic Number,PeerCastStation.UI.PortMapper,BinaryAccessor,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatDeviceDiscoverer.cs,GetUInt16BE,The following statement contains a magic number: return (bytes[offset]<<8) | bytes[offset+1];
Magic Number,PeerCastStation.UI.PortMapper,BinaryAccessor,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatDeviceDiscoverer.cs,PutUInt16BE,The following statement contains a magic number: bytes[offset+0] = (byte)((value & 0xFF00) >> 8);
Magic Number,PeerCastStation.UI.PortMapper,BinaryAccessor,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatDeviceDiscoverer.cs,GetUInt32BE,The following statement contains a magic number: return          ((uint)bytes[offset+0]<<24) |          ((uint)bytes[offset+1]<<16) |          ((uint)bytes[offset+2]<<8) |          ((uint)bytes[offset+3]);
Magic Number,PeerCastStation.UI.PortMapper,BinaryAccessor,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatDeviceDiscoverer.cs,GetUInt32BE,The following statement contains a magic number: return          ((uint)bytes[offset+0]<<24) |          ((uint)bytes[offset+1]<<16) |          ((uint)bytes[offset+2]<<8) |          ((uint)bytes[offset+3]);
Magic Number,PeerCastStation.UI.PortMapper,BinaryAccessor,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatDeviceDiscoverer.cs,GetUInt32BE,The following statement contains a magic number: return          ((uint)bytes[offset+0]<<24) |          ((uint)bytes[offset+1]<<16) |          ((uint)bytes[offset+2]<<8) |          ((uint)bytes[offset+3]);
Magic Number,PeerCastStation.UI.PortMapper,BinaryAccessor,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatDeviceDiscoverer.cs,GetUInt32BE,The following statement contains a magic number: return          ((uint)bytes[offset+0]<<24) |          ((uint)bytes[offset+1]<<16) |          ((uint)bytes[offset+2]<<8) |          ((uint)bytes[offset+3]);
Magic Number,PeerCastStation.UI.PortMapper,BinaryAccessor,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatDeviceDiscoverer.cs,GetUInt32BE,The following statement contains a magic number: return          ((uint)bytes[offset+0]<<24) |          ((uint)bytes[offset+1]<<16) |          ((uint)bytes[offset+2]<<8) |          ((uint)bytes[offset+3]);
Magic Number,PeerCastStation.UI.PortMapper,BinaryAccessor,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatDeviceDiscoverer.cs,PutUInt32BE,The following statement contains a magic number: bytes[offset+0] = (byte)((value & 0xFF000000) >> 24);
Magic Number,PeerCastStation.UI.PortMapper,BinaryAccessor,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatDeviceDiscoverer.cs,PutUInt32BE,The following statement contains a magic number: bytes[offset+1] = (byte)((value & 0x00FF0000) >> 16);
Magic Number,PeerCastStation.UI.PortMapper,BinaryAccessor,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatDeviceDiscoverer.cs,PutUInt32BE,The following statement contains a magic number: bytes[offset+2] = (byte)((value & 0x0000FF00) >> 8);
Magic Number,PeerCastStation.UI.PortMapper,BinaryAccessor,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatDeviceDiscoverer.cs,PutUInt32BE,The following statement contains a magic number: bytes[offset+2] = (byte)((value & 0x0000FF00) >> 8);
Magic Number,PeerCastStation.UI.PortMapper,BinaryAccessor,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatDeviceDiscoverer.cs,PutUInt32BE,The following statement contains a magic number: bytes[offset+3] = (byte)(value & 0x000000FF);
Magic Number,PeerCastStation.UI.PortMapper,BinaryAccessor,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatDeviceDiscoverer.cs,GetIPv4AddressBE,The following statement contains a magic number: return new IPAddress(new byte[] {           bytes[offset+0]'          bytes[offset+1]'          bytes[offset+2]'          bytes[offset+3]'        });
Magic Number,PeerCastStation.UI.PortMapper,BinaryAccessor,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatDeviceDiscoverer.cs,GetIPv4AddressBE,The following statement contains a magic number: return new IPAddress(new byte[] {           bytes[offset+0]'          bytes[offset+1]'          bytes[offset+2]'          bytes[offset+3]'        });
Magic Number,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,MapAsyncInternal,The following statement contains a magic number: using (var client = new UdpClient()) {          var cancel_source = CancellationTokenSource.CreateLinkedTokenSource(            new CancellationTokenSource(250*tries).Token'            cancel_token);          var cancel = cancel_source.Token;          cancel.Register(() => client.Close()' false);          try {            var bytes = new byte[12];            BinaryAccessor.PutByte(bytes' 0' PMPVersion);            switch (protocol) {            case MappingProtocol.TCP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapTcp);              break;            case MappingProtocol.UDP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapUdp);              break;            }            BinaryAccessor.PutUInt16BE(bytes' 2' 0);            BinaryAccessor.PutUInt16BE(bytes' 4' port);            BinaryAccessor.PutUInt16BE(bytes' 6' port);            BinaryAccessor.PutUInt32BE(bytes' 8' lifetime);              await client.SendAsync(bytes' bytes.Length' new IPEndPoint(this.DeviceAddress' PMPPort));            var msg = await client.ReceiveAsync();            if (!msg.RemoteEndPoint.Address.Equals(this.DeviceAddress) || msg.Buffer.Length<16) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            var ver    = BinaryAccessor.GetByte(msg.Buffer' 0);            var opcode = BinaryAccessor.GetByte(msg.Buffer' 1);            var err    = BinaryAccessor.GetUInt16BE(msg.Buffer' 2);            var time   = BinaryAccessor.GetUInt32BE(msg.Buffer' 4);            var internal_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 8);            var external_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 10);            var mapped_lifetime = BinaryAccessor.GetUInt32BE(msg.Buffer' 12);            if (ver!=PMPVersion) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            switch (protocol) {            case MappingProtocol.TCP:              if (opcode!=PMPOpResultMapTcp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            case MappingProtocol.UDP:              if (opcode!=PMPOpResultMapUdp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            }            if (err!=0) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            this.LastTimestamp = time;            return new MappedPort(              this'              protocol'              internal_port'              external_port'              DateTime.Now.AddSeconds(mapped_lifetime));          }          catch (SocketException) { }          catch (ObjectDisposedException) { }          if (tries++<PMPTries) goto retry;          throw new PortMappingException();        }
Magic Number,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,MapAsyncInternal,The following statement contains a magic number: using (var client = new UdpClient()) {          var cancel_source = CancellationTokenSource.CreateLinkedTokenSource(            new CancellationTokenSource(250*tries).Token'            cancel_token);          var cancel = cancel_source.Token;          cancel.Register(() => client.Close()' false);          try {            var bytes = new byte[12];            BinaryAccessor.PutByte(bytes' 0' PMPVersion);            switch (protocol) {            case MappingProtocol.TCP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapTcp);              break;            case MappingProtocol.UDP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapUdp);              break;            }            BinaryAccessor.PutUInt16BE(bytes' 2' 0);            BinaryAccessor.PutUInt16BE(bytes' 4' port);            BinaryAccessor.PutUInt16BE(bytes' 6' port);            BinaryAccessor.PutUInt32BE(bytes' 8' lifetime);              await client.SendAsync(bytes' bytes.Length' new IPEndPoint(this.DeviceAddress' PMPPort));            var msg = await client.ReceiveAsync();            if (!msg.RemoteEndPoint.Address.Equals(this.DeviceAddress) || msg.Buffer.Length<16) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            var ver    = BinaryAccessor.GetByte(msg.Buffer' 0);            var opcode = BinaryAccessor.GetByte(msg.Buffer' 1);            var err    = BinaryAccessor.GetUInt16BE(msg.Buffer' 2);            var time   = BinaryAccessor.GetUInt32BE(msg.Buffer' 4);            var internal_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 8);            var external_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 10);            var mapped_lifetime = BinaryAccessor.GetUInt32BE(msg.Buffer' 12);            if (ver!=PMPVersion) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            switch (protocol) {            case MappingProtocol.TCP:              if (opcode!=PMPOpResultMapTcp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            case MappingProtocol.UDP:              if (opcode!=PMPOpResultMapUdp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            }            if (err!=0) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            this.LastTimestamp = time;            return new MappedPort(              this'              protocol'              internal_port'              external_port'              DateTime.Now.AddSeconds(mapped_lifetime));          }          catch (SocketException) { }          catch (ObjectDisposedException) { }          if (tries++<PMPTries) goto retry;          throw new PortMappingException();        }
Magic Number,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,MapAsyncInternal,The following statement contains a magic number: using (var client = new UdpClient()) {          var cancel_source = CancellationTokenSource.CreateLinkedTokenSource(            new CancellationTokenSource(250*tries).Token'            cancel_token);          var cancel = cancel_source.Token;          cancel.Register(() => client.Close()' false);          try {            var bytes = new byte[12];            BinaryAccessor.PutByte(bytes' 0' PMPVersion);            switch (protocol) {            case MappingProtocol.TCP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapTcp);              break;            case MappingProtocol.UDP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapUdp);              break;            }            BinaryAccessor.PutUInt16BE(bytes' 2' 0);            BinaryAccessor.PutUInt16BE(bytes' 4' port);            BinaryAccessor.PutUInt16BE(bytes' 6' port);            BinaryAccessor.PutUInt32BE(bytes' 8' lifetime);              await client.SendAsync(bytes' bytes.Length' new IPEndPoint(this.DeviceAddress' PMPPort));            var msg = await client.ReceiveAsync();            if (!msg.RemoteEndPoint.Address.Equals(this.DeviceAddress) || msg.Buffer.Length<16) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            var ver    = BinaryAccessor.GetByte(msg.Buffer' 0);            var opcode = BinaryAccessor.GetByte(msg.Buffer' 1);            var err    = BinaryAccessor.GetUInt16BE(msg.Buffer' 2);            var time   = BinaryAccessor.GetUInt32BE(msg.Buffer' 4);            var internal_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 8);            var external_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 10);            var mapped_lifetime = BinaryAccessor.GetUInt32BE(msg.Buffer' 12);            if (ver!=PMPVersion) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            switch (protocol) {            case MappingProtocol.TCP:              if (opcode!=PMPOpResultMapTcp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            case MappingProtocol.UDP:              if (opcode!=PMPOpResultMapUdp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            }            if (err!=0) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            this.LastTimestamp = time;            return new MappedPort(              this'              protocol'              internal_port'              external_port'              DateTime.Now.AddSeconds(mapped_lifetime));          }          catch (SocketException) { }          catch (ObjectDisposedException) { }          if (tries++<PMPTries) goto retry;          throw new PortMappingException();        }
Magic Number,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,MapAsyncInternal,The following statement contains a magic number: using (var client = new UdpClient()) {          var cancel_source = CancellationTokenSource.CreateLinkedTokenSource(            new CancellationTokenSource(250*tries).Token'            cancel_token);          var cancel = cancel_source.Token;          cancel.Register(() => client.Close()' false);          try {            var bytes = new byte[12];            BinaryAccessor.PutByte(bytes' 0' PMPVersion);            switch (protocol) {            case MappingProtocol.TCP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapTcp);              break;            case MappingProtocol.UDP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapUdp);              break;            }            BinaryAccessor.PutUInt16BE(bytes' 2' 0);            BinaryAccessor.PutUInt16BE(bytes' 4' port);            BinaryAccessor.PutUInt16BE(bytes' 6' port);            BinaryAccessor.PutUInt32BE(bytes' 8' lifetime);              await client.SendAsync(bytes' bytes.Length' new IPEndPoint(this.DeviceAddress' PMPPort));            var msg = await client.ReceiveAsync();            if (!msg.RemoteEndPoint.Address.Equals(this.DeviceAddress) || msg.Buffer.Length<16) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            var ver    = BinaryAccessor.GetByte(msg.Buffer' 0);            var opcode = BinaryAccessor.GetByte(msg.Buffer' 1);            var err    = BinaryAccessor.GetUInt16BE(msg.Buffer' 2);            var time   = BinaryAccessor.GetUInt32BE(msg.Buffer' 4);            var internal_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 8);            var external_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 10);            var mapped_lifetime = BinaryAccessor.GetUInt32BE(msg.Buffer' 12);            if (ver!=PMPVersion) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            switch (protocol) {            case MappingProtocol.TCP:              if (opcode!=PMPOpResultMapTcp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            case MappingProtocol.UDP:              if (opcode!=PMPOpResultMapUdp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            }            if (err!=0) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            this.LastTimestamp = time;            return new MappedPort(              this'              protocol'              internal_port'              external_port'              DateTime.Now.AddSeconds(mapped_lifetime));          }          catch (SocketException) { }          catch (ObjectDisposedException) { }          if (tries++<PMPTries) goto retry;          throw new PortMappingException();        }
Magic Number,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,MapAsyncInternal,The following statement contains a magic number: using (var client = new UdpClient()) {          var cancel_source = CancellationTokenSource.CreateLinkedTokenSource(            new CancellationTokenSource(250*tries).Token'            cancel_token);          var cancel = cancel_source.Token;          cancel.Register(() => client.Close()' false);          try {            var bytes = new byte[12];            BinaryAccessor.PutByte(bytes' 0' PMPVersion);            switch (protocol) {            case MappingProtocol.TCP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapTcp);              break;            case MappingProtocol.UDP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapUdp);              break;            }            BinaryAccessor.PutUInt16BE(bytes' 2' 0);            BinaryAccessor.PutUInt16BE(bytes' 4' port);            BinaryAccessor.PutUInt16BE(bytes' 6' port);            BinaryAccessor.PutUInt32BE(bytes' 8' lifetime);              await client.SendAsync(bytes' bytes.Length' new IPEndPoint(this.DeviceAddress' PMPPort));            var msg = await client.ReceiveAsync();            if (!msg.RemoteEndPoint.Address.Equals(this.DeviceAddress) || msg.Buffer.Length<16) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            var ver    = BinaryAccessor.GetByte(msg.Buffer' 0);            var opcode = BinaryAccessor.GetByte(msg.Buffer' 1);            var err    = BinaryAccessor.GetUInt16BE(msg.Buffer' 2);            var time   = BinaryAccessor.GetUInt32BE(msg.Buffer' 4);            var internal_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 8);            var external_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 10);            var mapped_lifetime = BinaryAccessor.GetUInt32BE(msg.Buffer' 12);            if (ver!=PMPVersion) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            switch (protocol) {            case MappingProtocol.TCP:              if (opcode!=PMPOpResultMapTcp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            case MappingProtocol.UDP:              if (opcode!=PMPOpResultMapUdp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            }            if (err!=0) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            this.LastTimestamp = time;            return new MappedPort(              this'              protocol'              internal_port'              external_port'              DateTime.Now.AddSeconds(mapped_lifetime));          }          catch (SocketException) { }          catch (ObjectDisposedException) { }          if (tries++<PMPTries) goto retry;          throw new PortMappingException();        }
Magic Number,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,MapAsyncInternal,The following statement contains a magic number: using (var client = new UdpClient()) {          var cancel_source = CancellationTokenSource.CreateLinkedTokenSource(            new CancellationTokenSource(250*tries).Token'            cancel_token);          var cancel = cancel_source.Token;          cancel.Register(() => client.Close()' false);          try {            var bytes = new byte[12];            BinaryAccessor.PutByte(bytes' 0' PMPVersion);            switch (protocol) {            case MappingProtocol.TCP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapTcp);              break;            case MappingProtocol.UDP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapUdp);              break;            }            BinaryAccessor.PutUInt16BE(bytes' 2' 0);            BinaryAccessor.PutUInt16BE(bytes' 4' port);            BinaryAccessor.PutUInt16BE(bytes' 6' port);            BinaryAccessor.PutUInt32BE(bytes' 8' lifetime);              await client.SendAsync(bytes' bytes.Length' new IPEndPoint(this.DeviceAddress' PMPPort));            var msg = await client.ReceiveAsync();            if (!msg.RemoteEndPoint.Address.Equals(this.DeviceAddress) || msg.Buffer.Length<16) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            var ver    = BinaryAccessor.GetByte(msg.Buffer' 0);            var opcode = BinaryAccessor.GetByte(msg.Buffer' 1);            var err    = BinaryAccessor.GetUInt16BE(msg.Buffer' 2);            var time   = BinaryAccessor.GetUInt32BE(msg.Buffer' 4);            var internal_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 8);            var external_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 10);            var mapped_lifetime = BinaryAccessor.GetUInt32BE(msg.Buffer' 12);            if (ver!=PMPVersion) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            switch (protocol) {            case MappingProtocol.TCP:              if (opcode!=PMPOpResultMapTcp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            case MappingProtocol.UDP:              if (opcode!=PMPOpResultMapUdp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            }            if (err!=0) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            this.LastTimestamp = time;            return new MappedPort(              this'              protocol'              internal_port'              external_port'              DateTime.Now.AddSeconds(mapped_lifetime));          }          catch (SocketException) { }          catch (ObjectDisposedException) { }          if (tries++<PMPTries) goto retry;          throw new PortMappingException();        }
Magic Number,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,MapAsyncInternal,The following statement contains a magic number: using (var client = new UdpClient()) {          var cancel_source = CancellationTokenSource.CreateLinkedTokenSource(            new CancellationTokenSource(250*tries).Token'            cancel_token);          var cancel = cancel_source.Token;          cancel.Register(() => client.Close()' false);          try {            var bytes = new byte[12];            BinaryAccessor.PutByte(bytes' 0' PMPVersion);            switch (protocol) {            case MappingProtocol.TCP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapTcp);              break;            case MappingProtocol.UDP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapUdp);              break;            }            BinaryAccessor.PutUInt16BE(bytes' 2' 0);            BinaryAccessor.PutUInt16BE(bytes' 4' port);            BinaryAccessor.PutUInt16BE(bytes' 6' port);            BinaryAccessor.PutUInt32BE(bytes' 8' lifetime);              await client.SendAsync(bytes' bytes.Length' new IPEndPoint(this.DeviceAddress' PMPPort));            var msg = await client.ReceiveAsync();            if (!msg.RemoteEndPoint.Address.Equals(this.DeviceAddress) || msg.Buffer.Length<16) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            var ver    = BinaryAccessor.GetByte(msg.Buffer' 0);            var opcode = BinaryAccessor.GetByte(msg.Buffer' 1);            var err    = BinaryAccessor.GetUInt16BE(msg.Buffer' 2);            var time   = BinaryAccessor.GetUInt32BE(msg.Buffer' 4);            var internal_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 8);            var external_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 10);            var mapped_lifetime = BinaryAccessor.GetUInt32BE(msg.Buffer' 12);            if (ver!=PMPVersion) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            switch (protocol) {            case MappingProtocol.TCP:              if (opcode!=PMPOpResultMapTcp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            case MappingProtocol.UDP:              if (opcode!=PMPOpResultMapUdp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            }            if (err!=0) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            this.LastTimestamp = time;            return new MappedPort(              this'              protocol'              internal_port'              external_port'              DateTime.Now.AddSeconds(mapped_lifetime));          }          catch (SocketException) { }          catch (ObjectDisposedException) { }          if (tries++<PMPTries) goto retry;          throw new PortMappingException();        }
Magic Number,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,MapAsyncInternal,The following statement contains a magic number: using (var client = new UdpClient()) {          var cancel_source = CancellationTokenSource.CreateLinkedTokenSource(            new CancellationTokenSource(250*tries).Token'            cancel_token);          var cancel = cancel_source.Token;          cancel.Register(() => client.Close()' false);          try {            var bytes = new byte[12];            BinaryAccessor.PutByte(bytes' 0' PMPVersion);            switch (protocol) {            case MappingProtocol.TCP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapTcp);              break;            case MappingProtocol.UDP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapUdp);              break;            }            BinaryAccessor.PutUInt16BE(bytes' 2' 0);            BinaryAccessor.PutUInt16BE(bytes' 4' port);            BinaryAccessor.PutUInt16BE(bytes' 6' port);            BinaryAccessor.PutUInt32BE(bytes' 8' lifetime);              await client.SendAsync(bytes' bytes.Length' new IPEndPoint(this.DeviceAddress' PMPPort));            var msg = await client.ReceiveAsync();            if (!msg.RemoteEndPoint.Address.Equals(this.DeviceAddress) || msg.Buffer.Length<16) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            var ver    = BinaryAccessor.GetByte(msg.Buffer' 0);            var opcode = BinaryAccessor.GetByte(msg.Buffer' 1);            var err    = BinaryAccessor.GetUInt16BE(msg.Buffer' 2);            var time   = BinaryAccessor.GetUInt32BE(msg.Buffer' 4);            var internal_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 8);            var external_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 10);            var mapped_lifetime = BinaryAccessor.GetUInt32BE(msg.Buffer' 12);            if (ver!=PMPVersion) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            switch (protocol) {            case MappingProtocol.TCP:              if (opcode!=PMPOpResultMapTcp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            case MappingProtocol.UDP:              if (opcode!=PMPOpResultMapUdp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            }            if (err!=0) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            this.LastTimestamp = time;            return new MappedPort(              this'              protocol'              internal_port'              external_port'              DateTime.Now.AddSeconds(mapped_lifetime));          }          catch (SocketException) { }          catch (ObjectDisposedException) { }          if (tries++<PMPTries) goto retry;          throw new PortMappingException();        }
Magic Number,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,MapAsyncInternal,The following statement contains a magic number: using (var client = new UdpClient()) {          var cancel_source = CancellationTokenSource.CreateLinkedTokenSource(            new CancellationTokenSource(250*tries).Token'            cancel_token);          var cancel = cancel_source.Token;          cancel.Register(() => client.Close()' false);          try {            var bytes = new byte[12];            BinaryAccessor.PutByte(bytes' 0' PMPVersion);            switch (protocol) {            case MappingProtocol.TCP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapTcp);              break;            case MappingProtocol.UDP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapUdp);              break;            }            BinaryAccessor.PutUInt16BE(bytes' 2' 0);            BinaryAccessor.PutUInt16BE(bytes' 4' port);            BinaryAccessor.PutUInt16BE(bytes' 6' port);            BinaryAccessor.PutUInt32BE(bytes' 8' lifetime);              await client.SendAsync(bytes' bytes.Length' new IPEndPoint(this.DeviceAddress' PMPPort));            var msg = await client.ReceiveAsync();            if (!msg.RemoteEndPoint.Address.Equals(this.DeviceAddress) || msg.Buffer.Length<16) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            var ver    = BinaryAccessor.GetByte(msg.Buffer' 0);            var opcode = BinaryAccessor.GetByte(msg.Buffer' 1);            var err    = BinaryAccessor.GetUInt16BE(msg.Buffer' 2);            var time   = BinaryAccessor.GetUInt32BE(msg.Buffer' 4);            var internal_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 8);            var external_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 10);            var mapped_lifetime = BinaryAccessor.GetUInt32BE(msg.Buffer' 12);            if (ver!=PMPVersion) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            switch (protocol) {            case MappingProtocol.TCP:              if (opcode!=PMPOpResultMapTcp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            case MappingProtocol.UDP:              if (opcode!=PMPOpResultMapUdp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            }            if (err!=0) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            this.LastTimestamp = time;            return new MappedPort(              this'              protocol'              internal_port'              external_port'              DateTime.Now.AddSeconds(mapped_lifetime));          }          catch (SocketException) { }          catch (ObjectDisposedException) { }          if (tries++<PMPTries) goto retry;          throw new PortMappingException();        }
Magic Number,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,MapAsyncInternal,The following statement contains a magic number: using (var client = new UdpClient()) {          var cancel_source = CancellationTokenSource.CreateLinkedTokenSource(            new CancellationTokenSource(250*tries).Token'            cancel_token);          var cancel = cancel_source.Token;          cancel.Register(() => client.Close()' false);          try {            var bytes = new byte[12];            BinaryAccessor.PutByte(bytes' 0' PMPVersion);            switch (protocol) {            case MappingProtocol.TCP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapTcp);              break;            case MappingProtocol.UDP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapUdp);              break;            }            BinaryAccessor.PutUInt16BE(bytes' 2' 0);            BinaryAccessor.PutUInt16BE(bytes' 4' port);            BinaryAccessor.PutUInt16BE(bytes' 6' port);            BinaryAccessor.PutUInt32BE(bytes' 8' lifetime);              await client.SendAsync(bytes' bytes.Length' new IPEndPoint(this.DeviceAddress' PMPPort));            var msg = await client.ReceiveAsync();            if (!msg.RemoteEndPoint.Address.Equals(this.DeviceAddress) || msg.Buffer.Length<16) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            var ver    = BinaryAccessor.GetByte(msg.Buffer' 0);            var opcode = BinaryAccessor.GetByte(msg.Buffer' 1);            var err    = BinaryAccessor.GetUInt16BE(msg.Buffer' 2);            var time   = BinaryAccessor.GetUInt32BE(msg.Buffer' 4);            var internal_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 8);            var external_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 10);            var mapped_lifetime = BinaryAccessor.GetUInt32BE(msg.Buffer' 12);            if (ver!=PMPVersion) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            switch (protocol) {            case MappingProtocol.TCP:              if (opcode!=PMPOpResultMapTcp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            case MappingProtocol.UDP:              if (opcode!=PMPOpResultMapUdp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            }            if (err!=0) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            this.LastTimestamp = time;            return new MappedPort(              this'              protocol'              internal_port'              external_port'              DateTime.Now.AddSeconds(mapped_lifetime));          }          catch (SocketException) { }          catch (ObjectDisposedException) { }          if (tries++<PMPTries) goto retry;          throw new PortMappingException();        }
Magic Number,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,MapAsyncInternal,The following statement contains a magic number: using (var client = new UdpClient()) {          var cancel_source = CancellationTokenSource.CreateLinkedTokenSource(            new CancellationTokenSource(250*tries).Token'            cancel_token);          var cancel = cancel_source.Token;          cancel.Register(() => client.Close()' false);          try {            var bytes = new byte[12];            BinaryAccessor.PutByte(bytes' 0' PMPVersion);            switch (protocol) {            case MappingProtocol.TCP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapTcp);              break;            case MappingProtocol.UDP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapUdp);              break;            }            BinaryAccessor.PutUInt16BE(bytes' 2' 0);            BinaryAccessor.PutUInt16BE(bytes' 4' port);            BinaryAccessor.PutUInt16BE(bytes' 6' port);            BinaryAccessor.PutUInt32BE(bytes' 8' lifetime);              await client.SendAsync(bytes' bytes.Length' new IPEndPoint(this.DeviceAddress' PMPPort));            var msg = await client.ReceiveAsync();            if (!msg.RemoteEndPoint.Address.Equals(this.DeviceAddress) || msg.Buffer.Length<16) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            var ver    = BinaryAccessor.GetByte(msg.Buffer' 0);            var opcode = BinaryAccessor.GetByte(msg.Buffer' 1);            var err    = BinaryAccessor.GetUInt16BE(msg.Buffer' 2);            var time   = BinaryAccessor.GetUInt32BE(msg.Buffer' 4);            var internal_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 8);            var external_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 10);            var mapped_lifetime = BinaryAccessor.GetUInt32BE(msg.Buffer' 12);            if (ver!=PMPVersion) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            switch (protocol) {            case MappingProtocol.TCP:              if (opcode!=PMPOpResultMapTcp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            case MappingProtocol.UDP:              if (opcode!=PMPOpResultMapUdp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            }            if (err!=0) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            this.LastTimestamp = time;            return new MappedPort(              this'              protocol'              internal_port'              external_port'              DateTime.Now.AddSeconds(mapped_lifetime));          }          catch (SocketException) { }          catch (ObjectDisposedException) { }          if (tries++<PMPTries) goto retry;          throw new PortMappingException();        }
Magic Number,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,MapAsyncInternal,The following statement contains a magic number: using (var client = new UdpClient()) {          var cancel_source = CancellationTokenSource.CreateLinkedTokenSource(            new CancellationTokenSource(250*tries).Token'            cancel_token);          var cancel = cancel_source.Token;          cancel.Register(() => client.Close()' false);          try {            var bytes = new byte[12];            BinaryAccessor.PutByte(bytes' 0' PMPVersion);            switch (protocol) {            case MappingProtocol.TCP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapTcp);              break;            case MappingProtocol.UDP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapUdp);              break;            }            BinaryAccessor.PutUInt16BE(bytes' 2' 0);            BinaryAccessor.PutUInt16BE(bytes' 4' port);            BinaryAccessor.PutUInt16BE(bytes' 6' port);            BinaryAccessor.PutUInt32BE(bytes' 8' lifetime);              await client.SendAsync(bytes' bytes.Length' new IPEndPoint(this.DeviceAddress' PMPPort));            var msg = await client.ReceiveAsync();            if (!msg.RemoteEndPoint.Address.Equals(this.DeviceAddress) || msg.Buffer.Length<16) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            var ver    = BinaryAccessor.GetByte(msg.Buffer' 0);            var opcode = BinaryAccessor.GetByte(msg.Buffer' 1);            var err    = BinaryAccessor.GetUInt16BE(msg.Buffer' 2);            var time   = BinaryAccessor.GetUInt32BE(msg.Buffer' 4);            var internal_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 8);            var external_port = BinaryAccessor.GetUInt16BE(msg.Buffer' 10);            var mapped_lifetime = BinaryAccessor.GetUInt32BE(msg.Buffer' 12);            if (ver!=PMPVersion) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            switch (protocol) {            case MappingProtocol.TCP:              if (opcode!=PMPOpResultMapTcp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            case MappingProtocol.UDP:              if (opcode!=PMPOpResultMapUdp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            }            if (err!=0) {              if (tries++<PMPTries) goto retry;              throw new PortMappingException();            }            this.LastTimestamp = time;            return new MappedPort(              this'              protocol'              internal_port'              external_port'              DateTime.Now.AddSeconds(mapped_lifetime));          }          catch (SocketException) { }          catch (ObjectDisposedException) { }          if (tries++<PMPTries) goto retry;          throw new PortMappingException();        }
Magic Number,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,MapAsync,The following statement contains a magic number: return MapAsyncInternal(          protocol'          port'          lifetime.TotalSeconds<=0 ? 7200 : (int)lifetime.TotalSeconds'          cancel_token);
Magic Number,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,GetExternalAddressAsync,The following statement contains a magic number: using (var client = new UdpClient()) {          var cancel_source = CancellationTokenSource.CreateLinkedTokenSource(            new CancellationTokenSource(250*tries).Token'            cancel_token);          var cancel = cancel_source.Token;          cancel.Register(() => client.Close()' false);          try {            var bytes = new byte[] { PMPVersion' PMPOpExternalPort };            await client.SendAsync(bytes' bytes.Length' new IPEndPoint(this.DeviceAddress' PMPPort));            var msg = await client.ReceiveAsync();            if (!msg.RemoteEndPoint.Address.Equals(this.DeviceAddress) || msg.Buffer.Length<12) {              if (tries++<PMPTries) goto retry;              return null;            }            var ver    = BinaryAccessor.GetByte(msg.Buffer' 0);            var opcode = BinaryAccessor.GetByte(msg.Buffer' 1);            var err    = BinaryAccessor.GetUInt16BE(msg.Buffer' 2);            var time   = BinaryAccessor.GetUInt32BE(msg.Buffer' 4);            var external_ip = BinaryAccessor.GetIPv4AddressBE(msg.Buffer' 8);            if (ver!=PMPVersion || opcode!=PMPOpResultExternalPort || err!=0) {              if (tries++<PMPTries) goto retry;              return null;            }            this.LastTimestamp = time;            return external_ip;          }          catch (SocketException) { }          catch (ObjectDisposedException) { }          if (tries++<PMPTries) goto retry;          return null;        }
Magic Number,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,GetExternalAddressAsync,The following statement contains a magic number: using (var client = new UdpClient()) {          var cancel_source = CancellationTokenSource.CreateLinkedTokenSource(            new CancellationTokenSource(250*tries).Token'            cancel_token);          var cancel = cancel_source.Token;          cancel.Register(() => client.Close()' false);          try {            var bytes = new byte[] { PMPVersion' PMPOpExternalPort };            await client.SendAsync(bytes' bytes.Length' new IPEndPoint(this.DeviceAddress' PMPPort));            var msg = await client.ReceiveAsync();            if (!msg.RemoteEndPoint.Address.Equals(this.DeviceAddress) || msg.Buffer.Length<12) {              if (tries++<PMPTries) goto retry;              return null;            }            var ver    = BinaryAccessor.GetByte(msg.Buffer' 0);            var opcode = BinaryAccessor.GetByte(msg.Buffer' 1);            var err    = BinaryAccessor.GetUInt16BE(msg.Buffer' 2);            var time   = BinaryAccessor.GetUInt32BE(msg.Buffer' 4);            var external_ip = BinaryAccessor.GetIPv4AddressBE(msg.Buffer' 8);            if (ver!=PMPVersion || opcode!=PMPOpResultExternalPort || err!=0) {              if (tries++<PMPTries) goto retry;              return null;            }            this.LastTimestamp = time;            return external_ip;          }          catch (SocketException) { }          catch (ObjectDisposedException) { }          if (tries++<PMPTries) goto retry;          return null;        }
Magic Number,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,GetExternalAddressAsync,The following statement contains a magic number: using (var client = new UdpClient()) {          var cancel_source = CancellationTokenSource.CreateLinkedTokenSource(            new CancellationTokenSource(250*tries).Token'            cancel_token);          var cancel = cancel_source.Token;          cancel.Register(() => client.Close()' false);          try {            var bytes = new byte[] { PMPVersion' PMPOpExternalPort };            await client.SendAsync(bytes' bytes.Length' new IPEndPoint(this.DeviceAddress' PMPPort));            var msg = await client.ReceiveAsync();            if (!msg.RemoteEndPoint.Address.Equals(this.DeviceAddress) || msg.Buffer.Length<12) {              if (tries++<PMPTries) goto retry;              return null;            }            var ver    = BinaryAccessor.GetByte(msg.Buffer' 0);            var opcode = BinaryAccessor.GetByte(msg.Buffer' 1);            var err    = BinaryAccessor.GetUInt16BE(msg.Buffer' 2);            var time   = BinaryAccessor.GetUInt32BE(msg.Buffer' 4);            var external_ip = BinaryAccessor.GetIPv4AddressBE(msg.Buffer' 8);            if (ver!=PMPVersion || opcode!=PMPOpResultExternalPort || err!=0) {              if (tries++<PMPTries) goto retry;              return null;            }            this.LastTimestamp = time;            return external_ip;          }          catch (SocketException) { }          catch (ObjectDisposedException) { }          if (tries++<PMPTries) goto retry;          return null;        }
Magic Number,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,GetExternalAddressAsync,The following statement contains a magic number: using (var client = new UdpClient()) {          var cancel_source = CancellationTokenSource.CreateLinkedTokenSource(            new CancellationTokenSource(250*tries).Token'            cancel_token);          var cancel = cancel_source.Token;          cancel.Register(() => client.Close()' false);          try {            var bytes = new byte[] { PMPVersion' PMPOpExternalPort };            await client.SendAsync(bytes' bytes.Length' new IPEndPoint(this.DeviceAddress' PMPPort));            var msg = await client.ReceiveAsync();            if (!msg.RemoteEndPoint.Address.Equals(this.DeviceAddress) || msg.Buffer.Length<12) {              if (tries++<PMPTries) goto retry;              return null;            }            var ver    = BinaryAccessor.GetByte(msg.Buffer' 0);            var opcode = BinaryAccessor.GetByte(msg.Buffer' 1);            var err    = BinaryAccessor.GetUInt16BE(msg.Buffer' 2);            var time   = BinaryAccessor.GetUInt32BE(msg.Buffer' 4);            var external_ip = BinaryAccessor.GetIPv4AddressBE(msg.Buffer' 8);            if (ver!=PMPVersion || opcode!=PMPOpResultExternalPort || err!=0) {              if (tries++<PMPTries) goto retry;              return null;            }            this.LastTimestamp = time;            return external_ip;          }          catch (SocketException) { }          catch (ObjectDisposedException) { }          if (tries++<PMPTries) goto retry;          return null;        }
Magic Number,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,GetExternalAddressAsync,The following statement contains a magic number: using (var client = new UdpClient()) {          var cancel_source = CancellationTokenSource.CreateLinkedTokenSource(            new CancellationTokenSource(250*tries).Token'            cancel_token);          var cancel = cancel_source.Token;          cancel.Register(() => client.Close()' false);          try {            var bytes = new byte[] { PMPVersion' PMPOpExternalPort };            await client.SendAsync(bytes' bytes.Length' new IPEndPoint(this.DeviceAddress' PMPPort));            var msg = await client.ReceiveAsync();            if (!msg.RemoteEndPoint.Address.Equals(this.DeviceAddress) || msg.Buffer.Length<12) {              if (tries++<PMPTries) goto retry;              return null;            }            var ver    = BinaryAccessor.GetByte(msg.Buffer' 0);            var opcode = BinaryAccessor.GetByte(msg.Buffer' 1);            var err    = BinaryAccessor.GetUInt16BE(msg.Buffer' 2);            var time   = BinaryAccessor.GetUInt32BE(msg.Buffer' 4);            var external_ip = BinaryAccessor.GetIPv4AddressBE(msg.Buffer' 8);            if (ver!=PMPVersion || opcode!=PMPOpResultExternalPort || err!=0) {              if (tries++<PMPTries) goto retry;              return null;            }            this.LastTimestamp = time;            return external_ip;          }          catch (SocketException) { }          catch (ObjectDisposedException) { }          if (tries++<PMPTries) goto retry;          return null;        }
Magic Number,PeerCastStation.UI.PortMapper,WANConnectionService,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\UPnPDevice.cs,MapAsync,The following statement contains a magic number: if (result.IsSucceeded) {          if (lifetime==Timeout.InfiniteTimeSpan) {            return new MappedPort(this' protocol' port' port' DateTime.Now+TimeSpan.FromSeconds(604800));          }          else {            return new MappedPort(this' protocol' port' port' DateTime.Now+lifetime);          }        }        else {          return null;        }
Magic Number,PeerCastStation.UI.PortMapper,SSDPDiscoverer,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\UPnPDevice.cs,SSDPAsync,The following statement contains a magic number: try {          using (var client=new UdpClient(new IPEndPoint(bind_addr' 0))) {            for (int i=0; i<3; i++) {              await client.SendAsync(msg' msg.Length' SSDPEndpoint);            }            for (int i=0; i<10 && client.Available==0 && !cancel_token.IsCancellationRequested; i++) {              await Task.Delay(100' cancel_token);            }            while (client.Available>0 && !cancel_token.IsCancellationRequested) {              var result = await client.ReceiveAsync();              var response = System.Text.Encoding.ASCII.GetString(result.Buffer).Split(new string[] { "\r\n" }' StringSplitOptions.None);              if (response.Length<0) continue;              if (response[0].IndexOf("HTTP/1.1 200")!=0) continue;              var header_pattern = new System.Text.RegularExpressions.Regex(@"(.*?):(.*)");              var headers = new Dictionary<string'string>();              foreach (var line in response.Skip(1)) {                if (line.Length==0) break;                var md = header_pattern.Match(line);                if (!md.Success) continue;                var key   = md.Groups[1].Value.Trim();                var value = md.Groups[2].Value.Trim();                headers.Add(key.ToUpperInvariant()' value);              }              var rsp = new SSDPResponse(result.RemoteEndPoint' headers);              logger.Debug("SSDP Found {0} at {1}"' rsp.ST' rsp.Location);              responses.Add(rsp);              if (client.Available==0 && !cancel_token.IsCancellationRequested) {                await Task.Delay(100' cancel_token);              }            }          }        }        catch (SocketException e) {          logger.Debug("Search Error on {0}: {1}"' bind_addr' e);        }
Magic Number,PeerCastStation.UI.PortMapper,SSDPDiscoverer,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\UPnPDevice.cs,SSDPAsync,The following statement contains a magic number: try {          using (var client=new UdpClient(new IPEndPoint(bind_addr' 0))) {            for (int i=0; i<3; i++) {              await client.SendAsync(msg' msg.Length' SSDPEndpoint);            }            for (int i=0; i<10 && client.Available==0 && !cancel_token.IsCancellationRequested; i++) {              await Task.Delay(100' cancel_token);            }            while (client.Available>0 && !cancel_token.IsCancellationRequested) {              var result = await client.ReceiveAsync();              var response = System.Text.Encoding.ASCII.GetString(result.Buffer).Split(new string[] { "\r\n" }' StringSplitOptions.None);              if (response.Length<0) continue;              if (response[0].IndexOf("HTTP/1.1 200")!=0) continue;              var header_pattern = new System.Text.RegularExpressions.Regex(@"(.*?):(.*)");              var headers = new Dictionary<string'string>();              foreach (var line in response.Skip(1)) {                if (line.Length==0) break;                var md = header_pattern.Match(line);                if (!md.Success) continue;                var key   = md.Groups[1].Value.Trim();                var value = md.Groups[2].Value.Trim();                headers.Add(key.ToUpperInvariant()' value);              }              var rsp = new SSDPResponse(result.RemoteEndPoint' headers);              logger.Debug("SSDP Found {0} at {1}"' rsp.ST' rsp.Location);              responses.Add(rsp);              if (client.Available==0 && !cancel_token.IsCancellationRequested) {                await Task.Delay(100' cancel_token);              }            }          }        }        catch (SocketException e) {          logger.Debug("Search Error on {0}: {1}"' bind_addr' e);        }
Magic Number,PeerCastStation.UI.PortMapper,SSDPDiscoverer,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\UPnPDevice.cs,SSDPAsync,The following statement contains a magic number: try {          using (var client=new UdpClient(new IPEndPoint(bind_addr' 0))) {            for (int i=0; i<3; i++) {              await client.SendAsync(msg' msg.Length' SSDPEndpoint);            }            for (int i=0; i<10 && client.Available==0 && !cancel_token.IsCancellationRequested; i++) {              await Task.Delay(100' cancel_token);            }            while (client.Available>0 && !cancel_token.IsCancellationRequested) {              var result = await client.ReceiveAsync();              var response = System.Text.Encoding.ASCII.GetString(result.Buffer).Split(new string[] { "\r\n" }' StringSplitOptions.None);              if (response.Length<0) continue;              if (response[0].IndexOf("HTTP/1.1 200")!=0) continue;              var header_pattern = new System.Text.RegularExpressions.Regex(@"(.*?):(.*)");              var headers = new Dictionary<string'string>();              foreach (var line in response.Skip(1)) {                if (line.Length==0) break;                var md = header_pattern.Match(line);                if (!md.Success) continue;                var key   = md.Groups[1].Value.Trim();                var value = md.Groups[2].Value.Trim();                headers.Add(key.ToUpperInvariant()' value);              }              var rsp = new SSDPResponse(result.RemoteEndPoint' headers);              logger.Debug("SSDP Found {0} at {1}"' rsp.ST' rsp.Location);              responses.Add(rsp);              if (client.Available==0 && !cancel_token.IsCancellationRequested) {                await Task.Delay(100' cancel_token);              }            }          }        }        catch (SocketException e) {          logger.Debug("Search Error on {0}: {1}"' bind_addr' e);        }
Magic Number,PeerCastStation.UI.PortMapper,SSDPDiscoverer,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\UPnPDevice.cs,SSDPAsync,The following statement contains a magic number: try {          using (var client=new UdpClient(new IPEndPoint(bind_addr' 0))) {            for (int i=0; i<3; i++) {              await client.SendAsync(msg' msg.Length' SSDPEndpoint);            }            for (int i=0; i<10 && client.Available==0 && !cancel_token.IsCancellationRequested; i++) {              await Task.Delay(100' cancel_token);            }            while (client.Available>0 && !cancel_token.IsCancellationRequested) {              var result = await client.ReceiveAsync();              var response = System.Text.Encoding.ASCII.GetString(result.Buffer).Split(new string[] { "\r\n" }' StringSplitOptions.None);              if (response.Length<0) continue;              if (response[0].IndexOf("HTTP/1.1 200")!=0) continue;              var header_pattern = new System.Text.RegularExpressions.Regex(@"(.*?):(.*)");              var headers = new Dictionary<string'string>();              foreach (var line in response.Skip(1)) {                if (line.Length==0) break;                var md = header_pattern.Match(line);                if (!md.Success) continue;                var key   = md.Groups[1].Value.Trim();                var value = md.Groups[2].Value.Trim();                headers.Add(key.ToUpperInvariant()' value);              }              var rsp = new SSDPResponse(result.RemoteEndPoint' headers);              logger.Debug("SSDP Found {0} at {1}"' rsp.ST' rsp.Location);              responses.Add(rsp);              if (client.Available==0 && !cancel_token.IsCancellationRequested) {                await Task.Delay(100' cancel_token);              }            }          }        }        catch (SocketException e) {          logger.Debug("Search Error on {0}: {1}"' bind_addr' e);        }
Magic Number,PeerCastStation.UI.PortMapper,SSDPDiscoverer,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\UPnPDevice.cs,SSDPAsync,The following statement contains a magic number: try {          using (var client=new UdpClient(new IPEndPoint(bind_addr' 0))) {            for (int i=0; i<3; i++) {              await client.SendAsync(msg' msg.Length' SSDPEndpoint);            }            for (int i=0; i<10 && client.Available==0 && !cancel_token.IsCancellationRequested; i++) {              await Task.Delay(100' cancel_token);            }            while (client.Available>0 && !cancel_token.IsCancellationRequested) {              var result = await client.ReceiveAsync();              var response = System.Text.Encoding.ASCII.GetString(result.Buffer).Split(new string[] { "\r\n" }' StringSplitOptions.None);              if (response.Length<0) continue;              if (response[0].IndexOf("HTTP/1.1 200")!=0) continue;              var header_pattern = new System.Text.RegularExpressions.Regex(@"(.*?):(.*)");              var headers = new Dictionary<string'string>();              foreach (var line in response.Skip(1)) {                if (line.Length==0) break;                var md = header_pattern.Match(line);                if (!md.Success) continue;                var key   = md.Groups[1].Value.Trim();                var value = md.Groups[2].Value.Trim();                headers.Add(key.ToUpperInvariant()' value);              }              var rsp = new SSDPResponse(result.RemoteEndPoint' headers);              logger.Debug("SSDP Found {0} at {1}"' rsp.ST' rsp.Location);              responses.Add(rsp);              if (client.Available==0 && !cancel_token.IsCancellationRequested) {                await Task.Delay(100' cancel_token);              }            }          }        }        catch (SocketException e) {          logger.Debug("Search Error on {0}: {1}"' bind_addr' e);        }
Missing Default,PeerCastStation.UI,Updater,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\Updater.cs,Install,The following switch statement is missing a default case: switch (downloaded.Enclosure.InstallerType) {          case InstallerType.Archive:          case InstallerType.ServiceArchive:            Updater.InplaceUpdate(              PeerCastApplication.Current.BasePath'              downloaded.FilePath'              new string[] { "PeerCastStation.exe"' "PecaStationd.exe" });            PeerCastApplication.Current.Stop(-1);            break;          case InstallerType.Installer:            System.Diagnostics.Process.Start(downloaded.FilePath);            PeerCastApplication.Current.Stop();            break;          case InstallerType.ServiceInstaller:            System.Diagnostics.Process.Start(downloaded.FilePath' "/quiet");            break;          case InstallerType.Unknown:            throw new ApplicationException();          }
Missing Default,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,MapAsyncInternal,The following switch statement is missing a default case: switch (protocol) {            case MappingProtocol.TCP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapTcp);              break;            case MappingProtocol.UDP:              BinaryAccessor.PutByte(bytes' 1' PMPOpMapUdp);              break;            }
Missing Default,PeerCastStation.UI.PortMapper,NatPmpDevice,C:\repos\kumaryu_peercaststation\PeerCastStation\PeerCastStation.UI\PortMapper\NatPmpDevice.cs,MapAsyncInternal,The following switch statement is missing a default case: switch (protocol) {            case MappingProtocol.TCP:              if (opcode!=PMPOpResultMapTcp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            case MappingProtocol.UDP:              if (opcode!=PMPOpResultMapUdp) {                if (tries++<PMPTries) goto retry;                throw new PortMappingException();              }              break;            }
