Implementation smell,Namespace,Class,File,Method,Description
Long Method,CertPairGenerator,CertificateGenerator,C:\repos\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The method has 160 lines of code.
Long Parameter List,CertPairGenerator,NativeMethods,C:\repos\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CryptAcquireContextW,The method has 5 parameters. Parameters: providerContext' container' provider' providerType' flags
Long Parameter List,CertPairGenerator,NativeMethods,C:\repos\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CertStrToNameW,The method has 7 parameters. Parameters: certificateEncodingType' x500' strType' reserved' encoded' encodedLength' errorString
Long Parameter List,CertPairGenerator,NativeMethods,C:\repos\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CertCreateSelfSignCertificate,The method has 8 parameters. Parameters: providerHandle' subjectIssuerBlob' flags' keyProviderInformation' signatureAlgorithm' startTime' endTime' extensions
Long Parameter List,CertPairGenerator,NativeMethods,C:\repos\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CertOpenStore,The method has 5 parameters. Parameters: storeProvider' messageAndCertificateEncodingType' cryptProvHandle' flags' parameters
Long Parameter List,CertPairGenerator,NativeMethods,C:\repos\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,PFXExportCertStoreEx,The method has 5 parameters. Parameters: certificateStoreHandle' pfxBlob' password' reserved' flags
Long Identifier,CertPairGenerator,NativeMethods,C:\repos\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CertOpenStore,The length of the parameter messageAndCertificateEncodingType is 33.
Magic Number,CertPairGenerator,CertificateGenerator,C:\repos\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The following statement contains a magic number: try              {                  Check(NativeMethods.CryptAcquireContextW(                      out providerContext'                      containerName'                      null'                      1' // PROV_RSA_FULL                      8)); // CRYPT_NEWKEYSET                    Check(NativeMethods.CryptGenKey(                      providerContext'                      1' // AT_KEYEXCHANGE                      1' // CRYPT_EXPORTABLE                      out cryptKey));                    IntPtr errorStringPtr;                  int nameDataLength = 0;                  byte[] nameData;                    // errorStringPtr gets a pointer into the middle of the x500 string'                  // so x500 needs to be pinned until after we've copied the value                  // of errorStringPtr.                  dataHandle = GCHandle.Alloc(x500' GCHandleType.Pinned);                    if (!NativeMethods.CertStrToNameW(                      0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING                      dataHandle.AddrOfPinnedObject()'                      3' // CERT_X500_NAME_STR = 3                      IntPtr.Zero'                      null'                      ref nameDataLength'                      out errorStringPtr))                  {                      string error = Marshal.PtrToStringUni(errorStringPtr);                      throw new ArgumentException(error);                  }                    nameData = new byte[nameDataLength];                    if (!NativeMethods.CertStrToNameW(                      0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING                      dataHandle.AddrOfPinnedObject()'                      3' // CERT_X500_NAME_STR = 3                      IntPtr.Zero'                      nameData'                      ref nameDataLength'                      out errorStringPtr))                  {                      string error = Marshal.PtrToStringUni(errorStringPtr);                      throw new ArgumentException(error);                  }                    dataHandle.Free();                    dataHandle = GCHandle.Alloc(nameData' GCHandleType.Pinned);                  CryptoApiBlob nameBlob = new CryptoApiBlob(                      nameData.Length'                      dataHandle.AddrOfPinnedObject());                    CryptKeyProviderInformation kpi = new CryptKeyProviderInformation();                  kpi.ContainerName = containerName;                  kpi.ProviderType = 1; // PROV_RSA_FULL                  kpi.KeySpec = 1; // AT_KEYEXCHANGE                    certContext = NativeMethods.CertCreateSelfSignCertificate(                      providerContext'                      ref nameBlob'                      0'                      ref kpi'                      IntPtr.Zero' // default = SHA1RSA                      ref startSystemTime'                      ref endSystemTime'                      IntPtr.Zero);                  Check(certContext != IntPtr.Zero);                  dataHandle.Free();                    certStore = NativeMethods.CertOpenStore(                      "Memory"' // sz_CERT_STORE_PROV_MEMORY                      0'                      IntPtr.Zero'                      0x2000' // CERT_STORE_CREATE_NEW_FLAG                      IntPtr.Zero);                  Check(certStore != IntPtr.Zero);                    Check(NativeMethods.CertAddCertificateContextToStore(                      certStore'                      certContext'                      1' // CERT_STORE_ADD_NEW                      out storeCertContext));                    NativeMethods.CertSetCertificateContextProperty(                      storeCertContext'                      2' // CERT_KEY_PROV_INFO_PROP_ID                      0'                      ref kpi);                    if (password != null)                  {                      passwordPtr = Marshal.SecureStringToCoTaskMemUnicode(password);                  }                    CryptoApiBlob pfxBlob = new CryptoApiBlob();                  Check(NativeMethods.PFXExportCertStoreEx(                      certStore'                      ref pfxBlob'                      passwordPtr'                      IntPtr.Zero'                      7)); // EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY                    pfxData = new byte[pfxBlob.DataLength];                  dataHandle = GCHandle.Alloc(pfxData' GCHandleType.Pinned);                  pfxBlob.Data = dataHandle.AddrOfPinnedObject();                  Check(NativeMethods.PFXExportCertStoreEx(                      certStore'                      ref pfxBlob'                      passwordPtr'                      IntPtr.Zero'                      7)); // EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY                  dataHandle.Free();              }              finally              {                  if (passwordPtr != IntPtr.Zero)                  {                      Marshal.ZeroFreeCoTaskMemUnicode(passwordPtr);                  }                    if (dataHandle.IsAllocated)                  {                      dataHandle.Free();                  }                    if (certContext != IntPtr.Zero)                  {                      NativeMethods.CertFreeCertificateContext(certContext);                  }                    if (storeCertContext != IntPtr.Zero)                  {                      NativeMethods.CertFreeCertificateContext(storeCertContext);                  }                    if (certStore != IntPtr.Zero)                  {                      NativeMethods.CertCloseStore(certStore' 0);                  }                    if (cryptKey != IntPtr.Zero)                  {                      NativeMethods.CryptDestroyKey(cryptKey);                  }                    if (providerContext != IntPtr.Zero)                  {                      NativeMethods.CryptReleaseContext(providerContext' 0);                      NativeMethods.CryptAcquireContextW(                          out providerContext'                          containerName'                          null'                          1' // PROV_RSA_FULL                          0x10); // CRYPT_DELETEKEYSET                  }              }
Magic Number,CertPairGenerator,CertificateGenerator,C:\repos\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The following statement contains a magic number: try              {                  Check(NativeMethods.CryptAcquireContextW(                      out providerContext'                      containerName'                      null'                      1' // PROV_RSA_FULL                      8)); // CRYPT_NEWKEYSET                    Check(NativeMethods.CryptGenKey(                      providerContext'                      1' // AT_KEYEXCHANGE                      1' // CRYPT_EXPORTABLE                      out cryptKey));                    IntPtr errorStringPtr;                  int nameDataLength = 0;                  byte[] nameData;                    // errorStringPtr gets a pointer into the middle of the x500 string'                  // so x500 needs to be pinned until after we've copied the value                  // of errorStringPtr.                  dataHandle = GCHandle.Alloc(x500' GCHandleType.Pinned);                    if (!NativeMethods.CertStrToNameW(                      0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING                      dataHandle.AddrOfPinnedObject()'                      3' // CERT_X500_NAME_STR = 3                      IntPtr.Zero'                      null'                      ref nameDataLength'                      out errorStringPtr))                  {                      string error = Marshal.PtrToStringUni(errorStringPtr);                      throw new ArgumentException(error);                  }                    nameData = new byte[nameDataLength];                    if (!NativeMethods.CertStrToNameW(                      0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING                      dataHandle.AddrOfPinnedObject()'                      3' // CERT_X500_NAME_STR = 3                      IntPtr.Zero'                      nameData'                      ref nameDataLength'                      out errorStringPtr))                  {                      string error = Marshal.PtrToStringUni(errorStringPtr);                      throw new ArgumentException(error);                  }                    dataHandle.Free();                    dataHandle = GCHandle.Alloc(nameData' GCHandleType.Pinned);                  CryptoApiBlob nameBlob = new CryptoApiBlob(                      nameData.Length'                      dataHandle.AddrOfPinnedObject());                    CryptKeyProviderInformation kpi = new CryptKeyProviderInformation();                  kpi.ContainerName = containerName;                  kpi.ProviderType = 1; // PROV_RSA_FULL                  kpi.KeySpec = 1; // AT_KEYEXCHANGE                    certContext = NativeMethods.CertCreateSelfSignCertificate(                      providerContext'                      ref nameBlob'                      0'                      ref kpi'                      IntPtr.Zero' // default = SHA1RSA                      ref startSystemTime'                      ref endSystemTime'                      IntPtr.Zero);                  Check(certContext != IntPtr.Zero);                  dataHandle.Free();                    certStore = NativeMethods.CertOpenStore(                      "Memory"' // sz_CERT_STORE_PROV_MEMORY                      0'                      IntPtr.Zero'                      0x2000' // CERT_STORE_CREATE_NEW_FLAG                      IntPtr.Zero);                  Check(certStore != IntPtr.Zero);                    Check(NativeMethods.CertAddCertificateContextToStore(                      certStore'                      certContext'                      1' // CERT_STORE_ADD_NEW                      out storeCertContext));                    NativeMethods.CertSetCertificateContextProperty(                      storeCertContext'                      2' // CERT_KEY_PROV_INFO_PROP_ID                      0'                      ref kpi);                    if (password != null)                  {                      passwordPtr = Marshal.SecureStringToCoTaskMemUnicode(password);                  }                    CryptoApiBlob pfxBlob = new CryptoApiBlob();                  Check(NativeMethods.PFXExportCertStoreEx(                      certStore'                      ref pfxBlob'                      passwordPtr'                      IntPtr.Zero'                      7)); // EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY                    pfxData = new byte[pfxBlob.DataLength];                  dataHandle = GCHandle.Alloc(pfxData' GCHandleType.Pinned);                  pfxBlob.Data = dataHandle.AddrOfPinnedObject();                  Check(NativeMethods.PFXExportCertStoreEx(                      certStore'                      ref pfxBlob'                      passwordPtr'                      IntPtr.Zero'                      7)); // EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY                  dataHandle.Free();              }              finally              {                  if (passwordPtr != IntPtr.Zero)                  {                      Marshal.ZeroFreeCoTaskMemUnicode(passwordPtr);                  }                    if (dataHandle.IsAllocated)                  {                      dataHandle.Free();                  }                    if (certContext != IntPtr.Zero)                  {                      NativeMethods.CertFreeCertificateContext(certContext);                  }                    if (storeCertContext != IntPtr.Zero)                  {                      NativeMethods.CertFreeCertificateContext(storeCertContext);                  }                    if (certStore != IntPtr.Zero)                  {                      NativeMethods.CertCloseStore(certStore' 0);                  }                    if (cryptKey != IntPtr.Zero)                  {                      NativeMethods.CryptDestroyKey(cryptKey);                  }                    if (providerContext != IntPtr.Zero)                  {                      NativeMethods.CryptReleaseContext(providerContext' 0);                      NativeMethods.CryptAcquireContextW(                          out providerContext'                          containerName'                          null'                          1' // PROV_RSA_FULL                          0x10); // CRYPT_DELETEKEYSET                  }              }
Magic Number,CertPairGenerator,CertificateGenerator,C:\repos\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The following statement contains a magic number: try              {                  Check(NativeMethods.CryptAcquireContextW(                      out providerContext'                      containerName'                      null'                      1' // PROV_RSA_FULL                      8)); // CRYPT_NEWKEYSET                    Check(NativeMethods.CryptGenKey(                      providerContext'                      1' // AT_KEYEXCHANGE                      1' // CRYPT_EXPORTABLE                      out cryptKey));                    IntPtr errorStringPtr;                  int nameDataLength = 0;                  byte[] nameData;                    // errorStringPtr gets a pointer into the middle of the x500 string'                  // so x500 needs to be pinned until after we've copied the value                  // of errorStringPtr.                  dataHandle = GCHandle.Alloc(x500' GCHandleType.Pinned);                    if (!NativeMethods.CertStrToNameW(                      0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING                      dataHandle.AddrOfPinnedObject()'                      3' // CERT_X500_NAME_STR = 3                      IntPtr.Zero'                      null'                      ref nameDataLength'                      out errorStringPtr))                  {                      string error = Marshal.PtrToStringUni(errorStringPtr);                      throw new ArgumentException(error);                  }                    nameData = new byte[nameDataLength];                    if (!NativeMethods.CertStrToNameW(                      0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING                      dataHandle.AddrOfPinnedObject()'                      3' // CERT_X500_NAME_STR = 3                      IntPtr.Zero'                      nameData'                      ref nameDataLength'                      out errorStringPtr))                  {                      string error = Marshal.PtrToStringUni(errorStringPtr);                      throw new ArgumentException(error);                  }                    dataHandle.Free();                    dataHandle = GCHandle.Alloc(nameData' GCHandleType.Pinned);                  CryptoApiBlob nameBlob = new CryptoApiBlob(                      nameData.Length'                      dataHandle.AddrOfPinnedObject());                    CryptKeyProviderInformation kpi = new CryptKeyProviderInformation();                  kpi.ContainerName = containerName;                  kpi.ProviderType = 1; // PROV_RSA_FULL                  kpi.KeySpec = 1; // AT_KEYEXCHANGE                    certContext = NativeMethods.CertCreateSelfSignCertificate(                      providerContext'                      ref nameBlob'                      0'                      ref kpi'                      IntPtr.Zero' // default = SHA1RSA                      ref startSystemTime'                      ref endSystemTime'                      IntPtr.Zero);                  Check(certContext != IntPtr.Zero);                  dataHandle.Free();                    certStore = NativeMethods.CertOpenStore(                      "Memory"' // sz_CERT_STORE_PROV_MEMORY                      0'                      IntPtr.Zero'                      0x2000' // CERT_STORE_CREATE_NEW_FLAG                      IntPtr.Zero);                  Check(certStore != IntPtr.Zero);                    Check(NativeMethods.CertAddCertificateContextToStore(                      certStore'                      certContext'                      1' // CERT_STORE_ADD_NEW                      out storeCertContext));                    NativeMethods.CertSetCertificateContextProperty(                      storeCertContext'                      2' // CERT_KEY_PROV_INFO_PROP_ID                      0'                      ref kpi);                    if (password != null)                  {                      passwordPtr = Marshal.SecureStringToCoTaskMemUnicode(password);                  }                    CryptoApiBlob pfxBlob = new CryptoApiBlob();                  Check(NativeMethods.PFXExportCertStoreEx(                      certStore'                      ref pfxBlob'                      passwordPtr'                      IntPtr.Zero'                      7)); // EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY                    pfxData = new byte[pfxBlob.DataLength];                  dataHandle = GCHandle.Alloc(pfxData' GCHandleType.Pinned);                  pfxBlob.Data = dataHandle.AddrOfPinnedObject();                  Check(NativeMethods.PFXExportCertStoreEx(                      certStore'                      ref pfxBlob'                      passwordPtr'                      IntPtr.Zero'                      7)); // EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY                  dataHandle.Free();              }              finally              {                  if (passwordPtr != IntPtr.Zero)                  {                      Marshal.ZeroFreeCoTaskMemUnicode(passwordPtr);                  }                    if (dataHandle.IsAllocated)                  {                      dataHandle.Free();                  }                    if (certContext != IntPtr.Zero)                  {                      NativeMethods.CertFreeCertificateContext(certContext);                  }                    if (storeCertContext != IntPtr.Zero)                  {                      NativeMethods.CertFreeCertificateContext(storeCertContext);                  }                    if (certStore != IntPtr.Zero)                  {                      NativeMethods.CertCloseStore(certStore' 0);                  }                    if (cryptKey != IntPtr.Zero)                  {                      NativeMethods.CryptDestroyKey(cryptKey);                  }                    if (providerContext != IntPtr.Zero)                  {                      NativeMethods.CryptReleaseContext(providerContext' 0);                      NativeMethods.CryptAcquireContextW(                          out providerContext'                          containerName'                          null'                          1' // PROV_RSA_FULL                          0x10); // CRYPT_DELETEKEYSET                  }              }
Magic Number,CertPairGenerator,CertificateGenerator,C:\repos\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The following statement contains a magic number: try              {                  Check(NativeMethods.CryptAcquireContextW(                      out providerContext'                      containerName'                      null'                      1' // PROV_RSA_FULL                      8)); // CRYPT_NEWKEYSET                    Check(NativeMethods.CryptGenKey(                      providerContext'                      1' // AT_KEYEXCHANGE                      1' // CRYPT_EXPORTABLE                      out cryptKey));                    IntPtr errorStringPtr;                  int nameDataLength = 0;                  byte[] nameData;                    // errorStringPtr gets a pointer into the middle of the x500 string'                  // so x500 needs to be pinned until after we've copied the value                  // of errorStringPtr.                  dataHandle = GCHandle.Alloc(x500' GCHandleType.Pinned);                    if (!NativeMethods.CertStrToNameW(                      0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING                      dataHandle.AddrOfPinnedObject()'                      3' // CERT_X500_NAME_STR = 3                      IntPtr.Zero'                      null'                      ref nameDataLength'                      out errorStringPtr))                  {                      string error = Marshal.PtrToStringUni(errorStringPtr);                      throw new ArgumentException(error);                  }                    nameData = new byte[nameDataLength];                    if (!NativeMethods.CertStrToNameW(                      0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING                      dataHandle.AddrOfPinnedObject()'                      3' // CERT_X500_NAME_STR = 3                      IntPtr.Zero'                      nameData'                      ref nameDataLength'                      out errorStringPtr))                  {                      string error = Marshal.PtrToStringUni(errorStringPtr);                      throw new ArgumentException(error);                  }                    dataHandle.Free();                    dataHandle = GCHandle.Alloc(nameData' GCHandleType.Pinned);                  CryptoApiBlob nameBlob = new CryptoApiBlob(                      nameData.Length'                      dataHandle.AddrOfPinnedObject());                    CryptKeyProviderInformation kpi = new CryptKeyProviderInformation();                  kpi.ContainerName = containerName;                  kpi.ProviderType = 1; // PROV_RSA_FULL                  kpi.KeySpec = 1; // AT_KEYEXCHANGE                    certContext = NativeMethods.CertCreateSelfSignCertificate(                      providerContext'                      ref nameBlob'                      0'                      ref kpi'                      IntPtr.Zero' // default = SHA1RSA                      ref startSystemTime'                      ref endSystemTime'                      IntPtr.Zero);                  Check(certContext != IntPtr.Zero);                  dataHandle.Free();                    certStore = NativeMethods.CertOpenStore(                      "Memory"' // sz_CERT_STORE_PROV_MEMORY                      0'                      IntPtr.Zero'                      0x2000' // CERT_STORE_CREATE_NEW_FLAG                      IntPtr.Zero);                  Check(certStore != IntPtr.Zero);                    Check(NativeMethods.CertAddCertificateContextToStore(                      certStore'                      certContext'                      1' // CERT_STORE_ADD_NEW                      out storeCertContext));                    NativeMethods.CertSetCertificateContextProperty(                      storeCertContext'                      2' // CERT_KEY_PROV_INFO_PROP_ID                      0'                      ref kpi);                    if (password != null)                  {                      passwordPtr = Marshal.SecureStringToCoTaskMemUnicode(password);                  }                    CryptoApiBlob pfxBlob = new CryptoApiBlob();                  Check(NativeMethods.PFXExportCertStoreEx(                      certStore'                      ref pfxBlob'                      passwordPtr'                      IntPtr.Zero'                      7)); // EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY                    pfxData = new byte[pfxBlob.DataLength];                  dataHandle = GCHandle.Alloc(pfxData' GCHandleType.Pinned);                  pfxBlob.Data = dataHandle.AddrOfPinnedObject();                  Check(NativeMethods.PFXExportCertStoreEx(                      certStore'                      ref pfxBlob'                      passwordPtr'                      IntPtr.Zero'                      7)); // EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY                  dataHandle.Free();              }              finally              {                  if (passwordPtr != IntPtr.Zero)                  {                      Marshal.ZeroFreeCoTaskMemUnicode(passwordPtr);                  }                    if (dataHandle.IsAllocated)                  {                      dataHandle.Free();                  }                    if (certContext != IntPtr.Zero)                  {                      NativeMethods.CertFreeCertificateContext(certContext);                  }                    if (storeCertContext != IntPtr.Zero)                  {                      NativeMethods.CertFreeCertificateContext(storeCertContext);                  }                    if (certStore != IntPtr.Zero)                  {                      NativeMethods.CertCloseStore(certStore' 0);                  }                    if (cryptKey != IntPtr.Zero)                  {                      NativeMethods.CryptDestroyKey(cryptKey);                  }                    if (providerContext != IntPtr.Zero)                  {                      NativeMethods.CryptReleaseContext(providerContext' 0);                      NativeMethods.CryptAcquireContextW(                          out providerContext'                          containerName'                          null'                          1' // PROV_RSA_FULL                          0x10); // CRYPT_DELETEKEYSET                  }              }
Magic Number,CertPairGenerator,CertificateGenerator,C:\repos\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The following statement contains a magic number: try              {                  Check(NativeMethods.CryptAcquireContextW(                      out providerContext'                      containerName'                      null'                      1' // PROV_RSA_FULL                      8)); // CRYPT_NEWKEYSET                    Check(NativeMethods.CryptGenKey(                      providerContext'                      1' // AT_KEYEXCHANGE                      1' // CRYPT_EXPORTABLE                      out cryptKey));                    IntPtr errorStringPtr;                  int nameDataLength = 0;                  byte[] nameData;                    // errorStringPtr gets a pointer into the middle of the x500 string'                  // so x500 needs to be pinned until after we've copied the value                  // of errorStringPtr.                  dataHandle = GCHandle.Alloc(x500' GCHandleType.Pinned);                    if (!NativeMethods.CertStrToNameW(                      0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING                      dataHandle.AddrOfPinnedObject()'                      3' // CERT_X500_NAME_STR = 3                      IntPtr.Zero'                      null'                      ref nameDataLength'                      out errorStringPtr))                  {                      string error = Marshal.PtrToStringUni(errorStringPtr);                      throw new ArgumentException(error);                  }                    nameData = new byte[nameDataLength];                    if (!NativeMethods.CertStrToNameW(                      0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING                      dataHandle.AddrOfPinnedObject()'                      3' // CERT_X500_NAME_STR = 3                      IntPtr.Zero'                      nameData'                      ref nameDataLength'                      out errorStringPtr))                  {                      string error = Marshal.PtrToStringUni(errorStringPtr);                      throw new ArgumentException(error);                  }                    dataHandle.Free();                    dataHandle = GCHandle.Alloc(nameData' GCHandleType.Pinned);                  CryptoApiBlob nameBlob = new CryptoApiBlob(                      nameData.Length'                      dataHandle.AddrOfPinnedObject());                    CryptKeyProviderInformation kpi = new CryptKeyProviderInformation();                  kpi.ContainerName = containerName;                  kpi.ProviderType = 1; // PROV_RSA_FULL                  kpi.KeySpec = 1; // AT_KEYEXCHANGE                    certContext = NativeMethods.CertCreateSelfSignCertificate(                      providerContext'                      ref nameBlob'                      0'                      ref kpi'                      IntPtr.Zero' // default = SHA1RSA                      ref startSystemTime'                      ref endSystemTime'                      IntPtr.Zero);                  Check(certContext != IntPtr.Zero);                  dataHandle.Free();                    certStore = NativeMethods.CertOpenStore(                      "Memory"' // sz_CERT_STORE_PROV_MEMORY                      0'                      IntPtr.Zero'                      0x2000' // CERT_STORE_CREATE_NEW_FLAG                      IntPtr.Zero);                  Check(certStore != IntPtr.Zero);                    Check(NativeMethods.CertAddCertificateContextToStore(                      certStore'                      certContext'                      1' // CERT_STORE_ADD_NEW                      out storeCertContext));                    NativeMethods.CertSetCertificateContextProperty(                      storeCertContext'                      2' // CERT_KEY_PROV_INFO_PROP_ID                      0'                      ref kpi);                    if (password != null)                  {                      passwordPtr = Marshal.SecureStringToCoTaskMemUnicode(password);                  }                    CryptoApiBlob pfxBlob = new CryptoApiBlob();                  Check(NativeMethods.PFXExportCertStoreEx(                      certStore'                      ref pfxBlob'                      passwordPtr'                      IntPtr.Zero'                      7)); // EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY                    pfxData = new byte[pfxBlob.DataLength];                  dataHandle = GCHandle.Alloc(pfxData' GCHandleType.Pinned);                  pfxBlob.Data = dataHandle.AddrOfPinnedObject();                  Check(NativeMethods.PFXExportCertStoreEx(                      certStore'                      ref pfxBlob'                      passwordPtr'                      IntPtr.Zero'                      7)); // EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY                  dataHandle.Free();              }              finally              {                  if (passwordPtr != IntPtr.Zero)                  {                      Marshal.ZeroFreeCoTaskMemUnicode(passwordPtr);                  }                    if (dataHandle.IsAllocated)                  {                      dataHandle.Free();                  }                    if (certContext != IntPtr.Zero)                  {                      NativeMethods.CertFreeCertificateContext(certContext);                  }                    if (storeCertContext != IntPtr.Zero)                  {                      NativeMethods.CertFreeCertificateContext(storeCertContext);                  }                    if (certStore != IntPtr.Zero)                  {                      NativeMethods.CertCloseStore(certStore' 0);                  }                    if (cryptKey != IntPtr.Zero)                  {                      NativeMethods.CryptDestroyKey(cryptKey);                  }                    if (providerContext != IntPtr.Zero)                  {                      NativeMethods.CryptReleaseContext(providerContext' 0);                      NativeMethods.CryptAcquireContextW(                          out providerContext'                          containerName'                          null'                          1' // PROV_RSA_FULL                          0x10); // CRYPT_DELETEKEYSET                  }              }
Magic Number,CertPairGenerator,CertificateGenerator,C:\repos\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The following statement contains a magic number: try              {                  Check(NativeMethods.CryptAcquireContextW(                      out providerContext'                      containerName'                      null'                      1' // PROV_RSA_FULL                      8)); // CRYPT_NEWKEYSET                    Check(NativeMethods.CryptGenKey(                      providerContext'                      1' // AT_KEYEXCHANGE                      1' // CRYPT_EXPORTABLE                      out cryptKey));                    IntPtr errorStringPtr;                  int nameDataLength = 0;                  byte[] nameData;                    // errorStringPtr gets a pointer into the middle of the x500 string'                  // so x500 needs to be pinned until after we've copied the value                  // of errorStringPtr.                  dataHandle = GCHandle.Alloc(x500' GCHandleType.Pinned);                    if (!NativeMethods.CertStrToNameW(                      0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING                      dataHandle.AddrOfPinnedObject()'                      3' // CERT_X500_NAME_STR = 3                      IntPtr.Zero'                      null'                      ref nameDataLength'                      out errorStringPtr))                  {                      string error = Marshal.PtrToStringUni(errorStringPtr);                      throw new ArgumentException(error);                  }                    nameData = new byte[nameDataLength];                    if (!NativeMethods.CertStrToNameW(                      0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING                      dataHandle.AddrOfPinnedObject()'                      3' // CERT_X500_NAME_STR = 3                      IntPtr.Zero'                      nameData'                      ref nameDataLength'                      out errorStringPtr))                  {                      string error = Marshal.PtrToStringUni(errorStringPtr);                      throw new ArgumentException(error);                  }                    dataHandle.Free();                    dataHandle = GCHandle.Alloc(nameData' GCHandleType.Pinned);                  CryptoApiBlob nameBlob = new CryptoApiBlob(                      nameData.Length'                      dataHandle.AddrOfPinnedObject());                    CryptKeyProviderInformation kpi = new CryptKeyProviderInformation();                  kpi.ContainerName = containerName;                  kpi.ProviderType = 1; // PROV_RSA_FULL                  kpi.KeySpec = 1; // AT_KEYEXCHANGE                    certContext = NativeMethods.CertCreateSelfSignCertificate(                      providerContext'                      ref nameBlob'                      0'                      ref kpi'                      IntPtr.Zero' // default = SHA1RSA                      ref startSystemTime'                      ref endSystemTime'                      IntPtr.Zero);                  Check(certContext != IntPtr.Zero);                  dataHandle.Free();                    certStore = NativeMethods.CertOpenStore(                      "Memory"' // sz_CERT_STORE_PROV_MEMORY                      0'                      IntPtr.Zero'                      0x2000' // CERT_STORE_CREATE_NEW_FLAG                      IntPtr.Zero);                  Check(certStore != IntPtr.Zero);                    Check(NativeMethods.CertAddCertificateContextToStore(                      certStore'                      certContext'                      1' // CERT_STORE_ADD_NEW                      out storeCertContext));                    NativeMethods.CertSetCertificateContextProperty(                      storeCertContext'                      2' // CERT_KEY_PROV_INFO_PROP_ID                      0'                      ref kpi);                    if (password != null)                  {                      passwordPtr = Marshal.SecureStringToCoTaskMemUnicode(password);                  }                    CryptoApiBlob pfxBlob = new CryptoApiBlob();                  Check(NativeMethods.PFXExportCertStoreEx(                      certStore'                      ref pfxBlob'                      passwordPtr'                      IntPtr.Zero'                      7)); // EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY                    pfxData = new byte[pfxBlob.DataLength];                  dataHandle = GCHandle.Alloc(pfxData' GCHandleType.Pinned);                  pfxBlob.Data = dataHandle.AddrOfPinnedObject();                  Check(NativeMethods.PFXExportCertStoreEx(                      certStore'                      ref pfxBlob'                      passwordPtr'                      IntPtr.Zero'                      7)); // EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY                  dataHandle.Free();              }              finally              {                  if (passwordPtr != IntPtr.Zero)                  {                      Marshal.ZeroFreeCoTaskMemUnicode(passwordPtr);                  }                    if (dataHandle.IsAllocated)                  {                      dataHandle.Free();                  }                    if (certContext != IntPtr.Zero)                  {                      NativeMethods.CertFreeCertificateContext(certContext);                  }                    if (storeCertContext != IntPtr.Zero)                  {                      NativeMethods.CertFreeCertificateContext(storeCertContext);                  }                    if (certStore != IntPtr.Zero)                  {                      NativeMethods.CertCloseStore(certStore' 0);                  }                    if (cryptKey != IntPtr.Zero)                  {                      NativeMethods.CryptDestroyKey(cryptKey);                  }                    if (providerContext != IntPtr.Zero)                  {                      NativeMethods.CryptReleaseContext(providerContext' 0);                      NativeMethods.CryptAcquireContextW(                          out providerContext'                          containerName'                          null'                          1' // PROV_RSA_FULL                          0x10); // CRYPT_DELETEKEYSET                  }              }
Magic Number,CertPairGenerator,Program,C:\repos\iSECPartners_PeachFarmer\CertPairGenerator\Program.cs,CreatePfxFile,The following statement contains a magic number: try              {                  string x500 = string.Format("CN=\"{0}\""' commonName);                  byte[] certValue = CertificateGenerator.CreateSelfSignCertificatePfx(x500' DateTime.Now' DateTime.Now.AddYears(10));                    using (BinaryWriter writer = new BinaryWriter(File.Open(outputFilename' FileMode.CreateNew)))                  {                      writer.Write(certValue);                  }              }              catch (Exception ex)              {                  Console.WriteLine("Error creating certificate: {0}"' ex.Message);              }
