Implementation smell,Namespace,Class,File,Method,Description
Long Method,CertPairGenerator,CertificateGenerator,D:\newReposJune17\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The method has 104 lines of code.
Long Parameter List,CertPairGenerator,CertificateGenerator,D:\newReposJune17\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The method has 4 parameters.
Long Parameter List,CertPairGenerator,CertificateGenerator,D:\newReposJune17\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The method has 4 parameters.
Long Statement,CertPairGenerator,CertificateGenerator,D:\newReposJune17\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The length of the statement  "		certContext = NativeMethods.CertCreateSelfSignCertificate (providerContext' ref nameBlob' 0' ref kpi' IntPtr.Zero' // default = SHA1RSA " is 135.
Magic Number,CertPairGenerator,CertificateGenerator,D:\newReposJune17\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The following statement contains a magic number: try {  	Check (NativeMethods.CryptAcquireContextW (out providerContext' containerName' null' 1' // PROV_RSA_FULL  	8));  	// CRYPT_NEWKEYSET  	Check (NativeMethods.CryptGenKey (providerContext' 1' // AT_KEYEXCHANGE  	1' // CRYPT_EXPORTABLE  	out cryptKey));  	IntPtr errorStringPtr;  	int nameDataLength = 0;  	byte[] nameData;  	// errorStringPtr gets a pointer into the middle of the x500 string'  	// so x500 needs to be pinned until after we've copied the value  	// of errorStringPtr.  	dataHandle = GCHandle.Alloc (x500' GCHandleType.Pinned);  	if (!NativeMethods.CertStrToNameW (0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING  	dataHandle.AddrOfPinnedObject ()' 3' // CERT_X500_NAME_STR = 3  	IntPtr.Zero' null' ref nameDataLength' out errorStringPtr)) {  		string error = Marshal.PtrToStringUni (errorStringPtr);  		throw new ArgumentException (error);  	}  	nameData = new byte[nameDataLength];  	if (!NativeMethods.CertStrToNameW (0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING  	dataHandle.AddrOfPinnedObject ()' 3' // CERT_X500_NAME_STR = 3  	IntPtr.Zero' nameData' ref nameDataLength' out errorStringPtr)) {  		string error = Marshal.PtrToStringUni (errorStringPtr);  		throw new ArgumentException (error);  	}  	dataHandle.Free ();  	dataHandle = GCHandle.Alloc (nameData' GCHandleType.Pinned);  	CryptoApiBlob nameBlob = new CryptoApiBlob (nameData.Length' dataHandle.AddrOfPinnedObject ());  	CryptKeyProviderInformation kpi = new CryptKeyProviderInformation ();  	kpi.ContainerName = containerName;  	kpi.ProviderType = 1;  	// PROV_RSA_FULL  	kpi.KeySpec = 1;  	// AT_KEYEXCHANGE  	certContext = NativeMethods.CertCreateSelfSignCertificate (providerContext' ref nameBlob' 0' ref kpi' IntPtr.Zero' // default = SHA1RSA  	ref startSystemTime' ref endSystemTime' IntPtr.Zero);  	Check (certContext != IntPtr.Zero);  	dataHandle.Free ();  	certStore = NativeMethods.CertOpenStore ("Memory"' // sz_CERT_STORE_PROV_MEMORY  	0' IntPtr.Zero' 0x2000' // CERT_STORE_CREATE_NEW_FLAG  	IntPtr.Zero);  	Check (certStore != IntPtr.Zero);  	Check (NativeMethods.CertAddCertificateContextToStore (certStore' certContext' 1' // CERT_STORE_ADD_NEW  	out storeCertContext));  	NativeMethods.CertSetCertificateContextProperty (storeCertContext' 2' // CERT_KEY_PROV_INFO_PROP_ID  	0' ref kpi);  	if (password != null) {  		passwordPtr = Marshal.SecureStringToCoTaskMemUnicode (password);  	}  	CryptoApiBlob pfxBlob = new CryptoApiBlob ();  	Check (NativeMethods.PFXExportCertStoreEx (certStore' ref pfxBlob' passwordPtr' IntPtr.Zero' 7));  	// EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY  	pfxData = new byte[pfxBlob.DataLength];  	dataHandle = GCHandle.Alloc (pfxData' GCHandleType.Pinned);  	pfxBlob.Data = dataHandle.AddrOfPinnedObject ();  	Check (NativeMethods.PFXExportCertStoreEx (certStore' ref pfxBlob' passwordPtr' IntPtr.Zero' 7));  	// EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY  	dataHandle.Free ();  } finally {  	if (passwordPtr != IntPtr.Zero) {  		Marshal.ZeroFreeCoTaskMemUnicode (passwordPtr);  	}  	if (dataHandle.IsAllocated) {  		dataHandle.Free ();  	}  	if (certContext != IntPtr.Zero) {  		NativeMethods.CertFreeCertificateContext (certContext);  	}  	if (storeCertContext != IntPtr.Zero) {  		NativeMethods.CertFreeCertificateContext (storeCertContext);  	}  	if (certStore != IntPtr.Zero) {  		NativeMethods.CertCloseStore (certStore' 0);  	}  	if (cryptKey != IntPtr.Zero) {  		NativeMethods.CryptDestroyKey (cryptKey);  	}  	if (providerContext != IntPtr.Zero) {  		NativeMethods.CryptReleaseContext (providerContext' 0);  		NativeMethods.CryptAcquireContextW (out providerContext' containerName' null' 1' // PROV_RSA_FULL  		0x10);  		// CRYPT_DELETEKEYSET  	}  }  
Magic Number,CertPairGenerator,CertificateGenerator,D:\newReposJune17\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The following statement contains a magic number: try {  	Check (NativeMethods.CryptAcquireContextW (out providerContext' containerName' null' 1' // PROV_RSA_FULL  	8));  	// CRYPT_NEWKEYSET  	Check (NativeMethods.CryptGenKey (providerContext' 1' // AT_KEYEXCHANGE  	1' // CRYPT_EXPORTABLE  	out cryptKey));  	IntPtr errorStringPtr;  	int nameDataLength = 0;  	byte[] nameData;  	// errorStringPtr gets a pointer into the middle of the x500 string'  	// so x500 needs to be pinned until after we've copied the value  	// of errorStringPtr.  	dataHandle = GCHandle.Alloc (x500' GCHandleType.Pinned);  	if (!NativeMethods.CertStrToNameW (0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING  	dataHandle.AddrOfPinnedObject ()' 3' // CERT_X500_NAME_STR = 3  	IntPtr.Zero' null' ref nameDataLength' out errorStringPtr)) {  		string error = Marshal.PtrToStringUni (errorStringPtr);  		throw new ArgumentException (error);  	}  	nameData = new byte[nameDataLength];  	if (!NativeMethods.CertStrToNameW (0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING  	dataHandle.AddrOfPinnedObject ()' 3' // CERT_X500_NAME_STR = 3  	IntPtr.Zero' nameData' ref nameDataLength' out errorStringPtr)) {  		string error = Marshal.PtrToStringUni (errorStringPtr);  		throw new ArgumentException (error);  	}  	dataHandle.Free ();  	dataHandle = GCHandle.Alloc (nameData' GCHandleType.Pinned);  	CryptoApiBlob nameBlob = new CryptoApiBlob (nameData.Length' dataHandle.AddrOfPinnedObject ());  	CryptKeyProviderInformation kpi = new CryptKeyProviderInformation ();  	kpi.ContainerName = containerName;  	kpi.ProviderType = 1;  	// PROV_RSA_FULL  	kpi.KeySpec = 1;  	// AT_KEYEXCHANGE  	certContext = NativeMethods.CertCreateSelfSignCertificate (providerContext' ref nameBlob' 0' ref kpi' IntPtr.Zero' // default = SHA1RSA  	ref startSystemTime' ref endSystemTime' IntPtr.Zero);  	Check (certContext != IntPtr.Zero);  	dataHandle.Free ();  	certStore = NativeMethods.CertOpenStore ("Memory"' // sz_CERT_STORE_PROV_MEMORY  	0' IntPtr.Zero' 0x2000' // CERT_STORE_CREATE_NEW_FLAG  	IntPtr.Zero);  	Check (certStore != IntPtr.Zero);  	Check (NativeMethods.CertAddCertificateContextToStore (certStore' certContext' 1' // CERT_STORE_ADD_NEW  	out storeCertContext));  	NativeMethods.CertSetCertificateContextProperty (storeCertContext' 2' // CERT_KEY_PROV_INFO_PROP_ID  	0' ref kpi);  	if (password != null) {  		passwordPtr = Marshal.SecureStringToCoTaskMemUnicode (password);  	}  	CryptoApiBlob pfxBlob = new CryptoApiBlob ();  	Check (NativeMethods.PFXExportCertStoreEx (certStore' ref pfxBlob' passwordPtr' IntPtr.Zero' 7));  	// EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY  	pfxData = new byte[pfxBlob.DataLength];  	dataHandle = GCHandle.Alloc (pfxData' GCHandleType.Pinned);  	pfxBlob.Data = dataHandle.AddrOfPinnedObject ();  	Check (NativeMethods.PFXExportCertStoreEx (certStore' ref pfxBlob' passwordPtr' IntPtr.Zero' 7));  	// EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY  	dataHandle.Free ();  } finally {  	if (passwordPtr != IntPtr.Zero) {  		Marshal.ZeroFreeCoTaskMemUnicode (passwordPtr);  	}  	if (dataHandle.IsAllocated) {  		dataHandle.Free ();  	}  	if (certContext != IntPtr.Zero) {  		NativeMethods.CertFreeCertificateContext (certContext);  	}  	if (storeCertContext != IntPtr.Zero) {  		NativeMethods.CertFreeCertificateContext (storeCertContext);  	}  	if (certStore != IntPtr.Zero) {  		NativeMethods.CertCloseStore (certStore' 0);  	}  	if (cryptKey != IntPtr.Zero) {  		NativeMethods.CryptDestroyKey (cryptKey);  	}  	if (providerContext != IntPtr.Zero) {  		NativeMethods.CryptReleaseContext (providerContext' 0);  		NativeMethods.CryptAcquireContextW (out providerContext' containerName' null' 1' // PROV_RSA_FULL  		0x10);  		// CRYPT_DELETEKEYSET  	}  }  
Magic Number,CertPairGenerator,CertificateGenerator,D:\newReposJune17\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The following statement contains a magic number: try {  	Check (NativeMethods.CryptAcquireContextW (out providerContext' containerName' null' 1' // PROV_RSA_FULL  	8));  	// CRYPT_NEWKEYSET  	Check (NativeMethods.CryptGenKey (providerContext' 1' // AT_KEYEXCHANGE  	1' // CRYPT_EXPORTABLE  	out cryptKey));  	IntPtr errorStringPtr;  	int nameDataLength = 0;  	byte[] nameData;  	// errorStringPtr gets a pointer into the middle of the x500 string'  	// so x500 needs to be pinned until after we've copied the value  	// of errorStringPtr.  	dataHandle = GCHandle.Alloc (x500' GCHandleType.Pinned);  	if (!NativeMethods.CertStrToNameW (0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING  	dataHandle.AddrOfPinnedObject ()' 3' // CERT_X500_NAME_STR = 3  	IntPtr.Zero' null' ref nameDataLength' out errorStringPtr)) {  		string error = Marshal.PtrToStringUni (errorStringPtr);  		throw new ArgumentException (error);  	}  	nameData = new byte[nameDataLength];  	if (!NativeMethods.CertStrToNameW (0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING  	dataHandle.AddrOfPinnedObject ()' 3' // CERT_X500_NAME_STR = 3  	IntPtr.Zero' nameData' ref nameDataLength' out errorStringPtr)) {  		string error = Marshal.PtrToStringUni (errorStringPtr);  		throw new ArgumentException (error);  	}  	dataHandle.Free ();  	dataHandle = GCHandle.Alloc (nameData' GCHandleType.Pinned);  	CryptoApiBlob nameBlob = new CryptoApiBlob (nameData.Length' dataHandle.AddrOfPinnedObject ());  	CryptKeyProviderInformation kpi = new CryptKeyProviderInformation ();  	kpi.ContainerName = containerName;  	kpi.ProviderType = 1;  	// PROV_RSA_FULL  	kpi.KeySpec = 1;  	// AT_KEYEXCHANGE  	certContext = NativeMethods.CertCreateSelfSignCertificate (providerContext' ref nameBlob' 0' ref kpi' IntPtr.Zero' // default = SHA1RSA  	ref startSystemTime' ref endSystemTime' IntPtr.Zero);  	Check (certContext != IntPtr.Zero);  	dataHandle.Free ();  	certStore = NativeMethods.CertOpenStore ("Memory"' // sz_CERT_STORE_PROV_MEMORY  	0' IntPtr.Zero' 0x2000' // CERT_STORE_CREATE_NEW_FLAG  	IntPtr.Zero);  	Check (certStore != IntPtr.Zero);  	Check (NativeMethods.CertAddCertificateContextToStore (certStore' certContext' 1' // CERT_STORE_ADD_NEW  	out storeCertContext));  	NativeMethods.CertSetCertificateContextProperty (storeCertContext' 2' // CERT_KEY_PROV_INFO_PROP_ID  	0' ref kpi);  	if (password != null) {  		passwordPtr = Marshal.SecureStringToCoTaskMemUnicode (password);  	}  	CryptoApiBlob pfxBlob = new CryptoApiBlob ();  	Check (NativeMethods.PFXExportCertStoreEx (certStore' ref pfxBlob' passwordPtr' IntPtr.Zero' 7));  	// EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY  	pfxData = new byte[pfxBlob.DataLength];  	dataHandle = GCHandle.Alloc (pfxData' GCHandleType.Pinned);  	pfxBlob.Data = dataHandle.AddrOfPinnedObject ();  	Check (NativeMethods.PFXExportCertStoreEx (certStore' ref pfxBlob' passwordPtr' IntPtr.Zero' 7));  	// EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY  	dataHandle.Free ();  } finally {  	if (passwordPtr != IntPtr.Zero) {  		Marshal.ZeroFreeCoTaskMemUnicode (passwordPtr);  	}  	if (dataHandle.IsAllocated) {  		dataHandle.Free ();  	}  	if (certContext != IntPtr.Zero) {  		NativeMethods.CertFreeCertificateContext (certContext);  	}  	if (storeCertContext != IntPtr.Zero) {  		NativeMethods.CertFreeCertificateContext (storeCertContext);  	}  	if (certStore != IntPtr.Zero) {  		NativeMethods.CertCloseStore (certStore' 0);  	}  	if (cryptKey != IntPtr.Zero) {  		NativeMethods.CryptDestroyKey (cryptKey);  	}  	if (providerContext != IntPtr.Zero) {  		NativeMethods.CryptReleaseContext (providerContext' 0);  		NativeMethods.CryptAcquireContextW (out providerContext' containerName' null' 1' // PROV_RSA_FULL  		0x10);  		// CRYPT_DELETEKEYSET  	}  }  
Magic Number,CertPairGenerator,CertificateGenerator,D:\newReposJune17\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The following statement contains a magic number: try {  	Check (NativeMethods.CryptAcquireContextW (out providerContext' containerName' null' 1' // PROV_RSA_FULL  	8));  	// CRYPT_NEWKEYSET  	Check (NativeMethods.CryptGenKey (providerContext' 1' // AT_KEYEXCHANGE  	1' // CRYPT_EXPORTABLE  	out cryptKey));  	IntPtr errorStringPtr;  	int nameDataLength = 0;  	byte[] nameData;  	// errorStringPtr gets a pointer into the middle of the x500 string'  	// so x500 needs to be pinned until after we've copied the value  	// of errorStringPtr.  	dataHandle = GCHandle.Alloc (x500' GCHandleType.Pinned);  	if (!NativeMethods.CertStrToNameW (0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING  	dataHandle.AddrOfPinnedObject ()' 3' // CERT_X500_NAME_STR = 3  	IntPtr.Zero' null' ref nameDataLength' out errorStringPtr)) {  		string error = Marshal.PtrToStringUni (errorStringPtr);  		throw new ArgumentException (error);  	}  	nameData = new byte[nameDataLength];  	if (!NativeMethods.CertStrToNameW (0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING  	dataHandle.AddrOfPinnedObject ()' 3' // CERT_X500_NAME_STR = 3  	IntPtr.Zero' nameData' ref nameDataLength' out errorStringPtr)) {  		string error = Marshal.PtrToStringUni (errorStringPtr);  		throw new ArgumentException (error);  	}  	dataHandle.Free ();  	dataHandle = GCHandle.Alloc (nameData' GCHandleType.Pinned);  	CryptoApiBlob nameBlob = new CryptoApiBlob (nameData.Length' dataHandle.AddrOfPinnedObject ());  	CryptKeyProviderInformation kpi = new CryptKeyProviderInformation ();  	kpi.ContainerName = containerName;  	kpi.ProviderType = 1;  	// PROV_RSA_FULL  	kpi.KeySpec = 1;  	// AT_KEYEXCHANGE  	certContext = NativeMethods.CertCreateSelfSignCertificate (providerContext' ref nameBlob' 0' ref kpi' IntPtr.Zero' // default = SHA1RSA  	ref startSystemTime' ref endSystemTime' IntPtr.Zero);  	Check (certContext != IntPtr.Zero);  	dataHandle.Free ();  	certStore = NativeMethods.CertOpenStore ("Memory"' // sz_CERT_STORE_PROV_MEMORY  	0' IntPtr.Zero' 0x2000' // CERT_STORE_CREATE_NEW_FLAG  	IntPtr.Zero);  	Check (certStore != IntPtr.Zero);  	Check (NativeMethods.CertAddCertificateContextToStore (certStore' certContext' 1' // CERT_STORE_ADD_NEW  	out storeCertContext));  	NativeMethods.CertSetCertificateContextProperty (storeCertContext' 2' // CERT_KEY_PROV_INFO_PROP_ID  	0' ref kpi);  	if (password != null) {  		passwordPtr = Marshal.SecureStringToCoTaskMemUnicode (password);  	}  	CryptoApiBlob pfxBlob = new CryptoApiBlob ();  	Check (NativeMethods.PFXExportCertStoreEx (certStore' ref pfxBlob' passwordPtr' IntPtr.Zero' 7));  	// EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY  	pfxData = new byte[pfxBlob.DataLength];  	dataHandle = GCHandle.Alloc (pfxData' GCHandleType.Pinned);  	pfxBlob.Data = dataHandle.AddrOfPinnedObject ();  	Check (NativeMethods.PFXExportCertStoreEx (certStore' ref pfxBlob' passwordPtr' IntPtr.Zero' 7));  	// EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY  	dataHandle.Free ();  } finally {  	if (passwordPtr != IntPtr.Zero) {  		Marshal.ZeroFreeCoTaskMemUnicode (passwordPtr);  	}  	if (dataHandle.IsAllocated) {  		dataHandle.Free ();  	}  	if (certContext != IntPtr.Zero) {  		NativeMethods.CertFreeCertificateContext (certContext);  	}  	if (storeCertContext != IntPtr.Zero) {  		NativeMethods.CertFreeCertificateContext (storeCertContext);  	}  	if (certStore != IntPtr.Zero) {  		NativeMethods.CertCloseStore (certStore' 0);  	}  	if (cryptKey != IntPtr.Zero) {  		NativeMethods.CryptDestroyKey (cryptKey);  	}  	if (providerContext != IntPtr.Zero) {  		NativeMethods.CryptReleaseContext (providerContext' 0);  		NativeMethods.CryptAcquireContextW (out providerContext' containerName' null' 1' // PROV_RSA_FULL  		0x10);  		// CRYPT_DELETEKEYSET  	}  }  
Magic Number,CertPairGenerator,CertificateGenerator,D:\newReposJune17\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The following statement contains a magic number: try {  	Check (NativeMethods.CryptAcquireContextW (out providerContext' containerName' null' 1' // PROV_RSA_FULL  	8));  	// CRYPT_NEWKEYSET  	Check (NativeMethods.CryptGenKey (providerContext' 1' // AT_KEYEXCHANGE  	1' // CRYPT_EXPORTABLE  	out cryptKey));  	IntPtr errorStringPtr;  	int nameDataLength = 0;  	byte[] nameData;  	// errorStringPtr gets a pointer into the middle of the x500 string'  	// so x500 needs to be pinned until after we've copied the value  	// of errorStringPtr.  	dataHandle = GCHandle.Alloc (x500' GCHandleType.Pinned);  	if (!NativeMethods.CertStrToNameW (0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING  	dataHandle.AddrOfPinnedObject ()' 3' // CERT_X500_NAME_STR = 3  	IntPtr.Zero' null' ref nameDataLength' out errorStringPtr)) {  		string error = Marshal.PtrToStringUni (errorStringPtr);  		throw new ArgumentException (error);  	}  	nameData = new byte[nameDataLength];  	if (!NativeMethods.CertStrToNameW (0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING  	dataHandle.AddrOfPinnedObject ()' 3' // CERT_X500_NAME_STR = 3  	IntPtr.Zero' nameData' ref nameDataLength' out errorStringPtr)) {  		string error = Marshal.PtrToStringUni (errorStringPtr);  		throw new ArgumentException (error);  	}  	dataHandle.Free ();  	dataHandle = GCHandle.Alloc (nameData' GCHandleType.Pinned);  	CryptoApiBlob nameBlob = new CryptoApiBlob (nameData.Length' dataHandle.AddrOfPinnedObject ());  	CryptKeyProviderInformation kpi = new CryptKeyProviderInformation ();  	kpi.ContainerName = containerName;  	kpi.ProviderType = 1;  	// PROV_RSA_FULL  	kpi.KeySpec = 1;  	// AT_KEYEXCHANGE  	certContext = NativeMethods.CertCreateSelfSignCertificate (providerContext' ref nameBlob' 0' ref kpi' IntPtr.Zero' // default = SHA1RSA  	ref startSystemTime' ref endSystemTime' IntPtr.Zero);  	Check (certContext != IntPtr.Zero);  	dataHandle.Free ();  	certStore = NativeMethods.CertOpenStore ("Memory"' // sz_CERT_STORE_PROV_MEMORY  	0' IntPtr.Zero' 0x2000' // CERT_STORE_CREATE_NEW_FLAG  	IntPtr.Zero);  	Check (certStore != IntPtr.Zero);  	Check (NativeMethods.CertAddCertificateContextToStore (certStore' certContext' 1' // CERT_STORE_ADD_NEW  	out storeCertContext));  	NativeMethods.CertSetCertificateContextProperty (storeCertContext' 2' // CERT_KEY_PROV_INFO_PROP_ID  	0' ref kpi);  	if (password != null) {  		passwordPtr = Marshal.SecureStringToCoTaskMemUnicode (password);  	}  	CryptoApiBlob pfxBlob = new CryptoApiBlob ();  	Check (NativeMethods.PFXExportCertStoreEx (certStore' ref pfxBlob' passwordPtr' IntPtr.Zero' 7));  	// EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY  	pfxData = new byte[pfxBlob.DataLength];  	dataHandle = GCHandle.Alloc (pfxData' GCHandleType.Pinned);  	pfxBlob.Data = dataHandle.AddrOfPinnedObject ();  	Check (NativeMethods.PFXExportCertStoreEx (certStore' ref pfxBlob' passwordPtr' IntPtr.Zero' 7));  	// EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY  	dataHandle.Free ();  } finally {  	if (passwordPtr != IntPtr.Zero) {  		Marshal.ZeroFreeCoTaskMemUnicode (passwordPtr);  	}  	if (dataHandle.IsAllocated) {  		dataHandle.Free ();  	}  	if (certContext != IntPtr.Zero) {  		NativeMethods.CertFreeCertificateContext (certContext);  	}  	if (storeCertContext != IntPtr.Zero) {  		NativeMethods.CertFreeCertificateContext (storeCertContext);  	}  	if (certStore != IntPtr.Zero) {  		NativeMethods.CertCloseStore (certStore' 0);  	}  	if (cryptKey != IntPtr.Zero) {  		NativeMethods.CryptDestroyKey (cryptKey);  	}  	if (providerContext != IntPtr.Zero) {  		NativeMethods.CryptReleaseContext (providerContext' 0);  		NativeMethods.CryptAcquireContextW (out providerContext' containerName' null' 1' // PROV_RSA_FULL  		0x10);  		// CRYPT_DELETEKEYSET  	}  }  
Magic Number,CertPairGenerator,CertificateGenerator,D:\newReposJune17\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The following statement contains a magic number: try {  	Check (NativeMethods.CryptAcquireContextW (out providerContext' containerName' null' 1' // PROV_RSA_FULL  	8));  	// CRYPT_NEWKEYSET  	Check (NativeMethods.CryptGenKey (providerContext' 1' // AT_KEYEXCHANGE  	1' // CRYPT_EXPORTABLE  	out cryptKey));  	IntPtr errorStringPtr;  	int nameDataLength = 0;  	byte[] nameData;  	// errorStringPtr gets a pointer into the middle of the x500 string'  	// so x500 needs to be pinned until after we've copied the value  	// of errorStringPtr.  	dataHandle = GCHandle.Alloc (x500' GCHandleType.Pinned);  	if (!NativeMethods.CertStrToNameW (0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING  	dataHandle.AddrOfPinnedObject ()' 3' // CERT_X500_NAME_STR = 3  	IntPtr.Zero' null' ref nameDataLength' out errorStringPtr)) {  		string error = Marshal.PtrToStringUni (errorStringPtr);  		throw new ArgumentException (error);  	}  	nameData = new byte[nameDataLength];  	if (!NativeMethods.CertStrToNameW (0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING  	dataHandle.AddrOfPinnedObject ()' 3' // CERT_X500_NAME_STR = 3  	IntPtr.Zero' nameData' ref nameDataLength' out errorStringPtr)) {  		string error = Marshal.PtrToStringUni (errorStringPtr);  		throw new ArgumentException (error);  	}  	dataHandle.Free ();  	dataHandle = GCHandle.Alloc (nameData' GCHandleType.Pinned);  	CryptoApiBlob nameBlob = new CryptoApiBlob (nameData.Length' dataHandle.AddrOfPinnedObject ());  	CryptKeyProviderInformation kpi = new CryptKeyProviderInformation ();  	kpi.ContainerName = containerName;  	kpi.ProviderType = 1;  	// PROV_RSA_FULL  	kpi.KeySpec = 1;  	// AT_KEYEXCHANGE  	certContext = NativeMethods.CertCreateSelfSignCertificate (providerContext' ref nameBlob' 0' ref kpi' IntPtr.Zero' // default = SHA1RSA  	ref startSystemTime' ref endSystemTime' IntPtr.Zero);  	Check (certContext != IntPtr.Zero);  	dataHandle.Free ();  	certStore = NativeMethods.CertOpenStore ("Memory"' // sz_CERT_STORE_PROV_MEMORY  	0' IntPtr.Zero' 0x2000' // CERT_STORE_CREATE_NEW_FLAG  	IntPtr.Zero);  	Check (certStore != IntPtr.Zero);  	Check (NativeMethods.CertAddCertificateContextToStore (certStore' certContext' 1' // CERT_STORE_ADD_NEW  	out storeCertContext));  	NativeMethods.CertSetCertificateContextProperty (storeCertContext' 2' // CERT_KEY_PROV_INFO_PROP_ID  	0' ref kpi);  	if (password != null) {  		passwordPtr = Marshal.SecureStringToCoTaskMemUnicode (password);  	}  	CryptoApiBlob pfxBlob = new CryptoApiBlob ();  	Check (NativeMethods.PFXExportCertStoreEx (certStore' ref pfxBlob' passwordPtr' IntPtr.Zero' 7));  	// EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY  	pfxData = new byte[pfxBlob.DataLength];  	dataHandle = GCHandle.Alloc (pfxData' GCHandleType.Pinned);  	pfxBlob.Data = dataHandle.AddrOfPinnedObject ();  	Check (NativeMethods.PFXExportCertStoreEx (certStore' ref pfxBlob' passwordPtr' IntPtr.Zero' 7));  	// EXPORT_PRIVATE_KEYS | REPORT_NO_PRIVATE_KEY | REPORT_NOT_ABLE_TO_EXPORT_PRIVATE_KEY  	dataHandle.Free ();  } finally {  	if (passwordPtr != IntPtr.Zero) {  		Marshal.ZeroFreeCoTaskMemUnicode (passwordPtr);  	}  	if (dataHandle.IsAllocated) {  		dataHandle.Free ();  	}  	if (certContext != IntPtr.Zero) {  		NativeMethods.CertFreeCertificateContext (certContext);  	}  	if (storeCertContext != IntPtr.Zero) {  		NativeMethods.CertFreeCertificateContext (storeCertContext);  	}  	if (certStore != IntPtr.Zero) {  		NativeMethods.CertCloseStore (certStore' 0);  	}  	if (cryptKey != IntPtr.Zero) {  		NativeMethods.CryptDestroyKey (cryptKey);  	}  	if (providerContext != IntPtr.Zero) {  		NativeMethods.CryptReleaseContext (providerContext' 0);  		NativeMethods.CryptAcquireContextW (out providerContext' containerName' null' 1' // PROV_RSA_FULL  		0x10);  		// CRYPT_DELETEKEYSET  	}  }  
Magic Number,CertPairGenerator,CertificateGenerator,D:\newReposJune17\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The following statement contains a magic number: Check (NativeMethods.CryptAcquireContextW (out providerContext' containerName' null' 1' // PROV_RSA_FULL  8));  
Magic Number,CertPairGenerator,CertificateGenerator,D:\newReposJune17\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The following statement contains a magic number: if (!NativeMethods.CertStrToNameW (0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING  dataHandle.AddrOfPinnedObject ()' 3' // CERT_X500_NAME_STR = 3  IntPtr.Zero' null' ref nameDataLength' out errorStringPtr)) {  	string error = Marshal.PtrToStringUni (errorStringPtr);  	throw new ArgumentException (error);  }  
Magic Number,CertPairGenerator,CertificateGenerator,D:\newReposJune17\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The following statement contains a magic number: if (!NativeMethods.CertStrToNameW (0x00010001' // X509_ASN_ENCODING | PKCS_7_ASN_ENCODING  dataHandle.AddrOfPinnedObject ()' 3' // CERT_X500_NAME_STR = 3  IntPtr.Zero' nameData' ref nameDataLength' out errorStringPtr)) {  	string error = Marshal.PtrToStringUni (errorStringPtr);  	throw new ArgumentException (error);  }  
Magic Number,CertPairGenerator,CertificateGenerator,D:\newReposJune17\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The following statement contains a magic number: NativeMethods.CertSetCertificateContextProperty (storeCertContext' 2' // CERT_KEY_PROV_INFO_PROP_ID  0' ref kpi);  
Magic Number,CertPairGenerator,CertificateGenerator,D:\newReposJune17\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The following statement contains a magic number: Check (NativeMethods.PFXExportCertStoreEx (certStore' ref pfxBlob' passwordPtr' IntPtr.Zero' 7));  
Magic Number,CertPairGenerator,CertificateGenerator,D:\newReposJune17\iSECPartners_PeachFarmer\CertPairGenerator\CertificateGenerator.cs,CreateSelfSignCertificatePfx,The following statement contains a magic number: Check (NativeMethods.PFXExportCertStoreEx (certStore' ref pfxBlob' passwordPtr' IntPtr.Zero' 7));  
Magic Number,CertPairGenerator,Program,D:\newReposJune17\iSECPartners_PeachFarmer\CertPairGenerator\Program.cs,CreatePfxFile,The following statement contains a magic number: try {  	string x500 = string.Format ("CN=\"{0}\""' commonName);  	byte[] certValue = CertificateGenerator.CreateSelfSignCertificatePfx (x500' DateTime.Now' DateTime.Now.AddYears (10));  	using (BinaryWriter writer = new BinaryWriter (File.Open (outputFilename' FileMode.CreateNew))) {  		writer.Write (certValue);  	}  } catch (Exception ex) {  	Console.WriteLine ("Error creating certificate: {0}"' ex.Message);  }  
