Implementation smell,Namespace,Class,File,Method,Description
Long Method,SQLitePCL.pretty.Orm.Sql,SqlCompiler,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\SqlQuery.Offset.cs,CompileExpr,The method has 129 lines of code.
Long Parameter List,SQLitePCL.pretty.Orm,DatabaseConnection,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\DatabaseConnection.cs,CreateIndex,The method has 5 parameters. Parameters: This' indexName' tableName' columnNames' unique
Long Parameter List,SQLitePCL.pretty.Orm,ColumnMapping,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\ColumnMapping.cs,ColumnMapping,The method has 5 parameters. Parameters: clrType' defaultValue' property' metadata' foreignKeyConstraint
Long Statement,SQLitePCL.pretty.Orm,TableMappingExt,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\TableMapping.cs,GetColumnMapping,The length of the statement  "            return new KeyValuePair<string'ColumnMapping>(name' new ColumnMapping(columnType' defaultValue' This' metadata' fkConstraint)); " is 127.
Long Statement,SQLitePCL.pretty.Orm,TableMappingExt,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\TableMapping.cs,CreateColumnMetadata,The length of the statement  "            return new TableColumnMetadata(columnType.GetSQLiteType().ToSQLDeclaredType()' collation' hasNotNullConstraint' isPK' isAutoInc); " is 129.
Long Statement,SQLitePCL.pretty.Orm,TableMappingExt,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\TableMapping.cs,GetSQLiteType,The length of the statement  "            else if (clrType == typeof(Single) || clrType == typeof(Double) || clrType == typeof(Decimal)) { return SQLiteType.Float; }  " is 123.
Long Statement,SQLitePCL.pretty.Orm,TableMappingExt,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\TableMapping.cs,GetSQLiteType,The length of the statement  "            else if (clrType == typeof(String) || clrType == typeof(Guid) || clrType == typeof(Uri))       { return SQLiteType.Text; }  " is 122.
Long Statement,SQLitePCL.pretty.Orm,TableMappingExt,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\TableMapping.cs,GetSQLiteType,The length of the statement  "            else if (clrType == typeof(byte[]) || clrType.IsSameOrSubclass(typeof(Stream)))                { return SQLiteType.Blob; }  " is 122.
Long Statement,SQLitePCL.pretty.Orm,SQLBuilder,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\SQLBuilder.cs,CreateTableIfNotExists,The length of the statement  "                        $"FOREIGN KEY(\"{x.Key}\") REFERENCES \"{x.Value.ForeignKeyConstraint.TableName}\"(\"{x.Value.ForeignKeyConstraint.ColumnName}\")")); " is 133.
Long Statement,SQLitePCL.pretty.Orm,ColumnMapping,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\ColumnMapping.cs,Equals,The length of the statement  "                (this.ForeignKeyConstraint == null) ? (other.ForeignKeyConstraint == null) : this.ForeignKeyConstraint.Equals(other.ForeignKeyConstraint); " is 138.
Long Statement,SQLitePCL.pretty.Orm.Sql,SqlCompiler,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\SqlQuery.Offset.cs,ConvertToSQLiteValue,The length of the statement  "            if (typeof(string) == t)                                                          { return ((string) This).ToSQLiteValue(); } " is 125.
Long Statement,SQLitePCL.pretty.Orm.Sql,SqlCompiler,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\SqlQuery.Offset.cs,ConvertToSQLiteValue,The length of the statement  "                || (typeof(UInt32) == t))                                                     { return ((long)(Convert.ChangeType(This' typeof(long)))).ToSQLiteValue(); } " is 154.
Long Statement,SQLitePCL.pretty.Orm.Sql,SqlCompiler,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\SqlQuery.Offset.cs,ConvertToSQLiteValue,The length of the statement  "            else if ((typeof(double) == t) || (typeof(float) == t) || (typeof(decimal) == t)) { return ((double)(Convert.ChangeType(This' typeof(double)))).ToSQLiteValue(); } " is 162.
Long Statement,SQLitePCL.pretty.Orm.Sql,SqlCompiler,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\SqlQuery.Offset.cs,ConvertToSQLiteValue,The length of the statement  "            else if (typeof(byte[]) == t)                                                     { return ((byte[]) This).ToSQLiteValue(); } " is 125.
Long Statement,SQLitePCL.pretty.Orm.Sql,SqlCompiler,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\SqlQuery.Offset.cs,ConvertToSQLiteValue,The length of the statement  "            else if (This is TimeSpan)                                                        { return ((TimeSpan) This).ToSQLiteValue(); } " is 127.
Long Statement,SQLitePCL.pretty.Orm.Sql,SqlCompiler,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\SqlQuery.Offset.cs,ConvertToSQLiteValue,The length of the statement  "            else if (This is DateTime)                                                        { return ((DateTime) This).ToSQLiteValue(); } " is 127.
Long Statement,SQLitePCL.pretty.Orm.Sql,SqlCompiler,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\SqlQuery.Offset.cs,ConvertToSQLiteValue,The length of the statement  "            else if (This is DateTimeOffset)                                                  { return ((DateTimeOffset) This).ToSQLiteValue(); } " is 133.
Long Statement,SQLitePCL.pretty.Orm.Sql,SqlCompiler,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\SqlQuery.Offset.cs,ConvertToSQLiteValue,The length of the statement  "            else if (This is Guid)                                                            { return ((Guid) This).ToSQLiteValue(); } " is 123.
Long Statement,SQLitePCL.pretty.Orm.Sql,SqlCompiler,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\SqlQuery.Offset.cs,ConvertToSQLiteValue,The length of the statement  "            else if (This is Uri)                                                             { return ((Uri) This).ToSQLiteValue(); } " is 122.
Complex Conditional,SQLitePCL.pretty.Orm,TableMappingExt,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\TableMapping.cs,GetSQLiteType,The conditional expression  "clrType == typeof(Boolean)        ||                   clrType == typeof(Byte)           ||                   clrType == typeof(UInt16)         ||                   clrType == typeof(SByte)          ||                   clrType == typeof(Int16)          ||                   clrType == typeof(Int32)          ||                  clrType == typeof(UInt32)         ||                   clrType == typeof(Int64)          ||                  clrType == typeof(TimeSpan)       ||                  clrType == typeof(DateTime)       ||                  clrType == typeof(DateTimeOffset) ||                    clrType.GetTypeInfo().IsEnum"  is complex.
Complex Conditional,SQLitePCL.pretty.Orm.Sql,SqlCompiler,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\SqlQuery.Offset.cs,ConvertToSQLiteValue,The conditional expression  "(typeof(Int32) == t)                  || (typeof(Boolean) == t)                  || (typeof(Byte) == t)                  || (typeof(UInt16) == t)                  || (typeof(Int16) == t)                  || (typeof(sbyte) == t)                  || (typeof(Int64) == t)                  || (typeof(UInt32) == t)"  is complex.
Magic Number,SQLitePCL.pretty.Orm,TableMapping,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\TableMapping.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,SQLitePCL.pretty.Orm,TableMapping,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\TableMapping.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + this.Type.GetHashCode();
Magic Number,SQLitePCL.pretty.Orm,TableMapping,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\TableMapping.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + this.TableName.GetHashCode();
Magic Number,SQLitePCL.pretty.Orm,TableMapping,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\TableMapping.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + this.Indexes.GetHashCode();
Magic Number,SQLitePCL.pretty.Orm,TableMapping,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\TableMapping.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + this.Columns.GetHashCode();
Magic Number,SQLitePCL.pretty.Orm,ColumnMapping,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\ColumnMapping.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,SQLitePCL.pretty.Orm,ColumnMapping,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\ColumnMapping.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + this.ClrType.GetHashCode();
Magic Number,SQLitePCL.pretty.Orm,ColumnMapping,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\ColumnMapping.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + (this.DefaultValue ?? 0).GetHashCode();
Magic Number,SQLitePCL.pretty.Orm,ColumnMapping,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\ColumnMapping.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + this.Property.GetHashCode();
Magic Number,SQLitePCL.pretty.Orm,ColumnMapping,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\ColumnMapping.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + this.Metadata.GetHashCode();
Magic Number,SQLitePCL.pretty.Orm,ColumnMapping,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\ColumnMapping.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + (this.ForeignKeyConstraint ?? ((object) 0)).GetHashCode();
Magic Number,SQLitePCL.pretty.Orm,IndexInfo,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\IndexInfo.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,SQLitePCL.pretty.Orm,IndexInfo,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\IndexInfo.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + this.Unique.GetHashCode();
Magic Number,SQLitePCL.pretty.Orm,IndexInfo,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\IndexInfo.cs,GetHashCode,The following statement contains a magic number: foreach (var col in this.Columns)              {                  hash =  hash * 31 + col.GetHashCode();              }
Magic Number,SQLitePCL.pretty.Orm,ForeignKeyConstraint,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\ForeignKeyConstraint.cs,GetHashCode,The following statement contains a magic number: int hash = 17;
Magic Number,SQLitePCL.pretty.Orm,ForeignKeyConstraint,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\ForeignKeyConstraint.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + this.TableName.GetHashCode();
Magic Number,SQLitePCL.pretty.Orm,ForeignKeyConstraint,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\ForeignKeyConstraint.cs,GetHashCode,The following statement contains a magic number: hash = hash * 31 + this.ColumnName.GetHashCode();
Magic Number,SQLitePCL.pretty.Orm.Sql,SqlCompiler,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\SqlQuery.Offset.cs,CompileExpr,The following statement contains a magic number: if (This is BinaryExpression)              {                  var bin = (BinaryExpression)This;                                    var leftExpr = bin.Left.CompileExpr();                  var rightExpr = bin.Right.CompileExpr();                    if (rightExpr == "NULL" && bin.NodeType == ExpressionType.Equal)                  {                      if (bin.NodeType == ExpressionType.Equal)                      {                          return $"({leftExpr} IS NULL)";                      }                      else if (rightExpr == "NULL" && bin.NodeType == ExpressionType.NotEqual)                      {                          return $"({leftExpr} IS NOT NULL)";                      }                  }                    return $"({leftExpr} {GetSqlName(bin)} {rightExpr})";              }              else if (This is ParameterExpression)              {                  var param = (ParameterExpression)This;                  return $":{param.Name}";              }              else if (This is MemberExpression)              {                  var member = (MemberExpression)This;                    if (member.Expression != null && member.Expression.NodeType == ExpressionType.Parameter)                  {                      // This is a column in the table' output the column name                      var tableName = TableMapping.Get(member.Expression.Type).TableName;                      var columnName = ((PropertyInfo) member.Member).GetColumnName();                      return $"\"{tableName}\".\"{columnName}\"";                  }                  else                  {                      return member.EvaluateExpression().ConvertToSQLiteValue().ToSqlString();                  }              }              else if (This.NodeType == ExpressionType.Not)              {                  var operandExpr = ((UnaryExpression)This).Operand;                  return $"NOT({operandExpr.CompileExpr()})";              }              else if (This is ConstantExpression)              {                  return This.EvaluateExpression().ConvertToSQLiteValue().ToSqlString();              }              else if (This is MethodCallExpression)              {                  var call = (MethodCallExpression)This;                  var args = new String[call.Arguments.Count];                    var obj = call.Object != null ? call.Object.CompileExpr() : null;                                    for (var i = 0; i < args.Length; i++)                  {                      args[i] = call.Arguments[i].CompileExpr();                  }                                    if (call.Method.Name == "Like" && args.Length == 2)                  {                      return $"({args[0]} LIKE {args[1]})";                  }                  else if (call.Method.Name == "Contains" && args.Length == 2)                  {                      return $"({args[1]} IN {args[0]})";                  }                  else if (call.Method.Name == "Contains" && args.Length == 1)                  {                      if (call.Object != null && call.Object.Type == typeof(string))                      {                          return $"({obj} LIKE ('%' || {args[0]} || '%'))";                      }                      else                      {                          return $"({args[0]} IN {obj})";                      }                  }                  else if (call.Method.Name == "StartsWith" && args.Length == 1)                  {                      return $"({obj} LIKE ({args[0]} || '%'))";                  }                  else if (call.Method.Name == "EndsWith" && args.Length == 1)                  {                      return $"({obj} LIKE ('%' || {args[0]}))";                  }                  else if (call.Method.Name == "Equals" && args.Length == 1)                  {                      return $"({obj} = ({args[0]}))";                  }                  else if (call.Method.Name == "Is" && args.Length == 2)                  {                      return $"({args[0]} IS {args[1]})";                  }                  else if (call.Method.Name == "IsNot" && args.Length == 2)                  {                      return $"({args[0]} IS NOT {args[1]})";                  }              }              else if (This.NodeType == ExpressionType.Convert)              {                  var u = (UnaryExpression)This;                    // Let SQLite handle the casting for us                  var operand = u.Operand;                  return operand.CompileExpr();                    // FIXME: Might still want to support a direct cast here if the                  // operand is a constant value or a function that is evaluated                  /*                  var ty = u.Type;                  var value = EvaluateExpression(u.Operand);                    return value.ConvertTo(ty).ConvertToSQLiteValue().ToSqlString();*/              }              else if (This.NodeType == ExpressionType.Default)              {                  var d = (DefaultExpression)This;                  var ty = d.Type;                  if (ty == typeof(void))                  {                      return "";                  }              }              else if (This.NodeType == ExpressionType.Lambda)              {                  var expr = (LambdaExpression) This;                  return CompileExpr(expr.Body);              }
Magic Number,SQLitePCL.pretty.Orm.Sql,SqlCompiler,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\SqlQuery.Offset.cs,CompileExpr,The following statement contains a magic number: if (This is BinaryExpression)              {                  var bin = (BinaryExpression)This;                                    var leftExpr = bin.Left.CompileExpr();                  var rightExpr = bin.Right.CompileExpr();                    if (rightExpr == "NULL" && bin.NodeType == ExpressionType.Equal)                  {                      if (bin.NodeType == ExpressionType.Equal)                      {                          return $"({leftExpr} IS NULL)";                      }                      else if (rightExpr == "NULL" && bin.NodeType == ExpressionType.NotEqual)                      {                          return $"({leftExpr} IS NOT NULL)";                      }                  }                    return $"({leftExpr} {GetSqlName(bin)} {rightExpr})";              }              else if (This is ParameterExpression)              {                  var param = (ParameterExpression)This;                  return $":{param.Name}";              }              else if (This is MemberExpression)              {                  var member = (MemberExpression)This;                    if (member.Expression != null && member.Expression.NodeType == ExpressionType.Parameter)                  {                      // This is a column in the table' output the column name                      var tableName = TableMapping.Get(member.Expression.Type).TableName;                      var columnName = ((PropertyInfo) member.Member).GetColumnName();                      return $"\"{tableName}\".\"{columnName}\"";                  }                  else                  {                      return member.EvaluateExpression().ConvertToSQLiteValue().ToSqlString();                  }              }              else if (This.NodeType == ExpressionType.Not)              {                  var operandExpr = ((UnaryExpression)This).Operand;                  return $"NOT({operandExpr.CompileExpr()})";              }              else if (This is ConstantExpression)              {                  return This.EvaluateExpression().ConvertToSQLiteValue().ToSqlString();              }              else if (This is MethodCallExpression)              {                  var call = (MethodCallExpression)This;                  var args = new String[call.Arguments.Count];                    var obj = call.Object != null ? call.Object.CompileExpr() : null;                                    for (var i = 0; i < args.Length; i++)                  {                      args[i] = call.Arguments[i].CompileExpr();                  }                                    if (call.Method.Name == "Like" && args.Length == 2)                  {                      return $"({args[0]} LIKE {args[1]})";                  }                  else if (call.Method.Name == "Contains" && args.Length == 2)                  {                      return $"({args[1]} IN {args[0]})";                  }                  else if (call.Method.Name == "Contains" && args.Length == 1)                  {                      if (call.Object != null && call.Object.Type == typeof(string))                      {                          return $"({obj} LIKE ('%' || {args[0]} || '%'))";                      }                      else                      {                          return $"({args[0]} IN {obj})";                      }                  }                  else if (call.Method.Name == "StartsWith" && args.Length == 1)                  {                      return $"({obj} LIKE ({args[0]} || '%'))";                  }                  else if (call.Method.Name == "EndsWith" && args.Length == 1)                  {                      return $"({obj} LIKE ('%' || {args[0]}))";                  }                  else if (call.Method.Name == "Equals" && args.Length == 1)                  {                      return $"({obj} = ({args[0]}))";                  }                  else if (call.Method.Name == "Is" && args.Length == 2)                  {                      return $"({args[0]} IS {args[1]})";                  }                  else if (call.Method.Name == "IsNot" && args.Length == 2)                  {                      return $"({args[0]} IS NOT {args[1]})";                  }              }              else if (This.NodeType == ExpressionType.Convert)              {                  var u = (UnaryExpression)This;                    // Let SQLite handle the casting for us                  var operand = u.Operand;                  return operand.CompileExpr();                    // FIXME: Might still want to support a direct cast here if the                  // operand is a constant value or a function that is evaluated                  /*                  var ty = u.Type;                  var value = EvaluateExpression(u.Operand);                    return value.ConvertTo(ty).ConvertToSQLiteValue().ToSqlString();*/              }              else if (This.NodeType == ExpressionType.Default)              {                  var d = (DefaultExpression)This;                  var ty = d.Type;                  if (ty == typeof(void))                  {                      return "";                  }              }              else if (This.NodeType == ExpressionType.Lambda)              {                  var expr = (LambdaExpression) This;                  return CompileExpr(expr.Body);              }
Magic Number,SQLitePCL.pretty.Orm.Sql,SqlCompiler,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\SqlQuery.Offset.cs,CompileExpr,The following statement contains a magic number: if (This is BinaryExpression)              {                  var bin = (BinaryExpression)This;                                    var leftExpr = bin.Left.CompileExpr();                  var rightExpr = bin.Right.CompileExpr();                    if (rightExpr == "NULL" && bin.NodeType == ExpressionType.Equal)                  {                      if (bin.NodeType == ExpressionType.Equal)                      {                          return $"({leftExpr} IS NULL)";                      }                      else if (rightExpr == "NULL" && bin.NodeType == ExpressionType.NotEqual)                      {                          return $"({leftExpr} IS NOT NULL)";                      }                  }                    return $"({leftExpr} {GetSqlName(bin)} {rightExpr})";              }              else if (This is ParameterExpression)              {                  var param = (ParameterExpression)This;                  return $":{param.Name}";              }              else if (This is MemberExpression)              {                  var member = (MemberExpression)This;                    if (member.Expression != null && member.Expression.NodeType == ExpressionType.Parameter)                  {                      // This is a column in the table' output the column name                      var tableName = TableMapping.Get(member.Expression.Type).TableName;                      var columnName = ((PropertyInfo) member.Member).GetColumnName();                      return $"\"{tableName}\".\"{columnName}\"";                  }                  else                  {                      return member.EvaluateExpression().ConvertToSQLiteValue().ToSqlString();                  }              }              else if (This.NodeType == ExpressionType.Not)              {                  var operandExpr = ((UnaryExpression)This).Operand;                  return $"NOT({operandExpr.CompileExpr()})";              }              else if (This is ConstantExpression)              {                  return This.EvaluateExpression().ConvertToSQLiteValue().ToSqlString();              }              else if (This is MethodCallExpression)              {                  var call = (MethodCallExpression)This;                  var args = new String[call.Arguments.Count];                    var obj = call.Object != null ? call.Object.CompileExpr() : null;                                    for (var i = 0; i < args.Length; i++)                  {                      args[i] = call.Arguments[i].CompileExpr();                  }                                    if (call.Method.Name == "Like" && args.Length == 2)                  {                      return $"({args[0]} LIKE {args[1]})";                  }                  else if (call.Method.Name == "Contains" && args.Length == 2)                  {                      return $"({args[1]} IN {args[0]})";                  }                  else if (call.Method.Name == "Contains" && args.Length == 1)                  {                      if (call.Object != null && call.Object.Type == typeof(string))                      {                          return $"({obj} LIKE ('%' || {args[0]} || '%'))";                      }                      else                      {                          return $"({args[0]} IN {obj})";                      }                  }                  else if (call.Method.Name == "StartsWith" && args.Length == 1)                  {                      return $"({obj} LIKE ({args[0]} || '%'))";                  }                  else if (call.Method.Name == "EndsWith" && args.Length == 1)                  {                      return $"({obj} LIKE ('%' || {args[0]}))";                  }                  else if (call.Method.Name == "Equals" && args.Length == 1)                  {                      return $"({obj} = ({args[0]}))";                  }                  else if (call.Method.Name == "Is" && args.Length == 2)                  {                      return $"({args[0]} IS {args[1]})";                  }                  else if (call.Method.Name == "IsNot" && args.Length == 2)                  {                      return $"({args[0]} IS NOT {args[1]})";                  }              }              else if (This.NodeType == ExpressionType.Convert)              {                  var u = (UnaryExpression)This;                    // Let SQLite handle the casting for us                  var operand = u.Operand;                  return operand.CompileExpr();                    // FIXME: Might still want to support a direct cast here if the                  // operand is a constant value or a function that is evaluated                  /*                  var ty = u.Type;                  var value = EvaluateExpression(u.Operand);                    return value.ConvertTo(ty).ConvertToSQLiteValue().ToSqlString();*/              }              else if (This.NodeType == ExpressionType.Default)              {                  var d = (DefaultExpression)This;                  var ty = d.Type;                  if (ty == typeof(void))                  {                      return "";                  }              }              else if (This.NodeType == ExpressionType.Lambda)              {                  var expr = (LambdaExpression) This;                  return CompileExpr(expr.Body);              }
Magic Number,SQLitePCL.pretty.Orm.Sql,SqlCompiler,C:\repos\bordoley_SQLitePCL.pretty\SQLitePCL.pretty.Orm\SqlQuery.Offset.cs,CompileExpr,The following statement contains a magic number: if (This is BinaryExpression)              {                  var bin = (BinaryExpression)This;                                    var leftExpr = bin.Left.CompileExpr();                  var rightExpr = bin.Right.CompileExpr();                    if (rightExpr == "NULL" && bin.NodeType == ExpressionType.Equal)                  {                      if (bin.NodeType == ExpressionType.Equal)                      {                          return $"({leftExpr} IS NULL)";                      }                      else if (rightExpr == "NULL" && bin.NodeType == ExpressionType.NotEqual)                      {                          return $"({leftExpr} IS NOT NULL)";                      }                  }                    return $"({leftExpr} {GetSqlName(bin)} {rightExpr})";              }              else if (This is ParameterExpression)              {                  var param = (ParameterExpression)This;                  return $":{param.Name}";              }              else if (This is MemberExpression)              {                  var member = (MemberExpression)This;                    if (member.Expression != null && member.Expression.NodeType == ExpressionType.Parameter)                  {                      // This is a column in the table' output the column name                      var tableName = TableMapping.Get(member.Expression.Type).TableName;                      var columnName = ((PropertyInfo) member.Member).GetColumnName();                      return $"\"{tableName}\".\"{columnName}\"";                  }                  else                  {                      return member.EvaluateExpression().ConvertToSQLiteValue().ToSqlString();                  }              }              else if (This.NodeType == ExpressionType.Not)              {                  var operandExpr = ((UnaryExpression)This).Operand;                  return $"NOT({operandExpr.CompileExpr()})";              }              else if (This is ConstantExpression)              {                  return This.EvaluateExpression().ConvertToSQLiteValue().ToSqlString();              }              else if (This is MethodCallExpression)              {                  var call = (MethodCallExpression)This;                  var args = new String[call.Arguments.Count];                    var obj = call.Object != null ? call.Object.CompileExpr() : null;                                    for (var i = 0; i < args.Length; i++)                  {                      args[i] = call.Arguments[i].CompileExpr();                  }                                    if (call.Method.Name == "Like" && args.Length == 2)                  {                      return $"({args[0]} LIKE {args[1]})";                  }                  else if (call.Method.Name == "Contains" && args.Length == 2)                  {                      return $"({args[1]} IN {args[0]})";                  }                  else if (call.Method.Name == "Contains" && args.Length == 1)                  {                      if (call.Object != null && call.Object.Type == typeof(string))                      {                          return $"({obj} LIKE ('%' || {args[0]} || '%'))";                      }                      else                      {                          return $"({args[0]} IN {obj})";                      }                  }                  else if (call.Method.Name == "StartsWith" && args.Length == 1)                  {                      return $"({obj} LIKE ({args[0]} || '%'))";                  }                  else if (call.Method.Name == "EndsWith" && args.Length == 1)                  {                      return $"({obj} LIKE ('%' || {args[0]}))";                  }                  else if (call.Method.Name == "Equals" && args.Length == 1)                  {                      return $"({obj} = ({args[0]}))";                  }                  else if (call.Method.Name == "Is" && args.Length == 2)                  {                      return $"({args[0]} IS {args[1]})";                  }                  else if (call.Method.Name == "IsNot" && args.Length == 2)                  {                      return $"({args[0]} IS NOT {args[1]})";                  }              }              else if (This.NodeType == ExpressionType.Convert)              {                  var u = (UnaryExpression)This;                    // Let SQLite handle the casting for us                  var operand = u.Operand;                  return operand.CompileExpr();                    // FIXME: Might still want to support a direct cast here if the                  // operand is a constant value or a function that is evaluated                  /*                  var ty = u.Type;                  var value = EvaluateExpression(u.Operand);                    return value.ConvertTo(ty).ConvertToSQLiteValue().ToSqlString();*/              }              else if (This.NodeType == ExpressionType.Default)              {                  var d = (DefaultExpression)This;                  var ty = d.Type;                  if (ty == typeof(void))                  {                      return "";                  }              }              else if (This.NodeType == ExpressionType.Lambda)              {                  var expr = (LambdaExpression) This;                  return CompileExpr(expr.Body);              }
