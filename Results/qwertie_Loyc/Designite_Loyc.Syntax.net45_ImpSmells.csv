Implementation smell,Namespace,Class,File,Method,Description
Long Method,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,NextToken,The method has 269 lines of code.
Long Method,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The method has 317 lines of code.
Long Method,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,TopExpr,The method has 102 lines of code.
Long Method,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,Expr,The method has 108 lines of code.
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,MLComment,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DecDigits,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,HexDigits,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,Scan_HexDigits,Cyclomatic complexity of the method is 13
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,HexNumber,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,Number,Cyclomatic complexity of the method is 12
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,TQString,Cyclomatic complexity of the method is 16
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,TDQStringLine,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,TSQStringLine,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,MLCommentLine,Cyclomatic complexity of the method is 14
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,UnescapeString,Cyclomatic complexity of the method is 23
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,Cyclomatic complexity of the method is 10
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseNumberValue,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseIntegerValue,Cyclomatic complexity of the method is 17
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseNormalFloat,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseSpecialFloatValue,Cyclomatic complexity of the method is 11
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,GetOpNameAndType,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les2Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2ParserGrammar.out.cs,TopExpr,Cyclomatic complexity of the method is 12
Complex Method,Loyc.Syntax.Les,Les2Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2ParserGrammar.out.cs,Expr,Cyclomatic complexity of the method is 12
Complex Method,Loyc.Syntax.Les,Les2Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2ParserGrammar.out.cs,Particle,Cyclomatic complexity of the method is 11
Complex Method,Loyc.Syntax.Les,Les2Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2ParserGrammar.out.cs,ToString,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,MLComment,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,DecDigits,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,HexDigits,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,HexNumber,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,TQString,Cyclomatic complexity of the method is 16
Complex Method,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,TDQStringLine,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,TSQStringLine,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,MLCommentLine,Cyclomatic complexity of the method is 14
Complex Method,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetOpNameAndType,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,TopExpr,Cyclomatic complexity of the method is 13
Complex Method,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,Expr,Cyclomatic complexity of the method is 18
Complex Method,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,InfixOperatorName,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,Particle,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,KeywordExpression,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,ToString,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les3PrettyPrinter,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3PrettyPrinter.cs,PrintToConsoleCore,Cyclomatic complexity of the method is 22
Complex Method,Loyc.Syntax.Les,Les3PrettyPrinter,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3PrettyPrinter.cs,PrintToHtmlCore,Cyclomatic complexity of the method is 19
Complex Method,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintStringCore,Cyclomatic complexity of the method is 15
Complex Method,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintLiteralCore,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintDouble,Cyclomatic complexity of the method is 11
Complex Method,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,DoubleToString_HexOrBinary,Cyclomatic complexity of the method is 13
Complex Method,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,VisitCall,Cyclomatic complexity of the method is 11
Complex Method,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintCallAsNormalOp,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,MaybePrintTrivia,Cyclomatic complexity of the method is 20
Complex Method,Loyc.Syntax.Les,Les2Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,PrintArgList,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les2Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,WriteAttrs,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les2Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,MaybePrintTrivia,Cyclomatic complexity of the method is 18
Complex Method,Loyc.Syntax.Les,Les2PrecedenceMap,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\LesPrecedenceMap.cs,FindPrecedence,Cyclomatic complexity of the method is 15
Complex Method,Loyc.Syntax.Les,TokenExt,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\TokenType.cs,ToString,Cyclomatic complexity of the method is 22
Complex Method,Loyc.Syntax.Lexing,BaseILexer<CharSrc;Token>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseILexer.cs,ScanIndent,Cyclomatic complexity of the method is 10
Complex Method,Loyc.Syntax.Lexing,IndentTokenGenerator<Token>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\IndentTokenGenerator.cs,HandleNextToken,Cyclomatic complexity of the method is 17
Complex Method,Loyc.Syntax.Lexing,TokensToTree,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\TokensToTree.cs,GatherChildren,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Syntax,DescendantsFrame,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,Cyclomatic complexity of the method is 14
Complex Method,Loyc.Syntax,LNode,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNode.cs,Equals,Cyclomatic complexity of the method is 16
Complex Method,Loyc.Syntax,LNodeExt,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeExt.cs,MatchesPattern,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,Cyclomatic complexity of the method is 23
Complex Method,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloatParts,Cyclomatic complexity of the method is 11
Complex Method,Loyc.Syntax,StandardTriviaInjector,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\StandardTriviaInjector.cs,AttachTriviaTo,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Syntax,StandardTriviaInjector,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\StandardTriviaInjector.cs,MakeTriviaAttribute,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax,AbstractTriviaInjector<Trivia>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\AbstractTriviaInjector.cs,RunCore,Cyclomatic complexity of the method is 15
Complex Method,Loyc.Syntax,AbstractTriviaInjector<Trivia>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\AbstractTriviaInjector.cs,InjectTriviaInChildren,Cyclomatic complexity of the method is 13
Long Parameter List,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,UnescapeQuotedString,The method has 5 parameters. Parameters: sourceText' onError' sb' indentation' les3TQIndents
Long Parameter List,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,UnescapeString,The method has 7 parameters. Parameters: sourceText' quoteType' isTripleQuoted' onError' sb' indentation' les3TQIndents
Long Parameter List,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseNumberCore,The method has 6 parameters. Parameters: source' isNegative' numberBase' isFloat' typeSuffix' error
Long Parameter List,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseIntegerValue,The method has 5 parameters. Parameters: source' isNegative' numberBase' typeSuffix' error
Long Parameter List,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseSpecialFloatValue,The method has 5 parameters. Parameters: source' isNegative' radix' typeSuffix' error
Long Parameter List,Loyc.Syntax.Les,Les3LanguageService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3LanguageService.cs,Print,The method has 5 parameters. Parameters: node' target' sink' mode' options
Long Parameter List,Loyc.Syntax.Les,Les3LanguageService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3LanguageService.cs,Print,The method has 5 parameters. Parameters: nodes' target' sink' mode' options
Long Parameter List,Loyc.Syntax.Les,Les3LanguageService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3LanguageService.cs,Print,The method has 5 parameters. Parameters: node' target' sink' mode' options
Long Parameter List,Loyc.Syntax.Les,Les3LanguageService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3LanguageService.cs,Print,The method has 5 parameters. Parameters: nodes' target' sink' mode' options
Long Parameter List,Loyc.Syntax.Les,Les3LanguageService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3LanguageService.cs,Parse,The method has 5 parameters. Parameters: text' fileName' msgs' inputType' preserveComments
Long Parameter List,Loyc.Syntax.Les,Les3PrettyPrinter,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3PrettyPrinter.cs,PrintToHtml,The method has 5 parameters. Parameters: nodes' output' addPreCode' sink' options
Long Parameter List,Loyc.Syntax.Les,Les3PrettyPrinter,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3PrettyPrinter.cs,PrintToHtmlCore,The method has 5 parameters. Parameters: input' output' addPreCode' newline' colorCodesToCssClasses
Long Parameter List,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,DoubleToString_HexOrBinary,The method has 6 parameters. Parameters: result' value' prefix' bitsPerDigit' isFloat' forcePNotation
Long Parameter List,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintArgListCore,The method has 6 parameters. Parameters: args' leftDelim' rightDelim' style' spacesInside' leftBracket
Long Parameter List,Loyc.Syntax.Les,Les2LanguageService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LanguageService.cs,Print,The method has 5 parameters. Parameters: node' target' sink' mode' options
Long Parameter List,Loyc.Syntax.Les,Les2LanguageService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LanguageService.cs,Print,The method has 5 parameters. Parameters: node' target' sink' mode' options
Long Parameter List,Loyc.Syntax.Les,Les2LanguageService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LanguageService.cs,Print,The method has 5 parameters. Parameters: nodes' target' msgs' mode' options
Long Parameter List,Loyc.Syntax.Les,Les2LanguageService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LanguageService.cs,Parse,The method has 5 parameters. Parameters: text' fileName' msgs' inputType' preserveComments
Long Parameter List,Loyc.Syntax.Les,Les2Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,Print,The method has 5 parameters. Parameters: node' target' sink' mode' options
Long Parameter List,Loyc.Syntax.Les,Les2Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,PrintArgList,The method has 5 parameters. Parameters: args' stmtMode' leftDelim' rightDelim' target
Long Parameter List,Loyc.Syntax.Les,Les2PrecedenceMap,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\LesPrecedenceMap.cs,FindPrecedence,The method has 5 parameters. Parameters: table' symbol' default' cacheWordOp' les3InfixOp
Long Parameter List,Loyc.Syntax.Lexing,IndentTokenGenerator,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\IndentTokenGenerator.cs,IndentTokenGenerator,The method has 5 parameters. Parameters: lexer' allIndentTriggers' eolToken' indentToken' dedentToken
Long Parameter List,Loyc.Syntax.Lexing,Token,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\Token.cs,Token,The method has 5 parameters. Parameters: type' startIndex' length' style' value
Long Parameter List,LeMP,IMacroContext,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LeMP\IMacroContext.cs,PreProcess,The method has 5 parameters. Parameters: input' asRoot' resetOpenNamespaces' resetProperties' areAttributes
Long Parameter List,LeMP,IMacroContext,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LeMP\IMacroContext.cs,PreProcess,The method has 5 parameters. Parameters: input' asRoot' resetOpenNamespaces' resetProperties' isTarget
Long Parameter List,Loyc.Syntax,ILNodePrinter,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\ILNodePrinter.cs,Print,The method has 5 parameters. Parameters: node' target' sink' mode' options
Long Parameter List,Loyc.Syntax,ILNodePrinter,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\ILNodePrinter.cs,Print,The method has 5 parameters. Parameters: nodes' target' sink' mode' options
Long Parameter List,Loyc.Syntax,LNodePrinter,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\ILNodePrinter.cs,Print,The method has 5 parameters. Parameters: printer' node' sink' mode' options
Long Parameter List,Loyc.Syntax,LNodePrinter,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\ILNodePrinter.cs,Print,The method has 5 parameters. Parameters: printer' nodes' sink' mode' options
Long Parameter List,Loyc.Syntax,LNodePrinter,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\ILNodePrinter.cs,PrintMultiple,The method has 6 parameters. Parameters: printer' nodes' sb' sink' mode' options
Long Parameter List,Loyc.Syntax,IParsingService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\IParsingService.cs,Parse,The method has 5 parameters. Parameters: text' fileName' msgs' mode' preserveComments
Long Parameter List,Loyc.Syntax,ParsingService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\IParsingService.cs,Parse,The method has 5 parameters. Parameters: parser' input' msgs' inputType' preserveComments
Long Parameter List,Loyc.Syntax,ParsingService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\IParsingService.cs,ParseSingle,The method has 5 parameters. Parameters: parser' expr' msgs' inputType' preserveComments
Long Parameter List,Loyc.Syntax,ParsingService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\IParsingService.cs,ParseSingle,The method has 6 parameters. Parameters: parser' text' fileName' msgs' inputType' preserveComments
Long Parameter List,Loyc.Syntax,ParsingService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\IParsingService.cs,Parse,The method has 6 parameters. Parameters: parser' stream' fileName' inputType' msgs' preserveComments
Long Parameter List,Loyc.Syntax,ParsingService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\IParsingService.cs,ParseFile,The method has 5 parameters. Parameters: parser' fileName' msgs' inputType' preserveComments
Long Parameter List,Loyc.Syntax,LNode,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNode.cs,Call,The method has 5 parameters. Parameters: name' range' targetStart' targetEnd' style
Long Parameter List,Loyc.Syntax,LNode,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNode.cs,Call,The method has 6 parameters. Parameters: name' args' range' targetStart' targetEnd' style
Long Parameter List,Loyc.Syntax,LNode,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNode.cs,Call,The method has 5 parameters. Parameters: attrs' name' args' range' style
Long Parameter List,Loyc.Syntax,LNode,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNode.cs,Call,The method has 5 parameters. Parameters: attrs' target' args' range' style
Long Parameter List,Loyc.Syntax,LNode,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNode.cs,Call,The method has 5 parameters. Parameters: attrs' name' args' file' style
Long Parameter List,Loyc.Syntax,LNode,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNode.cs,Call,The method has 5 parameters. Parameters: attrs' target' args' file' style
Long Parameter List,Loyc.Syntax,LNodeExt,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeExt.cs,MatchThenParams,The method has 5 parameters. Parameters: cArgs' pArgs' paramsCap' captures' attrs
Long Parameter List,Loyc.Syntax,LNodeExt,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeExt.cs,CaptureGroup,The method has 6 parameters. Parameters: c' p' cArgs' pArgs' captures' attrs
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 5 parameters. Parameters: target' _1' _2' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 6 parameters. Parameters: target' _1' _2' _3' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 7 parameters. Parameters: target' _1' _2' _3' _4' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 7 parameters. Parameters: target' args' startIndex' endIndex' targetStart' targetEnd' style
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 5 parameters. Parameters: target' _1' _2' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 6 parameters. Parameters: target' _1' _2' _3' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 7 parameters. Parameters: target' _1' _2' _3' _4' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 6 parameters. Parameters: target' startIndex' endIndex' targetStart' targetEnd' style
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 7 parameters. Parameters: target' _1' startIndex' endIndex' targetStart' targetEnd' style
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 8 parameters. Parameters: target' _1' _2' startIndex' endIndex' targetStart' targetEnd' style
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 5 parameters. Parameters: target' _1' _2' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 6 parameters. Parameters: target' _1' _2' _3' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 7 parameters. Parameters: target' _1' _2' _3' _4' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 5 parameters. Parameters: target' args' startIndex' endIndex' style
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 5 parameters. Parameters: target' args' startIndex' endIndex' style
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 5 parameters. Parameters: target' _1' startIndex' endIndex' style
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 6 parameters. Parameters: target' _1' _2' startIndex' endIndex' style
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Dot,The method has 7 parameters. Parameters: prefix' symbol' startIndex' endIndex' dotStart' dotEnd' style
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Fn,The method has 6 parameters. Parameters: retType' name' argList' body' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Fn,The method has 6 parameters. Parameters: retType' name' argList' body' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Property,The method has 5 parameters. Parameters: type' name' body' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Property,The method has 7 parameters. Parameters: type' name' argList' body' initializer' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Var,The method has 5 parameters. Parameters: type' name' initValue' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Var,The method has 5 parameters. Parameters: type' name' initValue' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Var,The method has 5 parameters. Parameters: type' name' initValue' startIndex' endIndex
Long Parameter List,Loyc.Syntax,StdSimpleCallNode,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\StdNodes.cs,StdSimpleCallNode,The method has 6 parameters. Parameters: name' args' range' targetStart' targetEnd' style
Long Parameter List,Loyc.Syntax,StdSimpleCallNodeWithAttrs,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\StdNodes.cs,StdSimpleCallNodeWithAttrs,The method has 5 parameters. Parameters: attrs' name' args' range' style
Long Parameter List,Loyc.Syntax,StdSimpleCallNodeWithAttrs,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\StdNodes.cs,StdSimpleCallNodeWithAttrs,The method has 5 parameters. Parameters: attrs' targetToken' args' range' style
Long Parameter List,Loyc.Syntax,StdComplexCallNodeWithAttrs,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\StdNodes.cs,StdComplexCallNodeWithAttrs,The method has 5 parameters. Parameters: attrs' target' args' range' style
Long Parameter List,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseInt,The method has 5 parameters. Parameters: s' index' result' radix' skipSpaces
Long Parameter List,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseUInt,The method has 5 parameters. Parameters: s' result' radix' flags' numDigits
Long Parameter List,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseUInt,The method has 5 parameters. Parameters: s' result' radix' flags' numDigits
Long Parameter List,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloatParts,The method has 9 parameters. Parameters: source' radix' negative' mantissa' exponentBaseR' exponentBase2' exponentBase10' numDigits' flags
Long Parameter List,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloatParts,The method has 8 parameters. Parameters: source' radix' negative' mantissa' exponentBase2' exponentBase10' numDigits' flags
Long Parameter List,Loyc.Syntax,StandardTriviaInjector,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\StandardTriviaInjector.cs,StandardTriviaInjector,The method has 6 parameters. Parameters: sortedTrivia' sourceFile' newlineTypeInt' mlCommentPrefix' mlCommentSuffix' slCommentPrefix
Long Parameter List,Loyc.Syntax,StandardTriviaInjector,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\StandardTriviaInjector.cs,AttachTriviaTo,The method has 5 parameters. Parameters: node' trivia' loc' parent' indexInParent
Long Parameter List,Loyc.Syntax,AbstractTriviaInjector<Trivia>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\AbstractTriviaInjector.cs,AttachTriviaTo,The method has 5 parameters. Parameters: node' trivia' loc' parent' indexInParent
Long Parameter List,Loyc.Syntax,AbstractTriviaInjector<Trivia>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\AbstractTriviaInjector.cs,AttachTriviaTo,The method has 5 parameters. Parameters: node' trivia' loc' parent' indexInParent
Long Parameter List,Loyc.Syntax,AbstractTriviaInjector<Trivia>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\AbstractTriviaInjector.cs,TryAttachTriviaTo,The method has 5 parameters. Parameters: prev' triviaList' loc' parent' prevIndexInParent
Long Parameter List,Loyc.Syntax,AbstractTriviaInjector<Trivia>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\AbstractTriviaInjector.cs,InjectTriviaInChildren,The method has 5 parameters. Parameters: parent' triviaRange' trivia' indexInParent' node
Long Parameter List,Loyc.Syntax,StreamCharSource,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\SourceFiles\StreamCharSource.cs,AutoResizeAndGetChars,The method has 5 parameters. Parameters: buf' outChars' outIndex' neededOutSize' flush
Long Identifier,Loyc.Syntax.Les,Les3PrinterOptions,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,,The length of the parameter SpacesBetweenAppendedStatements is 31.
Long Identifier,Loyc.Syntax.Les,Les3PrinterOptions,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,,The length of the parameter SpaceAroundInfixStopPrecedence is 30.
Long Identifier,Loyc.Syntax.Les,Les3PrinterOptions,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,,The length of the parameter SpaceAfterPrefixStopPrecedence is 30.
Long Identifier,Loyc.Syntax.Les,Les2PrinterOptions,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,,The length of the parameter SpacesBetweenAppendedStatements is 31.
Long Identifier,Loyc.Syntax.Les,Les2PrinterOptions,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,,The length of the parameter SpaceAroundInfixStopPrecedence is 30.
Long Identifier,Loyc.Syntax.Les,Les2PrinterOptions,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,,The length of the parameter SpaceAfterPrefixStopPrecedence is 30.
Long Statement,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,TQString,The length of the statement  "			// Line 100: (["] ["] ["] nongreedy(Newline / [^\$])* ["] ["] ["] | ['] ['] ['] nongreedy(Newline / [^\$])* ['] ['] ['])" is 120.
Long Statement,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,NextToken,The length of the statement  "			// Line 167: ( &{InputPosition == 0} Shebang / Symbol / Id / Newline / SLComment / MLComment / Number / TQString / DQString / SQString / BQOperator / Comma / Semicolon / LParen / [)] / [[] / [\]] / [{] / [}] / At / Operator )" is 225.
Long Statement,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,UnescapeString,The length of the statement  "						onError(i0' @"Unrecognized escape sequence '\{0}' in string".Localized(PrintHelpers.EscapeCStyle(sourceText[0' ' '].ToString()' EscapeC.Control)));" is 147.
Long Statement,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,GetOpNameAndType,The length of the statement  "			else if (last == '=' && (length == 1 || (first != '=' && first != '!' && !(length == 2 && (first == '<' || first == '>')))))" is 124.
Long Statement,Loyc.Syntax.Les,Les2Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2ParserGrammar.out.cs,Expr,The length of the statement  "			// Line 131: greedy( &{context.CanParse(prec = InfixPrecedenceOf(LT($LI)))} (TT.Assignment|TT.BQOperator|TT.Dot|TT.NormalOp) Expr | &{context.CanParse(P.Primary)} FinishPrimaryExpr | &{context.CanParse(P.Of)} TT.Not (TT.LParen ExprList TT.RParen / Expr) | &{context.CanParse(SuffixPrecedenceOf(LT($LI)))} TT.PreOrSufOp )*" is 321.
Long Statement,Loyc.Syntax.Les,Les2Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2ParserGrammar.out.cs,Expr,The length of the statement  "							e = F.Call(ToSuffixOpName((Symbol) t.Value)' e' e.Range.StartIndex' t.EndIndex' t.StartIndex' t.EndIndex' NodeStyle.Operator);" is 126.
Long Statement,Loyc.Syntax.Les,Les2Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2ParserGrammar.out.cs,FinishPrimaryExpr,The length of the statement  "				e = F.Call(S.IndexBracks' args' e.Range.StartIndex' c.EndIndex' lit_lsqb.StartIndex' lit_lsqb.EndIndex' NodeStyle.Operator);" is 124.
Long Statement,Loyc.Syntax.Les,Les2Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2ParserGrammar.out.cs,Particle,The length of the statement  "			// Line 191: ( TT.Id | TT.Literal | TT.At (TT.LBrack TokenTree TT.RBrack | TT.LBrace TokenTree TT.RBrace) | TT.LBrace StmtList TT.RBrace | TT.LBrack ExprList TT.RBrack | (TT.LParen|TT.SpaceLParen) ExprList TT.RParen )" is 217.
Long Statement,Loyc.Syntax.Les,Les2Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2ParserGrammar.out.cs,TokenTree,The length of the statement  "			// Line 233: nongreedy((TT.LBrace|TT.LBrack|TT.LParen|TT.SpaceLParen) TokenTree (TT.RBrace|TT.RBrack|TT.RParen) / ~(EOF))*" is 122.
Long Statement,Loyc.Syntax.Les,Les3LanguageService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3LanguageService.cs,Parse,The length of the statement  "				var injector = new StandardTriviaInjector(saver.TriviaList' input.SourceFile' (int)TokenType.Newline' "/*"' "*/"' "//");" is 120.
Long Statement,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,TQString,The length of the statement  "			// Line 102: (["] ["] ["] nongreedy(Newline / [^\$])* ["] ["] ["] | ['] ['] ['] nongreedy(Newline / [^\$])* ['] ['] ['])" is 120.
Long Statement,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,Operator,The length of the statement  "			// Line 123: (([$])? ([!%&*+\-/:<-?^|~] | [.] [^0-9] =>  greedy([.])*) ([!%&*+\-/:<-?^|~] | [.] [^0-9] =>  greedy([.])*)* / [$])" is 128.
Long Statement,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The length of the statement  "			// Line 192: ( Shebang / SpecialLiteral / [`] => Id / Id / Newline / SLComment / MLComment / Number / TQString / DQString / SQString / SQOperator / ['] / [;] / [(] / [)] / [[] / [\]] / [{] / [}] / [@] / Keyword / Operator )" is 223.
Long Statement,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,InitLiteralParsers,The length of the statement  "			Func<UString' object> u   = s => { ulong n; return ParseULong(s' out n) ? ((uint)n == n ? (object)(uint)n : (object)(ulong)n) : null; };" is 136.
Long Statement,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,InitLiteralParsers,The length of the statement  "			Func<UString' object> f32 = s => { double n; return ParseDouble(s' out n) && n >= float.MinValue && n <= float.MaxValue ? (object)(float)n : null; };" is 149.
Long Statement,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetOpNameAndType,The length of the statement  "			else if (last == '=' && (length == 1 || (first != '=' && first != '!' && !(length == 2 && (first == '<' || first == '>')))))" is 124.
Long Statement,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,PrintErrorIfTypeMarkerIsKeywordLiteral,The length of the statement  "				ErrorSink.Write(Severity.Error' IndexToPositionObject(_startPosition)' "Keyword '{0}' used as a type marker"' boolOrNull);" is 122.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,ExprList,The length of the statement  "			// Line 87: ((&{isBracedBlock} (TT.RBrack|TT.RParen))? (TT.Comma|TT.Newline|TT.Semicolon) NewlinesOpt ({..} / TopExpr) ErrorTokensOpt)*" is 135.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,TopExpr,The length of the statement  "			// Line 127: (TT.At (TT.At | Particle (&!{IsSpaceBefore($LI)} CallArgs)?) greedy(~(EOF|TT.LBrace|TT.Newline) => {..})? NewlinesOpt)*" is 132.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,Expr,The length of the statement  "			// Line 162: (KeywordExpression | PrefixExpr greedy( &{context.CanParse(P.Primary)} FinishPrimaryExpr | &{CanParse(context' $LI' out prec)} InfixOperatorName Expr | &{context.CanParse(_prec.Find(OperatorShape.Suffix' LT($LI).Value))} TT.PreOrSufOp | &{context.CanParse(P.Of)} TT.Not (TT.LParen ExprList TT.RParen / Expr) )*)" is 324.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,Expr,The length of the statement  "				// Line 167: greedy( &{context.CanParse(P.Primary)} FinishPrimaryExpr | &{CanParse(context' $LI' out prec)} InfixOperatorName Expr | &{context.CanParse(_prec.Find(OperatorShape.Suffix' LT($LI).Value))} TT.PreOrSufOp | &{context.CanParse(P.Of)} TT.Not (TT.LParen ExprList TT.RParen / Expr) )*" is 291.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,Expr,The length of the statement  "								e = F.Call(_prec.ToSuffixOpName((Symbol) t.Value)' e' e.Range.StartIndex' t.EndIndex' t.StartIndex' t.EndIndex' NodeStyle.Operator);" is 132.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,InfixOperatorName,The length of the statement  "			// Line 190: ( (TT.Assignment|TT.Dot|TT.NormalOp) (TT.Newline)* | &{(TT) LA($LI + 1) != TT.Newline} TT.Colon | &!{IsContinuator(LT($LI).Value)} TT.Id (&{op.EndIndex == LT0.StartIndex} (TT.Assignment|TT.Dot|TT.NormalOp) / {..}) (TT.Newline (TT.Newline)* / {..}) )" is 262.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,InfixOperatorName,The length of the statement  "								Error(0' "Syntax error. {0}' is used like an operator but is followed by a newline' which is not allowed unless the expression is placed in parentheses.".Localized(result));" is 173.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,CallArgs,The length of the statement  "			result = MarkCall(F.Call(target' args' target.Range.StartIndex' lit_rpar.EndIndex).SetBaseStyle(NodeStyle.PrefixNotation));" is 123.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,Particle,The length of the statement  "			// Line 246: ( (TT.BQId|TT.Id) | TT.Literal | TT.SingleQuoteOp TokenList | BracedBlock | SquareBracketList | TT.LParen ExprList TT.RParen )" is 139.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,Particle,The length of the statement  "					result = F.Call((Symbol) op.Value' got_TokenList' op.StartIndex' got_TokenList.IsEmpty ? op.EndIndex : got_TokenList.Last.Range.EndIndex);" is 138.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,SquareBracketList,The length of the statement  "			result = F.Call(S.Array' list' lit_lsqb.StartIndex' lit_rsqb.EndIndex' lit_lsqb.StartIndex' lit_lsqb.EndIndex).SetStyle(NodeStyle.Expression);" is 142.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,TokenListParticle,The length of the statement  "			// Line 288: ( TT.LParen TokenListEx TT.RParen / SquareBracketList / BracedBlock / TT.Literal / ~(EOF|TT.Comma|TT.Newline|TT.RBrace|TT.RBrack|TT.RParen|TT.Semicolon) )" is 167.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,BracedBlock,The length of the statement  "			return F.Call(S.Braces' stmts' lit_lcub.StartIndex' lit_rcub.EndIndex' lit_lcub.StartIndex' lit_lcub.EndIndex).SetStyle(NodeStyle.Statement);" is 141.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,CanParse,The length of the statement  "				Error(li' "Operator \"{0}\" cannot be mixed with the infix operator to its left. Add parentheses to clarify the code's meaning."' LT(li).Value);" is 144.
Long Statement,Loyc.Syntax.Les,Les3PrettyPrinter,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3PrettyPrinter.cs,PrintToHtmlCore,The length of the statement  "						input.TryGet(i + 2' '\0').IsOneOf((char)LesColorCode.Id' (char)LesColorCode.Number' (char)LesColorCode.KeywordLiteral' (char)LesColorCode.CustomLiteral' (char)LesColorCode.String))" is 180.
Long Statement,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintCallAsNormalOp,The length of the statement  "			Precedence prec = Les3PrecedenceMap.Default.Find(shape' opName' cacheWordOp: true' les3InfixOp: shape == OperatorShape.Infix);" is 126.
Long Statement,Loyc.Syntax.Les,CustomLiteral,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\SpecialLiteral.cs,ToString,The length of the statement  "				return LiteralTypeAsLes3Identifier() + "\"" + PrintHelpers.EscapeCStyle((string)Value' EscapeC.Control | EscapeC.DoubleQuotes) + "\"";" is 134.
Long Statement,Loyc.Syntax.Les,Les2LanguageService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LanguageService.cs,Parse,The length of the statement  "				var injector = new StandardTriviaInjector(saver.TriviaList' saver.SourceFile' (int)TokenType.Newline' "/*"' "*/"' "//");" is 120.
Long Statement,Loyc.Syntax.Les,Les2Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,PrintShortInteger,The length of the statement  "			ErrorSink.Write(Severity.Warning' null' "LesNodePrinter: Encountered literal of type '{0}'. It will be printed as 'Int32'."' type);" is 131.
Long Statement,Loyc.Syntax,ParsingService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\IParsingService.cs,ExtensionMatches,The length of the statement  "			return fn.Length > ext.Length && fn[fn.Length - ext.Length - 1] == '.' && fn.EndsWith(ext' StringComparison.OrdinalIgnoreCase);" is 127.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdComplexCallNode(target' new VList<LNode>(args)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 121.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdComplexCallNode(target' new VList<LNode>(_1' _2)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 123.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdComplexCallNode(target' new VList<LNode>(_1' _2).Add(_3)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 131.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdComplexCallNode(target' new VList<LNode>(_1' _2).Add(_3).Add(_4)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 139.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdComplexCallNode(target' new VList<LNode>(list)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 121.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' args' new SourceRange(_file' startIndex' endIndex - startIndex)' targetStart' targetEnd' style);" is 133.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' new VList<LNode>(_1' _2)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 122.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' new VList<LNode>(_1' _2).Add(_3)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 130.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' new VList<LNode>(_1' _2).Add(_3).Add(_4)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 138.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' VList<LNode>.Empty' new SourceRange(_file' startIndex' endIndex - startIndex)' targetStart' targetEnd' style);" is 147.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' new VList<LNode>(_1)' new SourceRange(_file' startIndex' endIndex - startIndex)' targetStart' targetEnd' style);" is 149.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' new VList<LNode>(_1' _2)' new SourceRange(_file' startIndex' endIndex - startIndex)' targetStart' targetEnd' style);" is 153.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' new VList<LNode>(args)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 120.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' new VList<LNode>(args)' new SourceRange(_file' startIndex' endIndex - startIndex)' style);" is 127.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' VList<LNode>.Empty' new SourceRange(_file' startIndex' endIndex - startIndex)' style);" is 123.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' new VList<LNode>(_1)' new SourceRange(_file' startIndex' endIndex - startIndex)' style);" is 125.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' new VList<LNode>(_1' _2)' new SourceRange(_file' startIndex' endIndex - startIndex)' style);" is 129.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Dot,The length of the statement  "			return new StdSimpleCallNode(S.Dot' new VList<LNode>(prefix' Id(symbol))' new SourceRange(_file' startIndex' endIndex - startIndex));" is 133.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Dot,The length of the statement  "			return new StdSimpleCallNode(S.Dot' new VList<LNode>(prefix' symbol)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 129.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Dot,The length of the statement  "			return new StdSimpleCallNode(S.Dot' new VList<LNode>(prefix' symbol)' new SourceRange(_file' startIndex' endIndex - startIndex)' dotStart' dotEnd' style);" is 154.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Tuple,The length of the statement  "			return new StdSimpleCallNode(S.Tuple' new VList<LNode>(contents)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 125.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Fn,The length of the statement  "			return new StdSimpleCallNode(S.Fn' new VList<LNode>(list)' new SourceRange(_file' startIndex' endIndex - startIndex)' startIndex' startIndex);" is 142.
Long Statement,Loyc.Syntax,LNodeFactory,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Property,The length of the statement  "			return new StdSimpleCallNode(S.Property' new VList<LNode>(list)' new SourceRange(_file' startIndex' endIndex - startIndex)' startIndex' startIndex);" is 148.
Long Statement,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloatParts,The length of the statement  "			bool success = TryParseFloatParts(ref source' radix' out negative' out mantissa' out exponentBaseR' out exponentBase2' out exponentBase10' out numDigits' flags);" is 161.
Long Statement,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseDouble,The length of the statement  "			if (!TryParseFloatParts(ref source' radix' out negative' out mantissa' out exponentBase2' out exponentBase10' out numDigits' flags))" is 132.
Long Statement,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloat,The length of the statement  "			if (!TryParseFloatParts(ref source' radix' out negative' out mantissa' out exponentBase2' out exponentBase10' out numDigits' flags))" is 132.
Long Statement,Loyc.Syntax,AbstractTriviaInjector<Trivia>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\AbstractTriviaInjector.cs,InjectTriviaInChildren,The length of the statement  "					newChildren.InternalArray[i].A = AttachTriviaTo(last.A' triviaList' TriviaLocation.TrailingExtra' node' last.B) ?? last.A;" is 122.
Long Statement,Loyc.Syntax,StreamCharSource,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\SourceFiles\StreamCharSource.cs,ReadNextBlock,The length of the statement  "						throw new ArgumentException(Localize.Localized("StreamCharSource cannot use the supplied decoder because it can produce single characters from byte sequences longer than {0} characters"' MaxSeqSize));" is 200.
Long Statement,Loyc.Syntax,StreamCharSource,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\SourceFiles\StreamCharSource.cs,ReadNextBlock,The length of the statement  "					throw new ArgumentException(Localize.Localized("StreamCharSource cannot use the supplied decoder because it seems to divide characters on bit boundaries")' exc);" is 161.
Long Statement,Loyc.Syntax.Impl,PrinterState,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\PrinterState.cs,GetCheckpoint,The length of the statement  "			return new Checkpoint { _oldLineStart = _lineStartIndex' _oldLineNo = LineNo' _oldLineStartAfterIndent = _lineStartAfterIndent };" is 129.
Complex Conditional,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DecNumber,The conditional expression  "la1 == '+' || la1 == '-' || la1 >= '0' && la1 <= '9'"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,HexNumber,The conditional expression  "la1 == '+' || la1 == '-' || la1 >= '0' && la1 <= '9'"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,BinNumber,The conditional expression  "la1 == '+' || la1 == '-' || la1 >= '0' && la1 <= '9'"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,SQString,The conditional expression  "!(la0 == -1 || la0 == '\n' || la0 == '\r' || la0 == '\'')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DQString,The conditional expression  "!(la0 == -1 || la0 == '\n' || la0 == '\r' || la0 == '"')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,BQString,The conditional expression  "!(la0 == -1 || la0 == '\n' || la0 == '\r' || la0 == '`')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,GetOpNameAndType,The conditional expression  "length >= 2 && first == last && (last == '+' || last == '-' || last == '!')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,GetOpNameAndType,The conditional expression  "last == '=' && (length == 1 || (first != '=' && first != '!' && !(length == 2 && (first == '<' || first == '>'))))"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,DecNumber,The conditional expression  "la1 == '+' || la1 == '-' || la1 >= '0' && la1 <= '9'"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,HexNumber,The conditional expression  "la1 == '+' || la1 == '-' || la1 >= '0' && la1 <= '9'"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,BinNumber,The conditional expression  "la1 == '+' || la1 == '-' || la1 >= '0' && la1 <= '9'"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,DQString,The conditional expression  "!(la0 == -1 || la0 == '\n' || la0 == '\r' || la0 == '"')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,BQString,The conditional expression  "!(la0 == -1 || la0 == '\n' || la0 == '\r' || la0 == '`')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetOpNameAndType,The conditional expression  "length >= 2 && first == last && (last == '+' || last == '-' || last == '!')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetOpNameAndType,The conditional expression  "last == '=' && (length == 1 || (first != '=' && first != '!' && !(length == 2 && (first == '<' || first == '>'))))"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintIdCore,The conditional expression  "forceQuote || !IsNormalIdentifier(name) || name == sy_true || name == sy_false || name == sy_null"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintStringCore,The conditional expression  "c == quoteType && ((b == quoteType && a == quoteType) || i + 1 == text.Length)"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintStringCore,The conditional expression  "c == '\\' && i + 2 < text.Length && text[i + 2] == '/' && 						((d = text[i + 1]) == 'r' || d == 'n' || d == 't' || d == '0' || d == '\\' || d == '\'' || d == '"')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintStringCore,The conditional expression  "c >= 0xDC80 && c <= 0xDCFF && !(b >= 0xD800 && b <= 0xDBFF)"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,IsContinuator,The conditional expression  "(argc == 1 || argc == 2) && ContinuatorOps.Contains(candidate.Name) && HasTargetIdWithoutPAttrs(candidate)"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,IsAcceptableKeyword,The conditional expression  "!(c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == '_')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,GetPrecedenceIfOperator,The conditional expression  "(naturalOp && bs != NodeStyle.PrefixNotation) || 					(bs == NodeStyle.Operator && node.Name != null)"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,AutoPrintBracesOrBracks,The conditional expression  "(name == S.Array || name == S.Braces) && node.IsCall() && !HasPAttrs(node.Target)"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,IsSpecialIdentifier,The conditional expression  "special && !backquote && (name.Name == "-inf_d" || name.Name == "-inf_f")"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,PrintStringCore,The conditional expression  "a == '\\' && b == '\\' && (c == quoteType || c == 'n' || c == 'r' || c == '\\')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2PrecedenceMap,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\LesPrecedenceMap.cs,IsOperator,The conditional expression  "c == '/' && rejectComment && (name[i] == '/' || name[i] == '*')"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,Match,The conditional expression  "la != a && la != b && la != c && la != d"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,MatchRange,The conditional expression  "(la < aLo || la > aHi) && (la < bLo || la > bHi)"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,MatchExcept,The conditional expression  "la == -1 || la == a || la == b || la == c"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,MatchExcept,The conditional expression  "la == -1 || la == a || la == b || la == c || la == d"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,MatchExceptRange,The conditional expression  "la == -1 || (la >= aLo && la <= aHi) || (la >= bLo && la <= bHi)"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,TryMatch,The conditional expression  "la != a && la != b && la != c && la != d"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,TryMatchRange,The conditional expression  "(la < aLo || la > aHi) && (la < bLo || la > bHi)"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,TryMatchExcept,The conditional expression  "la == -1 || la == a || la == b || la == c"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,TryMatchExcept,The conditional expression  "la == -1 || la == a || la == b || la == c || la == d"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,TryMatchExceptRange,The conditional expression  "la == -1 || (la >= aLo && la <= aHi) || (la >= bLo && la <= bHi)"  is complex.
Complex Conditional,Loyc.Syntax,BaseParser<Token;MatchType>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\BaseParser.cs,Match,The conditional expression  "!la.Equals(a) && !la.Equals(b) && !la.Equals(c) && !la.Equals(d)"  is complex.
Complex Conditional,Loyc.Syntax,BaseParser<Token;MatchType>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\BaseParser.cs,MatchExcept,The conditional expression  "la.Equals(a) || la.Equals(b) || la.Equals(c) || la.Equals(EOF)"  is complex.
Complex Conditional,Loyc.Syntax,BaseParser<Token;MatchType>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\BaseParser.cs,MatchExcept,The conditional expression  "la.Equals(a) || la.Equals(b) || la.Equals(c) || la.Equals(d) || la.Equals(EOF)"  is complex.
Complex Conditional,Loyc.Syntax,BaseParser<Token;MatchType>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\BaseParser.cs,TryMatch,The conditional expression  "!la.Equals(a) && !la.Equals(b) && !la.Equals(c) && !la.Equals(d)"  is complex.
Complex Conditional,Loyc.Syntax,BaseParser<Token;MatchType>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\BaseParser.cs,TryMatchExcept,The conditional expression  "la.Equals(EOF) || la.Equals(a) || la.Equals(b) || la.Equals(c)"  is complex.
Complex Conditional,Loyc.Syntax,BaseParser<Token;MatchType>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\BaseParser.cs,TryMatchExcept,The conditional expression  "la.Equals(EOF) || la.Equals(a) || la.Equals(b) || la.Equals(c) || la.Equals(d)"  is complex.
Virtual Method Call from Constructor,Loyc.Syntax.Les,Les2PrecedenceMap,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\LesPrecedenceMap.cs,Les2PrecedenceMap,The constructor "Les2PrecedenceMap" calls a virtual method "Reset".
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DecNumber,The following statement contains a magic number: _numberBase = 10;
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,HexNumber,The following statement contains a magic number: _numberBase = 16;
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,BinNumber,The following statement contains a magic number: _numberBase = 2;
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,TQString,The following statement contains a magic number: switch (LA0) { 					case '"': 						{ 							la1 = LA(1); 							if (la1 == '"') { 								la2 = LA(2); 								if (la2 == -1 || la2 == '"') 									goto stop; 								else 									Skip(); 							} else if (la1 == -1) 								goto stop; 							else 								Skip(); 						} 						break; 					case -1: 						goto stop; 					case '\n': case '\r': 						Newline(true); 						break; 					default: 						Skip(); 						break; 					}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,IdExtLetter,The following statement contains a magic number: MatchRange(128' 65532);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,IdExtLetter,The following statement contains a magic number: MatchRange(128' 65532);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,NextToken,The following statement contains a magic number: switch (la0) { 				case '#': 					{ 						if (InputPosition == 0) { 							la1 = LA(1); 							if (la1 == '!') { 								// line 168 								_type = TT.Shebang; 								Shebang(); 							} else 								goto matchId; 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (NextToken_set0.Contains(la2)) { 								// line 169 								_type = TT.Literal; 								Symbol(); 							} else 								goto matchAt; 						} else if (la1 == '`') { 							la2 = LA(2); 							if (!(la2 == -1 || la2 == '\n' || la2 == '\r')) 								goto matchId; 							else 								goto matchAt; 						} else if (NextToken_set1.Contains(la1)) 							goto matchId; 						else 							goto matchAt; 					} 					break; 				case '\n': case '\r': 					{ 						// line 171 						_type = TT.Newline; 						Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 172 							_type = TT.SLComment; 							SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								// line 173 								_type = TT.MLComment; 								MLComment(); 							} else 								Operator(); 						} else 							Operator(); 					} 					break; 				case '-': 					{ 						la1 = LA(1); 						if (la1 == '0') 							goto matchNumber; 						else if (la1 == '.') { 							la2 = LA(2); 							if (la2 >= '0' && la2 <= '9') 								goto matchNumber; 							else 								Operator(); 						} else if (la1 >= '1' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '0': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '1': case '2': case '3': case '4': 				case '5': case '6': case '7': case '8': 				case '9': 					goto matchNumber; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') 								goto matchTQString; 							else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchTQString; 							else 								goto matchSQString; 						} else 							goto matchSQString; 					} 				case '`': 					{ 						// line 178 						_type = TT.BQOperator; 						BQOperator(); 					} 					break; 				case ''': 					{ 						// line 179 						_type = TT.Comma; 						Comma(); 					} 					break; 				case ';': 					{ 						// line 180 						_type = TT.Semicolon; 						Semicolon(); 					} 					break; 				case '(': 					{ 						// line 181 						_type = TT.LParen; 						LParen(); 					} 					break; 				case ')': 					{ 						// line 182 						_type = TT.RParen; 						Skip(); 					} 					break; 				case '[': 					{ 						// line 183 						_type = TT.LBrack; 						Skip(); 					} 					break; 				case ']': 					{ 						// line 184 						_type = TT.RBrack; 						Skip(); 					} 					break; 				case '{': 					{ 						// line 185 						_type = TT.LBrace; 						Skip(); 					} 					break; 				case '}': 					{ 						// line 186 						_type = TT.RBrace; 						Skip(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case ':': case '<': 				case '=': case '>': case '?': case '^': 				case '|': case '~': 					Operator(); 					break; 				default: 					if (NextToken_set2.Contains(la0)) 						goto matchId; 					else { 						// line 189 						_value = null; 						// Line 190: ([\$] | [^\$]) 						la0 = LA0; 						if (la0 == -1) { 							Skip(); 							// line 190 							_type = TT.EOF; 						} else { 							Skip(); 							// line 191 							_type = TT.Unknown; 						} 					} 					break; 				}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,NextToken,The following statement contains a magic number: switch (la0) { 				case '#': 					{ 						if (InputPosition == 0) { 							la1 = LA(1); 							if (la1 == '!') { 								// line 168 								_type = TT.Shebang; 								Shebang(); 							} else 								goto matchId; 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (NextToken_set0.Contains(la2)) { 								// line 169 								_type = TT.Literal; 								Symbol(); 							} else 								goto matchAt; 						} else if (la1 == '`') { 							la2 = LA(2); 							if (!(la2 == -1 || la2 == '\n' || la2 == '\r')) 								goto matchId; 							else 								goto matchAt; 						} else if (NextToken_set1.Contains(la1)) 							goto matchId; 						else 							goto matchAt; 					} 					break; 				case '\n': case '\r': 					{ 						// line 171 						_type = TT.Newline; 						Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 172 							_type = TT.SLComment; 							SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								// line 173 								_type = TT.MLComment; 								MLComment(); 							} else 								Operator(); 						} else 							Operator(); 					} 					break; 				case '-': 					{ 						la1 = LA(1); 						if (la1 == '0') 							goto matchNumber; 						else if (la1 == '.') { 							la2 = LA(2); 							if (la2 >= '0' && la2 <= '9') 								goto matchNumber; 							else 								Operator(); 						} else if (la1 >= '1' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '0': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '1': case '2': case '3': case '4': 				case '5': case '6': case '7': case '8': 				case '9': 					goto matchNumber; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') 								goto matchTQString; 							else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchTQString; 							else 								goto matchSQString; 						} else 							goto matchSQString; 					} 				case '`': 					{ 						// line 178 						_type = TT.BQOperator; 						BQOperator(); 					} 					break; 				case ''': 					{ 						// line 179 						_type = TT.Comma; 						Comma(); 					} 					break; 				case ';': 					{ 						// line 180 						_type = TT.Semicolon; 						Semicolon(); 					} 					break; 				case '(': 					{ 						// line 181 						_type = TT.LParen; 						LParen(); 					} 					break; 				case ')': 					{ 						// line 182 						_type = TT.RParen; 						Skip(); 					} 					break; 				case '[': 					{ 						// line 183 						_type = TT.LBrack; 						Skip(); 					} 					break; 				case ']': 					{ 						// line 184 						_type = TT.RBrack; 						Skip(); 					} 					break; 				case '{': 					{ 						// line 185 						_type = TT.LBrace; 						Skip(); 					} 					break; 				case '}': 					{ 						// line 186 						_type = TT.RBrace; 						Skip(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case ':': case '<': 				case '=': case '>': case '?': case '^': 				case '|': case '~': 					Operator(); 					break; 				default: 					if (NextToken_set2.Contains(la0)) 						goto matchId; 					else { 						// line 189 						_value = null; 						// Line 190: ([\$] | [^\$]) 						la0 = LA0; 						if (la0 == -1) { 							Skip(); 							// line 190 							_type = TT.EOF; 						} else { 							Skip(); 							// line 191 							_type = TT.Unknown; 						} 					} 					break; 				}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,NextToken,The following statement contains a magic number: switch (la0) { 				case '#': 					{ 						if (InputPosition == 0) { 							la1 = LA(1); 							if (la1 == '!') { 								// line 168 								_type = TT.Shebang; 								Shebang(); 							} else 								goto matchId; 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (NextToken_set0.Contains(la2)) { 								// line 169 								_type = TT.Literal; 								Symbol(); 							} else 								goto matchAt; 						} else if (la1 == '`') { 							la2 = LA(2); 							if (!(la2 == -1 || la2 == '\n' || la2 == '\r')) 								goto matchId; 							else 								goto matchAt; 						} else if (NextToken_set1.Contains(la1)) 							goto matchId; 						else 							goto matchAt; 					} 					break; 				case '\n': case '\r': 					{ 						// line 171 						_type = TT.Newline; 						Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 172 							_type = TT.SLComment; 							SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								// line 173 								_type = TT.MLComment; 								MLComment(); 							} else 								Operator(); 						} else 							Operator(); 					} 					break; 				case '-': 					{ 						la1 = LA(1); 						if (la1 == '0') 							goto matchNumber; 						else if (la1 == '.') { 							la2 = LA(2); 							if (la2 >= '0' && la2 <= '9') 								goto matchNumber; 							else 								Operator(); 						} else if (la1 >= '1' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '0': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '1': case '2': case '3': case '4': 				case '5': case '6': case '7': case '8': 				case '9': 					goto matchNumber; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') 								goto matchTQString; 							else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchTQString; 							else 								goto matchSQString; 						} else 							goto matchSQString; 					} 				case '`': 					{ 						// line 178 						_type = TT.BQOperator; 						BQOperator(); 					} 					break; 				case ''': 					{ 						// line 179 						_type = TT.Comma; 						Comma(); 					} 					break; 				case ';': 					{ 						// line 180 						_type = TT.Semicolon; 						Semicolon(); 					} 					break; 				case '(': 					{ 						// line 181 						_type = TT.LParen; 						LParen(); 					} 					break; 				case ')': 					{ 						// line 182 						_type = TT.RParen; 						Skip(); 					} 					break; 				case '[': 					{ 						// line 183 						_type = TT.LBrack; 						Skip(); 					} 					break; 				case ']': 					{ 						// line 184 						_type = TT.RBrack; 						Skip(); 					} 					break; 				case '{': 					{ 						// line 185 						_type = TT.LBrace; 						Skip(); 					} 					break; 				case '}': 					{ 						// line 186 						_type = TT.RBrace; 						Skip(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case ':': case '<': 				case '=': case '>': case '?': case '^': 				case '|': case '~': 					Operator(); 					break; 				default: 					if (NextToken_set2.Contains(la0)) 						goto matchId; 					else { 						// line 189 						_value = null; 						// Line 190: ([\$] | [^\$]) 						la0 = LA0; 						if (la0 == -1) { 							Skip(); 							// line 190 							_type = TT.EOF; 						} else { 							Skip(); 							// line 191 							_type = TT.Unknown; 						} 					} 					break; 				}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,NextToken,The following statement contains a magic number: switch (la0) { 				case '#': 					{ 						if (InputPosition == 0) { 							la1 = LA(1); 							if (la1 == '!') { 								// line 168 								_type = TT.Shebang; 								Shebang(); 							} else 								goto matchId; 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (NextToken_set0.Contains(la2)) { 								// line 169 								_type = TT.Literal; 								Symbol(); 							} else 								goto matchAt; 						} else if (la1 == '`') { 							la2 = LA(2); 							if (!(la2 == -1 || la2 == '\n' || la2 == '\r')) 								goto matchId; 							else 								goto matchAt; 						} else if (NextToken_set1.Contains(la1)) 							goto matchId; 						else 							goto matchAt; 					} 					break; 				case '\n': case '\r': 					{ 						// line 171 						_type = TT.Newline; 						Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 172 							_type = TT.SLComment; 							SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								// line 173 								_type = TT.MLComment; 								MLComment(); 							} else 								Operator(); 						} else 							Operator(); 					} 					break; 				case '-': 					{ 						la1 = LA(1); 						if (la1 == '0') 							goto matchNumber; 						else if (la1 == '.') { 							la2 = LA(2); 							if (la2 >= '0' && la2 <= '9') 								goto matchNumber; 							else 								Operator(); 						} else if (la1 >= '1' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '0': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '1': case '2': case '3': case '4': 				case '5': case '6': case '7': case '8': 				case '9': 					goto matchNumber; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') 								goto matchTQString; 							else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchTQString; 							else 								goto matchSQString; 						} else 							goto matchSQString; 					} 				case '`': 					{ 						// line 178 						_type = TT.BQOperator; 						BQOperator(); 					} 					break; 				case ''': 					{ 						// line 179 						_type = TT.Comma; 						Comma(); 					} 					break; 				case ';': 					{ 						// line 180 						_type = TT.Semicolon; 						Semicolon(); 					} 					break; 				case '(': 					{ 						// line 181 						_type = TT.LParen; 						LParen(); 					} 					break; 				case ')': 					{ 						// line 182 						_type = TT.RParen; 						Skip(); 					} 					break; 				case '[': 					{ 						// line 183 						_type = TT.LBrack; 						Skip(); 					} 					break; 				case ']': 					{ 						// line 184 						_type = TT.RBrack; 						Skip(); 					} 					break; 				case '{': 					{ 						// line 185 						_type = TT.LBrace; 						Skip(); 					} 					break; 				case '}': 					{ 						// line 186 						_type = TT.RBrace; 						Skip(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case ':': case '<': 				case '=': case '>': case '?': case '^': 				case '|': case '~': 					Operator(); 					break; 				default: 					if (NextToken_set2.Contains(la0)) 						goto matchId; 					else { 						// line 189 						_value = null; 						// Line 190: ([\$] | [^\$]) 						la0 = LA0; 						if (la0 == -1) { 							Skip(); 							// line 190 							_type = TT.EOF; 						} else { 							Skip(); 							// line 191 							_type = TT.Unknown; 						} 					} 					break; 				}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,NextToken,The following statement contains a magic number: switch (la0) { 				case '#': 					{ 						if (InputPosition == 0) { 							la1 = LA(1); 							if (la1 == '!') { 								// line 168 								_type = TT.Shebang; 								Shebang(); 							} else 								goto matchId; 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (NextToken_set0.Contains(la2)) { 								// line 169 								_type = TT.Literal; 								Symbol(); 							} else 								goto matchAt; 						} else if (la1 == '`') { 							la2 = LA(2); 							if (!(la2 == -1 || la2 == '\n' || la2 == '\r')) 								goto matchId; 							else 								goto matchAt; 						} else if (NextToken_set1.Contains(la1)) 							goto matchId; 						else 							goto matchAt; 					} 					break; 				case '\n': case '\r': 					{ 						// line 171 						_type = TT.Newline; 						Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 172 							_type = TT.SLComment; 							SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								// line 173 								_type = TT.MLComment; 								MLComment(); 							} else 								Operator(); 						} else 							Operator(); 					} 					break; 				case '-': 					{ 						la1 = LA(1); 						if (la1 == '0') 							goto matchNumber; 						else if (la1 == '.') { 							la2 = LA(2); 							if (la2 >= '0' && la2 <= '9') 								goto matchNumber; 							else 								Operator(); 						} else if (la1 >= '1' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '0': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '1': case '2': case '3': case '4': 				case '5': case '6': case '7': case '8': 				case '9': 					goto matchNumber; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') 								goto matchTQString; 							else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchTQString; 							else 								goto matchSQString; 						} else 							goto matchSQString; 					} 				case '`': 					{ 						// line 178 						_type = TT.BQOperator; 						BQOperator(); 					} 					break; 				case ''': 					{ 						// line 179 						_type = TT.Comma; 						Comma(); 					} 					break; 				case ';': 					{ 						// line 180 						_type = TT.Semicolon; 						Semicolon(); 					} 					break; 				case '(': 					{ 						// line 181 						_type = TT.LParen; 						LParen(); 					} 					break; 				case ')': 					{ 						// line 182 						_type = TT.RParen; 						Skip(); 					} 					break; 				case '[': 					{ 						// line 183 						_type = TT.LBrack; 						Skip(); 					} 					break; 				case ']': 					{ 						// line 184 						_type = TT.RBrack; 						Skip(); 					} 					break; 				case '{': 					{ 						// line 185 						_type = TT.LBrace; 						Skip(); 					} 					break; 				case '}': 					{ 						// line 186 						_type = TT.RBrace; 						Skip(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case ':': case '<': 				case '=': case '>': case '?': case '^': 				case '|': case '~': 					Operator(); 					break; 				default: 					if (NextToken_set2.Contains(la0)) 						goto matchId; 					else { 						// line 189 						_value = null; 						// Line 190: ([\$] | [^\$]) 						la0 = LA0; 						if (la0 == -1) { 							Skip(); 							// line 190 							_type = TT.EOF; 						} else { 							Skip(); 							// line 191 							_type = TT.Unknown; 						} 					} 					break; 				}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,NextToken,The following statement contains a magic number: switch (la0) { 				case '#': 					{ 						if (InputPosition == 0) { 							la1 = LA(1); 							if (la1 == '!') { 								// line 168 								_type = TT.Shebang; 								Shebang(); 							} else 								goto matchId; 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (NextToken_set0.Contains(la2)) { 								// line 169 								_type = TT.Literal; 								Symbol(); 							} else 								goto matchAt; 						} else if (la1 == '`') { 							la2 = LA(2); 							if (!(la2 == -1 || la2 == '\n' || la2 == '\r')) 								goto matchId; 							else 								goto matchAt; 						} else if (NextToken_set1.Contains(la1)) 							goto matchId; 						else 							goto matchAt; 					} 					break; 				case '\n': case '\r': 					{ 						// line 171 						_type = TT.Newline; 						Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 172 							_type = TT.SLComment; 							SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								// line 173 								_type = TT.MLComment; 								MLComment(); 							} else 								Operator(); 						} else 							Operator(); 					} 					break; 				case '-': 					{ 						la1 = LA(1); 						if (la1 == '0') 							goto matchNumber; 						else if (la1 == '.') { 							la2 = LA(2); 							if (la2 >= '0' && la2 <= '9') 								goto matchNumber; 							else 								Operator(); 						} else if (la1 >= '1' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '0': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '1': case '2': case '3': case '4': 				case '5': case '6': case '7': case '8': 				case '9': 					goto matchNumber; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') 								goto matchTQString; 							else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchTQString; 							else 								goto matchSQString; 						} else 							goto matchSQString; 					} 				case '`': 					{ 						// line 178 						_type = TT.BQOperator; 						BQOperator(); 					} 					break; 				case ''': 					{ 						// line 179 						_type = TT.Comma; 						Comma(); 					} 					break; 				case ';': 					{ 						// line 180 						_type = TT.Semicolon; 						Semicolon(); 					} 					break; 				case '(': 					{ 						// line 181 						_type = TT.LParen; 						LParen(); 					} 					break; 				case ')': 					{ 						// line 182 						_type = TT.RParen; 						Skip(); 					} 					break; 				case '[': 					{ 						// line 183 						_type = TT.LBrack; 						Skip(); 					} 					break; 				case ']': 					{ 						// line 184 						_type = TT.RBrack; 						Skip(); 					} 					break; 				case '{': 					{ 						// line 185 						_type = TT.LBrace; 						Skip(); 					} 					break; 				case '}': 					{ 						// line 186 						_type = TT.RBrace; 						Skip(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case ':': case '<': 				case '=': case '>': case '?': case '^': 				case '|': case '~': 					Operator(); 					break; 				default: 					if (NextToken_set2.Contains(la0)) 						goto matchId; 					else { 						// line 189 						_value = null; 						// Line 190: ([\$] | [^\$]) 						la0 = LA0; 						if (la0 == -1) { 							Skip(); 							// line 190 							_type = TT.EOF; 						} else { 							Skip(); 							// line 191 							_type = TT.Unknown; 						} 					} 					break; 				}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,TDQStringLine,The following statement contains a magic number: switch (LA0) { 				case '\n': case '\r': 					goto stop; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == -1 || la2 == '"') 								goto stop; 							else 								Skip(); 						} else if (la1 == -1) 							goto stop; 						else 							Skip(); 					} 					break; 				case -1: 					goto stop; 				default: 					Skip(); 					break; 				}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,TSQStringLine,The following statement contains a magic number: switch (LA0) { 				case '\n': case '\r': 					goto stop; 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == -1 || la2 == '\'') 								goto stop; 							else 								Skip(); 						} else if (la1 == -1) 							goto stop; 						else 							Skip(); 					} 					break; 				case -1: 					goto stop; 				default: 					Skip(); 					break; 				}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseStringValue,The following statement contains a magic number: return _value = s.Length < 16 ? CG.Cache(s) : s;
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,UnescapeQuotedString,The following statement contains a magic number: sourceText = sourceText.Substring(2);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: Debug.Assert(minus1.IsInRange((char)128' (char)255));
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: Debug.Assert(minus1.IsInRange((char)128' (char)255));
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: int minus2 = sb[sb.Length - 2];
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: int c = ((minus2 & 0x1F) << 6) | (minus1 & 0x3F);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,RecodeSurrogate,The following statement contains a magic number: int b1 = 0xE0 | (c >> 12);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,RecodeSurrogate,The following statement contains a magic number: int b2 = 0x80 | ((c >> 6) & 0x3F);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseSymbolValue,The following statement contains a magic number: UString original = CharSource.Slice(_startPosition + 2' InputPosition - _startPosition - 2);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseSymbolValue,The following statement contains a magic number: UString original = CharSource.Slice(_startPosition + 2' InputPosition - _startPosition - 2);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseNumberValue,The following statement contains a magic number: start += 2;
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseNumberValue,The following statement contains a magic number: _numberBase != 10
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,GetOpNameAndType,The following statement contains a magic number: length >= 2 && first == last && (last == '+' || last == '-' || last == '!')
Magic Number,Loyc.Syntax.Les,Les2Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2ParserGrammar.out.cs,TopExpr,The following statement contains a magic number: switch ((TT) LA0) { 			case TT.Assignment: case TT.BQOperator: case TT.Dot: case TT.NormalOp: 			case TT.Not: case TT.PrefixOp: case TT.PreOrSufOp: 				e = Expr(StartStmt); 				break; 			case TT.Id: 				{ 					switch ((TT) LA(1)) { 					case EOF: case TT.Assignment: case TT.BQOperator: case TT.Comma: 					case TT.Dot: case TT.LBrack: case TT.LParen: case TT.NormalOp: 					case TT.Not: case TT.PreOrSufOp: case TT.RBrace: case TT.RBrack: 					case TT.RParen: case TT.Semicolon: 						e = Expr(StartStmt); 						break; 					default: 						{ 							var id = MatchAny(); 							// line 102 							var args = VList<LNode>.Empty; 							args.Add(Expr(P.SuperExpr)); 							// Line 104: (Particle)* 							for (;;) { 								switch ((TT) LA0) { 								case TT.At: case TT.Id: case TT.LBrace: case TT.LBrack: 								case TT.Literal: case TT.LParen: case TT.SpaceLParen: 									{ 										// line 105 										if (((TT) LA0 == TT.LParen)) { 											var loc = args[args.Count - 2' args.Last].Range.End; 											Error(0' "Expected a space before '(' (possibly missing ';' or ''' at {0})"' loc); 										} 										args.Add(Particle()); 									} 									break; 								default: 									goto stop; 								} 							} 						stop:; 							// line 112 							e = MarkSpecial(F.Call(id' args' id.StartIndex' args.Last.Range.EndIndex)); 						} 						break; 					} 				} 				break; 			default: 				e = Expr(StartStmt); 				break; 			}
Magic Number,Loyc.Syntax.Les,Les3LanguageService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3LanguageService.cs,Parse,The following statement contains a magic number: inputType == ParsingMode.Expressions || file.Text.TryGet(255' ref _)
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,TQString,The following statement contains a magic number: switch (LA0) { 					case '"': 						{ 							la1 = LA(1); 							if (la1 == '"') { 								la2 = LA(2); 								if (la2 == -1 || la2 == '"') 									goto stop; 								else 									Skip(); 							} else if (la1 == -1) 								goto stop; 							else 								Skip(); 						} 						break; 					case -1: 						goto stop; 					case '\n': case '\r': 						Newline(true); 						break; 					default: 						Skip(); 						break; 					}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,TDQStringLine,The following statement contains a magic number: switch (LA0) { 				case '\n': case '\r': 					goto stop; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == -1 || la2 == '"') 								goto stop; 							else 								Skip(); 						} else if (la1 == -1) 							goto stop; 						else 							Skip(); 					} 					break; 				case -1: 					goto stop; 				default: 					Skip(); 					break; 				}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,TSQStringLine,The following statement contains a magic number: switch (LA0) { 				case '\n': case '\r': 					goto stop; 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == -1 || la2 == '\'') 								goto stop; 							else 								Skip(); 						} else if (la1 == -1) 							goto stop; 						else 							Skip(); 					} 					break; 				case -1: 					goto stop; 				default: 					Skip(); 					break; 				}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetSignAndRadix,The following statement contains a magic number: int radix = 10;
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetSignAndRadix,The following statement contains a magic number: s = s.Substring(2);
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetSignAndRadix,The following statement contains a magic number: (radix = x == 'x' ? 16 : x == 'b' ? 2 : 10) != 10
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetSignAndRadix,The following statement contains a magic number: (radix = x == 'x' ? 16 : x == 'b' ? 2 : 10) != 10
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetSignAndRadix,The following statement contains a magic number: (radix = x == 'x' ? 16 : x == 'b' ? 2 : 10) != 10
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetSignAndRadix,The following statement contains a magic number: (radix = x == 'x' ? 16 : x == 'b' ? 2 : 10) != 10
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,ParseAtAtLiteral,The following statement contains a magic number: text = text.Substring(2);
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetOpNameAndType,The following statement contains a magic number: length >= 2 && first == last && (last == '+' || last == '-' || last == '!')
Magic Number,Loyc.Syntax.Les,Les3PrettyPrinter,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3PrettyPrinter.cs,GetDefaultCssClassTable,The following statement contains a magic number: var names = new string[32];
Magic Number,Loyc.Syntax.Les,Les3PrettyPrinter,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3PrettyPrinter.cs,PrintToHtmlCore,The following statement contains a magic number: i += 2;
Magic Number,Loyc.Syntax.Les,Les3PrettyPrinter,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3PrettyPrinter.cs,PrintToHtmlCore,The following statement contains a magic number: c == (char)LesColorCode.Attribute && next == '@' &&  						input.TryGet(i + 2' '\0').IsOneOf((char)LesColorCode.Id' (char)LesColorCode.Number' (char)LesColorCode.KeywordLiteral' (char)LesColorCode.CustomLiteral' (char)LesColorCode.String)
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintIntegerCore,The following statement contains a magic number: PrintHelpers.AppendIntegerTo(SB' value' "0x"' 16' 4' '_');
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintIntegerCore,The following statement contains a magic number: PrintHelpers.AppendIntegerTo(SB' value' "0x"' 16' 4' '_');
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,DoubleToString_HexOrBinary,The following statement contains a magic number: int precision = isFloat ? 23 : MantissaBits;
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,DoubleToString_HexOrBinary,The following statement contains a magic number: separatorInterval = bitsPerDigit == 1 ? 8 : 4;
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,DoubleToString_HexOrBinary,The following statement contains a magic number: separatorInterval = bitsPerDigit == 1 ? 8 : 4;
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,DoubleToString_HexOrBinary,The following statement contains a magic number: PrintHelpers.AppendIntegerTo(result' scientificNotationShift' "p"' @base: 10' separatorInterval: 0);
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,DoubleToString_Decimal,The following statement contains a magic number: iDot > 3
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,DoubleToString_Decimal,The following statement contains a magic number: _o.DigitSeparator.HasValue && asStr.Length > 3
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,VisitCall,The following statement contains a magic number: switch (_o.PrefixNotationOnly ? NodeStyle.PrefixNotation : node.BaseStyle()) 			{ 				case NodeStyle.Operator: 				case NodeStyle.Statement: 				case NodeStyle.Default: 					// Figure out if this node can be treated as an operator and if  					// so' whether it's a suffix operator. 					if (!HasTargetIdWithoutPAttrs(node)) 						goto default;  					Symbol opName = node.Name; 					if (!TryToPrintCallAsSpecialOperator(opName' node)) 					{ 						if (!node.ArgCount().IsInRange(1' 2)) 							goto default; 						var shape = (OperatorShape)node.ArgCount(); 						if (node.ArgCount() == 1 && Les3PrecedenceMap.IsSuffixOperatorName(opName' out opName)) 							shape = OperatorShape.Suffix;  						if (!PrintCallAsNormalOp(shape' opName' node' ref parens)) 							PrintPrefixNotation(node' ref parens); 					} 					break; 				case NodeStyle.Special: 					if (!TryToPrintCallAsKeywordExpression(node)) 						goto default; 					break; 				case NodeStyle.PrefixNotation: 					PrintPrefixNotation(node' ref parens); 					break; 				default: 					PrintPrefixNotation(node' ref parens); 					break; 			}
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,IsContinuator,The following statement contains a magic number: argc == 2
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,IsContinuator,The following statement contains a magic number: (argc == 1 || argc == 2) && ContinuatorOps.Contains(candidate.Name) && HasTargetIdWithoutPAttrs(candidate)
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,CanBePrefixOperator,The following statement contains a magic number: int i = name[1] == '$' ? 2 : 1;
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintCallAsNormalOp,The following statement contains a magic number: switch (shape) { 				case OperatorShape.Prefix: 					Debug.Assert(node.ArgCount() == 1); 					var inner = node[0]; 					PrintOpName(opName' node.Target' isBinaryOp: false); 					Space(prec.Lo < _o.SpaceAfterPrefixStopPrecedence); 					Print(inner' prec.RightContext(_context)); 					break; 				case OperatorShape.Suffix: 					Debug.Assert(node.ArgCount() == 1); 					Print(node[0]' prec.LeftContext(_context)); 					PrintOpName(opName' node.Target' isBinaryOp: false); 					break; 				default: 					Debug.Assert(node.ArgCount() == 2); 					Print(node[0]' prec.LeftContext(_context)); 					Space(prec.Lo < _o.SpaceAroundInfixStopPrecedence); 					bool newlineSafe = PrintOpName(opName' node.Target' isBinaryOp: true); 					if (SB.Last() != '\n') 						Space(prec.Lo < _o.SpaceAroundInfixStopPrecedence); 					var nlContext = NewlineContext.AutoDetect; 					if (newlineSafe) 						nlContext |= NewlineContext.NewlineSafeBefore; 					Print(node[1]' prec.RightContext(_context)' nlContext: nlContext); 					break; 			}
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintContinuator,The following statement contains a magic number: argc >= 2
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,IsKeywordExpression,The following statement contains a magic number: int i = block.Calls(S.Braces) ? 2 : 1;
Magic Number,Loyc.Syntax.Les,Les3PrinterOptions,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,Les3PrinterOptions,The following statement contains a magic number: ForcedLineBreakThreshold = 120;
Magic Number,Loyc.Syntax.Les,Les2LanguageService,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LanguageService.cs,Parse,The following statement contains a magic number: inputType == ParsingMode.Expressions || file.Text.TryGet(255' ref _)
Magic Number,Loyc.Syntax.Les,Les2PrecedenceMap,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\LesPrecedenceMap.cs,GetOpChars,The following statement contains a magic number: var map = new BitArray(128);
Magic Number,Loyc.Syntax.Les,Les2PrecedenceMap,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\LesPrecedenceMap.cs,IsOperator,The following statement contains a magic number: i >= name.Length || name.Length > 255
Magic Number,Loyc.Syntax.Les,Les2PrecedenceMap,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\LesPrecedenceMap.cs,IsSuffixOperatorName,The following statement contains a magic number: bareName = (Symbol)name.Name.Substring(0' name.Name.Length - 3);
Magic Number,Loyc.Syntax.Lexing,BaseILexer<CharSrc;Token>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseILexer.cs,ScanIndent,The following statement contains a magic number: li += 2;
Magic Number,Loyc.Syntax.Lexing,IndentTokenGenerator<Token>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\IndentTokenGenerator.cs,HandleNextToken,The following statement contains a magic number: _outerIndents.Count >= 2 && _outerIndents.Last == _outerIndents[_outerIndents.Count - 2]
Magic Number,Loyc.Syntax.Lexing,IndentTokenGenerator<Token>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\IndentTokenGenerator.cs,HandleNextToken,The following statement contains a magic number: _outerIndents.Count >= 2 && _outerIndents.Last == _outerIndents[_outerIndents.Count - 2]
Magic Number,Loyc.Syntax.Lexing,Token,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\Token.cs,KindAttrTable,The following statement contains a magic number: Debug.Assert(((int)TokenKind.KindMask & ((2 << TokenKindShift) - 1)) == (1 << TokenKindShift));
Magic Number,LeMP,MacroContext,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LeMP\IMacroContext.cs,GetOptions,The following statement contains a magic number: (option.Calls(CodeSymbols.NamedArg' 2) || option.Calls(CodeSymbols.Colon' 2)) && option.Args[0].IsId
Magic Number,LeMP,MacroContext,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LeMP\IMacroContext.cs,GetOptions,The following statement contains a magic number: (option.Calls(CodeSymbols.NamedArg' 2) || option.Calls(CodeSymbols.Colon' 2)) && option.Args[0].IsId
Magic Number,Loyc.Syntax,BaseParser<Token;MatchType>,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\BaseParser.cs,ToString,The following statement contains a magic number: int plural = expected.Take(2).Count();
Magic Number,Loyc.Syntax,CodeSymbols,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\CodeSymbols.cs,CountArrayDimensions,The following statement contains a magic number: return s.Name.Length-2;
Magic Number,Loyc.Syntax,CodeSymbols,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\CodeSymbols.cs,CountArrayDimensions,The following statement contains a magic number: s.Name.Length >= 3 && s.Name.StartsWith("'[") && s.Name[s.Name.Length-1] == ']'
Magic Number,Loyc.Syntax,CodeSymbols,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\CodeSymbols.cs,GetArrayKeyword,The following statement contains a magic number: dims == 2
Magic Number,Loyc.Syntax,CallNode,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\AbstractNodes.cs,GetHashCode,The following statement contains a magic number: int hash = (args.Count << 3) + attrs.Count;
Magic Number,Loyc.Syntax,CallNode,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\AbstractNodes.cs,GetHashCode,The following statement contains a magic number: hash = (hash * 4129) + attrs[i].GetHashCode(recurse - 1' styleMask);
Magic Number,Loyc.Syntax,CallNode,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\AbstractNodes.cs,GetHashCode,The following statement contains a magic number: hash = (hash * 1013) + args[i].GetHashCode(recurse - 1' styleMask);
Magic Number,Loyc.Syntax,DescendantsFrame,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,SubMode,The following statement contains a magic number: var subMode = (_mode & ~(NodeScanMode.YieldLocal | NodeScanMode.YieldSelf)) 						| (NodeScanMode)((int)(_mode & NodeScanMode.YieldDeep) >> 3);
Magic Number,Loyc.Syntax,LNode,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNode.cs,GetHashCode,The following statement contains a magic number: return GetHashCode(3' 0);
Magic Number,Loyc.Syntax,StdSimpleCallNode,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\StdNodes.cs,DetectTargetRange,The following statement contains a magic number: _targetLen = (ushort)System.Math.Max(0' Range.Length - 2);
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,HexDigitValue,The following statement contains a magic number: return c - 'A' + 10;
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,HexDigitValue,The following statement contains a magic number: return c - 'a' + 10;
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,Base36DigitValue,The following statement contains a magic number: return c - 'A' + 10;
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,Base36DigitValue,The following statement contains a magic number: return c - 'a' + 10;
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloatParts,The following statement contains a magic number: success = TryParseInt(ref source' out exponentBase2' 10' flags) && success;
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloatParts,The following statement contains a magic number: success = TryParseInt(ref source' out exponentBase10' 10' flags) && success;
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloatParts,The following statement contains a magic number: radix > 32 || radix != 1 << radixShift
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloatParts,The following statement contains a magic number: radix != 10
Magic Number,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloatParts,The following statement contains a magic number: radix == 10
Magic Number,Loyc.Syntax,Precedence,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\Precedence.cs,GetHashCode,The following statement contains a magic number: return Lo ^ (Hi << 4);
Magic Number,Loyc.Syntax,LineAndCol,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\SourceFiles\SourcePos.cs,GetHashCode,The following statement contains a magic number: return (_line << 4) ^ _posInLine;
Magic Number,Loyc.Syntax,SourceRange,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\SourceFiles\SourceRange.cs,GetHashCode,The following statement contains a magic number: return hc ^ _startIndex ^ (_length << 4);
Magic Number,Loyc.Syntax,StreamCharSource,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\SourceFiles\StreamCharSource.cs,Slice,The following statement contains a magic number: StringBuilder sb = new StringBuilder(Math.Min(length' 1024));
Missing Default,Loyc.Syntax.Les,Les2Lexer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,Number,The following switch statement is missing a default case: switch (LA0) { 			case 'F': case 'f': 				{ 					Skip(); 					// line 72 					_typeSuffix = _F; 					_isFloat = true; 				} 				break; 			case 'D': case 'd': 				{ 					Skip(); 					// line 73 					_typeSuffix = _D; 					_isFloat = true; 				} 				break; 			case 'M': case 'm': 				{ 					Skip(); 					// line 74 					_typeSuffix = _M; 					_isFloat = true; 				} 				break; 			case 'Z': case 'z': 				{ 					Skip(); 					// line 75 					_typeSuffix = _Z; 				} 				break; 			case 'L': case 'l': 				{ 					Skip(); 					// line 77 					_typeSuffix = _L; 					// Line 77: ([Uu])? 					la0 = LA0; 					if (la0 == 'U' || la0 == 'u') { 						Skip(); 						// line 77 						_typeSuffix = _UL; 					} 				} 				break; 			case 'U': case 'u': 				{ 					Skip(); 					// line 78 					_typeSuffix = _U; 					// Line 78: ([Ll])? 					la0 = LA0; 					if (la0 == 'L' || la0 == 'l') { 						Skip(); 						// line 78 						_typeSuffix = _UL; 					} 				} 				break; 			}
Missing Default,Loyc.Syntax.Les,Les2Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2ParserGrammar.out.cs,ToString,The following switch statement is missing a default case: switch ((TokenType)type) { 				case TT.SpaceLParen: return "' ('"; 				case TT.LParen: return "'('"; 				case TT.RParen: return "')'"; 				case TT.LBrack: return "'['"; 				case TT.RBrack: return "']'"; 				case TT.LBrace: return "'{'"; 				case TT.RBrace: return "'}'"; 				case TT.Comma:  return "'''"; 				case TT.Semicolon: return "';'"; 			}
Missing Default,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,ExprList,The following switch statement is missing a default case: switch ((TT) LA0) { 			case TT.Assignment: case TT.At: case TT.BQId: case TT.BQOperator: 			case TT.Id: case TT.Keyword: case TT.LBrace: case TT.LBrack: 			case TT.Literal: case TT.LParen: case TT.NormalOp: case TT.Not: 			case TT.PrefixOp: case TT.PreOrSufOp: case TT.SingleQuoteOp: 				e = TopExpr(); 				break; 			}
Missing Default,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,ExprListLazy,The following switch statement is missing a default case: switch ((TT) LA0) { 			case TT.Assignment: case TT.At: case TT.BQId: case TT.BQOperator: 			case TT.Id: case TT.Keyword: case TT.LBrace: case TT.LBrack: 			case TT.Literal: case TT.LParen: case TT.NormalOp: case TT.Not: 			case TT.PrefixOp: case TT.PreOrSufOp: case TT.SingleQuoteOp: 				e = TopExpr(); 				break; 			}
Missing Default,Loyc.Syntax.Les,Les3Parser,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,ToString,The following switch statement is missing a default case: switch ((TokenType)type) { 				case TokenType.LParen: return "'('"; 				case TokenType.RParen: return "')'"; 				case TokenType.LBrack: return "'['"; 				case TokenType.RBrack: return "']'"; 				case TokenType.LBrace: return "'{'"; 				case TokenType.RBrace: return "'}'"; 				case TokenType.Comma:  return "'''"; 				case TokenType.Semicolon: return "';'"; 			}
Missing Default,Loyc.Syntax.Les,Les3Printer,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintCore,The following switch statement is missing a default case: switch (node.Kind) 			{ 				case LNodeKind.Id: VisitId(node); break; 				case LNodeKind.Literal: VisitLiteral(node); break; 				case LNodeKind.Call: 					VisitCall(node); 					if (_endIndexOfKeywordExpr == SB.Length && avoidKwExprBraceAmbiguity) {  					} 					break; 			}
Missing Default,Loyc.Syntax.Les,TokenExt,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\TokenType.cs,ToString,The following switch statement is missing a default case: switch (t.Kind) 			{ 				case TokenKind.Spaces: return (t.Value ?? " ").ToString(); 				case TokenKind.Comment: 					if (t.Type() == TokenType.SLComment) 						return "// (comment)"; 					else 						return "/* (comment) */"; 				case TokenKind.Id: 					return Les2Printer.PrintId(t.Value as Symbol ?? GSymbol.Empty); 				case TokenKind.Literal: 					return Les2Printer.PrintLiteral(t.Value' t.Style); 			}
Missing Default,Loyc.Syntax.Les,TokenExt,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\TokenType.cs,ToString,The following switch statement is missing a default case: switch (t.Kind) 			{ 				case TokenKind.LParen: return "("; 				case TokenKind.RParen: return ")"; 				case TokenKind.LBrack: return "["; 				case TokenKind.RBrack: return "]"; 				case TokenKind.LBrace: return "{"; 				case TokenKind.RBrace: return "}"; 				case TokenKind.Indent:       return "(Indent)"; 				case TokenKind.Dedent:       return "(Dedent)"; 				case TokenKind.Dot:          return "(Dot)"; 				case TokenKind.Assignment:   return "(Assignment)"; 				case TokenKind.Operator:     return "(Operator)"; 				case TokenKind.Separator:    return "(Separator)"; 				case TokenKind.AttrKeyword:  return "(AttrKeyword)"; 				case TokenKind.TypeKeyword:  return "(TypeKeyword)"; 				case TokenKind.OtherKeyword: return "(OtherKeyword)"; 			}
Missing Default,Loyc.Syntax,ParseHelpers,C:\research\architectureSmells\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following switch statement is missing a default case: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
