Implementation smell,Namespace,Class,File,Method,Description
Long Method,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The method has 112 lines of code.
Complex Method,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,BackingField,Cyclomatic complexity of the method is 9
Complex Method,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,DoDeconstruct,Cyclomatic complexity of the method is 8
Complex Method,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,matchCode,Cyclomatic complexity of the method is 17
Complex Method,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,match,Cyclomatic complexity of the method is 9
Complex Method,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,replace,Cyclomatic complexity of the method is 11
Complex Method,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,SetOrCreateMember,Cyclomatic complexity of the method is 13
Complex Method,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ReduceBooleanExpr,Cyclomatic complexity of the method is 10
Complex Method,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,unroll,Cyclomatic complexity of the method is 10
Complex Method,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,IsExpressionContext,Cyclomatic complexity of the method is 8
Complex Method,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,AltType,Cyclomatic complexity of the method is 8
Complex Method,LeMP,CodeContractRewriter,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\ContractsMacro.out.cs,ProcessEnsuresAttribute,Cyclomatic complexity of the method is 9
Complex Method,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeArgListTests,Cyclomatic complexity of the method is 8
Complex Method,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GenCodeForPattern,Cyclomatic complexity of the method is 14
Complex Method,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUp_GeneralCall2,Cyclomatic complexity of the method is 10
Complex Method,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,TranslateSpaceDefinition,Cyclomatic complexity of the method is 11
Complex Method,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,DefOrConstructor,Cyclomatic complexity of the method is 9
Complex Method,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,var,Cyclomatic complexity of the method is 11
Complex Method,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,try,Cyclomatic complexity of the method is 8
Long Parameter List,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,TryReplaceHere,The method has 5 parameters. Parameters: node' pattern' replacement' captures' allPatterns
Long Parameter List,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,DetectSetOrCreateMember,The method has 6 parameters. Parameters: arg' relevantAttribute' fieldName' paramName' newArg' propOrFieldDecl
Long Parameter List,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,UseSymbolsCore,The method has 5 parameters. Parameters: symbolAttrs' options' body' context' inType
Long Parameter List,LeMP,CodeContractRewriter,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\ContractsMacro.out.cs,ProcessAttribute,The method has 5 parameters. Parameters: attr' mode' exceptionType' variableName' isPropSetter
Long Parameter List,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The method has 8 parameters. Parameters: pattern' varBinding' refExistingVar' cmpExpr' isType' inRange' subPatterns' conditions
Long Parameter List,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,ESEInForLoop,The method has 6 parameters. Parameters: stmt' attrs' init' cond' inc' block
Long Identifier,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,,The length of the parameter sy__numassertMethodForRequires is 30.
Long Identifier,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,,The length of the parameter sy__numassertMethodForEnsuresFinally is 36.
Long Identifier,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,,The length of the parameter sy__numexceptionTypeForEnsuresOnThrow is 37.
Long Identifier,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,,The length of the parameter _useSequenceExpressionsIsRunning is 32.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,AlgebraicDataType,The length of the statement  "				if ((attrs = classDecl.Attrs).IsEmpty | true && (i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1 && classDecl.Calls(CodeSymbols.Class' 3) && (baseName = classDecl.Args[0]) != null && classDecl.Args[1].Calls(CodeSymbols.AltList) && classDecl.Args[2].Calls(CodeSymbols.Braces)) {" is 281.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,GetFnAndClassName,The length of the statement  "					if (name == S.Struct || name == S.Class || name == S.Namespace || name == S.Interface || name == S.Trait || name == S.Alias) {" is 126.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,BackingField,The length of the statement  "				sink.Warning(fieldAttr' "The body of the property does not contain a 'get;' or 'set;' statement without a body' so no code was generated to get or set the backing field.");" is 172.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ContractsOnMethod,The length of the statement  "						body = LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(CodeSymbols.Return' LNode.List(body)))).SetStyle(NodeStyle.Statement);" is 130.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ContractsOnLambda,The length of the statement  "						body = LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(CodeSymbols.Return' LNode.List(body)))).SetStyle(NodeStyle.Statement);" is 130.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ContractsOnProperty,The length of the statement  "					getter = LNode.Call(CodeSymbols.get' LNode.List(LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(CodeSymbols.Return' LNode.List(braces)))).SetStyle(NodeStyle.Statement))).SetStyle(NodeStyle.Special);" is 203.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,GetVarName,The length of the statement  "				if (arg.Calls(CodeSymbols.Var' 2) && (tmp_10 = arg.Args[1]) != null && tmp_10.Calls(CodeSymbols.Assign' 2) && (variableName = tmp_10.Args[0]) != null || arg.Calls(CodeSymbols.Var' 2) && (variableName = arg.Args[1]) != null)" is 223.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,In,The length of the statement  "									return LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(x' LNode.Id((Symbol) "IsInRangeExcludeHi"))).SetStyle(NodeStyle.Operator)' LNode.List(lo' hi));" is 152.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,In,The length of the statement  "									return LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(x' LNode.Id((Symbol) "IsInRange"))).SetStyle(NodeStyle.Operator)' LNode.List(lo' hi));" is 143.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,In,The length of the statement  "					return LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(range' LNode.Id((Symbol) "Contains"))).SetStyle(NodeStyle.Operator)' LNode.List(x));" is 141.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,RangeExcl,The length of the statement  "				if (node.Args.Count == 2 && (lo = node.Args[0]) != null && (hi = node.Args[1]) != null || node.Args.Count == 1 && (hi = node.Args[0]) != null)" is 142.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,RangeIncl,The length of the statement  "				if (node.Args.Count == 2 && (lo = node.Args[0]) != null && (hi = node.Args[1]) != null || node.Args.Count == 1 && (hi = node.Args[0]) != null)" is 142.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,matchCode,The length of the statement  "				//          && (x = tmp9.Args[0]) != null // this will never be null' but we want to put it the assignment in the 'if' statement" is 128.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,matchCode,The length of the statement  "				cmc.NodeVars.OrderBy(v => v.Key.Name).Select(kvp => kvp.Value ? F.Call(S.Assign' F.Id(kvp.Key)' F.Null) : F.Id(kvp.Key)))));" is 124.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,matchCode,The length of the statement  "				LNode type = LNode.Call(CodeSymbols.Of' LNode.List(LNode.Id((Symbol) "VList")' LNode.Id((Symbol) "LNode"))).SetStyle(NodeStyle.Operator);" is 137.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,matchCode,The length of the statement  "				cmc.ListVars.OrderBy(v => v.Key.Name).Select(kvp => kvp.Value ? LNode.Call(CodeSymbols.Assign' LNode.List(F.Id(kvp.Key)' LNode.Call(CodeSymbols.Default' LNode.List(type)))).SetStyle(NodeStyle.Operator) : F.Id(kvp.Key)))));" is 222.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,IsCaseLabel,The length of the statement  "			if (@case.Calls(CodeSymbols.Case) || @case.Calls(CodeSymbols.Label' 1) && @case.Args[0].IsIdNamed((Symbol) "#default")) return true;" is 132.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,on_return,The length of the statement  "					if (varDecl.Calls(CodeSymbols.Var' 2) && (tmp_10 = varDecl.Args[1]) != null && tmp_10.Calls(CodeSymbols.Assign' 2) && (varName = tmp_10.Args[0]) != null)" is 153.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,on_return,The length of the statement  "						context.Sink.Error(varName' "The return value cannot be assigned here. The value of this variable must be placed on the return statement(s).");" is 143.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,on_return,The length of the statement  "					else if (varDecl.Calls(CodeSymbols.Var' 2) && (varName = varDecl.Args[1]) != null) { } else if ((varName = varDecl).IsId)" is 121.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,on_return,The length of the statement  "						return Reject(context' varDecl' "The first parameter to on_return must be a simple identifier (the name of a variable to return) or a variable declaration (for a variable to be returned).");" is 190.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,on_return,The length of the statement  "						return LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(bracedHandler.Args).Add(rnode)).SetStyle(NodeStyle.Statement);" is 122.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,on_return,The length of the statement  "						var retValDecl = varDecl.WithArgChanged(1' LNode.Call(CodeSymbols.Assign' LNode.List(varName' retVal)).SetStyle(NodeStyle.Operator));" is 133.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,on_return,The length of the statement  "						return LNode.Call(CodeSymbols.Braces' LNode.List().Add(retValDecl).AddRange(bracedHandler.Args).Add(rnode)).SetStyle(NodeStyle.Statement);" is 138.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,on_return,The length of the statement  "				context.Sink.Warning(node' "'on_return': no 'return' statements were found in this context' so this macro had no effect.");" is 123.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,replace,The length of the statement  "								context.Write(Severity.Error' pattern' "The braces must contain only a single statement. To search for braces literally' use `{{ ... }}`");" is 139.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,replaceFn,The length of the statement  "			if (EcsValidators.MethodDefinitionKind(node' out replaceKw' out macroName' out args' out body' allowDelegate: false) != S.Fn || body == null)" is 141.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,saveAndRestore,The length of the statement  "					if (tmp_11.Calls(CodeSymbols.Assign' 2) && (property = tmp_11.Args[0]) != null && (newValue = tmp_11.Args[1]) != null || (property = tmp_11) != null) {" is 151.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,saveAndRestore,The length of the statement  "						LNode tryFinally = LNode.Call(CodeSymbols.Try' LNode.List(LNode.Call(CodeSymbols.Braces' LNode.List(body)).SetStyle(NodeStyle.Statement)' LNode.Call(CodeSymbols.Finally' LNode.List(LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(CodeSymbols.Assign' LNode.List(property' varName)).SetStyle(NodeStyle.Operator))).SetStyle(NodeStyle.Statement)))));" is 350.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,saveAndRestore,The length of the statement  "							return LNode.Call(CodeSymbols.Splice' LNode.List(varDecl' LNode.Call(CodeSymbols.Assign' LNode.List(property' newValue)).SetStyle(NodeStyle.Operator)' tryFinally));" is 164.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,SetOrCreateMember,The length of the statement  "				if (DetectSetOrCreateMember(arg' out relevantAttribute' out fieldName' out paramName' out plainArg' out propOrFieldDecl))" is 121.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,SetOrCreateMember,The length of the statement  "						return Reject(sink' arg' Localize.Localized("'{0}': to set or create a field or property' the method must have a body in braces {{}}."' relevantAttribute));" is 156.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,DetectSetOrCreateMember,The length of the statement  "			if (EcsValidators.IsPropertyDefinition(arg' out type' out name' out propArgs' out _' out defaultValue) && propArgs.ArgCount == 0) {" is 131.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,static_matchCode,The length of the statement  "				context.Write(Severity.Error' node' "The `default:` case must be the last one' because the cases are tested in the order they appear' so no case after `default:` can be matched.");" is 180.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,unroll,The length of the statement  "					sink.Error(replacement' "iteration {0}: Expected {1} replacement items' got {2}"' iteration' replacements.Count' count);" is 120.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,UseSymbolsCore,The length of the statement  "				else if (pair.Key.Name.Name == "inherit" && (pair.Value.Calls(S.Braces) || pair.Value.Calls(S.Tuple)) && pair.Value.Args.All(n => n.Value is Symbol))" is 149.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,UsingMulti,The length of the statement  "						return LNode.Call(CodeSymbols.Splice' LNode.List(list.Select(namespc => (LNode) LNode.Call(CodeSymbols.Import' LNode.List(namespc)))));" is 135.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,GetNamespaces,The length of the statement  "				if (multiName.Calls(CodeSymbols.Dot) || multiName.Calls(CodeSymbols.Of)) { } else if (multiName.IsCall && (outerNamespace = multiName.Target) != null) {" is 152.
Long Statement,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,MergeIdentifiers,The length of the statement  "					throw new LogException(Severity.Note' right' "Multi-using statement seems malformed. Correct example: `using System(.Text' .Linq));`");" is 135.
Long Statement,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,ScanClassBody,The length of the statement  "						if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 3) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true || (attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 4) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true && stmt.Args[3].Calls(CodeSymbols.Braces) && (childBody = stmt.Args[3].Args).IsEmpty | true) {" is 573.
Long Statement,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,ScanClassBody,The length of the statement  "								genericAltName = LNode.Call(CodeSymbols.Of' LNode.List().Add(altName).AddRange(_genericArgs.ToVList())).SetStyle(NodeStyle.Operator);" is 133.
Long Statement,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,ScanClassBody,The length of the statement  "						} else if ((attrs = stmt.Attrs).IsEmpty | true && (i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1 && stmt.CallsMin(CodeSymbols.Constructor' 3) && stmt.Args[1].IsIdNamed((Symbol) "#this") && stmt.Args[2].Calls(CodeSymbols.AltList) && (rest = new VList<LNode>(stmt.Args.Slice(3))).IsEmpty | true && rest.Count <= 1) {" is 320.
Long Statement,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,GenerateOutput,The length of the statement  "				var initialization = Parts.Select(p => LNode.Call(CodeSymbols.Assign' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(LNode.Id(CodeSymbols.This)' p.NameId)).SetStyle(NodeStyle.Operator)' p.NameId)).SetStyle(NodeStyle.Operator)).ToList();" is 239.
Long Statement,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,GenerateOutput,The length of the statement  "				LNode constructor = LNode.Call(LNode.List(_constructorAttrs)' CodeSymbols.Constructor' LNode.List(LNode.Missing' _typeNameStem' LNode.Call(CodeSymbols.AltList' LNode.List(args))' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(initialization).AddRange(_extraConstrLogic)).SetStyle(NodeStyle.Statement)));" is 309.
Long Statement,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,GenerateOutput,The length of the statement  "				list.Add(LNode.Call(LNode.List(_classAttrs)' CodeSymbols.Class' LNode.List(TypeName' LNode.Call(CodeSymbols.AltList' LNode.List(BaseTypes))' LNode.Call(CodeSymbols.Braces' LNode.List(outBody)).SetStyle(NodeStyle.Statement))));" is 226.
Long Statement,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,GenerateOutput,The length of the statement  "					list.Add(LNode.Call(LNode.List().AddRange(_classAttrs).Add(LNode.Id(CodeSymbols.Static)).Add(LNode.Id(CodeSymbols.Partial))' CodeSymbols.Class' LNode.List(_typeNameStem' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(LNode.List(LNode.Id(CodeSymbols.Public)' LNode.Id(CodeSymbols.Static))' CodeSymbols.Fn' LNode.List(TypeNameWithoutAttrs' LNode.Call(CodeSymbols.Of' LNode.List().Add(LNode.Id((Symbol) "New")).AddRange(_genericArgs)).SetStyle(NodeStyle.Operator)' LNode.Call(CodeSymbols.AltList' LNode.List(args))' LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(CodeSymbols.Return' LNode.List(LNode.Call(CodeSymbols.New' LNode.List(LNode.Call(TypeNameWithoutAttrs' LNode.List(argNames)))))))).SetStyle(NodeStyle.Statement))))).SetStyle(NodeStyle.Statement))));" is 803.
Long Statement,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,GetWithFn,The length of the statement  "					method = LNode.Call(LNode.List(attrs)' CodeSymbols.Fn' LNode.List(retType' withField' LNode.Call(CodeSymbols.AltList' LNode.List(LNode.Call(LNode.List(part.OriginalDecl.Attrs)' CodeSymbols.Var' LNode.List(type' LNode.Id((Symbol) "newValue")))))));" is 247.
Long Statement,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,GetWithFn,The length of the statement  "					method = LNode.Call(LNode.List(attrs)' CodeSymbols.Fn' LNode.List(retType' withField' LNode.Call(CodeSymbols.AltList' LNode.List(LNode.Call(LNode.List(part.OriginalDecl.Attrs)' CodeSymbols.Var' LNode.List(type' LNode.Id((Symbol) "newValue")))))' LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(CodeSymbols.Return' LNode.List(LNode.Call(CodeSymbols.New' LNode.List(LNode.Call(TypeNameWithoutAttrs' LNode.List(args)))))))).SetStyle(NodeStyle.Statement)));" is 458.
Long Statement,LeMP,AdtParam,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,GetFieldDecl,The length of the statement  "				return LNode.Call(LNode.List(LNode.Id(CodeSymbols.Public))' CodeSymbols.Property' LNode.List(Type' NameId' LNode.Missing' LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Id(CodeSymbols.get)' LNode.Id(LNode.List(LNode.Id(CodeSymbols.Private))' CodeSymbols.set))).SetStyle(NodeStyle.Statement)));" is 294.
Long Statement,LeMP,AdtParam,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,GetItemDecl,The length of the statement  "				return LNode.Call(LNode.List(LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(LNode.Id((Symbol) "System")' LNode.Id((Symbol) "ComponentModel"))).SetStyle(NodeStyle.Operator)' LNode.Id((Symbol) "EditorBrowsable"))).SetStyle(NodeStyle.Operator)' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(LNode.Id((Symbol) "System")' LNode.Id((Symbol) "ComponentModel"))).SetStyle(NodeStyle.Operator)' LNode.Id((Symbol) "EditorBrowsableState"))).SetStyle(NodeStyle.Operator)' LNode.Id((Symbol) "Never"))).SetStyle(NodeStyle.Operator)))' LNode.Id(CodeSymbols.Public))' CodeSymbols.Property' LNode.List(Type' ItemN' LNode.Missing' LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(CodeSymbols.get' LNode.List(LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(CodeSymbols.Return' LNode.List(NameId)))).SetStyle(NodeStyle.Statement))).SetStyle(NodeStyle.Special))).SetStyle(NodeStyle.Statement)));" is 1006.
Long Statement,LeMP,CodeContractRewriter,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\ContractsMacro.out.cs,ProcessAttribute,The length of the statement  "					conditions.Add(LNode.Call(CodeSymbols.Neq' LNode.List(LNode.Id((Symbol) "_")' LNode.Literal(null))).SetStyle(NodeStyle.Operator));" is 130.
Long Statement,LeMP,CodeContractRewriter,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\ContractsMacro.out.cs,ProcessRequiresAttribute,The length of the statement  "						PrependStmts.Add(LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(LNode.Id((Symbol) "Contract")' LNode.Id((Symbol) "Requires"))).SetStyle(NodeStyle.Operator)' LNode.List(condition)));" is 184.
Long Statement,LeMP,CodeContractRewriter,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\ContractsMacro.out.cs,ProcessEnsuresAttribute,The length of the statement  "						contractResult = haveCCRewriter ? LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(LNode.Id((Symbol) "Contract")' LNode.Call(CodeSymbols.Of' LNode.List(LNode.Id((Symbol) "Result")' ReturnType)).SetStyle(NodeStyle.Operator))).SetStyle(NodeStyle.Operator)) : Id_return_value;" is 274.
Long Statement,LeMP,CodeContractRewriter,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\ContractsMacro.out.cs,ProcessEnsuresAttribute,The length of the statement  "							underscoreError = "The macro for `{0}` does not support `_` in this context when MS Code Contracts are enabled' because the return type is unknown.";" is 149.
Long Statement,LeMP,CodeContractRewriter,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\ContractsMacro.out.cs,ProcessEnsuresAttribute,The length of the statement  "							? LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(LNode.Id((Symbol) "Contract")' LNode.Call(CodeSymbols.Of' LNode.List(LNode.Id((Symbol) "EnsuresOnThrow")' exceptionType)).SetStyle(NodeStyle.Operator))).SetStyle(NodeStyle.Operator)' LNode.List(condition)) : LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(LNode.Id((Symbol) "Contract")' LNode.Id((Symbol) "EnsuresOnThrow"))).SetStyle(NodeStyle.Operator)' LNode.List(condition)));" is 433.
Long Statement,LeMP,CodeContractRewriter,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\ContractsMacro.out.cs,ProcessEnsuresAttribute,The length of the statement  "							checks.Add(LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(LNode.Id((Symbol) "Contract")' LNode.Id((Symbol) "Ensures"))).SetStyle(NodeStyle.Operator)' LNode.List(condition)));" is 177.
Long Statement,LeMP,CodeContractRewriter,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\ContractsMacro.out.cs,ProcessEnsuresAttribute,The length of the statement  "							checks.Add(LNode.Call(CodeSymbols.If' LNode.List(LNode.Call(CodeSymbols.Not' LNode.List(condition)).SetStyle(NodeStyle.Operator)' LNode.Call(CodeSymbols.Throw' LNode.List(LNode.Call(CodeSymbols.New' LNode.List(LNode.Call(excType' LNode.List(conditionStr' Id__exception__)))))))));" is 280.
Long Statement,LeMP,CodeContractRewriter,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\ContractsMacro.out.cs,ProcessEnsuresAttribute,The length of the statement  "						LNode excSpec = exceptionType == null ? Id__exception__ : LNode.Call(CodeSymbols.Var' LNode.List(exceptionType' Id__exception__));" is 130.
Long Statement,LeMP,CodeContractRewriter,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\ContractsMacro.out.cs,ProcessEnsuresAttribute,The length of the statement  "						PrependStmts.Add(LNode.Call((Symbol) "on_throw"' LNode.List(excSpec' LNode.Call(CodeSymbols.Braces' LNode.List(checks)).SetStyle(NodeStyle.Statement))).SetStyle(NodeStyle.Special));" is 181.
Long Statement,LeMP,CodeContractRewriter,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\ContractsMacro.out.cs,ProcessEnsuresAttribute,The length of the statement  "						PrependStmts.Add(LNode.Call((Symbol) "on_finally"' LNode.List(LNode.Call(CodeSymbols.Braces' LNode.List(checks)).SetStyle(NodeStyle.Statement))).SetStyle(NodeStyle.Special));" is 174.
Long Statement,LeMP,CodeContractRewriter,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\ContractsMacro.out.cs,ProcessEnsuresAttribute,The length of the statement  "						PrependStmts.Add(LNode.Call((Symbol) "on_return"' LNode.List(Id_return_value' LNode.Call(CodeSymbols.Braces' LNode.List(checks)).SetStyle(NodeStyle.Statement))).SetStyle(NodeStyle.Special));" is 190.
Long Statement,LeMP,CodeContractRewriter,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\ContractsMacro.out.cs,GetAssertMethodForEnsuresFinally,The length of the statement  "				return (Context.ScopedProperties.TryGetValue(sy__numassertMethodForEnsuresFinally' null)as LNode) ?? defaultContractAssert;" is 123.
Long Statement,LeMP,CodeContractRewriter,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\ContractsMacro.out.cs,PrependStmtsToGetterOrSetter,The length of the statement  "							body = LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(CodeSymbols.Return' LNode.List(body)))).SetStyle(NodeStyle.Statement);" is 130.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeTestExpr,The length of the statement  "							Tests.Add(LNode.Call(CodeSymbols.Neq' LNode.List(assignment.PlusAttrs(LNode.List(LNode.InParensTrivia))' LNode.Literal(null))).SetStyle(NodeStyle.Operator));" is 157.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeTestExpr,The length of the statement  "					Tests.Add(LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(candidate' LNode.Id((Symbol) "IsIdNamed"))).SetStyle(NodeStyle.Operator)' LNode.List(LNode.Call(CodeSymbols.Cast' LNode.List(F.Literal(pattern.Name.Name)' LNode.Id((Symbol) "Symbol"))).SetStyle(NodeStyle.Operator))));" is 277.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeTestExpr,The length of the statement  "						Tests.Add(LNode.Call(CodeSymbols.Eq' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(candidate' LNode.Id((Symbol) "Value"))).SetStyle(NodeStyle.Operator)' LNode.Literal(null))).SetStyle(NodeStyle.Operator));" is 209.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeTestExpr,The length of the statement  "						Tests.Add(LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(pattern' LNode.Id((Symbol) "Equals"))).SetStyle(NodeStyle.Operator)' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(candidate' LNode.Id((Symbol) "Value"))).SetStyle(NodeStyle.Operator))));" is 251.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeTestExpr,The length of the statement  "							targetTest = LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(candidate' LNode.Id((Symbol) "Calls"))).SetStyle(NodeStyle.Operator)' LNode.List(quoteTarget));" is 158.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeTestExpr,The length of the statement  "							targetTest = LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(candidate' LNode.Id((Symbol) "CallsMin"))).SetStyle(NodeStyle.Operator)' LNode.List(quoteTarget' F.Literal(fixedArgC)));" is 183.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeTestExpr,The length of the statement  "							targetTest = LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(candidate' LNode.Id((Symbol) "Calls"))).SetStyle(NodeStyle.Operator)' LNode.List(quoteTarget' F.Literal(fixedArgC)));" is 180.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeTestExpr,The length of the statement  "							Tests.Add(LNode.Call(CodeSymbols.Dot' LNode.List(candidate' LNode.Id((Symbol) "IsCall"))).SetStyle(NodeStyle.Operator));" is 120.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeTestExpr,The length of the statement  "								Tests.Add(LNode.Call(CodeSymbols.Eq' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(candidate' LNode.Id((Symbol) "Args"))).SetStyle(NodeStyle.Operator)' LNode.Id((Symbol) "Count"))).SetStyle(NodeStyle.Operator)' LNode.Literal(0))).SetStyle(NodeStyle.Operator));" is 303.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeTestExpr,The length of the statement  "							Tests.Add(LNode.Call(op' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(candidate' LNode.Id((Symbol) "Args"))).SetStyle(NodeStyle.Operator)' LNode.Id((Symbol) "Count"))).SetStyle(NodeStyle.Operator)' F.Literal(fixedArgC))));" is 266.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeTestExpr,The length of the statement  "						MakeTestExpr(pTarget' LNode.Call(CodeSymbols.Dot' LNode.List(candidate' LNode.Id((Symbol) "Target"))).SetStyle(NodeStyle.Operator));" is 132.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MaybePutCandidateInTempVar,The length of the statement  "					Tests.Add(LNode.Call(CodeSymbols.Neq' LNode.List(LNode.Call(LNode.List(LNode.InParensTrivia)' CodeSymbols.Assign' LNode.List(targetTmpId' candidate)).SetStyle(NodeStyle.Operator)' LNode.Literal(null))).SetStyle(NodeStyle.Operator));" is 232.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MatchAttributes,The length of the statement  "				if (pAttrs.Count == 1 && (listVar = GetSubstitutionVar(pAttrs[0]' out condition' out isParams' out refExistingVar)) != null && isParams) {" is 138.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MatchAttributes,The length of the statement  "						Tests.Add(LNode.Call(CodeSymbols.OrBits' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(LNode.Call(LNode.List(LNode.InParensTrivia)' CodeSymbols.Assign' LNode.List(F.Id(listVar)' LNode.Call(CodeSymbols.Dot' LNode.List(candidate' LNode.Id((Symbol) "Attrs"))).SetStyle(NodeStyle.Operator))).SetStyle(NodeStyle.Operator)' LNode.Id((Symbol) "IsEmpty"))).SetStyle(NodeStyle.Operator)' LNode.Literal(true))).SetStyle(NodeStyle.Operator));" is 435.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeArgListTests,The length of the statement  "					MakeTestExpr(patternArgs[i]' LNode.Call(CodeSymbols.IndexBracks' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(candidate' LNode.Id((Symbol) "Args"))).SetStyle(NodeStyle.Operator)' F.Literal(i)))' out varArgSym' out varArgCond);" is 231.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeArgListTests,The length of the statement  "					MakeTestExpr(patternArgs[i2]' LNode.Call(CodeSymbols.IndexBracks' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(candidate' LNode.Id((Symbol) "Args"))).SetStyle(NodeStyle.Operator)' LNode.Call(CodeSymbols.Sub' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(candidate' LNode.Id((Symbol) "Args"))).SetStyle(NodeStyle.Operator)' LNode.Id((Symbol) "Count"))).SetStyle(NodeStyle.Operator)' F.Literal(left))).SetStyle(NodeStyle.Operator)))' out varArgSym2' out varArgCond2);" is 513.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeArgListTests,The length of the statement  "						Context.Sink.Error(patternArgs[i2]' "More than a single $(...varargs) variable is not supported in a single argument list.");" is 125.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeArgListTests,The length of the statement  "						grabVarArgs = LNode.Call(CodeSymbols.Assign' LNode.List(varArgSymId' LNode.Call(CodeSymbols.Dot' LNode.List(candidate' LNode.Id((Symbol) "Args"))).SetStyle(NodeStyle.Operator))).SetStyle(NodeStyle.Operator);" is 207.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeArgListTests,The length of the statement  "						grabVarArgs = LNode.Call(CodeSymbols.Assign' LNode.List(varArgSymId' LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(candidate' LNode.Id((Symbol) "Args"))).SetStyle(NodeStyle.Operator)' LNode.Id((Symbol) "WithoutLast"))).SetStyle(NodeStyle.Operator)' LNode.List(fixedArgsLit)))).SetStyle(NodeStyle.Operator);" is 349.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeArgListTests,The length of the statement  "							grabVarArgs = LNode.Call(CodeSymbols.Assign' LNode.List(varArgSymId' LNode.Call(CodeSymbols.New' LNode.List(LNode.Call(LNode.Call(CodeSymbols.Of' LNode.List(LNode.Id((Symbol) "VList")' LNode.Id((Symbol) "LNode"))).SetStyle(NodeStyle.Operator)' LNode.List(LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(candidate' LNode.Id((Symbol) "Args"))).SetStyle(NodeStyle.Operator)' LNode.Id((Symbol) "Slice"))).SetStyle(NodeStyle.Operator)' LNode.List(varArgStartLit)))))))).SetStyle(NodeStyle.Operator);" is 535.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeArgListTests,The length of the statement  "							grabVarArgs = LNode.Call(CodeSymbols.Assign' LNode.List(varArgSymId' LNode.Call(CodeSymbols.New' LNode.List(LNode.Call(LNode.Call(CodeSymbols.Of' LNode.List(LNode.Id((Symbol) "VList")' LNode.Id((Symbol) "LNode"))).SetStyle(NodeStyle.Operator)' LNode.List(LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(candidate' LNode.Id((Symbol) "Args"))).SetStyle(NodeStyle.Operator)' LNode.Id((Symbol) "Slice"))).SetStyle(NodeStyle.Operator)' LNode.List(varArgStartLit' LNode.Call(CodeSymbols.Sub' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(candidate' LNode.Id((Symbol) "Args"))).SetStyle(NodeStyle.Operator)' LNode.Id((Symbol) "Count"))).SetStyle(NodeStyle.Operator)' fixedArgsLit)).SetStyle(NodeStyle.Operator))))))))).SetStyle(NodeStyle.Operator);" is 825.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,MakeArgListTests,The length of the statement  "						Tests.Add(LNode.Call(CodeSymbols.OrBits' LNode.List(LNode.Call(CodeSymbols.Dot' LNode.List(grabVarArgs.PlusAttrs(LNode.List(LNode.InParensTrivia))' LNode.Id((Symbol) "IsEmpty"))).SetStyle(NodeStyle.Operator)' LNode.Literal(true))).SetStyle(NodeStyle.Operator));" is 261.
Long Statement,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,GetSubstitutionVar,The length of the statement  "							condition = condition == null ? id.Args[1] : LNode.Call(CodeSymbols.And' LNode.List(id.Args[1]' condition)).SetStyle(NodeStyle.Operator);" is 137.
Long Statement,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GenCodeForPattern,The length of the statement  "				GetPatternComponents(pattern' out varBinding' out refExistingVar' out cmpExpr' out isType' out inRange' out subPatterns' out conditions);" is 137.
Long Statement,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GenCodeForPattern,The length of the statement  "							PutStmt(LNode.Call(CodeSymbols.Assign' LNode.List(varBinding' LNode.Call(CodeSymbols.Cast' LNode.List(input' isType)).SetStyle(NodeStyle.Operator))).SetStyle(NodeStyle.Operator));" is 179.
Long Statement,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GenCodeForPattern,The length of the statement  "							PutStmt(LNode.Call(CodeSymbols.Var' LNode.List(isType' LNode.Call(CodeSymbols.Assign' LNode.List(varBinding' LNode.Call(CodeSymbols.Cast' LNode.List(input' isType)).SetStyle(NodeStyle.Operator))))));" is 199.
Long Statement,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GenCodeForPattern,The length of the statement  "							PutStmt(LNode.Call(CodeSymbols.Var' LNode.List(LNode.Missing' LNode.Call(CodeSymbols.Assign' LNode.List(varBinding' input)))));" is 127.
Long Statement,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GenCodeForPattern,The length of the statement  "						PutCond(LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(cmpExpr' LNode.Id((Symbol) "Equals"))).SetStyle(NodeStyle.Operator)' LNode.List(input)));" is 147.
Long Statement,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The length of the statement  "						if (pattern.Calls(CodeSymbols.In' 2) && (patternL = pattern.Args[0]) != null && (inRange = pattern.Args[1]) != null || pattern.Calls((Symbol) "in"' 2) && (patternL = pattern.Args[0]) != null && (inRange = pattern.Args[1]) != null) {" is 232.
Long Statement,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The length of the statement  "						} else if (pattern.Calls(CodeSymbols.Is' 2) && (cmpExprOrBinding = pattern.Args[0]) != null && (isType = pattern.Args[1]) != null || pattern.Calls((Symbol) "is"' 2) && (cmpExprOrBinding = pattern.Args[0]) != null && (isType = pattern.Args[1]) != null) {" is 253.
Long Statement,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The length of the statement  "						} else if (pattern.Calls(CodeSymbols.Is' 1) && (isType = pattern.Args[0]) != null || pattern.Calls((Symbol) "is"' 1) && (isType = pattern.Args[0]) != null) {" is 157.
Long Statement,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The length of the statement  "						} else if (pattern.Calls(CodeSymbols.DotDotDot' 2) || pattern.Calls(CodeSymbols.DotDot' 2) || pattern.Calls(CodeSymbols.DotDotDot' 1) || pattern.Calls(CodeSymbols.DotDot' 1)) {" is 176.
Long Statement,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The length of the statement  "							if (!haveSubPatterns && pattern.IsCall && (!target.IsId || target.AttrNamed(S.TriviaInParens) != null || (!target.HasSpecialName && Les2Printer.IsNormalIdentifier(target.Name)))" is 177.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInLambdaExpr,The length of the statement  "							Context.Sink.Warning(expr' "This lambda must be converted to a braced block' but in LeMP it's not possible to tell whether the return keyword is needed. The output assumes `return` is required.");" is 196.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The length of the statement  "					else if (stmt.CallsMin(CodeSymbols.If' 1) || stmt.Calls(CodeSymbols.UsingStmt' 2) || stmt.Calls(CodeSymbols.Lock' 2) || stmt.Calls(CodeSymbols.Switch' 2) && stmt.Args[1].Calls(CodeSymbols.Braces))" is 196.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The length of the statement  "					else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fixed' 2) && (init = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) {" is 150.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The length of the statement  "							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(init.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.Fixed' LNode.List(init.Args.Last' block)))).SetStyle(NodeStyle.Statement);" is 206.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The length of the statement  "					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.While' 2) && (cond = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) {" is 152.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The length of the statement  "							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList)' LNode.Missing' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(cond.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.If' LNode.List(cond.Args.Last' block' LNode.Call(CodeSymbols.Break))))).SetStyle(NodeStyle.Statement)));" is 356.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The length of the statement  "					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.DoWhile' 2) && (block = stmt.Args[0]) != null && (cond = stmt.Args[1]) != null) {" is 154.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The length of the statement  "							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(LNode.Id(CodeSymbols.Bool)' LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' LNode.Literal(true)))))))' continue_N' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List(bodyStmts)).SetStyle(NodeStyle.Statement)));" is 387.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The length of the statement  "					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.For' 4) && stmt.Args[0].Calls(CodeSymbols.AltList) && (cond = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (block = stmt.Args[3]) != null) {" is 236.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The length of the statement  "					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.ForEach' 3) && (tmp_11 = stmt.Args[0]) != null && tmp_11.Calls(CodeSymbols.Var' 2) && (type = tmp_11.Args[0]) != null && (loopVar = tmp_11.Args[1]) != null && (collection = stmt.Args[1]) != null && (block = stmt.Args[2]) != null) {" is 304.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The length of the statement  "							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(collection.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.ForEach' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(type' loopVar))' collection.Args.Last' block)))).SetStyle(NodeStyle.Statement);" is 276.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The length of the statement  "					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Var' 2) && (type = stmt.Args[0]) != null && (tmp_12 = stmt.Args[1]) != null && tmp_12.Calls(CodeSymbols.Assign' 2) && (name = tmp_12.Args[0]) != null && (initValue = tmp_12.Args[1]) != null) {" is 265.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The length of the statement  "								if (initValue_apos.CallsMin((Symbol) "#runSequence"' 1) && (last = initValue_apos.Args[initValue_apos.Args.Count - 1]) != null) {" is 129.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The length of the statement  "									return LNode.Call((Symbol) "#runSequence"' LNode.List().AddRange(stmts).Add(LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' last))))));" is 199.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The length of the statement  "									return LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' initValue_apos))));" is 138.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,ESEInForLoop,The length of the statement  "						stmt = LNode.Call(CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(init))' LNode.Missing' LNode.Call(CodeSymbols.AltList' LNode.List(inc))' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(preCond).Add(LNode.Call(CodeSymbols.If' LNode.List(cond' block' LNode.Call(CodeSymbols.Break))))).SetStyle(NodeStyle.Statement)));" is 345.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,ESEInForLoop,The length of the statement  "						stmt = LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(init))' cond' LNode.Call(CodeSymbols.AltList' LNode.List(inc))' block));" is 180.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateRunSeqFromInitializer,The length of the statement  "					return LNode.Call(LNode.List(LNode.Id(CodeSymbols.Static))' CodeSymbols.Fn' LNode.List(retType' methodName' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(statements).Add(LNode.Call(CodeSymbols.Return' LNode.List(finalResult)))).SetStyle(NodeStyle.Statement)));" is 300.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUpBlocks,The length of the statement  "							Context.Sink.Warning(expr' "A braced block is not supported directly within an expression. Did you mean to use `#runSequence {...}`?");" is 135.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUpBlocks,The length of the statement  "						} else if ((attrs = expr.Attrs).IsEmpty | true && attrs.NodeNamed(S.Out) != null && expr.Calls(CodeSymbols.Var' 2) && (varType = expr.Args[0]) != null && (varName = expr.Args[1]) != null && varName.IsId) {" is 205.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUpBlocks,The length of the statement  "								Context.Sink.Error(expr' "#useSequenceExpressions: the data type of this variable declaration cannot be inferred and must be stated explicitly.");" is 146.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUpBlocks,The length of the statement  "							result = LNode.Call(LNode.List(_trivia_pure)' (Symbol) "#runSequence"' LNode.List(expr.WithoutAttrNamed(S.Out)' varName.PlusAttrs(LNode.List(LNode.Id(CodeSymbols.Out)))));" is 171.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUpBlocks,The length of the statement  "						} else if ((attrs = expr.Attrs).IsEmpty | true && expr.Calls(CodeSymbols.Var' 2) && (varType = expr.Args[0]) != null && (tmp_14 = expr.Args[1]) != null && tmp_14.Calls(CodeSymbols.Assign' 2) && (varName = tmp_14.Args[0]) != null && (value = tmp_14.Args[1]) != null)" is 265.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUpBlocks,The length of the statement  "						if ((attrs = expr.Attrs).IsEmpty | true && expr.Calls(CodeSymbols.ColonColon' 2) && (value = expr.Args[0]) != null && IsQuickBindLhs(value) && (varName = expr.Args[1]) != null && varName.IsId)" is 192.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUpBlocks,The length of the statement  "						else if ((attrs = expr.Attrs).IsEmpty | true && expr.Calls(CodeSymbols.Lambda' 2) && (args = expr.Args[0]) != null && (code = expr.Args[1]) != null)" is 148.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUp_GeneralCall2,The length of the statement  "					(args.Count == 2 && (target.IsIdNamed(S.And) || target.IsIdNamed(S.Or)) || args.Count == 3 && target.IsIdNamed(S.QuestionMark)))" is 128.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUp_GeneralCall2,The length of the statement  "						"#useSequenceExpressions is not designed to support sequences or variable declarations on the right-hand side of the `&&`' `||` or `?` operators. The generated code will be incorrect.");" is 186.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,MaybeCreateTemporaryForLValue,The length of the statement  "					if (expr.Calls(CodeSymbols.Dot' 2) && (lhs = expr.Args[0]) != null || expr.CallsMin(CodeSymbols.Of' 1) && (lhs = expr.Args[0]) != null)" is 135.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,ConvertVarDeclToRunSequence,The length of the statement  "					if (initValue.CallsMin((Symbol) "#runSequence"' 1) && (resultValue = initValue.Args[initValue.Args.Count - 1]) != null) {" is 121.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,ConvertVarDeclToRunSequence,The length of the statement  "						var newVarDecl = LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(varType' LNode.Call(CodeSymbols.Assign' LNode.List(varName' resultValue))));" is 151.
Long Statement,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,ConvertVarDeclToRunSequence,The length of the statement  "						var newVarDecl = LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(varType' LNode.Call(CodeSymbols.Assign' LNode.List(varName' initValue))));" is 149.
Long Statement,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,TranslateSpaceDefinition,The length of the statement  "					return Reject(context' node' "A type definition must have the form kind(Name' { Body }) or kind(Name(Bases)' { Body }) (where kind is struct/class/enum/trait/alias)");" is 169.
Long Statement,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,TranslateSpaceDefinition,The length of the statement  "					return Reject(context' node' "An 'alias' (or 'using') definition must have the form alias(NewName = OldName' { Body }) or alias(NewName(Interfaces) = OldName' { Body })");" is 171.
Long Statement,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,prop,The length of the statement  "				return Reject(sink' node' "A property definition must have the form prop(Name' { Body })' or prop(Name::type' { Body })");" is 122.
Long Statement,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,var,The length of the statement  "				return Reject(sink' node' "A variable definition must have the form var(Name::Type)' var(Name = value)' or var(Name::Type = value)");" is 133.
Long Statement,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,default1,The length of the statement  "				return F.Call(S.Splice' new VList<LNode>(node.With(S.Label' new VList<LNode>(F.Id(S.Default))).SetBaseStyle(NodeStyle.Default)' node.Args[0]));" is 143.
Complex Conditional,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,AlgebraicDataType,The conditional expression  "(attrs = classDecl.Attrs).IsEmpty | true && (i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1 && classDecl.Calls(CodeSymbols.Class' 3) && (baseName = classDecl.Args[0]) != null && classDecl.Args[1].Calls(CodeSymbols.AltList) && classDecl.Args[2].Calls(CodeSymbols.Braces)"  is complex.
Complex Conditional,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,GetFnAndClassName,The conditional expression  "name == S.Fn || name == S.Property || name == S.Constructor || name == S.Event"  is complex.
Complex Conditional,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,GetFnAndClassName,The conditional expression  "name == S.Struct || name == S.Class || name == S.Namespace || name == S.Interface || name == S.Trait || name == S.Alias"  is complex.
Complex Conditional,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,GetVarName,The conditional expression  "arg.Calls(CodeSymbols.Var' 2) && (tmp_10 = arg.Args[1]) != null && tmp_10.Calls(CodeSymbols.Assign' 2) && (variableName = tmp_10.Args[0]) != null || arg.Calls(CodeSymbols.Var' 2) && (variableName = arg.Args[1]) != null"  is complex.
Complex Conditional,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,GetContractAttrMode,The conditional expression  "mode == sy_ensuresOnThrow || mode == sy_requires || mode == sy_notnull || mode == sy_assert ||  			mode == sy_ensures || mode == sy_ensuresAssert || mode == sy_ensuresFinally"  is complex.
Complex Conditional,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,RangeExcl,The conditional expression  "node.Args.Count == 2 && (lo = node.Args[0]) != null && (hi = node.Args[1]) != null || node.Args.Count == 1 && (hi = node.Args[0]) != null"  is complex.
Complex Conditional,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,RangeIncl,The conditional expression  "node.Args.Count == 2 && (lo = node.Args[0]) != null && (hi = node.Args[1]) != null || node.Args.Count == 1 && (hi = node.Args[0]) != null"  is complex.
Complex Conditional,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,on_return,The conditional expression  "varDecl.Calls(CodeSymbols.Var' 2) && (tmp_10 = varDecl.Args[1]) != null && tmp_10.Calls(CodeSymbols.Assign' 2) && (varName = tmp_10.Args[0]) != null"  is complex.
Complex Conditional,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,saveAndRestore,The conditional expression  "tmp_11.Calls(CodeSymbols.Assign' 2) && (property = tmp_11.Args[0]) != null && (newValue = tmp_11.Args[1]) != null || (property = tmp_11) != null"  is complex.
Complex Conditional,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,unroll,The conditional expression  "(var.Calls(S.Tuple) || var.Calls(S.Braces)) && vars.All(a => a.IsId && !a.HasPAttrs())"  is complex.
Complex Conditional,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,UseSymbolsCore,The conditional expression  "pair.Key.Name.Name == "inherit" && (pair.Value.Calls(S.Braces) || pair.Value.Calls(S.Tuple)) && pair.Value.Args.All(n => n.Value is Symbol)"  is complex.
Complex Conditional,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,UseSymbolsCore,The conditional expression  "kind == S.Class || kind == S.Struct || kind == S.Interface || kind == S.Alias || kind == S.Trait"  is complex.
Complex Conditional,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,AltType,The conditional expression  "TypeName.CallsMin(CodeSymbols.Of' 1) && (stem = TypeName.Args[0]) != null && (a = new VList<LNode>(TypeName.Args.Slice(1))).IsEmpty | true || (stem = TypeName) != null"  is complex.
Complex Conditional,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,ScanClassBody,The conditional expression  "(attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 3) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true || (attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 4) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true && stmt.Args[3].Calls(CodeSymbols.Braces) && (childBody = stmt.Args[3].Args).IsEmpty | true"  is complex.
Complex Conditional,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,ScanClassBody,The conditional expression  "(attrs = stmt.Attrs).IsEmpty | true && (i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1 && stmt.CallsMin(CodeSymbols.Constructor' 3) && stmt.Args[1].IsIdNamed((Symbol) "#this") && stmt.Args[2].Calls(CodeSymbols.AltList) && (rest = new VList<LNode>(stmt.Args.Slice(3))).IsEmpty | true && rest.Count <= 1"  is complex.
Complex Conditional,LeMP,CodeQuoter,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\CodeQuoteMacro.cs,QuoteOne,The conditional expression  "!_ignoreTrivia && node.ArgCount == 1 && node.TriviaValue != NoValue.Value && node.Target.IsId"  is complex.
Complex Conditional,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The conditional expression  "pattern.Calls(CodeSymbols.In' 2) && (patternL = pattern.Args[0]) != null && (inRange = pattern.Args[1]) != null || pattern.Calls((Symbol) "in"' 2) && (patternL = pattern.Args[0]) != null && (inRange = pattern.Args[1]) != null"  is complex.
Complex Conditional,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The conditional expression  "pattern.Calls(CodeSymbols.Is' 2) && (cmpExprOrBinding = pattern.Args[0]) != null && (isType = pattern.Args[1]) != null || pattern.Calls((Symbol) "is"' 2) && (cmpExprOrBinding = pattern.Args[0]) != null && (isType = pattern.Args[1]) != null"  is complex.
Complex Conditional,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The conditional expression  "pattern.Calls(CodeSymbols.Is' 1) && (isType = pattern.Args[0]) != null || pattern.Calls((Symbol) "is"' 1) && (isType = pattern.Args[0]) != null"  is complex.
Complex Conditional,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The conditional expression  "pattern.Calls(CodeSymbols.DotDotDot' 2) || pattern.Calls(CodeSymbols.DotDot' 2) || pattern.Calls(CodeSymbols.DotDotDot' 1) || pattern.Calls(CodeSymbols.DotDot' 1)"  is complex.
Complex Conditional,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The conditional expression  "!haveSubPatterns && pattern.IsCall && (!target.IsId || target.AttrNamed(S.TriviaInParens) != null || (!target.HasSpecialName && Les2Printer.IsNormalIdentifier(target.Name)))"  is complex.
Complex Conditional,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The conditional expression  "stmt.CallsMin(CodeSymbols.If' 1) || stmt.Calls(CodeSymbols.UsingStmt' 2) || stmt.Calls(CodeSymbols.Lock' 2) || stmt.Calls(CodeSymbols.Switch' 2) && stmt.Args[1].Calls(CodeSymbols.Braces)"  is complex.
Complex Conditional,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The conditional expression  "(attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fixed' 2) && (init = stmt.Args[0]) != null && (block = stmt.Args[1]) != null"  is complex.
Complex Conditional,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The conditional expression  "(attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.While' 2) && (cond = stmt.Args[0]) != null && (block = stmt.Args[1]) != null"  is complex.
Complex Conditional,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The conditional expression  "(attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.DoWhile' 2) && (block = stmt.Args[0]) != null && (cond = stmt.Args[1]) != null"  is complex.
Complex Conditional,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The conditional expression  "(attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.For' 4) && stmt.Args[0].Calls(CodeSymbols.AltList) && (cond = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (block = stmt.Args[3]) != null"  is complex.
Complex Conditional,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The conditional expression  "(attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.ForEach' 3) && (tmp_11 = stmt.Args[0]) != null && tmp_11.Calls(CodeSymbols.Var' 2) && (type = tmp_11.Args[0]) != null && (loopVar = tmp_11.Args[1]) != null && (collection = stmt.Args[1]) != null && (block = stmt.Args[2]) != null"  is complex.
Complex Conditional,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The conditional expression  "(attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Var' 2) && (type = stmt.Args[0]) != null && (tmp_12 = stmt.Args[1]) != null && tmp_12.Calls(CodeSymbols.Assign' 2) && (name = tmp_12.Args[0]) != null && (initValue = tmp_12.Args[1]) != null"  is complex.
Complex Conditional,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUpBlocks,The conditional expression  "(attrs = expr.Attrs).IsEmpty | true && attrs.NodeNamed(S.Out) != null && expr.Calls(CodeSymbols.Var' 2) && (varType = expr.Args[0]) != null && (varName = expr.Args[1]) != null && varName.IsId"  is complex.
Complex Conditional,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUpBlocks,The conditional expression  "(attrs = expr.Attrs).IsEmpty | true && expr.Calls(CodeSymbols.Var' 2) && (varType = expr.Args[0]) != null && (tmp_14 = expr.Args[1]) != null && tmp_14.Calls(CodeSymbols.Assign' 2) && (varName = tmp_14.Args[0]) != null && (value = tmp_14.Args[1]) != null"  is complex.
Complex Conditional,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUpBlocks,The conditional expression  "(attrs = expr.Attrs).IsEmpty | true && expr.Calls(CodeSymbols.ColonColon' 2) && (value = expr.Args[0]) != null && IsQuickBindLhs(value) && (varName = expr.Args[1]) != null && varName.IsId"  is complex.
Complex Conditional,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUpBlocks,The conditional expression  "(attrs = expr.Attrs).IsEmpty | true && expr.Calls(CodeSymbols.Lambda' 2) && (args = expr.Args[0]) != null && (code = expr.Args[1]) != null"  is complex.
Complex Conditional,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUp_GeneralCall2,The conditional expression  "lastRunSeq > 0 &&  					(args.Count == 2 && (target.IsIdNamed(S.And) || target.IsIdNamed(S.Or)) || args.Count == 3 && target.IsIdNamed(S.QuestionMark))"  is complex.
Complex Conditional,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,MaybeCreateTemporaryForLValue,The conditional expression  "expr.Calls(CodeSymbols.Dot' 2) && (lhs = expr.Args[0]) != null || expr.CallsMin(CodeSymbols.Of' 1) && (lhs = expr.Args[0]) != null"  is complex.
Complex Conditional,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,DefOrConstructor,The conditional expression  "!parts.Count.IsInRange(1' 2) || !sig.IsCall || (body != null && !body.Calls(S.Braces))"  is complex.
Complex Conditional,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,new,The conditional expression  "consExpr == null || node.ArgCount > 2 || (csharpInitializer != null && !csharpInitializer.Calls(S.Braces))"  is complex.
Virtual Method Call from Constructor,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,AltType,The constructor "AltType" calls a virtual method "CallsMin".
Virtual Method Call from Constructor,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,AltType,The constructor "AltType" calls a virtual method "IsIdNamed".
Virtual Method Call from Constructor,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,AltType,The constructor "AltType" calls a virtual method "WithAttrs".
Virtual Method Call from Constructor,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,AltType,The constructor "AltType" calls a virtual method "Calls".
Virtual Method Call from Constructor,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,AltType,The constructor "AltType" calls a virtual method "Select".
Virtual Method Call from Constructor,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,AltType,The constructor "AltType" calls a virtual method "WithoutAttrs".
Virtual Method Call from Constructor,LeMP,AdtParam,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,AdtParam,The constructor "AdtParam" calls a virtual method "Calls".
Virtual Method Call from Constructor,LeMP,AdtParam,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,AdtParam,The constructor "AdtParam" calls a virtual method "Calls".
Virtual Method Call from Constructor,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,CodeGeneratorForMatchCase,The constructor "CodeGeneratorForMatchCase" calls a virtual method "Call".
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,AlgebraicDataType,The following statement contains a magic number: { 				LNode baseName; 				VList<LNode> attrs' baseTypes' body; 				if ((attrs = classDecl.Attrs).IsEmpty | true && (i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1 && classDecl.Calls(CodeSymbols.Class' 3) && (baseName = classDecl.Args[0]) != null && classDecl.Args[1].Calls(CodeSymbols.AltList) && classDecl.Args[2].Calls(CodeSymbols.Braces)) { 					baseTypes = classDecl.Args[1].Args; 					body = classDecl.Args[2].Args; 					attrs = attrs.RemoveAt(i); 					var adt = new AltType(attrs' baseName' baseTypes' null); 					adt.ScanClassBody(body); 					var output = new VList<LNode>(); 					adt.GenerateOutput(ref output); 					return LNode.Call(CodeSymbols.Splice' LNode.List(output)); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,AlgebraicDataType,The following statement contains a magic number: { 				LNode baseName; 				VList<LNode> attrs' baseTypes' body; 				if ((attrs = classDecl.Attrs).IsEmpty | true && (i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1 && classDecl.Calls(CodeSymbols.Class' 3) && (baseName = classDecl.Args[0]) != null && classDecl.Args[1].Calls(CodeSymbols.AltList) && classDecl.Args[2].Calls(CodeSymbols.Braces)) { 					baseTypes = classDecl.Args[1].Args; 					body = classDecl.Args[2].Args; 					attrs = attrs.RemoveAt(i); 					var adt = new AltType(attrs' baseName' baseTypes' null); 					adt.ScanClassBody(body); 					var output = new VList<LNode>(); 					adt.GenerateOutput(ref output); 					return LNode.Call(CodeSymbols.Splice' LNode.List(output)); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,AlgebraicDataType,The following statement contains a magic number: { 				LNode baseName; 				VList<LNode> attrs' baseTypes' body; 				if ((attrs = classDecl.Attrs).IsEmpty | true && (i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1 && classDecl.Calls(CodeSymbols.Class' 3) && (baseName = classDecl.Args[0]) != null && classDecl.Args[1].Calls(CodeSymbols.AltList) && classDecl.Args[2].Calls(CodeSymbols.Braces)) { 					baseTypes = classDecl.Args[1].Args; 					body = classDecl.Args[2].Args; 					attrs = attrs.RemoveAt(i); 					var adt = new AltType(attrs' baseName' baseTypes' null); 					adt.ScanClassBody(body); 					var output = new VList<LNode>(); 					adt.GenerateOutput(ref output); 					return LNode.Call(CodeSymbols.Splice' LNode.List(output)); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,GetFnAndClassName,The following statement contains a magic number: for (int i = anc.Count - 1; i >= 0; i--) { 				var name = anc[i].Name; 				if (anc[i].ArgCount >= 2) { 					if (fn == null) { 						if (name == S.Fn || name == S.Property || name == S.Constructor || name == S.Event) 							fn = anc[i][1]; 					} 					if (name == S.Struct || name == S.Class || name == S.Namespace || name == S.Interface || name == S.Trait || name == S.Alias) { 						@class = anc[i][0]; 						return name; 					} 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,GetFnAndClassNameString,The following statement contains a magic number: if (fn == null) 				return @class == null ? null : ps.Print(@class' MessageSink.Null' ParsingMode.Expressions); 			else if (@class == null) 				return ps.Print(fn' MessageSink.Null' ParsingMode.Expressions); 			else { 				while (fn.CallsMin(S.Dot' 2)) 					fn = fn.Args.Last; 				return string.Format("{0}.{1}"' ps.Print(@class' MessageSink.Null' ParsingMode.Expressions)'  				ps.Print(fn' MessageSink.Null' ParsingMode.Expressions)); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,BackingField,The following statement contains a magic number: if (prop.ArgCount != 4 || !(body = prop.Args[3]).Calls(S.Braces)) 				return null;
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,BackingField,The following statement contains a magic number: if (prop.ArgCount != 4 || !(body = prop.Args[3]).Calls(S.Braces)) 				return null;
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,BackingField,The following statement contains a magic number: for (i = 0; i < prop.Attrs.Count; i++) { 				LNode attr = prop.Attrs[i]; 				if (attr.IsIdNamed(_field)) { 					fieldAttr = attr; 					break; 				} else if (attr.Calls(S.Var' 2)) { 					LNode fieldVarAttr = null; 					attr = attr.WithoutAttrNamed(__field' out fieldVarAttr); 					if (fieldVarAttr != null && fieldVarAttr.IsId || (autoType = attr.Args[0].IsIdNamed(_field))) { 						fieldAttr = attr; 						break; 					} 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,BackingField,The following statement contains a magic number: propArgs = prop.Args[2];
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,BackingField,The following statement contains a magic number: if (field.IsId) { 				fieldName = F.Id(ChooseFieldName(Loyc.Ecs.EcsNodePrinter.KeyNameComponentOf(propName))); 				field = F.Call(S.Var' propType' fieldName).WithAttrs(fieldAttr.Attrs); 			} else { 				fieldName = field.Args[1]; 				if (fieldName.Calls(S.Assign' 2)) 					fieldName = fieldName.Args[0]; 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,BackingField,The following statement contains a magic number: prop = prop.WithAttrs(prop.Attrs.RemoveAt(i)).WithArgChanged(3' newBody);
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ContractsOnMethod,The following statement contains a magic number: if (fn.ArgCount >= 4) { 				var rw = new CodeContractRewriter(fn.Args[0]' fn.Args[1]' context); 			 				// If this thing has an argument list' scan it 				fn = ProcessArgContractAttributes(fn' 2' rw); 			 				// Scan attributes on return type' then attributes on the whole method 				if (fn.Args[0].HasAttrs) 					fn = fn.WithArgChanged(0' fn.Args[0].WithAttrs(rw.Process(fn.Args[0].Attrs' null))); 				if (fn.HasAttrs) 					fn = fn.WithAttrs(rw.Process(fn.Attrs' null)); 			 				if (rw.PrependStmts.IsEmpty) { 					return null;	// this is the common case 				} else { 					var body = fn.Args[3]; 					if (!body.Calls(S.Braces)	// Add braces in case of void LambdaMethod() => expr; 					) 						body = LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(CodeSymbols.Return' LNode.List(body)))).SetStyle(NodeStyle.Statement); 					body = body.WithArgs(body.Args.InsertRange(0' rw.PrependStmts)); 					fn = fn.WithArgChanged(3' body); 					return fn; 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ContractsOnMethod,The following statement contains a magic number: if (fn.ArgCount >= 4) { 				var rw = new CodeContractRewriter(fn.Args[0]' fn.Args[1]' context); 			 				// If this thing has an argument list' scan it 				fn = ProcessArgContractAttributes(fn' 2' rw); 			 				// Scan attributes on return type' then attributes on the whole method 				if (fn.Args[0].HasAttrs) 					fn = fn.WithArgChanged(0' fn.Args[0].WithAttrs(rw.Process(fn.Args[0].Attrs' null))); 				if (fn.HasAttrs) 					fn = fn.WithAttrs(rw.Process(fn.Attrs' null)); 			 				if (rw.PrependStmts.IsEmpty) { 					return null;	// this is the common case 				} else { 					var body = fn.Args[3]; 					if (!body.Calls(S.Braces)	// Add braces in case of void LambdaMethod() => expr; 					) 						body = LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(CodeSymbols.Return' LNode.List(body)))).SetStyle(NodeStyle.Statement); 					body = body.WithArgs(body.Args.InsertRange(0' rw.PrependStmts)); 					fn = fn.WithArgChanged(3' body); 					return fn; 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ContractsOnMethod,The following statement contains a magic number: if (fn.ArgCount >= 4) { 				var rw = new CodeContractRewriter(fn.Args[0]' fn.Args[1]' context); 			 				// If this thing has an argument list' scan it 				fn = ProcessArgContractAttributes(fn' 2' rw); 			 				// Scan attributes on return type' then attributes on the whole method 				if (fn.Args[0].HasAttrs) 					fn = fn.WithArgChanged(0' fn.Args[0].WithAttrs(rw.Process(fn.Args[0].Attrs' null))); 				if (fn.HasAttrs) 					fn = fn.WithAttrs(rw.Process(fn.Attrs' null)); 			 				if (rw.PrependStmts.IsEmpty) { 					return null;	// this is the common case 				} else { 					var body = fn.Args[3]; 					if (!body.Calls(S.Braces)	// Add braces in case of void LambdaMethod() => expr; 					) 						body = LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(CodeSymbols.Return' LNode.List(body)))).SetStyle(NodeStyle.Statement); 					body = body.WithArgs(body.Args.InsertRange(0' rw.PrependStmts)); 					fn = fn.WithArgChanged(3' body); 					return fn; 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ContractsOnMethod,The following statement contains a magic number: if (fn.ArgCount >= 4) { 				var rw = new CodeContractRewriter(fn.Args[0]' fn.Args[1]' context); 			 				// If this thing has an argument list' scan it 				fn = ProcessArgContractAttributes(fn' 2' rw); 			 				// Scan attributes on return type' then attributes on the whole method 				if (fn.Args[0].HasAttrs) 					fn = fn.WithArgChanged(0' fn.Args[0].WithAttrs(rw.Process(fn.Args[0].Attrs' null))); 				if (fn.HasAttrs) 					fn = fn.WithAttrs(rw.Process(fn.Attrs' null)); 			 				if (rw.PrependStmts.IsEmpty) { 					return null;	// this is the common case 				} else { 					var body = fn.Args[3]; 					if (!body.Calls(S.Braces)	// Add braces in case of void LambdaMethod() => expr; 					) 						body = LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(CodeSymbols.Return' LNode.List(body)))).SetStyle(NodeStyle.Statement); 					body = body.WithArgs(body.Args.InsertRange(0' rw.PrependStmts)); 					fn = fn.WithArgChanged(3' body); 					return fn; 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ContractsOnLambda,The following statement contains a magic number: if (fn.ArgCount == 2) { 				var rw = new CodeContractRewriter(LNode.Missing' Id_lambda_function' context); 			 				// If this thing has an argument list' scan it 				fn = ProcessArgContractAttributes(fn' 0' rw' isLambda: true); 			 				// Scan attributes on the lambda as a whole 				if (fn.HasAttrs) 					fn = fn.WithAttrs(rw.Process(fn.Attrs' null)); 			 				if (rw.PrependStmts.IsEmpty) { 					return null;	// this is the common case 				} else { 					var body = fn.Args[1]; 					if (!body.Calls(S.Braces)	// Add braces in case of void LambdaMethod() => expr; 					) 						body = LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(CodeSymbols.Return' LNode.List(body)))).SetStyle(NodeStyle.Statement); 					body = body.WithArgs(body.Args.InsertRange(0' rw.PrependStmts)); 					fn = fn.WithArgChanged(1' body); 					return fn; 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ContractsOnProperty,The following statement contains a magic number: if (prop.ArgCount == 4) { 				LNode braces = prop[3]; 				var oldBraces = braces; 				var rw = new CodeContractRewriter(prop.Args[0]' prop.Args[1]' context); 			 				// If this has an argument list (this[...])' process its contract attributes 				prop = ProcessArgContractAttributes(prop' 2' rw); 			 				// Remove contract attributes from the property and store in a list 				VList<LNode> cAttrs = LNode.List(); 				prop = prop.WithArgChanged(0' GrabContractAttrs(prop.Args[0]' ref cAttrs' ContractAppliesTo.Getter)); 				prop = GrabContractAttrs(prop' ref cAttrs); 			 				// Find the getter and setter 				LNode getter = null' setter = null; 				int getterIndex = -1' setterIndex = -1; 				VList<LNode> getterAttrs = LNode.List()' setterAttrs = LNode.List(); 				bool isLambdaProperty = !braces.Calls(S.Braces); 				if (isLambdaProperty) { 					if (cAttrs.Count == 0) 						return null;	// lambda property has no contract attributes 					// Transform into a normal property 					getterAttrs = cAttrs; 					getter = LNode.Call(CodeSymbols.get' LNode.List(LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(CodeSymbols.Return' LNode.List(braces)))).SetStyle(NodeStyle.Statement))).SetStyle(NodeStyle.Special); 					braces = LNode.Call(CodeSymbols.Braces' LNode.List(getter)).SetStyle(NodeStyle.Statement); 					getterIndex = 0; 				} else { 					for (int i = 0; i < braces.Args.Count; i++) { 						var part = braces.Args[i]; 						if (part.Calls(S.get)) { getter = part; getterIndex = i; } 						if (part.Calls(S.set)) { setter = part; setterIndex = i; } 					} 				 					// Now create separate lists of contract attributes for the getter and the setter 					if (cAttrs.Count != 0) { 						getterAttrs = cAttrs.SmartWhere(a => (PropertyContractInterpretation(a) & ContractAppliesTo.Getter) != 0); 						setterAttrs = cAttrs.SmartWhere(a => (PropertyContractInterpretation(a) & ContractAppliesTo.Setter) != 0); 					} 				} 			 				// Process the discovered attributes to produce prepended statements 				var sharedPrependStmts = rw.PrependStmts; 				if (getter != null) { 					getter = GrabContractAttrs(getter' ref getterAttrs); 					rw.Process(getterAttrs' null); 					rw.PrependStmtsToGetterOrSetter(ref braces' getterIndex' getter); 				} 				if (setter != null) { 					rw.PrependStmts = sharedPrependStmts; 					setter = GrabContractAttrs(setter' ref setterAttrs); 					rw.Process(setterAttrs' LNode.Id(CodeSymbols.value)' true); 					rw.PrependStmtsToGetterOrSetter(ref braces' setterIndex' setter); 				} 			 				// Update the property 				if (braces == oldBraces) 					return null;	// this is the common case 				else 					return prop.WithArgChanged(3' braces); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ContractsOnProperty,The following statement contains a magic number: if (prop.ArgCount == 4) { 				LNode braces = prop[3]; 				var oldBraces = braces; 				var rw = new CodeContractRewriter(prop.Args[0]' prop.Args[1]' context); 			 				// If this has an argument list (this[...])' process its contract attributes 				prop = ProcessArgContractAttributes(prop' 2' rw); 			 				// Remove contract attributes from the property and store in a list 				VList<LNode> cAttrs = LNode.List(); 				prop = prop.WithArgChanged(0' GrabContractAttrs(prop.Args[0]' ref cAttrs' ContractAppliesTo.Getter)); 				prop = GrabContractAttrs(prop' ref cAttrs); 			 				// Find the getter and setter 				LNode getter = null' setter = null; 				int getterIndex = -1' setterIndex = -1; 				VList<LNode> getterAttrs = LNode.List()' setterAttrs = LNode.List(); 				bool isLambdaProperty = !braces.Calls(S.Braces); 				if (isLambdaProperty) { 					if (cAttrs.Count == 0) 						return null;	// lambda property has no contract attributes 					// Transform into a normal property 					getterAttrs = cAttrs; 					getter = LNode.Call(CodeSymbols.get' LNode.List(LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(CodeSymbols.Return' LNode.List(braces)))).SetStyle(NodeStyle.Statement))).SetStyle(NodeStyle.Special); 					braces = LNode.Call(CodeSymbols.Braces' LNode.List(getter)).SetStyle(NodeStyle.Statement); 					getterIndex = 0; 				} else { 					for (int i = 0; i < braces.Args.Count; i++) { 						var part = braces.Args[i]; 						if (part.Calls(S.get)) { getter = part; getterIndex = i; } 						if (part.Calls(S.set)) { setter = part; setterIndex = i; } 					} 				 					// Now create separate lists of contract attributes for the getter and the setter 					if (cAttrs.Count != 0) { 						getterAttrs = cAttrs.SmartWhere(a => (PropertyContractInterpretation(a) & ContractAppliesTo.Getter) != 0); 						setterAttrs = cAttrs.SmartWhere(a => (PropertyContractInterpretation(a) & ContractAppliesTo.Setter) != 0); 					} 				} 			 				// Process the discovered attributes to produce prepended statements 				var sharedPrependStmts = rw.PrependStmts; 				if (getter != null) { 					getter = GrabContractAttrs(getter' ref getterAttrs); 					rw.Process(getterAttrs' null); 					rw.PrependStmtsToGetterOrSetter(ref braces' getterIndex' getter); 				} 				if (setter != null) { 					rw.PrependStmts = sharedPrependStmts; 					setter = GrabContractAttrs(setter' ref setterAttrs); 					rw.Process(setterAttrs' LNode.Id(CodeSymbols.value)' true); 					rw.PrependStmtsToGetterOrSetter(ref braces' setterIndex' setter); 				} 			 				// Update the property 				if (braces == oldBraces) 					return null;	// this is the common case 				else 					return prop.WithArgChanged(3' braces); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ContractsOnProperty,The following statement contains a magic number: if (prop.ArgCount == 4) { 				LNode braces = prop[3]; 				var oldBraces = braces; 				var rw = new CodeContractRewriter(prop.Args[0]' prop.Args[1]' context); 			 				// If this has an argument list (this[...])' process its contract attributes 				prop = ProcessArgContractAttributes(prop' 2' rw); 			 				// Remove contract attributes from the property and store in a list 				VList<LNode> cAttrs = LNode.List(); 				prop = prop.WithArgChanged(0' GrabContractAttrs(prop.Args[0]' ref cAttrs' ContractAppliesTo.Getter)); 				prop = GrabContractAttrs(prop' ref cAttrs); 			 				// Find the getter and setter 				LNode getter = null' setter = null; 				int getterIndex = -1' setterIndex = -1; 				VList<LNode> getterAttrs = LNode.List()' setterAttrs = LNode.List(); 				bool isLambdaProperty = !braces.Calls(S.Braces); 				if (isLambdaProperty) { 					if (cAttrs.Count == 0) 						return null;	// lambda property has no contract attributes 					// Transform into a normal property 					getterAttrs = cAttrs; 					getter = LNode.Call(CodeSymbols.get' LNode.List(LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(CodeSymbols.Return' LNode.List(braces)))).SetStyle(NodeStyle.Statement))).SetStyle(NodeStyle.Special); 					braces = LNode.Call(CodeSymbols.Braces' LNode.List(getter)).SetStyle(NodeStyle.Statement); 					getterIndex = 0; 				} else { 					for (int i = 0; i < braces.Args.Count; i++) { 						var part = braces.Args[i]; 						if (part.Calls(S.get)) { getter = part; getterIndex = i; } 						if (part.Calls(S.set)) { setter = part; setterIndex = i; } 					} 				 					// Now create separate lists of contract attributes for the getter and the setter 					if (cAttrs.Count != 0) { 						getterAttrs = cAttrs.SmartWhere(a => (PropertyContractInterpretation(a) & ContractAppliesTo.Getter) != 0); 						setterAttrs = cAttrs.SmartWhere(a => (PropertyContractInterpretation(a) & ContractAppliesTo.Setter) != 0); 					} 				} 			 				// Process the discovered attributes to produce prepended statements 				var sharedPrependStmts = rw.PrependStmts; 				if (getter != null) { 					getter = GrabContractAttrs(getter' ref getterAttrs); 					rw.Process(getterAttrs' null); 					rw.PrependStmtsToGetterOrSetter(ref braces' getterIndex' getter); 				} 				if (setter != null) { 					rw.PrependStmts = sharedPrependStmts; 					setter = GrabContractAttrs(setter' ref setterAttrs); 					rw.Process(setterAttrs' LNode.Id(CodeSymbols.value)' true); 					rw.PrependStmtsToGetterOrSetter(ref braces' setterIndex' setter); 				} 			 				// Update the property 				if (braces == oldBraces) 					return null;	// this is the common case 				else 					return prop.WithArgChanged(3' braces); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ContractsOnProperty,The following statement contains a magic number: if (prop.ArgCount == 4) { 				LNode braces = prop[3]; 				var oldBraces = braces; 				var rw = new CodeContractRewriter(prop.Args[0]' prop.Args[1]' context); 			 				// If this has an argument list (this[...])' process its contract attributes 				prop = ProcessArgContractAttributes(prop' 2' rw); 			 				// Remove contract attributes from the property and store in a list 				VList<LNode> cAttrs = LNode.List(); 				prop = prop.WithArgChanged(0' GrabContractAttrs(prop.Args[0]' ref cAttrs' ContractAppliesTo.Getter)); 				prop = GrabContractAttrs(prop' ref cAttrs); 			 				// Find the getter and setter 				LNode getter = null' setter = null; 				int getterIndex = -1' setterIndex = -1; 				VList<LNode> getterAttrs = LNode.List()' setterAttrs = LNode.List(); 				bool isLambdaProperty = !braces.Calls(S.Braces); 				if (isLambdaProperty) { 					if (cAttrs.Count == 0) 						return null;	// lambda property has no contract attributes 					// Transform into a normal property 					getterAttrs = cAttrs; 					getter = LNode.Call(CodeSymbols.get' LNode.List(LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(CodeSymbols.Return' LNode.List(braces)))).SetStyle(NodeStyle.Statement))).SetStyle(NodeStyle.Special); 					braces = LNode.Call(CodeSymbols.Braces' LNode.List(getter)).SetStyle(NodeStyle.Statement); 					getterIndex = 0; 				} else { 					for (int i = 0; i < braces.Args.Count; i++) { 						var part = braces.Args[i]; 						if (part.Calls(S.get)) { getter = part; getterIndex = i; } 						if (part.Calls(S.set)) { setter = part; setterIndex = i; } 					} 				 					// Now create separate lists of contract attributes for the getter and the setter 					if (cAttrs.Count != 0) { 						getterAttrs = cAttrs.SmartWhere(a => (PropertyContractInterpretation(a) & ContractAppliesTo.Getter) != 0); 						setterAttrs = cAttrs.SmartWhere(a => (PropertyContractInterpretation(a) & ContractAppliesTo.Setter) != 0); 					} 				} 			 				// Process the discovered attributes to produce prepended statements 				var sharedPrependStmts = rw.PrependStmts; 				if (getter != null) { 					getter = GrabContractAttrs(getter' ref getterAttrs); 					rw.Process(getterAttrs' null); 					rw.PrependStmtsToGetterOrSetter(ref braces' getterIndex' getter); 				} 				if (setter != null) { 					rw.PrependStmts = sharedPrependStmts; 					setter = GrabContractAttrs(setter' ref setterAttrs); 					rw.Process(setterAttrs' LNode.Id(CodeSymbols.value)' true); 					rw.PrependStmtsToGetterOrSetter(ref braces' setterIndex' setter); 				} 			 				// Update the property 				if (braces == oldBraces) 					return null;	// this is the common case 				else 					return prop.WithArgChanged(3' braces); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,GetVarName,The following statement contains a magic number: { 				LNode tmp_10 = null' variableName; 				if (arg.Calls(CodeSymbols.Var' 2) && (tmp_10 = arg.Args[1]) != null && tmp_10.Calls(CodeSymbols.Assign' 2) && (variableName = tmp_10.Args[0]) != null || arg.Calls(CodeSymbols.Var' 2) && (variableName = arg.Args[1]) != null) 					return variableName; 				else 					return arg.WithoutAttrs(); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,GetVarName,The following statement contains a magic number: { 				LNode tmp_10 = null' variableName; 				if (arg.Calls(CodeSymbols.Var' 2) && (tmp_10 = arg.Args[1]) != null && tmp_10.Calls(CodeSymbols.Assign' 2) && (variableName = tmp_10.Args[0]) != null || arg.Calls(CodeSymbols.Var' 2) && (variableName = arg.Args[1]) != null) 					return variableName; 				else 					return arg.WithoutAttrs(); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,GetVarName,The following statement contains a magic number: { 				LNode tmp_10 = null' variableName; 				if (arg.Calls(CodeSymbols.Var' 2) && (tmp_10 = arg.Args[1]) != null && tmp_10.Calls(CodeSymbols.Assign' 2) && (variableName = tmp_10.Args[0]) != null || arg.Calls(CodeSymbols.Var' 2) && (variableName = arg.Args[1]) != null) 					return variableName; 				else 					return arg.WithoutAttrs(); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,GetContractAttrMode,The following statement contains a magic number: if (!attr.HasSimpleHead()) { 				var target = attr.Target; 				if (target.Calls(S.Of' 2) && target.Args[0].IsIdNamed(sy_ensuresOnThrow)) { 					exceptionType = target.Args[1]; 					mode = sy_ensuresOnThrow; 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,DoDeconstruct,The following statement contains a magic number: if (!arg.Calls(S.Assign' 2)) 			{ 				if (arg.Calls(S.Lambda' 2)) 					G.Swap(ref patternSpec' ref input); 				else { 					context.Sink.Error(arg' "expected an assignment (`patterns = input`)"); 					return; 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,DoDeconstruct,The following statement contains a magic number: if (!arg.Calls(S.Assign' 2)) 			{ 				if (arg.Calls(S.Lambda' 2)) 					G.Swap(ref patternSpec' ref input); 				else { 					context.Sink.Error(arg' "expected an assignment (`patterns = input`)"); 					return; 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,DoDeconstruct,The following statement contains a magic number: while (patternSpec.Calls(S.OrBits' 2) && !patternSpec.IsParenthesizedExpr()) { 				patterns.Add(patternSpec[1]); 				patternSpec = patternSpec[0]; 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ForwardMethod,The following statement contains a magic number: if (fn.ArgCount != 4 || !(fwd = fn.Args[3]).Calls(S.Forward' 1) || !(args = fn.Args[2]).Calls(S.AltList)) 				return null;
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ForwardMethod,The following statement contains a magic number: if (fn.ArgCount != 4 || !(fwd = fn.Args[3]).Calls(S.Forward' 1) || !(args = fn.Args[2]).Calls(S.AltList)) 				return null;
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ForwardMethod,The following statement contains a magic number: if (fn.ArgCount != 4 || !(fwd = fn.Args[3]).Calls(S.Forward' 1) || !(args = fn.Args[2]).Calls(S.AltList)) 				return null;
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ForwardMethod,The following statement contains a magic number: return fn.WithArgChanged(3' body);
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,GetArgNamesFromFormalArgList,The following statement contains a magic number: foreach (var formalArg in formalArgs) 			{ 				if (!formalArg.Calls(S.Var' 2)) { 					onError(formalArg); 				} else { 					LNode argName = formalArg.Args[1]; 					if (argName.Calls(S.Assign' 2)) 						argName = argName.Args[0]; 					LNode @ref = formalArg.AttrNamed(S.Ref) ?? formalArg.AttrNamed(S.Out); 					if (@ref != null) 						argName = argName.PlusAttr(@ref); 					argList.Add(argName); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,GetArgNamesFromFormalArgList,The following statement contains a magic number: foreach (var formalArg in formalArgs) 			{ 				if (!formalArg.Calls(S.Var' 2)) { 					onError(formalArg); 				} else { 					LNode argName = formalArg.Args[1]; 					if (argName.Calls(S.Assign' 2)) 						argName = argName.Args[0]; 					LNode @ref = formalArg.AttrNamed(S.Ref) ?? formalArg.AttrNamed(S.Out); 					if (@ref != null) 						argName = argName.PlusAttr(@ref); 					argList.Add(argName); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ForwardProperty,The following statement contains a magic number: if (prop.ArgCount != 4) 				return null;
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ForwardProperty,The following statement contains a magic number: LNode target = GetForwardingTarget(name = prop.Args[1]' fwd = prop.Args[3]);
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ForwardProperty,The following statement contains a magic number: if (target != null) 			{ 				body = F.Braces(F.Call(S.get' F.Braces(F.Call(S.Return' target))).SetBaseStyle(NodeStyle.Special)); 				return prop.WithArgChanged(3' body); 			} 			else if ((body = fwd).Calls(S.Braces)) 			{ 				var body2 = body.WithArgs(stmt => { 					if (stmt.Calls(S.get' 1) && (target = GetForwardingTarget(name' stmt.Args[0])) != null) 						return stmt.WithArgs(new VList<LNode>(F.Braces(F.Call(S.Return' target)))); 					if (stmt.Calls(S.set' 1) && (target = GetForwardingTarget(name' stmt.Args[0])) != null) 						return stmt.WithArgs(new VList<LNode>(F.Braces(F.Call(S.Assign' target' F.Id(S.value))))); 					return stmt; 				}); 				if (body2 != body) 					return prop.WithArgChanged(3' body2); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ForwardProperty,The following statement contains a magic number: if (target != null) 			{ 				body = F.Braces(F.Call(S.get' F.Braces(F.Call(S.Return' target))).SetBaseStyle(NodeStyle.Special)); 				return prop.WithArgChanged(3' body); 			} 			else if ((body = fwd).Calls(S.Braces)) 			{ 				var body2 = body.WithArgs(stmt => { 					if (stmt.Calls(S.get' 1) && (target = GetForwardingTarget(name' stmt.Args[0])) != null) 						return stmt.WithArgs(new VList<LNode>(F.Braces(F.Call(S.Return' target)))); 					if (stmt.Calls(S.set' 1) && (target = GetForwardingTarget(name' stmt.Args[0])) != null) 						return stmt.WithArgs(new VList<LNode>(F.Braces(F.Call(S.Assign' target' F.Id(S.value))))); 					return stmt; 				}); 				if (body2 != body) 					return prop.WithArgChanged(3' body2); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,GetForwardingTarget,The following statement contains a magic number: if (fwd.Calls(S.Forward' 1)) { 				LNode target = fwd.Args[0]; 				if (target.Calls(S.Dot' 2) && (target.Args[1].IsIdNamed(_hash) || target.Args[1].IsIdNamed(__))) 					return target.WithArgChanged(1' target.Args[1].WithName( 						EcsNodePrinter.KeyNameComponentOf(methodName))); 				return target; 			} else 				return null;
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,In,The following statement contains a magic number: { 				LNode range' x; 				if (node.Calls(CodeSymbols.In' 2) && (x = node.Args[0]) != null && (range = node.Args[1]) != null) { 					LNode parens; 					range = range.WithoutAttrNamed(S.TriviaInParens' out parens); 					if (parens == null) { 						{ 							LNode hi' lo; 							if (range.Calls(CodeSymbols.DotDot' 2) && (lo = range.Args[0]) != null && (hi = range.Args[1]) != null) 								if (lo.IsIdNamed(__)) 									return LNode.Call(CodeSymbols.LT' LNode.List(x' hi)).SetStyle(NodeStyle.Operator); 								else if (hi.IsIdNamed(__)) 									return LNode.Call(CodeSymbols.GE' LNode.List(x' lo)).SetStyle(NodeStyle.Operator); 								else 									return LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(x' LNode.Id((Symbol) "IsInRangeExcludeHi"))).SetStyle(NodeStyle.Operator)' LNode.List(lo' hi)); 							else if (range.Calls(CodeSymbols.DotDot' 1) && (hi = range.Args[0]) != null) 								return LNode.Call(CodeSymbols.LT' LNode.List(x' hi)).SetStyle(NodeStyle.Operator); 							else if (range.Calls(CodeSymbols.DotDotDot' 2) && (lo = range.Args[0]) != null && (hi = range.Args[1]) != null) 								if (lo.IsIdNamed(__)) 									return LNode.Call(CodeSymbols.LE' LNode.List(x' hi)).SetStyle(NodeStyle.Operator); 								else if (hi.IsIdNamed(__)) 									return LNode.Call(CodeSymbols.GE' LNode.List(x' lo)).SetStyle(NodeStyle.Operator); 								else 									return LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(x' LNode.Id((Symbol) "IsInRange"))).SetStyle(NodeStyle.Operator)' LNode.List(lo' hi)); 							else if (range.Calls(CodeSymbols.DotDotDot' 1) && (hi = range.Args[0]) != null) 								return LNode.Call(CodeSymbols.LE' LNode.List(x' hi)).SetStyle(NodeStyle.Operator); 						} 					} 					return LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(range' LNode.Id((Symbol) "Contains"))).SetStyle(NodeStyle.Operator)' LNode.List(x)); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,In,The following statement contains a magic number: { 				LNode range' x; 				if (node.Calls(CodeSymbols.In' 2) && (x = node.Args[0]) != null && (range = node.Args[1]) != null) { 					LNode parens; 					range = range.WithoutAttrNamed(S.TriviaInParens' out parens); 					if (parens == null) { 						{ 							LNode hi' lo; 							if (range.Calls(CodeSymbols.DotDot' 2) && (lo = range.Args[0]) != null && (hi = range.Args[1]) != null) 								if (lo.IsIdNamed(__)) 									return LNode.Call(CodeSymbols.LT' LNode.List(x' hi)).SetStyle(NodeStyle.Operator); 								else if (hi.IsIdNamed(__)) 									return LNode.Call(CodeSymbols.GE' LNode.List(x' lo)).SetStyle(NodeStyle.Operator); 								else 									return LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(x' LNode.Id((Symbol) "IsInRangeExcludeHi"))).SetStyle(NodeStyle.Operator)' LNode.List(lo' hi)); 							else if (range.Calls(CodeSymbols.DotDot' 1) && (hi = range.Args[0]) != null) 								return LNode.Call(CodeSymbols.LT' LNode.List(x' hi)).SetStyle(NodeStyle.Operator); 							else if (range.Calls(CodeSymbols.DotDotDot' 2) && (lo = range.Args[0]) != null && (hi = range.Args[1]) != null) 								if (lo.IsIdNamed(__)) 									return LNode.Call(CodeSymbols.LE' LNode.List(x' hi)).SetStyle(NodeStyle.Operator); 								else if (hi.IsIdNamed(__)) 									return LNode.Call(CodeSymbols.GE' LNode.List(x' lo)).SetStyle(NodeStyle.Operator); 								else 									return LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(x' LNode.Id((Symbol) "IsInRange"))).SetStyle(NodeStyle.Operator)' LNode.List(lo' hi)); 							else if (range.Calls(CodeSymbols.DotDotDot' 1) && (hi = range.Args[0]) != null) 								return LNode.Call(CodeSymbols.LE' LNode.List(x' hi)).SetStyle(NodeStyle.Operator); 						} 					} 					return LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(range' LNode.Id((Symbol) "Contains"))).SetStyle(NodeStyle.Operator)' LNode.List(x)); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,In,The following statement contains a magic number: { 				LNode range' x; 				if (node.Calls(CodeSymbols.In' 2) && (x = node.Args[0]) != null && (range = node.Args[1]) != null) { 					LNode parens; 					range = range.WithoutAttrNamed(S.TriviaInParens' out parens); 					if (parens == null) { 						{ 							LNode hi' lo; 							if (range.Calls(CodeSymbols.DotDot' 2) && (lo = range.Args[0]) != null && (hi = range.Args[1]) != null) 								if (lo.IsIdNamed(__)) 									return LNode.Call(CodeSymbols.LT' LNode.List(x' hi)).SetStyle(NodeStyle.Operator); 								else if (hi.IsIdNamed(__)) 									return LNode.Call(CodeSymbols.GE' LNode.List(x' lo)).SetStyle(NodeStyle.Operator); 								else 									return LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(x' LNode.Id((Symbol) "IsInRangeExcludeHi"))).SetStyle(NodeStyle.Operator)' LNode.List(lo' hi)); 							else if (range.Calls(CodeSymbols.DotDot' 1) && (hi = range.Args[0]) != null) 								return LNode.Call(CodeSymbols.LT' LNode.List(x' hi)).SetStyle(NodeStyle.Operator); 							else if (range.Calls(CodeSymbols.DotDotDot' 2) && (lo = range.Args[0]) != null && (hi = range.Args[1]) != null) 								if (lo.IsIdNamed(__)) 									return LNode.Call(CodeSymbols.LE' LNode.List(x' hi)).SetStyle(NodeStyle.Operator); 								else if (hi.IsIdNamed(__)) 									return LNode.Call(CodeSymbols.GE' LNode.List(x' lo)).SetStyle(NodeStyle.Operator); 								else 									return LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(x' LNode.Id((Symbol) "IsInRange"))).SetStyle(NodeStyle.Operator)' LNode.List(lo' hi)); 							else if (range.Calls(CodeSymbols.DotDotDot' 1) && (hi = range.Args[0]) != null) 								return LNode.Call(CodeSymbols.LE' LNode.List(x' hi)).SetStyle(NodeStyle.Operator); 						} 					} 					return LNode.Call(LNode.Call(CodeSymbols.Dot' LNode.List(range' LNode.Id((Symbol) "Contains"))).SetStyle(NodeStyle.Operator)' LNode.List(x)); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,RangeExcl,The following statement contains a magic number: { 				LNode hi; 				if (node.Args.Count == 2 && (lo = node.Args[0]) != null && (hi = node.Args[1]) != null || node.Args.Count == 1 && (hi = node.Args[0]) != null) 					if (lo == null || lo.IsIdNamed(__)) 						if (hi.IsIdNamed(__)) 							return Range_Everything; 						else 							return LNode.Call(Range_UntilExclusive' LNode.List(hi)); 					else if (hi.IsIdNamed(__)) 						return LNode.Call(Range_StartingAt' LNode.List(lo)); 					else 						return LNode.Call(Range_ExcludeHi' LNode.List(lo' hi)); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,RangeIncl,The following statement contains a magic number: { 				LNode hi; 				if (node.Args.Count == 2 && (lo = node.Args[0]) != null && (hi = node.Args[1]) != null || node.Args.Count == 1 && (hi = node.Args[0]) != null) 					if (lo == null || lo.IsIdNamed(__)) 						if (hi.IsIdNamed(__)) 							return Range_Everything; 						else 							return LNode.Call(Range_UntilInclusive' LNode.List(hi)); 					else if (hi.IsIdNamed(__)) 						return LNode.Call(Range_StartingAt' LNode.List(lo)); 					else 						return LNode.Call(Range_Inclusive' LNode.List(lo' hi)); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,GetCases,The following statement contains a magic number: for (int i = 0; i < body.Count; i++) 			{ 				bool isDefault; 				if (body[i].Calls(S.Lambda' 2)) 				{ 					var alts = body[i][0].WithoutOuterParens().AsList(S.Tuple).SmartSelect(AutoStripBraces); 					pairs.Add(Pair.Create(alts' body[i][1].AsList(S.Braces))); 				} else 				if ((isDefault = IsDefaultLabel(body[i])) || body[i].CallsMin(S.Case' 1)) 				{ 					var alts = isDefault ? VList<LNode>.Empty : body[i].Args.SmartSelect(AutoStripBraces); 					int bodyStart = ++i; 					for (; i < body.Count && !IsDefaultLabel(body[i]) && !body[i].CallsMin(S.Case' 1); i++) { } 					var handler = new VList<LNode>(body.Slice(bodyStart' i - bodyStart)); 					pairs.Add(Pair.Create(alts' handler)); 					i--;	// counteract i++ when loop repeats (redo) 				} else 				{ 					Reject(sink' body[i]' "expected 'case _:' or '_ => _'"); 					break; 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,match,The following statement contains a magic number: { 				LNode input; 				VList<LNode> contents; 				if (node.Args.Count == 2 && (input = node.Args[0]) != null && node.Args[1].Calls(CodeSymbols.Braces)) { 					contents = node.Args[1].Args; 					var outputs = new WList<LNode>(); 					input = MaybeAddTempVarDecl(context' input' outputs); 				 					int next_i = 0; 					for (int case_i = 0; case_i < contents.Count; case_i = next_i) { 						var @case = contents[case_i]; 						if (!IsCaseLabel(@case)) 							return Reject(context' contents[0]' "In 'match': expected 'case' statement"); 						for (next_i = case_i + 1; next_i < contents.Count; next_i++) { 							var stmt = contents[next_i]; 							if (IsCaseLabel(stmt)) 								break; 							if (stmt.Calls(S.Break' 0)) { 								next_i++; 								break; 							} 						} 						var handler = new VList<LNode>(contents.Slice(case_i + 1' next_i - (case_i + 1))); 					 						if (@case.Calls(S.Case) && @case.Args.Count > 0) { 							var codeGen = new CodeGeneratorForMatchCase(context' input' handler); 							foreach (var pattern in @case.Args) 								outputs.Add(codeGen.GenCodeForPattern(pattern)); 						} else {	// default: 							// Note: the extra {braces} around the handler are rarely  							// needed. They are added just in case the handler declares a  							// variable and a different handler declares another variable  							// by the same name' which is illegal unless we add braces. 							outputs.Add(LNode.Call(CodeSymbols.Braces' LNode.List(handler)).SetStyle(NodeStyle.Statement)); 							if (next_i < contents.Count) 								context.Sink.Error(contents[next_i]' "The default branch must be the final branch in a 'match' statement."); 						} 					} 					return LNode.Call(CodeSymbols.DoWhile' LNode.List(outputs.ToVList().AsLNode(S.Braces)' LNode.Literal(false))); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ValidateOnStmt,The following statement contains a magic number: if (a.Count == 2) { 				firstArg = a[0]; 			} else if (a.Count != 1) 				return null;
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,scope,The following statement contains a magic number: if (a.Count == 2 && a[1].Calls(S.Braces) && a[0].IsId) { 				Symbol name = a[0].Name; 				if (name == _exit || name == S.Finally) 					return F.Call(_on_finally' a[1]); 				else if (name == _success || name == S.Return) 					return F.Call(_on_return' a[1]); 				else if (name == _failure || name == S.Catch) 					return F.Call(_on_throw_catch' a[1]); 				else 					return Reject(context' a[0]' "Expected 'exit'' 'success'' or 'failure'"); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,on_return,The following statement contains a magic number: if (varDecl == null) { 				varName = Id__result__; 				varDecl = F.Var(F.Missing' varName); 			} else { 				{ 					LNode tmp_10; 					if (varDecl.Calls(CodeSymbols.Var' 2) && (tmp_10 = varDecl.Args[1]) != null && tmp_10.Calls(CodeSymbols.Assign' 2) && (varName = tmp_10.Args[0]) != null) 						context.Sink.Error(varName' "The return value cannot be assigned here. The value of this variable must be placed on the return statement(s)."); 					else if (varDecl.Calls(CodeSymbols.Var' 2) && (varName = varDecl.Args[1]) != null) { } else if ((varName = varDecl).IsId) 						varDecl = varName.With(S.Var' F.Missing' varName); 					else 						return Reject(context' varDecl' "The first parameter to on_return must be a simple identifier (the name of a variable to return) or a variable declaration (for a variable to be returned)."); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,on_return,The following statement contains a magic number: if (varDecl == null) { 				varName = Id__result__; 				varDecl = F.Var(F.Missing' varName); 			} else { 				{ 					LNode tmp_10; 					if (varDecl.Calls(CodeSymbols.Var' 2) && (tmp_10 = varDecl.Args[1]) != null && tmp_10.Calls(CodeSymbols.Assign' 2) && (varName = tmp_10.Args[0]) != null) 						context.Sink.Error(varName' "The return value cannot be assigned here. The value of this variable must be placed on the return statement(s)."); 					else if (varDecl.Calls(CodeSymbols.Var' 2) && (varName = varDecl.Args[1]) != null) { } else if ((varName = varDecl).IsId) 						varDecl = varName.With(S.Var' F.Missing' varName); 					else 						return Reject(context' varDecl' "The first parameter to on_return must be a simple identifier (the name of a variable to return) or a variable declaration (for a variable to be returned)."); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,on_return,The following statement contains a magic number: if (varDecl == null) { 				varName = Id__result__; 				varDecl = F.Var(F.Missing' varName); 			} else { 				{ 					LNode tmp_10; 					if (varDecl.Calls(CodeSymbols.Var' 2) && (tmp_10 = varDecl.Args[1]) != null && tmp_10.Calls(CodeSymbols.Assign' 2) && (varName = tmp_10.Args[0]) != null) 						context.Sink.Error(varName' "The return value cannot be assigned here. The value of this variable must be placed on the return statement(s)."); 					else if (varDecl.Calls(CodeSymbols.Var' 2) && (varName = varDecl.Args[1]) != null) { } else if ((varName = varDecl).IsId) 						varDecl = varName.With(S.Var' F.Missing' varName); 					else 						return Reject(context' varDecl' "The first parameter to on_return must be a simple identifier (the name of a variable to return) or a variable declaration (for a variable to be returned)."); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,on_return,The following statement contains a magic number: rest = rest.SmartSelect(arg => arg.ReplaceRecursive(rnode => { 				{ 					LNode retVal; 					if (rnode.Calls(CodeSymbols.Lambda' 2)) 						return rnode;	// ignore children of lambda expression or delegate(){} 					else if (rnode.Calls(CodeSymbols.Return' 0)) { 						foundReturn = true; 						return LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(bracedHandler.Args).Add(rnode)).SetStyle(NodeStyle.Statement); 					} else if (rnode.Calls(CodeSymbols.Return' 1) && (retVal = rnode.Args[0]) != null) { 						foundReturn = true; 						var retValDecl = varDecl.WithArgChanged(1' LNode.Call(CodeSymbols.Assign' LNode.List(varName' retVal)).SetStyle(NodeStyle.Operator)); 						rnode = rnode.WithArgs(varName); 						return LNode.Call(CodeSymbols.Braces' LNode.List().Add(retValDecl).AddRange(bracedHandler.Args).Add(rnode)).SetStyle(NodeStyle.Statement); 					} else 						return null; 				} 			}));
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,DetectMissingVoidReturn,The following statement contains a magic number: var parent = anc.TryGet(anc.Count - 2' LNode.Missing);
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,DetectMissingVoidReturn,The following statement contains a magic number: var grandparent = anc.TryGet(anc.Count - 3' LNode.Missing);
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,DetectMissingVoidReturn,The following statement contains a magic number: do { 				if (parent.Calls(S.Braces)) { 					if (grandparent.CallsMin(S.Fn' 4) && grandparent.Args[0].IsIdNamed(S.Void)) 						return true; 					if (grandparent.Calls(S.Constructor)) 						return true; 					if (grandparent.Calls(S.set' 1) || grandparent.Calls(S.add' 1) || grandparent.Calls(S.remove' 1)) 						return true; 					if (grandparent.Calls(S.Lambda' 2)) 						return true; 				} 				return false; 			} while (false);
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,DetectMissingVoidReturn,The following statement contains a magic number: do { 				if (parent.Calls(S.Braces)) { 					if (grandparent.CallsMin(S.Fn' 4) && grandparent.Args[0].IsIdNamed(S.Void)) 						return true; 					if (grandparent.Calls(S.Constructor)) 						return true; 					if (grandparent.Calls(S.set' 1) || grandparent.Calls(S.add' 1) || grandparent.Calls(S.remove' 1)) 						return true; 					if (grandparent.Calls(S.Lambda' 2)) 						return true; 				} 				return false; 			} while (false);
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,replace,The following statement contains a magic number: if (args.Count >= 1) 			{ 				bool preprocess = node.Calls("replacePP");  				var patterns = new Pair<LNode' LNode>[args.Count]; 				for (int i = 0; i < patterns.Length; i++) 				{ 					var pair = args[i]; 					if (pair.Calls(S.Lambda' 2)) { 						LNode pattern = pair[0]' repl = pair[1]; 						if (preprocess) 						{ 							pattern = context.PreProcess(pattern); 							repl = context.PreProcess(repl); 						} 						if (pattern.Calls(S.Braces)) { 							if (pattern.ArgCount == 1) 								pattern = pattern.Args[0]; 							else 								context.Write(Severity.Error' pattern' "The braces must contain only a single statement. To search for braces literally' use `{{ ... }}`"); 						} 						if (repl.Calls(S.Braces)) 							repl = repl.Args.AsLNode(S.Splice); 						 						// Avoid StackOverflowException when pattern is $Id (sadly' it 						// is uncatchable so it can crash LeMP.exe and even Visual Studio) 						if (LNodeExt.GetCaptureIdentifier(pattern) != null)  							return Reject(context' pattern' "The left side of `=>` cannot be a capture. Remove the `$`.");  						patterns[i] = Pair.Create(pattern' repl); 					} else { 						string msg = "Expected 'pattern => replacement'."; 						if (pair.Descendants().Any(n => n.Calls(S.Lambda' 2))) 							msg += " " + "(Using '=>' already? Put the pattern on the left-hand side in parentheses.)"; 						return Reject(context' pair' msg); 					} 				}  				int replacementCount; 				var output = Replace(body' patterns' out replacementCount); 				if (replacementCount == 0) 					context.Sink.Warning(node' "No patterns recognized; no replacements were made."); 				return output.AsLNode(S.Splice); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,replace,The following statement contains a magic number: if (args.Count >= 1) 			{ 				bool preprocess = node.Calls("replacePP");  				var patterns = new Pair<LNode' LNode>[args.Count]; 				for (int i = 0; i < patterns.Length; i++) 				{ 					var pair = args[i]; 					if (pair.Calls(S.Lambda' 2)) { 						LNode pattern = pair[0]' repl = pair[1]; 						if (preprocess) 						{ 							pattern = context.PreProcess(pattern); 							repl = context.PreProcess(repl); 						} 						if (pattern.Calls(S.Braces)) { 							if (pattern.ArgCount == 1) 								pattern = pattern.Args[0]; 							else 								context.Write(Severity.Error' pattern' "The braces must contain only a single statement. To search for braces literally' use `{{ ... }}`"); 						} 						if (repl.Calls(S.Braces)) 							repl = repl.Args.AsLNode(S.Splice); 						 						// Avoid StackOverflowException when pattern is $Id (sadly' it 						// is uncatchable so it can crash LeMP.exe and even Visual Studio) 						if (LNodeExt.GetCaptureIdentifier(pattern) != null)  							return Reject(context' pattern' "The left side of `=>` cannot be a capture. Remove the `$`.");  						patterns[i] = Pair.Create(pattern' repl); 					} else { 						string msg = "Expected 'pattern => replacement'."; 						if (pair.Descendants().Any(n => n.Calls(S.Lambda' 2))) 							msg += " " + "(Using '=>' already? Put the pattern on the left-hand side in parentheses.)"; 						return Reject(context' pair' msg); 					} 				}  				int replacementCount; 				var output = Replace(body' patterns' out replacementCount); 				if (replacementCount == 0) 					context.Sink.Warning(node' "No patterns recognized; no replacements were made."); 				return output.AsLNode(S.Splice); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,saveAndRestore,The following statement contains a magic number: if (args.Count == 1) { 				LNode newValue = null; 				{ 					var tmp_11 = args[0]; 					LNode property; 					if (tmp_11.Calls(CodeSymbols.Assign' 2) && (property = tmp_11.Args[0]) != null && (newValue = tmp_11.Args[1]) != null || (property = tmp_11) != null) { 						string mainProp = KeyNameComponentOf(property).Name; 						string varPrefix = "old" + mainProp + "_"; 						LNode varName' varDecl = TempVarDecl(context' property' out varName' varPrefix); 						LNode tryFinally = LNode.Call(CodeSymbols.Try' LNode.List(LNode.Call(CodeSymbols.Braces' LNode.List(body)).SetStyle(NodeStyle.Statement)' LNode.Call(CodeSymbols.Finally' LNode.List(LNode.Call(CodeSymbols.Braces' LNode.List(LNode.Call(CodeSymbols.Assign' LNode.List(property' varName)).SetStyle(NodeStyle.Operator))).SetStyle(NodeStyle.Statement))))); 						if (newValue != null) { 							return LNode.Call(CodeSymbols.Splice' LNode.List(varDecl' LNode.Call(CodeSymbols.Assign' LNode.List(property' newValue)).SetStyle(NodeStyle.Operator)' tryFinally)); 						} else { 							return LNode.Call(CodeSymbols.Splice' LNode.List(varDecl' tryFinally)); 						} 					} 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,SetOrCreateMember,The following statement contains a magic number: if (fn.ArgCount < 3 || !fn.Args[2].Calls(S.AltList)) 				return null;
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,SetOrCreateMember,The following statement contains a magic number: if (fn.ArgCount < 3 || !fn.Args[2].Calls(S.AltList)) 				return null;
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,SetOrCreateMember,The following statement contains a magic number: var args = fn.Args[2].Args;
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,SetOrCreateMember,The following statement contains a magic number: for (int i = 0; i < args.Count; i++) { 				var arg = args[i]; 				Symbol relevantAttribute' fieldName' paramName; 				LNode plainArg' propOrFieldDecl; 				if (DetectSetOrCreateMember(arg' out relevantAttribute' out fieldName' out paramName' out plainArg' out propOrFieldDecl)) 				{ 					if (fn.ArgCount < 4) 						return Reject(sink' arg' Localize.Localized("'{0}': to set or create a field or property' the method must have a body in braces {{}}."' relevantAttribute));  					args[i] = plainArg; 					assignments = assignments ?? new Dictionary<Symbol' LNode>(); 					assignments[fieldName] = F.Id(paramName); 					if (propOrFieldDecl != null) 						propOrFieldDecls.Add(propOrFieldDecl); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,SetOrCreateMember,The following statement contains a magic number: if (assignments != null) // if this macro has been used... 			{ 				var parts = fn.Args; 				parts[2] = parts[2].WithArgs(args); 				var body = parts[3]; 				 				// Ensure the method has a normal braced body 				if (!body.Calls(S.Braces)) { 					if (parts[0].IsIdNamed(S.Void)) 						body = F.Braces(body); 					else 						body = F.Braces(F.Call(S.Return' body)); 				}  				// In case one constructor calls another' we have to ensure that the  				// assignments are inserted _after_ that call' and if the constructor 				// call refers to properties or fields that will be set' we must remap 				// those references onto parameters' e.g. 				//   this(public int X) { base(X); } => this(int x) { base(x); X = x; } 				var bodyStmts = body.Args; 				int indexAtWhichToDoAssignments = 0; 				if (fn.Calls(S.Constructor)) { 					LNode baseCall = bodyStmts[0' LNode.Missing]; 					if (baseCall.Calls(S.Base) || baseCall.Calls(S.This)) { 						bodyStmts[0] = baseCall.ReplaceRecursive(n => { 							LNode param; 							if (n.IsId && assignments.TryGetValue(n.Name' out param)) 								return param; 							return null; 						}); 						indexAtWhichToDoAssignments = 1; 					} 				}  				// Insert assignment statements 				parts[3] = body.WithArgs(bodyStmts.InsertRange(indexAtWhichToDoAssignments' assignments.Select(p => { 					if (p.Key == p.Value.Name) 						return F.Call(S.Assign' F.Dot(F.@this' F.Id(p.Key))' p.Value); 					else 						return F.Call(S.Assign' F.Id(p.Key)' p.Value); 				}).ToList()));  				fn.Style &= ~NodeStyle.OneLiner; 				foreach (var p in parts) 					p.Style &= ~NodeStyle.OneLiner;  				// Return output code 				fn = fn.WithArgs(parts); 				if (propOrFieldDecls.IsEmpty) 					return fn; 				else { 					propOrFieldDecls.Add(fn); 					return F.Call(S.Splice' propOrFieldDecls); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,SetOrCreateMember,The following statement contains a magic number: if (assignments != null) // if this macro has been used... 			{ 				var parts = fn.Args; 				parts[2] = parts[2].WithArgs(args); 				var body = parts[3]; 				 				// Ensure the method has a normal braced body 				if (!body.Calls(S.Braces)) { 					if (parts[0].IsIdNamed(S.Void)) 						body = F.Braces(body); 					else 						body = F.Braces(F.Call(S.Return' body)); 				}  				// In case one constructor calls another' we have to ensure that the  				// assignments are inserted _after_ that call' and if the constructor 				// call refers to properties or fields that will be set' we must remap 				// those references onto parameters' e.g. 				//   this(public int X) { base(X); } => this(int x) { base(x); X = x; } 				var bodyStmts = body.Args; 				int indexAtWhichToDoAssignments = 0; 				if (fn.Calls(S.Constructor)) { 					LNode baseCall = bodyStmts[0' LNode.Missing]; 					if (baseCall.Calls(S.Base) || baseCall.Calls(S.This)) { 						bodyStmts[0] = baseCall.ReplaceRecursive(n => { 							LNode param; 							if (n.IsId && assignments.TryGetValue(n.Name' out param)) 								return param; 							return null; 						}); 						indexAtWhichToDoAssignments = 1; 					} 				}  				// Insert assignment statements 				parts[3] = body.WithArgs(bodyStmts.InsertRange(indexAtWhichToDoAssignments' assignments.Select(p => { 					if (p.Key == p.Value.Name) 						return F.Call(S.Assign' F.Dot(F.@this' F.Id(p.Key))' p.Value); 					else 						return F.Call(S.Assign' F.Id(p.Key)' p.Value); 				}).ToList()));  				fn.Style &= ~NodeStyle.OneLiner; 				foreach (var p in parts) 					p.Style &= ~NodeStyle.OneLiner;  				// Return output code 				fn = fn.WithArgs(parts); 				if (propOrFieldDecls.IsEmpty) 					return fn; 				else { 					propOrFieldDecls.Add(fn); 					return F.Call(S.Splice' propOrFieldDecls); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,SetOrCreateMember,The following statement contains a magic number: if (assignments != null) // if this macro has been used... 			{ 				var parts = fn.Args; 				parts[2] = parts[2].WithArgs(args); 				var body = parts[3]; 				 				// Ensure the method has a normal braced body 				if (!body.Calls(S.Braces)) { 					if (parts[0].IsIdNamed(S.Void)) 						body = F.Braces(body); 					else 						body = F.Braces(F.Call(S.Return' body)); 				}  				// In case one constructor calls another' we have to ensure that the  				// assignments are inserted _after_ that call' and if the constructor 				// call refers to properties or fields that will be set' we must remap 				// those references onto parameters' e.g. 				//   this(public int X) { base(X); } => this(int x) { base(x); X = x; } 				var bodyStmts = body.Args; 				int indexAtWhichToDoAssignments = 0; 				if (fn.Calls(S.Constructor)) { 					LNode baseCall = bodyStmts[0' LNode.Missing]; 					if (baseCall.Calls(S.Base) || baseCall.Calls(S.This)) { 						bodyStmts[0] = baseCall.ReplaceRecursive(n => { 							LNode param; 							if (n.IsId && assignments.TryGetValue(n.Name' out param)) 								return param; 							return null; 						}); 						indexAtWhichToDoAssignments = 1; 					} 				}  				// Insert assignment statements 				parts[3] = body.WithArgs(bodyStmts.InsertRange(indexAtWhichToDoAssignments' assignments.Select(p => { 					if (p.Key == p.Value.Name) 						return F.Call(S.Assign' F.Dot(F.@this' F.Id(p.Key))' p.Value); 					else 						return F.Call(S.Assign' F.Id(p.Key)' p.Value); 				}).ToList()));  				fn.Style &= ~NodeStyle.OneLiner; 				foreach (var p in parts) 					p.Style &= ~NodeStyle.OneLiner;  				// Return output code 				fn = fn.WithArgs(parts); 				if (propOrFieldDecls.IsEmpty) 					return fn; 				else { 					propOrFieldDecls.Add(fn); 					return F.Call(S.Splice' propOrFieldDecls); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,SetOrCreateMember,The following statement contains a magic number: if (assignments != null) // if this macro has been used... 			{ 				var parts = fn.Args; 				parts[2] = parts[2].WithArgs(args); 				var body = parts[3]; 				 				// Ensure the method has a normal braced body 				if (!body.Calls(S.Braces)) { 					if (parts[0].IsIdNamed(S.Void)) 						body = F.Braces(body); 					else 						body = F.Braces(F.Call(S.Return' body)); 				}  				// In case one constructor calls another' we have to ensure that the  				// assignments are inserted _after_ that call' and if the constructor 				// call refers to properties or fields that will be set' we must remap 				// those references onto parameters' e.g. 				//   this(public int X) { base(X); } => this(int x) { base(x); X = x; } 				var bodyStmts = body.Args; 				int indexAtWhichToDoAssignments = 0; 				if (fn.Calls(S.Constructor)) { 					LNode baseCall = bodyStmts[0' LNode.Missing]; 					if (baseCall.Calls(S.Base) || baseCall.Calls(S.This)) { 						bodyStmts[0] = baseCall.ReplaceRecursive(n => { 							LNode param; 							if (n.IsId && assignments.TryGetValue(n.Name' out param)) 								return param; 							return null; 						}); 						indexAtWhichToDoAssignments = 1; 					} 				}  				// Insert assignment statements 				parts[3] = body.WithArgs(bodyStmts.InsertRange(indexAtWhichToDoAssignments' assignments.Select(p => { 					if (p.Key == p.Value.Name) 						return F.Call(S.Assign' F.Dot(F.@this' F.Id(p.Key))' p.Value); 					else 						return F.Call(S.Assign' F.Id(p.Key)' p.Value); 				}).ToList()));  				fn.Style &= ~NodeStyle.OneLiner; 				foreach (var p in parts) 					p.Style &= ~NodeStyle.OneLiner;  				// Return output code 				fn = fn.WithArgs(parts); 				if (propOrFieldDecls.IsEmpty) 					return fn; 				else { 					propOrFieldDecls.Add(fn); 					return F.Call(S.Splice' propOrFieldDecls); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,DetectSetOrCreateMember,The following statement contains a magic number: if (EcsValidators.IsPropertyDefinition(arg' out type' out name' out propArgs' out _' out defaultValue) && propArgs.ArgCount == 0) { 				// #property(Type' Name<T>' {...}) 				relevantAttribute = S.Property; 				fieldName = EcsNodePrinter.KeyNameComponentOf(name); 				paramName = ChooseArgName(fieldName); 				if (defaultValue != null) { // initializer is Args[4] 					newArg = LNode.Call(S.Var' LNode.List(type' F.Assign(paramName' defaultValue))' arg); 					propOrFieldDecl = arg.WithArgs(arg.Args.First(4)); 				} else { 					newArg = LNode.Call(S.Var' LNode.List(type' F.Id(paramName))' arg); 					propOrFieldDecl = arg; 				} 				DSOCM_DistributeAttributes(arg.Attrs' ref newArg' ref propOrFieldDecl); 				return true; 			} else if (IsVar(arg' out type' out paramName' out defaultValue)) { 				int a_i = 0; 				foreach (var attr in arg.Attrs) { 					if (attr.IsId) { 						var a = attr.Name; 						if (a == _set || FieldCreationAttributes.Contains(a)) 						{ 							relevantAttribute = a; 							fieldName = paramName; 							paramName = ChooseArgName(fieldName); 							if (a == _set) { 								newArg = F.Var(type' paramName' defaultValue).WithAttrs(arg.Attrs.Without(attr)); 							} else { 								// in case of something like "[A] public params T arg = value"'  								// assume that "= value" represents a default value' not a field  								// initializer. Most attributes stay on the argument. 								newArg = arg.WithArgChanged(1'  									defaultValue != null ? F.Assign(paramName' defaultValue) : F.Id(paramName)); 								propOrFieldDecl = LNode.Call(S.Var' LNode.List(type' F.Id(fieldName))' arg); 								DSOCM_DistributeAttributes(arg.Attrs' ref newArg' ref propOrFieldDecl); 							} 							break; 						} 					} 					a_i++; 				} 				return newArg != null; 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,DSOCM_DistributeAttributes,The following statement contains a magic number: foreach (var attr in attrs) { 				var name = attr.Name; 				if (attr.IsId && (FieldCreationAttributes.Contains(name) || name == S.Readonly)) 					fieldAttrs.Add(attr); 				else if (name == S.TriviaSLComment || name == S.TriviaNewline) 					fieldAttrs.Add(attr); // Put doc comments and leading newline on the field/prop 				else if (attr.Calls(S.NamedArg' 2) && (attr.Args[0].IsIdNamed("field") || attr.Args[0].IsIdNamed("property"))) 					fieldAttrs.Add(attr.Args[1]); 				else 					argAttrs.Add(attr); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,LooksLikeSimpleValue,The following statement contains a magic number: if (value.IsCall) { 				if (value.Calls(S.Dot)) { 					if (value.ArgCount == 1) 						value = value.Args[0]; 					else if (value.ArgCount == 2) { 						if (!LooksLikeSimpleValue(value.Args[0])) 							return false; 						value = value.Args[1]; 					} else 						return false; 				} else 					return false; 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,NextStatementMayBeReachable,The following statement contains a magic number: if (stmt.Calls(S.If' 2)) 				return true; 			else if (stmt.Calls(S.If' 3)) 			{ 				var r1 = NextStatementMayBeReachable(stmt.Args[1]); 				var r2 = NextStatementMayBeReachable(stmt.Args[2]); 				return r1 || r2; 			} 			else if (stmt.CallsMin(S.Switch' 2) && (body = stmt.Args[1]).CallsMin(S.Braces' 2)) 			{ 				// for a switch statement' assume it exits normally if a break  				// statement is the last statement of any of the cases' or if 				// there is no "default" case. 				bool beforeCase = true; 				bool hasDefaultCase = false; 				foreach (var substmt in body.Args.ToFVList()) 				{ 					if (beforeCase && substmt.Calls(S.Break)) 						return true; 					if (substmt.Calls(S.Label' 1) && substmt.Args[0].IsIdNamed(S.Default)) 						hasDefaultCase = beforeCase = true; 					else 						beforeCase = substmt.Calls(S.Case); 				} 				return hasDefaultCase == false; 			} 			else if ((isFor = stmt.Calls(S.For' 4)) || stmt.Calls(S.While' 2) || stmt.Calls(S.DoWhile' 2)) 			{   // Infinite loop? 				var cond = stmt.Args[isFor ? 1 : 0]; 				if (cond.IsIdNamed(S.Missing) || true.Equals(cond.Value)) 					return true; // ok' I don't know what to do 				return true; 			} 			else if (stmt.CallsMin(S.Try' 1)) 			{ 				return NextStatementMayBeReachable(stmt.Args[0]); 			} 			else if (stmt.ArgCount >= 1) 			{ 				Debug.Assert(stmt.HasSpecialName); 				return NextStatementMayBeReachable(stmt.Args.Last); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,NextStatementMayBeReachable,The following statement contains a magic number: if (stmt.Calls(S.If' 2)) 				return true; 			else if (stmt.Calls(S.If' 3)) 			{ 				var r1 = NextStatementMayBeReachable(stmt.Args[1]); 				var r2 = NextStatementMayBeReachable(stmt.Args[2]); 				return r1 || r2; 			} 			else if (stmt.CallsMin(S.Switch' 2) && (body = stmt.Args[1]).CallsMin(S.Braces' 2)) 			{ 				// for a switch statement' assume it exits normally if a break  				// statement is the last statement of any of the cases' or if 				// there is no "default" case. 				bool beforeCase = true; 				bool hasDefaultCase = false; 				foreach (var substmt in body.Args.ToFVList()) 				{ 					if (beforeCase && substmt.Calls(S.Break)) 						return true; 					if (substmt.Calls(S.Label' 1) && substmt.Args[0].IsIdNamed(S.Default)) 						hasDefaultCase = beforeCase = true; 					else 						beforeCase = substmt.Calls(S.Case); 				} 				return hasDefaultCase == false; 			} 			else if ((isFor = stmt.Calls(S.For' 4)) || stmt.Calls(S.While' 2) || stmt.Calls(S.DoWhile' 2)) 			{   // Infinite loop? 				var cond = stmt.Args[isFor ? 1 : 0]; 				if (cond.IsIdNamed(S.Missing) || true.Equals(cond.Value)) 					return true; // ok' I don't know what to do 				return true; 			} 			else if (stmt.CallsMin(S.Try' 1)) 			{ 				return NextStatementMayBeReachable(stmt.Args[0]); 			} 			else if (stmt.ArgCount >= 1) 			{ 				Debug.Assert(stmt.HasSpecialName); 				return NextStatementMayBeReachable(stmt.Args.Last); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,NextStatementMayBeReachable,The following statement contains a magic number: if (stmt.Calls(S.If' 2)) 				return true; 			else if (stmt.Calls(S.If' 3)) 			{ 				var r1 = NextStatementMayBeReachable(stmt.Args[1]); 				var r2 = NextStatementMayBeReachable(stmt.Args[2]); 				return r1 || r2; 			} 			else if (stmt.CallsMin(S.Switch' 2) && (body = stmt.Args[1]).CallsMin(S.Braces' 2)) 			{ 				// for a switch statement' assume it exits normally if a break  				// statement is the last statement of any of the cases' or if 				// there is no "default" case. 				bool beforeCase = true; 				bool hasDefaultCase = false; 				foreach (var substmt in body.Args.ToFVList()) 				{ 					if (beforeCase && substmt.Calls(S.Break)) 						return true; 					if (substmt.Calls(S.Label' 1) && substmt.Args[0].IsIdNamed(S.Default)) 						hasDefaultCase = beforeCase = true; 					else 						beforeCase = substmt.Calls(S.Case); 				} 				return hasDefaultCase == false; 			} 			else if ((isFor = stmt.Calls(S.For' 4)) || stmt.Calls(S.While' 2) || stmt.Calls(S.DoWhile' 2)) 			{   // Infinite loop? 				var cond = stmt.Args[isFor ? 1 : 0]; 				if (cond.IsIdNamed(S.Missing) || true.Equals(cond.Value)) 					return true; // ok' I don't know what to do 				return true; 			} 			else if (stmt.CallsMin(S.Try' 1)) 			{ 				return NextStatementMayBeReachable(stmt.Args[0]); 			} 			else if (stmt.ArgCount >= 1) 			{ 				Debug.Assert(stmt.HasSpecialName); 				return NextStatementMayBeReachable(stmt.Args.Last); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,NextStatementMayBeReachable,The following statement contains a magic number: if (stmt.Calls(S.If' 2)) 				return true; 			else if (stmt.Calls(S.If' 3)) 			{ 				var r1 = NextStatementMayBeReachable(stmt.Args[1]); 				var r2 = NextStatementMayBeReachable(stmt.Args[2]); 				return r1 || r2; 			} 			else if (stmt.CallsMin(S.Switch' 2) && (body = stmt.Args[1]).CallsMin(S.Braces' 2)) 			{ 				// for a switch statement' assume it exits normally if a break  				// statement is the last statement of any of the cases' or if 				// there is no "default" case. 				bool beforeCase = true; 				bool hasDefaultCase = false; 				foreach (var substmt in body.Args.ToFVList()) 				{ 					if (beforeCase && substmt.Calls(S.Break)) 						return true; 					if (substmt.Calls(S.Label' 1) && substmt.Args[0].IsIdNamed(S.Default)) 						hasDefaultCase = beforeCase = true; 					else 						beforeCase = substmt.Calls(S.Case); 				} 				return hasDefaultCase == false; 			} 			else if ((isFor = stmt.Calls(S.For' 4)) || stmt.Calls(S.While' 2) || stmt.Calls(S.DoWhile' 2)) 			{   // Infinite loop? 				var cond = stmt.Args[isFor ? 1 : 0]; 				if (cond.IsIdNamed(S.Missing) || true.Equals(cond.Value)) 					return true; // ok' I don't know what to do 				return true; 			} 			else if (stmt.CallsMin(S.Try' 1)) 			{ 				return NextStatementMayBeReachable(stmt.Args[0]); 			} 			else if (stmt.ArgCount >= 1) 			{ 				Debug.Assert(stmt.HasSpecialName); 				return NextStatementMayBeReachable(stmt.Args.Last); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,NextStatementMayBeReachable,The following statement contains a magic number: if (stmt.Calls(S.If' 2)) 				return true; 			else if (stmt.Calls(S.If' 3)) 			{ 				var r1 = NextStatementMayBeReachable(stmt.Args[1]); 				var r2 = NextStatementMayBeReachable(stmt.Args[2]); 				return r1 || r2; 			} 			else if (stmt.CallsMin(S.Switch' 2) && (body = stmt.Args[1]).CallsMin(S.Braces' 2)) 			{ 				// for a switch statement' assume it exits normally if a break  				// statement is the last statement of any of the cases' or if 				// there is no "default" case. 				bool beforeCase = true; 				bool hasDefaultCase = false; 				foreach (var substmt in body.Args.ToFVList()) 				{ 					if (beforeCase && substmt.Calls(S.Break)) 						return true; 					if (substmt.Calls(S.Label' 1) && substmt.Args[0].IsIdNamed(S.Default)) 						hasDefaultCase = beforeCase = true; 					else 						beforeCase = substmt.Calls(S.Case); 				} 				return hasDefaultCase == false; 			} 			else if ((isFor = stmt.Calls(S.For' 4)) || stmt.Calls(S.While' 2) || stmt.Calls(S.DoWhile' 2)) 			{   // Infinite loop? 				var cond = stmt.Args[isFor ? 1 : 0]; 				if (cond.IsIdNamed(S.Missing) || true.Equals(cond.Value)) 					return true; // ok' I don't know what to do 				return true; 			} 			else if (stmt.CallsMin(S.Try' 1)) 			{ 				return NextStatementMayBeReachable(stmt.Args[0]); 			} 			else if (stmt.ArgCount >= 1) 			{ 				Debug.Assert(stmt.HasSpecialName); 				return NextStatementMayBeReachable(stmt.Args.Last); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,NextStatementMayBeReachable,The following statement contains a magic number: if (stmt.Calls(S.If' 2)) 				return true; 			else if (stmt.Calls(S.If' 3)) 			{ 				var r1 = NextStatementMayBeReachable(stmt.Args[1]); 				var r2 = NextStatementMayBeReachable(stmt.Args[2]); 				return r1 || r2; 			} 			else if (stmt.CallsMin(S.Switch' 2) && (body = stmt.Args[1]).CallsMin(S.Braces' 2)) 			{ 				// for a switch statement' assume it exits normally if a break  				// statement is the last statement of any of the cases' or if 				// there is no "default" case. 				bool beforeCase = true; 				bool hasDefaultCase = false; 				foreach (var substmt in body.Args.ToFVList()) 				{ 					if (beforeCase && substmt.Calls(S.Break)) 						return true; 					if (substmt.Calls(S.Label' 1) && substmt.Args[0].IsIdNamed(S.Default)) 						hasDefaultCase = beforeCase = true; 					else 						beforeCase = substmt.Calls(S.Case); 				} 				return hasDefaultCase == false; 			} 			else if ((isFor = stmt.Calls(S.For' 4)) || stmt.Calls(S.While' 2) || stmt.Calls(S.DoWhile' 2)) 			{   // Infinite loop? 				var cond = stmt.Args[isFor ? 1 : 0]; 				if (cond.IsIdNamed(S.Missing) || true.Equals(cond.Value)) 					return true; // ok' I don't know what to do 				return true; 			} 			else if (stmt.CallsMin(S.Try' 1)) 			{ 				return NextStatementMayBeReachable(stmt.Args[0]); 			} 			else if (stmt.ArgCount >= 1) 			{ 				Debug.Assert(stmt.HasSpecialName); 				return NextStatementMayBeReachable(stmt.Args.Last); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,NextStatementMayBeReachable,The following statement contains a magic number: if (stmt.Calls(S.If' 2)) 				return true; 			else if (stmt.Calls(S.If' 3)) 			{ 				var r1 = NextStatementMayBeReachable(stmt.Args[1]); 				var r2 = NextStatementMayBeReachable(stmt.Args[2]); 				return r1 || r2; 			} 			else if (stmt.CallsMin(S.Switch' 2) && (body = stmt.Args[1]).CallsMin(S.Braces' 2)) 			{ 				// for a switch statement' assume it exits normally if a break  				// statement is the last statement of any of the cases' or if 				// there is no "default" case. 				bool beforeCase = true; 				bool hasDefaultCase = false; 				foreach (var substmt in body.Args.ToFVList()) 				{ 					if (beforeCase && substmt.Calls(S.Break)) 						return true; 					if (substmt.Calls(S.Label' 1) && substmt.Args[0].IsIdNamed(S.Default)) 						hasDefaultCase = beforeCase = true; 					else 						beforeCase = substmt.Calls(S.Case); 				} 				return hasDefaultCase == false; 			} 			else if ((isFor = stmt.Calls(S.For' 4)) || stmt.Calls(S.While' 2) || stmt.Calls(S.DoWhile' 2)) 			{   // Infinite loop? 				var cond = stmt.Args[isFor ? 1 : 0]; 				if (cond.IsIdNamed(S.Missing) || true.Equals(cond.Value)) 					return true; // ok' I don't know what to do 				return true; 			} 			else if (stmt.CallsMin(S.Try' 1)) 			{ 				return NextStatementMayBeReachable(stmt.Args[0]); 			} 			else if (stmt.ArgCount >= 1) 			{ 				Debug.Assert(stmt.HasSpecialName); 				return NextStatementMayBeReachable(stmt.Args.Last); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,NextStatementMayBeReachable,The following statement contains a magic number: if (stmt.Calls(S.If' 2)) 				return true; 			else if (stmt.Calls(S.If' 3)) 			{ 				var r1 = NextStatementMayBeReachable(stmt.Args[1]); 				var r2 = NextStatementMayBeReachable(stmt.Args[2]); 				return r1 || r2; 			} 			else if (stmt.CallsMin(S.Switch' 2) && (body = stmt.Args[1]).CallsMin(S.Braces' 2)) 			{ 				// for a switch statement' assume it exits normally if a break  				// statement is the last statement of any of the cases' or if 				// there is no "default" case. 				bool beforeCase = true; 				bool hasDefaultCase = false; 				foreach (var substmt in body.Args.ToFVList()) 				{ 					if (beforeCase && substmt.Calls(S.Break)) 						return true; 					if (substmt.Calls(S.Label' 1) && substmt.Args[0].IsIdNamed(S.Default)) 						hasDefaultCase = beforeCase = true; 					else 						beforeCase = substmt.Calls(S.Case); 				} 				return hasDefaultCase == false; 			} 			else if ((isFor = stmt.Calls(S.For' 4)) || stmt.Calls(S.While' 2) || stmt.Calls(S.DoWhile' 2)) 			{   // Infinite loop? 				var cond = stmt.Args[isFor ? 1 : 0]; 				if (cond.IsIdNamed(S.Missing) || true.Equals(cond.Value)) 					return true; // ok' I don't know what to do 				return true; 			} 			else if (stmt.CallsMin(S.Try' 1)) 			{ 				return NextStatementMayBeReachable(stmt.Args[0]); 			} 			else if (stmt.ArgCount >= 1) 			{ 				Debug.Assert(stmt.HasSpecialName); 				return NextStatementMayBeReachable(stmt.Args.Last); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,treeEquals,The following statement contains a magic number: if (node.ArgCount < 2) return null;
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,static_if,The following statement contains a magic number: if (!@if.ArgCount.IsInRange(2' 3)) 				return null;
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,static_if,The following statement contains a magic number: if (!@if.ArgCount.IsInRange(2' 3)) 				return null;
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,static_if,The following statement contains a magic number: if ((@bool = cond.Value) is bool) 			{ 				LNode output = (bool)@bool ? @if.Args[1] : @if.Args.TryGet(2' null) ?? F.Call(S.Splice); 				if (output.Calls(S.Braces)) 					return output.WithTarget(S.Splice); 				else 					return output; 			} 			else 				return Reject(context' @if.Args[0]' "Only boolean expressions can be evaluated.");
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ReduceBooleanExpr,The following statement contains a magic number: if (node.ArgCount == 2) 			{ 				var lhs = ReduceBooleanExpr(node[0]); 				if (lhs.Value is bool) 				{ 					if (n == S.And || n == S.AndBits) 						if ((bool)lhs.Value) 							return ReduceBooleanExpr(node[1]); 						else 							return F.False; 					if (n == S.Or || n == S.OrBits) 						if ((bool)lhs.Value) 							return F.True; 						else 							return ReduceBooleanExpr(node[1]); 					if (n == S.Eq || n == S.Neq) { 						var rhs = ReduceBooleanExpr(node[1]); 						if (rhs.Value is bool) 							if ((((bool)lhs.Value) == ((bool)rhs.Value)) == (n == S.Eq)) 								return F.True; 							else 								return F.False; 					} 				} 			} 			else if (node.ArgCount == 1 && (n == S.Not || n == S.NotBits)) 			{ 				var arg = ReduceBooleanExpr(node[0]); 				if (arg.Value is bool) 					return !(bool)arg.Value ? F.True : F.False; 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,NullCoalesceSet,The following statement contains a magic number: if (a.Count != 2) 				return null;
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,QuickBind,The following statement contains a magic number: if (a.Count == 2) { 				LNode A = a[0]' B = a[1]; 				return F.Vars(F.Missing' F.Assign(B' A)); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,ColonEquals,The following statement contains a magic number: if (a.Count == 2) { 				LNode A = a[0]' B = a[1]; 				return F.Vars(F.Missing' F.Assign(A' B)); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,Namespace,The following statement contains a magic number: if (node.ArgCount == 2 && !node.Args.Last.Calls(S.Braces)) 			{ 				context.DropRemainingNodes = true; 				node = node.PlusArg(F.Braces(context.RemainingNodes).PlusAttr(F.TriviaNewline)); 				// avoid artifact: `namespace Xyz` tends to be on one line' but we don't want the output to be. 				return node.SetStyle(node.Style & ~NodeStyle.OneLiner); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,includeFileBinary,The following statement contains a magic number: if (node.ArgCount == 1 && (filename = context.PreProcess(node[0]).Value as string) != null) { 				var inputFolder = context.ScopedProperties.TryGetValue((Symbol)"#inputFolder"' "").ToString(); 				var path = System.IO.Path.Combine(inputFolder' filename); 				var bytes = File.ReadAllBytes(path); 				var literal = F.Literal(bytes); 				// hex is typically more readable but decimal takes up fewer characters 				if (bytes.Length <= 1024) 					literal.SetBaseStyle(NodeStyle.HexLiteral); 				return literal; 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,staticMatches,The following statement contains a magic number: if (node.ArgCount != 2) 				return null;
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,Constructor,The following statement contains a magic number: if (cons.ArgCount >= 3 && cons.Args[1].IsIdNamed(S.This)) 			{ 				var anc = context.Ancestors; 				LNode space = anc.TryGet(anc.Count - 3' LNode.Missing)' typeName; 				Symbol type = EcsValidators.SpaceDefinitionKind(space); 				if (type != null && anc[anc.Count - 2] == space.Args[2]) { 					typeName = space.Args[0]; 					return cons.WithArgChanged(1' F.Id(KeyNameComponentOf(typeName))); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,Constructor,The following statement contains a magic number: if (cons.ArgCount >= 3 && cons.Args[1].IsIdNamed(S.This)) 			{ 				var anc = context.Ancestors; 				LNode space = anc.TryGet(anc.Count - 3' LNode.Missing)' typeName; 				Symbol type = EcsValidators.SpaceDefinitionKind(space); 				if (type != null && anc[anc.Count - 2] == space.Args[2]) { 					typeName = space.Args[0]; 					return cons.WithArgChanged(1' F.Id(KeyNameComponentOf(typeName))); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,Constructor,The following statement contains a magic number: if (cons.ArgCount >= 3 && cons.Args[1].IsIdNamed(S.This)) 			{ 				var anc = context.Ancestors; 				LNode space = anc.TryGet(anc.Count - 3' LNode.Missing)' typeName; 				Symbol type = EcsValidators.SpaceDefinitionKind(space); 				if (type != null && anc[anc.Count - 2] == space.Args[2]) { 					typeName = space.Args[0]; 					return cons.WithArgChanged(1' F.Id(KeyNameComponentOf(typeName))); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,Constructor,The following statement contains a magic number: if (cons.ArgCount >= 3 && cons.Args[1].IsIdNamed(S.This)) 			{ 				var anc = context.Ancestors; 				LNode space = anc.TryGet(anc.Count - 3' LNode.Missing)' typeName; 				Symbol type = EcsValidators.SpaceDefinitionKind(space); 				if (type != null && anc[anc.Count - 2] == space.Args[2]) { 					typeName = space.Args[0]; 					return cons.WithArgChanged(1' F.Id(KeyNameComponentOf(typeName))); 				} 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,setTupleType,The following statement contains a magic number: if (!rest.Count.IsInRange(1' 2))  				return Reject(context' node' "Incorrect number of arguments");
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,Tuple,The following statement contains a magic number: if (node.IsCall) { 				// Do not change a tuple on the LHS of =>' i.e. `(x' y) => expr` 				if (context.Parent == null || (context.Parent.Calls(S.Lambda' 2) && context.Parent.Args[0].Equals(node))) 					return null; 				var props = context.ScopedProperties; 				var tupleMakers = MaybeInitTupleMakers(props); 				LNode method = (node.ArgCount < tupleMakers.Count  					? tupleMakers[node.ArgCount] : ((Pair<LNode' LNode>)props[DefaultTupleMaker])).B; 				if (method != null) 					return node.WithTarget(method); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,UnpackTuple,The following statement contains a magic number: if (a.Count == 2 && a[0].CallsMin(S.Tuple' 1)) { 				var output = new WList<LNode>(); 				var tuple = a[0].Args; 				var rhs = a[1]; 				 				// Avoid evaluating rhs more than once' if it doesn't look like a simple variable 				rhs = MaybeAddTempVarDecl(context' rhs' output);  				for (int i = 0; i < tuple.Count; i++) { 					var itemi = F.Dot(rhs' F.Id(GSymbol.Get("Item" + (i + 1)))); 					if (tuple[i].Calls(S.Var' 2)) 						output.Add(F.Var(tuple[i].Args[0]' tuple[i].Args[1]' itemi)); 					else 						output.Add(F.Call(S.Assign' tuple[i]' itemi)); 				} 				return F.Call(S.Splice' output.ToVList()); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,UnpackTuple,The following statement contains a magic number: if (a.Count == 2 && a[0].CallsMin(S.Tuple' 1)) { 				var output = new WList<LNode>(); 				var tuple = a[0].Args; 				var rhs = a[1]; 				 				// Avoid evaluating rhs more than once' if it doesn't look like a simple variable 				rhs = MaybeAddTempVarDecl(context' rhs' output);  				for (int i = 0; i < tuple.Count; i++) { 					var itemi = F.Dot(rhs' F.Id(GSymbol.Get("Item" + (i + 1)))); 					if (tuple[i].Calls(S.Var' 2)) 						output.Add(F.Var(tuple[i].Args[0]' tuple[i].Args[1]' itemi)); 					else 						output.Add(F.Call(S.Assign' tuple[i]' itemi)); 				} 				return F.Call(S.Splice' output.ToVList()); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,unroll,The following statement contains a magic number: if (node.ArgCount == 2 && ((clause = node.Args[0]).Calls(@in' 2) || clause.Calls(S.In' 2))) 			{ 				LNode identifiers = clause.Args[0]' cases = clause.Args[1]; 				if (!cases.Calls(S.Tuple) && !cases.Calls(S.Braces) && !cases.Calls(S.Splice)) { 					cases = context.PreProcess(cases); 					if (!cases.Calls(S.Tuple) && !cases.Calls(S.Braces) && !cases.Calls(S.Splice)) 						return Reject(context' cases' "The right-hand side of 'in' should be a tuple or braced block."); 				} 				var result = unroll(identifiers' cases.Args' node.Args[1]' context.Sink); 				if (result != null && node.HasPAttrs()) 					context.Sink.Warning(result.Attrs[0]' "'unroll' does not support attributes."); 				return result; 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,unroll,The following statement contains a magic number: if (node.ArgCount == 2 && ((clause = node.Args[0]).Calls(@in' 2) || clause.Calls(S.In' 2))) 			{ 				LNode identifiers = clause.Args[0]' cases = clause.Args[1]; 				if (!cases.Calls(S.Tuple) && !cases.Calls(S.Braces) && !cases.Calls(S.Splice)) { 					cases = context.PreProcess(cases); 					if (!cases.Calls(S.Tuple) && !cases.Calls(S.Braces) && !cases.Calls(S.Splice)) 						return Reject(context' cases' "The right-hand side of 'in' should be a tuple or braced block."); 				} 				var result = unroll(identifiers' cases.Args' node.Args[1]' context.Sink); 				if (result != null && node.HasPAttrs()) 					context.Sink.Warning(result.Attrs[0]' "'unroll' does not support attributes."); 				return result; 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,unroll,The following statement contains a magic number: if (node.ArgCount == 2 && ((clause = node.Args[0]).Calls(@in' 2) || clause.Calls(S.In' 2))) 			{ 				LNode identifiers = clause.Args[0]' cases = clause.Args[1]; 				if (!cases.Calls(S.Tuple) && !cases.Calls(S.Braces) && !cases.Calls(S.Splice)) { 					cases = context.PreProcess(cases); 					if (!cases.Calls(S.Tuple) && !cases.Calls(S.Braces) && !cases.Calls(S.Splice)) 						return Reject(context' cases' "The right-hand side of 'in' should be a tuple or braced block."); 				} 				var result = unroll(identifiers' cases.Args' node.Args[1]' context.Sink); 				if (result != null && node.HasPAttrs()) 					context.Sink.Warning(result.Attrs[0]' "'unroll' does not support attributes."); 				return result; 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,UseSymbolsCore,The following statement contains a magic number: VList<LNode> output = body.SmartSelect(stmt => stmt.ReplaceRecursive(n => { 				if (!inType && n.ArgCount == 3) { 					// Since we're outside any type' we must avoid creating symbol  					// fields. When we cross into a type then we can start making 					// Symbols by calling ourself recursively with inType=true 					var kind = EcsValidators.SpaceDefinitionKind(n); 					if (kind == S.Class || kind == S.Struct || kind == S.Interface || kind == S.Alias || kind == S.Trait) { 						var body2 = n.Args[2]; 						return n.WithArgChanged(2' UseSymbolsCore(symbolAttrs' options' body2.Args' context' true).WithName(body2.Name)); 					} 				} 				var sym = n.Value as Symbol; 				if (n.IsLiteral && sym != null) 					return symbols[sym] = LNode.Id(prefix + sym.Name); 				return null; 			}));
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,UseSymbolsCore,The following statement contains a magic number: VList<LNode> output = body.SmartSelect(stmt => stmt.ReplaceRecursive(n => { 				if (!inType && n.ArgCount == 3) { 					// Since we're outside any type' we must avoid creating symbol  					// fields. When we cross into a type then we can start making 					// Symbols by calling ourself recursively with inType=true 					var kind = EcsValidators.SpaceDefinitionKind(n); 					if (kind == S.Class || kind == S.Struct || kind == S.Interface || kind == S.Alias || kind == S.Trait) { 						var body2 = n.Args[2]; 						return n.WithArgChanged(2' UseSymbolsCore(symbolAttrs' options' body2.Args' context' true).WithName(body2.Name)); 					} 				} 				var sym = n.Value as Symbol; 				if (n.IsLiteral && sym != null) 					return symbols[sym] = LNode.Id(prefix + sym.Name); 				return null; 			}));
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,UseSymbolsCore,The following statement contains a magic number: VList<LNode> output = body.SmartSelect(stmt => stmt.ReplaceRecursive(n => { 				if (!inType && n.ArgCount == 3) { 					// Since we're outside any type' we must avoid creating symbol  					// fields. When we cross into a type then we can start making 					// Symbols by calling ourself recursively with inType=true 					var kind = EcsValidators.SpaceDefinitionKind(n); 					if (kind == S.Class || kind == S.Struct || kind == S.Interface || kind == S.Alias || kind == S.Trait) { 						var body2 = n.Args[2]; 						return n.WithArgChanged(2' UseSymbolsCore(symbolAttrs' options' body2.Args' context' true).WithName(body2.Name)); 					} 				} 				var sym = n.Value as Symbol; 				if (n.IsLiteral && sym != null) 					return symbols[sym] = LNode.Id(prefix + sym.Name); 				return null; 			}));
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,MergeIdentifiers,The following statement contains a magic number: { 				LNode right1' right2; 				if (right.Calls(CodeSymbols.Dot' 1) && (right2 = right.Args[0]) != null) 					return LNode.Call(CodeSymbols.Dot' LNode.List(left' right2)).SetStyle(NodeStyle.Operator); 				else if (right.Calls(CodeSymbols.Dot' 2) && (right1 = right.Args[0]) != null && (right2 = right.Args[1]) != null) 					return LNode.Call(CodeSymbols.Dot' LNode.List(MergeIdentifiers(left' right1)' right2)).SetStyle(NodeStyle.Operator); 				else 					throw new LogException(Severity.Note' right' "Multi-using statement seems malformed. Correct example: `using System(.Text' .Linq));`"); 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,with,The following statement contains a magic number: if (fn.ArgCount != 2 || !(braces = fn.Args[1]).Calls(S.Braces)) 				return null;
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,IsExpressionContext,The following statement contains a magic number: if (parent.HasSpecialName) { 				if (parent.Name == S.If && index > 0) 					return false; 				if (parent.Name.IsOneOf(S.While' S.UsingStmt' S.Lock' S.Fixed) && index == 1) 					return false; 				if (parent.Name.IsOneOf(S.DoWhile' S.Try) && index == 0) 					return false; 				if (parent.Name == S.For && index == 3) 					return false; 				if (parent.Name == S.ForEach && index == 2) 					return false; 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,IsExpressionContext,The following statement contains a magic number: if (parent.HasSpecialName) { 				if (parent.Name == S.If && index > 0) 					return false; 				if (parent.Name.IsOneOf(S.While' S.UsingStmt' S.Lock' S.Fixed) && index == 1) 					return false; 				if (parent.Name.IsOneOf(S.DoWhile' S.Try) && index == 0) 					return false; 				if (parent.Name == S.For && index == 3) 					return false; 				if (parent.Name == S.ForEach && index == 2) 					return false; 			}
Magic Number,LeMP,StandardMacros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AddLineDirectivesMacro.cs,IsExpressionContext,The following statement contains a magic number: if (ctx.Ancestors.Count <= 2) // unit test context 				return false;
Magic Number,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,ScanClassBody,The following statement contains a magic number: foreach (var stmt in body) { 					int i; 					{ 						LNode altName; 						VList<LNode> attrs' childBody = default(VList<LNode>)' parts' rest; 						if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 3) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true || (attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 4) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true && stmt.Args[3].Calls(CodeSymbols.Braces) && (childBody = stmt.Args[3].Args).IsEmpty | true) { 							LNode genericAltName = altName; 							if (altName.CallsMin(CodeSymbols.Of' 1)) { } else if (_genericArgs.Count > 0) 								genericAltName = LNode.Call(CodeSymbols.Of' LNode.List().Add(altName).AddRange(_genericArgs.ToVList())).SetStyle(NodeStyle.Operator); 							var child = new AltType(attrs' genericAltName' LNode.List()' this); 							child.AddParts(parts); 							child.ScanClassBody(childBody); 							_children.Add(child); 						} else if ((attrs = stmt.Attrs).IsEmpty | true && (i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1 && stmt.CallsMin(CodeSymbols.Constructor' 3) && stmt.Args[1].IsIdNamed((Symbol) "#this") && stmt.Args[2].Calls(CodeSymbols.AltList) && (rest = new VList<LNode>(stmt.Args.Slice(3))).IsEmpty | true && rest.Count <= 1) { 							parts = stmt.Args[2].Args; 							attrs.RemoveAt(i); 							_constructorAttrs.AddRange(attrs); 							if (rest.Count > 0 && rest[0].Calls(S.Braces)) 								_extraConstrLogic.AddRange(rest[0].Args); 							AddParts(parts); 						} else 							_classBody.Add(stmt); 					} 				}
Magic Number,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,ScanClassBody,The following statement contains a magic number: foreach (var stmt in body) { 					int i; 					{ 						LNode altName; 						VList<LNode> attrs' childBody = default(VList<LNode>)' parts' rest; 						if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 3) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true || (attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 4) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true && stmt.Args[3].Calls(CodeSymbols.Braces) && (childBody = stmt.Args[3].Args).IsEmpty | true) { 							LNode genericAltName = altName; 							if (altName.CallsMin(CodeSymbols.Of' 1)) { } else if (_genericArgs.Count > 0) 								genericAltName = LNode.Call(CodeSymbols.Of' LNode.List().Add(altName).AddRange(_genericArgs.ToVList())).SetStyle(NodeStyle.Operator); 							var child = new AltType(attrs' genericAltName' LNode.List()' this); 							child.AddParts(parts); 							child.ScanClassBody(childBody); 							_children.Add(child); 						} else if ((attrs = stmt.Attrs).IsEmpty | true && (i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1 && stmt.CallsMin(CodeSymbols.Constructor' 3) && stmt.Args[1].IsIdNamed((Symbol) "#this") && stmt.Args[2].Calls(CodeSymbols.AltList) && (rest = new VList<LNode>(stmt.Args.Slice(3))).IsEmpty | true && rest.Count <= 1) { 							parts = stmt.Args[2].Args; 							attrs.RemoveAt(i); 							_constructorAttrs.AddRange(attrs); 							if (rest.Count > 0 && rest[0].Calls(S.Braces)) 								_extraConstrLogic.AddRange(rest[0].Args); 							AddParts(parts); 						} else 							_classBody.Add(stmt); 					} 				}
Magic Number,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,ScanClassBody,The following statement contains a magic number: foreach (var stmt in body) { 					int i; 					{ 						LNode altName; 						VList<LNode> attrs' childBody = default(VList<LNode>)' parts' rest; 						if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 3) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true || (attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 4) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true && stmt.Args[3].Calls(CodeSymbols.Braces) && (childBody = stmt.Args[3].Args).IsEmpty | true) { 							LNode genericAltName = altName; 							if (altName.CallsMin(CodeSymbols.Of' 1)) { } else if (_genericArgs.Count > 0) 								genericAltName = LNode.Call(CodeSymbols.Of' LNode.List().Add(altName).AddRange(_genericArgs.ToVList())).SetStyle(NodeStyle.Operator); 							var child = new AltType(attrs' genericAltName' LNode.List()' this); 							child.AddParts(parts); 							child.ScanClassBody(childBody); 							_children.Add(child); 						} else if ((attrs = stmt.Attrs).IsEmpty | true && (i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1 && stmt.CallsMin(CodeSymbols.Constructor' 3) && stmt.Args[1].IsIdNamed((Symbol) "#this") && stmt.Args[2].Calls(CodeSymbols.AltList) && (rest = new VList<LNode>(stmt.Args.Slice(3))).IsEmpty | true && rest.Count <= 1) { 							parts = stmt.Args[2].Args; 							attrs.RemoveAt(i); 							_constructorAttrs.AddRange(attrs); 							if (rest.Count > 0 && rest[0].Calls(S.Braces)) 								_extraConstrLogic.AddRange(rest[0].Args); 							AddParts(parts); 						} else 							_classBody.Add(stmt); 					} 				}
Magic Number,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,ScanClassBody,The following statement contains a magic number: foreach (var stmt in body) { 					int i; 					{ 						LNode altName; 						VList<LNode> attrs' childBody = default(VList<LNode>)' parts' rest; 						if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 3) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true || (attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 4) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true && stmt.Args[3].Calls(CodeSymbols.Braces) && (childBody = stmt.Args[3].Args).IsEmpty | true) { 							LNode genericAltName = altName; 							if (altName.CallsMin(CodeSymbols.Of' 1)) { } else if (_genericArgs.Count > 0) 								genericAltName = LNode.Call(CodeSymbols.Of' LNode.List().Add(altName).AddRange(_genericArgs.ToVList())).SetStyle(NodeStyle.Operator); 							var child = new AltType(attrs' genericAltName' LNode.List()' this); 							child.AddParts(parts); 							child.ScanClassBody(childBody); 							_children.Add(child); 						} else if ((attrs = stmt.Attrs).IsEmpty | true && (i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1 && stmt.CallsMin(CodeSymbols.Constructor' 3) && stmt.Args[1].IsIdNamed((Symbol) "#this") && stmt.Args[2].Calls(CodeSymbols.AltList) && (rest = new VList<LNode>(stmt.Args.Slice(3))).IsEmpty | true && rest.Count <= 1) { 							parts = stmt.Args[2].Args; 							attrs.RemoveAt(i); 							_constructorAttrs.AddRange(attrs); 							if (rest.Count > 0 && rest[0].Calls(S.Braces)) 								_extraConstrLogic.AddRange(rest[0].Args); 							AddParts(parts); 						} else 							_classBody.Add(stmt); 					} 				}
Magic Number,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,ScanClassBody,The following statement contains a magic number: foreach (var stmt in body) { 					int i; 					{ 						LNode altName; 						VList<LNode> attrs' childBody = default(VList<LNode>)' parts' rest; 						if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 3) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true || (attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 4) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true && stmt.Args[3].Calls(CodeSymbols.Braces) && (childBody = stmt.Args[3].Args).IsEmpty | true) { 							LNode genericAltName = altName; 							if (altName.CallsMin(CodeSymbols.Of' 1)) { } else if (_genericArgs.Count > 0) 								genericAltName = LNode.Call(CodeSymbols.Of' LNode.List().Add(altName).AddRange(_genericArgs.ToVList())).SetStyle(NodeStyle.Operator); 							var child = new AltType(attrs' genericAltName' LNode.List()' this); 							child.AddParts(parts); 							child.ScanClassBody(childBody); 							_children.Add(child); 						} else if ((attrs = stmt.Attrs).IsEmpty | true && (i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1 && stmt.CallsMin(CodeSymbols.Constructor' 3) && stmt.Args[1].IsIdNamed((Symbol) "#this") && stmt.Args[2].Calls(CodeSymbols.AltList) && (rest = new VList<LNode>(stmt.Args.Slice(3))).IsEmpty | true && rest.Count <= 1) { 							parts = stmt.Args[2].Args; 							attrs.RemoveAt(i); 							_constructorAttrs.AddRange(attrs); 							if (rest.Count > 0 && rest[0].Calls(S.Braces)) 								_extraConstrLogic.AddRange(rest[0].Args); 							AddParts(parts); 						} else 							_classBody.Add(stmt); 					} 				}
Magic Number,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,ScanClassBody,The following statement contains a magic number: foreach (var stmt in body) { 					int i; 					{ 						LNode altName; 						VList<LNode> attrs' childBody = default(VList<LNode>)' parts' rest; 						if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 3) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true || (attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 4) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true && stmt.Args[3].Calls(CodeSymbols.Braces) && (childBody = stmt.Args[3].Args).IsEmpty | true) { 							LNode genericAltName = altName; 							if (altName.CallsMin(CodeSymbols.Of' 1)) { } else if (_genericArgs.Count > 0) 								genericAltName = LNode.Call(CodeSymbols.Of' LNode.List().Add(altName).AddRange(_genericArgs.ToVList())).SetStyle(NodeStyle.Operator); 							var child = new AltType(attrs' genericAltName' LNode.List()' this); 							child.AddParts(parts); 							child.ScanClassBody(childBody); 							_children.Add(child); 						} else if ((attrs = stmt.Attrs).IsEmpty | true && (i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1 && stmt.CallsMin(CodeSymbols.Constructor' 3) && stmt.Args[1].IsIdNamed((Symbol) "#this") && stmt.Args[2].Calls(CodeSymbols.AltList) && (rest = new VList<LNode>(stmt.Args.Slice(3))).IsEmpty | true && rest.Count <= 1) { 							parts = stmt.Args[2].Args; 							attrs.RemoveAt(i); 							_constructorAttrs.AddRange(attrs); 							if (rest.Count > 0 && rest[0].Calls(S.Braces)) 								_extraConstrLogic.AddRange(rest[0].Args); 							AddParts(parts); 						} else 							_classBody.Add(stmt); 					} 				}
Magic Number,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,ScanClassBody,The following statement contains a magic number: foreach (var stmt in body) { 					int i; 					{ 						LNode altName; 						VList<LNode> attrs' childBody = default(VList<LNode>)' parts' rest; 						if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 3) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true || (attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 4) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true && stmt.Args[3].Calls(CodeSymbols.Braces) && (childBody = stmt.Args[3].Args).IsEmpty | true) { 							LNode genericAltName = altName; 							if (altName.CallsMin(CodeSymbols.Of' 1)) { } else if (_genericArgs.Count > 0) 								genericAltName = LNode.Call(CodeSymbols.Of' LNode.List().Add(altName).AddRange(_genericArgs.ToVList())).SetStyle(NodeStyle.Operator); 							var child = new AltType(attrs' genericAltName' LNode.List()' this); 							child.AddParts(parts); 							child.ScanClassBody(childBody); 							_children.Add(child); 						} else if ((attrs = stmt.Attrs).IsEmpty | true && (i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1 && stmt.CallsMin(CodeSymbols.Constructor' 3) && stmt.Args[1].IsIdNamed((Symbol) "#this") && stmt.Args[2].Calls(CodeSymbols.AltList) && (rest = new VList<LNode>(stmt.Args.Slice(3))).IsEmpty | true && rest.Count <= 1) { 							parts = stmt.Args[2].Args; 							attrs.RemoveAt(i); 							_constructorAttrs.AddRange(attrs); 							if (rest.Count > 0 && rest[0].Calls(S.Braces)) 								_extraConstrLogic.AddRange(rest[0].Args); 							AddParts(parts); 						} else 							_classBody.Add(stmt); 					} 				}
Magic Number,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,ScanClassBody,The following statement contains a magic number: foreach (var stmt in body) { 					int i; 					{ 						LNode altName; 						VList<LNode> attrs' childBody = default(VList<LNode>)' parts' rest; 						if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 3) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true || (attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 4) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true && stmt.Args[3].Calls(CodeSymbols.Braces) && (childBody = stmt.Args[3].Args).IsEmpty | true) { 							LNode genericAltName = altName; 							if (altName.CallsMin(CodeSymbols.Of' 1)) { } else if (_genericArgs.Count > 0) 								genericAltName = LNode.Call(CodeSymbols.Of' LNode.List().Add(altName).AddRange(_genericArgs.ToVList())).SetStyle(NodeStyle.Operator); 							var child = new AltType(attrs' genericAltName' LNode.List()' this); 							child.AddParts(parts); 							child.ScanClassBody(childBody); 							_children.Add(child); 						} else if ((attrs = stmt.Attrs).IsEmpty | true && (i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1 && stmt.CallsMin(CodeSymbols.Constructor' 3) && stmt.Args[1].IsIdNamed((Symbol) "#this") && stmt.Args[2].Calls(CodeSymbols.AltList) && (rest = new VList<LNode>(stmt.Args.Slice(3))).IsEmpty | true && rest.Count <= 1) { 							parts = stmt.Args[2].Args; 							attrs.RemoveAt(i); 							_constructorAttrs.AddRange(attrs); 							if (rest.Count > 0 && rest[0].Calls(S.Braces)) 								_extraConstrLogic.AddRange(rest[0].Args); 							AddParts(parts); 						} else 							_classBody.Add(stmt); 					} 				}
Magic Number,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,ScanClassBody,The following statement contains a magic number: foreach (var stmt in body) { 					int i; 					{ 						LNode altName; 						VList<LNode> attrs' childBody = default(VList<LNode>)' parts' rest; 						if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 3) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true || (attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 4) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true && stmt.Args[3].Calls(CodeSymbols.Braces) && (childBody = stmt.Args[3].Args).IsEmpty | true) { 							LNode genericAltName = altName; 							if (altName.CallsMin(CodeSymbols.Of' 1)) { } else if (_genericArgs.Count > 0) 								genericAltName = LNode.Call(CodeSymbols.Of' LNode.List().Add(altName).AddRange(_genericArgs.ToVList())).SetStyle(NodeStyle.Operator); 							var child = new AltType(attrs' genericAltName' LNode.List()' this); 							child.AddParts(parts); 							child.ScanClassBody(childBody); 							_children.Add(child); 						} else if ((attrs = stmt.Attrs).IsEmpty | true && (i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1 && stmt.CallsMin(CodeSymbols.Constructor' 3) && stmt.Args[1].IsIdNamed((Symbol) "#this") && stmt.Args[2].Calls(CodeSymbols.AltList) && (rest = new VList<LNode>(stmt.Args.Slice(3))).IsEmpty | true && rest.Count <= 1) { 							parts = stmt.Args[2].Args; 							attrs.RemoveAt(i); 							_constructorAttrs.AddRange(attrs); 							if (rest.Count > 0 && rest[0].Calls(S.Braces)) 								_extraConstrLogic.AddRange(rest[0].Args); 							AddParts(parts); 						} else 							_classBody.Add(stmt); 					} 				}
Magic Number,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,ScanClassBody,The following statement contains a magic number: foreach (var stmt in body) { 					int i; 					{ 						LNode altName; 						VList<LNode> attrs' childBody = default(VList<LNode>)' parts' rest; 						if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 3) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true || (attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 4) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true && stmt.Args[3].Calls(CodeSymbols.Braces) && (childBody = stmt.Args[3].Args).IsEmpty | true) { 							LNode genericAltName = altName; 							if (altName.CallsMin(CodeSymbols.Of' 1)) { } else if (_genericArgs.Count > 0) 								genericAltName = LNode.Call(CodeSymbols.Of' LNode.List().Add(altName).AddRange(_genericArgs.ToVList())).SetStyle(NodeStyle.Operator); 							var child = new AltType(attrs' genericAltName' LNode.List()' this); 							child.AddParts(parts); 							child.ScanClassBody(childBody); 							_children.Add(child); 						} else if ((attrs = stmt.Attrs).IsEmpty | true && (i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1 && stmt.CallsMin(CodeSymbols.Constructor' 3) && stmt.Args[1].IsIdNamed((Symbol) "#this") && stmt.Args[2].Calls(CodeSymbols.AltList) && (rest = new VList<LNode>(stmt.Args.Slice(3))).IsEmpty | true && rest.Count <= 1) { 							parts = stmt.Args[2].Args; 							attrs.RemoveAt(i); 							_constructorAttrs.AddRange(attrs); 							if (rest.Count > 0 && rest[0].Calls(S.Braces)) 								_extraConstrLogic.AddRange(rest[0].Args); 							AddParts(parts); 						} else 							_classBody.Add(stmt); 					} 				}
Magic Number,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,ScanClassBody,The following statement contains a magic number: foreach (var stmt in body) { 					int i; 					{ 						LNode altName; 						VList<LNode> attrs' childBody = default(VList<LNode>)' parts' rest; 						if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 3) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true || (attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 4) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true && stmt.Args[3].Calls(CodeSymbols.Braces) && (childBody = stmt.Args[3].Args).IsEmpty | true) { 							LNode genericAltName = altName; 							if (altName.CallsMin(CodeSymbols.Of' 1)) { } else if (_genericArgs.Count > 0) 								genericAltName = LNode.Call(CodeSymbols.Of' LNode.List().Add(altName).AddRange(_genericArgs.ToVList())).SetStyle(NodeStyle.Operator); 							var child = new AltType(attrs' genericAltName' LNode.List()' this); 							child.AddParts(parts); 							child.ScanClassBody(childBody); 							_children.Add(child); 						} else if ((attrs = stmt.Attrs).IsEmpty | true && (i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1 && stmt.CallsMin(CodeSymbols.Constructor' 3) && stmt.Args[1].IsIdNamed((Symbol) "#this") && stmt.Args[2].Calls(CodeSymbols.AltList) && (rest = new VList<LNode>(stmt.Args.Slice(3))).IsEmpty | true && rest.Count <= 1) { 							parts = stmt.Args[2].Args; 							attrs.RemoveAt(i); 							_constructorAttrs.AddRange(attrs); 							if (rest.Count > 0 && rest[0].Calls(S.Braces)) 								_extraConstrLogic.AddRange(rest[0].Args); 							AddParts(parts); 						} else 							_classBody.Add(stmt); 					} 				}
Magic Number,LeMP,AltType,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,ScanClassBody,The following statement contains a magic number: foreach (var stmt in body) { 					int i; 					{ 						LNode altName; 						VList<LNode> attrs' childBody = default(VList<LNode>)' parts' rest; 						if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 3) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true || (attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fn' 4) && stmt.Args[0].IsIdNamed((Symbol) "alt") && (altName = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (parts = stmt.Args[2].Args).IsEmpty | true && stmt.Args[3].Calls(CodeSymbols.Braces) && (childBody = stmt.Args[3].Args).IsEmpty | true) { 							LNode genericAltName = altName; 							if (altName.CallsMin(CodeSymbols.Of' 1)) { } else if (_genericArgs.Count > 0) 								genericAltName = LNode.Call(CodeSymbols.Of' LNode.List().Add(altName).AddRange(_genericArgs.ToVList())).SetStyle(NodeStyle.Operator); 							var child = new AltType(attrs' genericAltName' LNode.List()' this); 							child.AddParts(parts); 							child.ScanClassBody(childBody); 							_children.Add(child); 						} else if ((attrs = stmt.Attrs).IsEmpty | true && (i = attrs.IndexWhere(a => a.IsIdNamed(__alt))) > -1 && stmt.CallsMin(CodeSymbols.Constructor' 3) && stmt.Args[1].IsIdNamed((Symbol) "#this") && stmt.Args[2].Calls(CodeSymbols.AltList) && (rest = new VList<LNode>(stmt.Args.Slice(3))).IsEmpty | true && rest.Count <= 1) { 							parts = stmt.Args[2].Args; 							attrs.RemoveAt(i); 							_constructorAttrs.AddRange(attrs); 							if (rest.Count > 0 && rest[0].Calls(S.Braces)) 								_extraConstrLogic.AddRange(rest[0].Args); 							AddParts(parts); 						} else 							_classBody.Add(stmt); 					} 				}
Magic Number,LeMP,AdtParam,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,AdtParam,The following statement contains a magic number: if (!OriginalDecl.Calls(S.Var' 2)) 					throw new LogException(OriginalDecl' "alt: Expected a variable declaration");
Magic Number,LeMP,AdtParam,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\AlgebraicDataType.out.cs,AdtParam,The following statement contains a magic number: if (NameId.Calls(S.Assign' 2)) 					NameId = NameId.Args[0];
Magic Number,LeMP,CodeContractRewriter,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\ContractsMacro.out.cs,ConditionToStringLit,The following statement contains a magic number: while (methodName.CallsMin(S.Dot' 2)) 					methodName = methodName.Args.Last;
Magic Number,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,GetSubstitutionVar,The following statement contains a magic number: if (expr.Calls(S.Substitute' 1)) 				{ 					LNode id = expr.Args[0]; 					if (id.AttrNamed(S.Params) != null) 						isParams = true; 					else if (id.Calls(S.DotDotDot' 1) || id.Calls(S.DotDot' 1)) { 						isParams = true; 						id = id.Args[0]; 					} 				 					if (id.AttrNamed(S.Ref) != null) 						refExistingVar = true; 				 					if (id.Calls(S.IndexBracks' 2)) { 						// old style 						condition = id.Args[1]; 						id = id.Args[0]; 					} else 						while (id.Calls(S.And' 2)) { 							// new style (recommended) 							condition = condition == null ? id.Args[1] : LNode.Call(CodeSymbols.And' LNode.List(id.Args[1]' condition)).SetStyle(NodeStyle.Operator); 							id = id.Args[0]; 						} 				 					if (condition != null) 						condition = condition.ReplaceRecursive(n => n.IsIdNamed(S._HashMark) ? id : null); 					if (!id.IsId) 						return null; 					return id.Name; 				}
Magic Number,LeMP,CodeMatchContext,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchCode.out.cs,GetSubstitutionVar,The following statement contains a magic number: if (expr.Calls(S.Substitute' 1)) 				{ 					LNode id = expr.Args[0]; 					if (id.AttrNamed(S.Params) != null) 						isParams = true; 					else if (id.Calls(S.DotDotDot' 1) || id.Calls(S.DotDot' 1)) { 						isParams = true; 						id = id.Args[0]; 					} 				 					if (id.AttrNamed(S.Ref) != null) 						refExistingVar = true; 				 					if (id.Calls(S.IndexBracks' 2)) { 						// old style 						condition = id.Args[1]; 						id = id.Args[0]; 					} else 						while (id.Calls(S.And' 2)) { 							// new style (recommended) 							condition = condition == null ? id.Args[1] : LNode.Call(CodeSymbols.And' LNode.List(id.Args[1]' condition)).SetStyle(NodeStyle.Operator); 							id = id.Args[0]; 						} 				 					if (condition != null) 						condition = condition.ReplaceRecursive(n => n.IsIdNamed(S._HashMark) ? id : null); 					if (!id.IsId) 						return null; 					return id.Name; 				}
Magic Number,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GenCodeForPattern,The following statement contains a magic number: for (int itemIndex = 0; itemIndex < subPatterns.Count; itemIndex++) { 					var subPattern = subPatterns[itemIndex]; 					LNode propName; 					// Recognize `propName:` in front of the subpattern (fun fact: we  					// can't use `matchCode` to detect a named parameter here' because if  					// we write `case { $propName: $subPattern; }:` it is parsed as a  					// goto-label' not as a named parameter.) 					if (subPattern.Calls(S.NamedArg' 2) || subPattern.Calls(S.Colon' 2)) { 						propName = subPattern[0]; 						subPattern = subPattern[1]; 					} else 						propName = LNode.Id("Item" + (itemIndex + 1)' subPattern); 				 					GenCodeForPattern(LNode.Call(CodeSymbols.Dot' LNode.List(input' propName)).SetStyle(NodeStyle.Operator)' subPattern); 				}
Magic Number,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GenCodeForPattern,The following statement contains a magic number: for (int itemIndex = 0; itemIndex < subPatterns.Count; itemIndex++) { 					var subPattern = subPatterns[itemIndex]; 					LNode propName; 					// Recognize `propName:` in front of the subpattern (fun fact: we  					// can't use `matchCode` to detect a named parameter here' because if  					// we write `case { $propName: $subPattern; }:` it is parsed as a  					// goto-label' not as a named parameter.) 					if (subPattern.Calls(S.NamedArg' 2) || subPattern.Calls(S.Colon' 2)) { 						propName = subPattern[0]; 						subPattern = subPattern[1]; 					} else 						propName = LNode.Id("Item" + (itemIndex + 1)' subPattern); 				 					GenCodeForPattern(LNode.Call(CodeSymbols.Dot' LNode.List(input' propName)).SetStyle(NodeStyle.Operator)' subPattern); 				}
Magic Number,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The following statement contains a magic number: while (pattern.Calls(S.And' 2)) { 					conditions.Add(pattern.Args.Last); 					pattern = pattern.Args[0]; 				}
Magic Number,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The following statement contains a magic number: for (int pass = 1; pass <= 3; pass++) { 					LNode inRange2 = inRange' isType2 = isType; 					{ 						LNode patternL; 						if (pattern.Calls(CodeSymbols.In' 2) && (patternL = pattern.Args[0]) != null && (inRange = pattern.Args[1]) != null || pattern.Calls((Symbol) "in"' 2) && (patternL = pattern.Args[0]) != null && (inRange = pattern.Args[1]) != null) { 							pattern = patternL; 							if (inRange2 != null) 								_context.Sink.Error(inRange2' "match-case does not support multiple 'in' operators"); 						} else if (pattern.Calls(CodeSymbols.Is' 2) && (cmpExprOrBinding = pattern.Args[0]) != null && (isType = pattern.Args[1]) != null || pattern.Calls((Symbol) "is"' 2) && (cmpExprOrBinding = pattern.Args[0]) != null && (isType = pattern.Args[1]) != null) { 							pattern = cmpExprOrBinding; 							if (isType2 != null) 								_context.Sink.Error(isType2' "match-case does not support multiple 'is' operators"); 						} else if (pattern.Calls(CodeSymbols.Is' 1) && (isType = pattern.Args[0]) != null || pattern.Calls((Symbol) "is"' 1) && (isType = pattern.Args[0]) != null) { 							if (isType2 != null) 								_context.Sink.Error(isType2' "match-case does not support multiple 'is' operators"); 							goto doneAnalysis; 						} else if (pattern.Calls(CodeSymbols.DotDotDot' 2) || pattern.Calls(CodeSymbols.DotDot' 2) || pattern.Calls(CodeSymbols.DotDotDot' 1) || pattern.Calls(CodeSymbols.DotDot' 1)) { 							inRange = pattern; 							goto doneAnalysis; 						} else if (pattern.Calls(CodeSymbols.Tuple)) { 							subPatterns = pattern.Args; 							cmpExprOrBinding = null; 						} else { 							// It's very tempting to detect NodeStyle.PrefixNotation to distinguish'  							// say' A.B<C> from id(A' B' C)' but I'm reluctant to do so. BaseStyle  							// is by convention "unsemantic" and not guaranteed to be preserved  							// across serializations or supported the same way by different parsers.  							// So instead of asking "is this in PrefixNotation?" I ask "does the  							// target appear to be a normal identifier?"  							LNode target = pattern.Target; 							if (!haveSubPatterns && pattern.IsCall && (!target.IsId || target.AttrNamed(S.TriviaInParens) != null || (!target.HasSpecialName && Les2Printer.IsNormalIdentifier(target.Name))) 							) 						 							{ 								haveSubPatterns = true; 								subPatterns = pattern.Args; 								pattern = pattern.Target; 							} else 								cmpExprOrBinding = pattern; 						} 					} 				}
Magic Number,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The following statement contains a magic number: for (int pass = 1; pass <= 3; pass++) { 					LNode inRange2 = inRange' isType2 = isType; 					{ 						LNode patternL; 						if (pattern.Calls(CodeSymbols.In' 2) && (patternL = pattern.Args[0]) != null && (inRange = pattern.Args[1]) != null || pattern.Calls((Symbol) "in"' 2) && (patternL = pattern.Args[0]) != null && (inRange = pattern.Args[1]) != null) { 							pattern = patternL; 							if (inRange2 != null) 								_context.Sink.Error(inRange2' "match-case does not support multiple 'in' operators"); 						} else if (pattern.Calls(CodeSymbols.Is' 2) && (cmpExprOrBinding = pattern.Args[0]) != null && (isType = pattern.Args[1]) != null || pattern.Calls((Symbol) "is"' 2) && (cmpExprOrBinding = pattern.Args[0]) != null && (isType = pattern.Args[1]) != null) { 							pattern = cmpExprOrBinding; 							if (isType2 != null) 								_context.Sink.Error(isType2' "match-case does not support multiple 'is' operators"); 						} else if (pattern.Calls(CodeSymbols.Is' 1) && (isType = pattern.Args[0]) != null || pattern.Calls((Symbol) "is"' 1) && (isType = pattern.Args[0]) != null) { 							if (isType2 != null) 								_context.Sink.Error(isType2' "match-case does not support multiple 'is' operators"); 							goto doneAnalysis; 						} else if (pattern.Calls(CodeSymbols.DotDotDot' 2) || pattern.Calls(CodeSymbols.DotDot' 2) || pattern.Calls(CodeSymbols.DotDotDot' 1) || pattern.Calls(CodeSymbols.DotDot' 1)) { 							inRange = pattern; 							goto doneAnalysis; 						} else if (pattern.Calls(CodeSymbols.Tuple)) { 							subPatterns = pattern.Args; 							cmpExprOrBinding = null; 						} else { 							// It's very tempting to detect NodeStyle.PrefixNotation to distinguish'  							// say' A.B<C> from id(A' B' C)' but I'm reluctant to do so. BaseStyle  							// is by convention "unsemantic" and not guaranteed to be preserved  							// across serializations or supported the same way by different parsers.  							// So instead of asking "is this in PrefixNotation?" I ask "does the  							// target appear to be a normal identifier?"  							LNode target = pattern.Target; 							if (!haveSubPatterns && pattern.IsCall && (!target.IsId || target.AttrNamed(S.TriviaInParens) != null || (!target.HasSpecialName && Les2Printer.IsNormalIdentifier(target.Name))) 							) 						 							{ 								haveSubPatterns = true; 								subPatterns = pattern.Args; 								pattern = pattern.Target; 							} else 								cmpExprOrBinding = pattern; 						} 					} 				}
Magic Number,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The following statement contains a magic number: for (int pass = 1; pass <= 3; pass++) { 					LNode inRange2 = inRange' isType2 = isType; 					{ 						LNode patternL; 						if (pattern.Calls(CodeSymbols.In' 2) && (patternL = pattern.Args[0]) != null && (inRange = pattern.Args[1]) != null || pattern.Calls((Symbol) "in"' 2) && (patternL = pattern.Args[0]) != null && (inRange = pattern.Args[1]) != null) { 							pattern = patternL; 							if (inRange2 != null) 								_context.Sink.Error(inRange2' "match-case does not support multiple 'in' operators"); 						} else if (pattern.Calls(CodeSymbols.Is' 2) && (cmpExprOrBinding = pattern.Args[0]) != null && (isType = pattern.Args[1]) != null || pattern.Calls((Symbol) "is"' 2) && (cmpExprOrBinding = pattern.Args[0]) != null && (isType = pattern.Args[1]) != null) { 							pattern = cmpExprOrBinding; 							if (isType2 != null) 								_context.Sink.Error(isType2' "match-case does not support multiple 'is' operators"); 						} else if (pattern.Calls(CodeSymbols.Is' 1) && (isType = pattern.Args[0]) != null || pattern.Calls((Symbol) "is"' 1) && (isType = pattern.Args[0]) != null) { 							if (isType2 != null) 								_context.Sink.Error(isType2' "match-case does not support multiple 'is' operators"); 							goto doneAnalysis; 						} else if (pattern.Calls(CodeSymbols.DotDotDot' 2) || pattern.Calls(CodeSymbols.DotDot' 2) || pattern.Calls(CodeSymbols.DotDotDot' 1) || pattern.Calls(CodeSymbols.DotDot' 1)) { 							inRange = pattern; 							goto doneAnalysis; 						} else if (pattern.Calls(CodeSymbols.Tuple)) { 							subPatterns = pattern.Args; 							cmpExprOrBinding = null; 						} else { 							// It's very tempting to detect NodeStyle.PrefixNotation to distinguish'  							// say' A.B<C> from id(A' B' C)' but I'm reluctant to do so. BaseStyle  							// is by convention "unsemantic" and not guaranteed to be preserved  							// across serializations or supported the same way by different parsers.  							// So instead of asking "is this in PrefixNotation?" I ask "does the  							// target appear to be a normal identifier?"  							LNode target = pattern.Target; 							if (!haveSubPatterns && pattern.IsCall && (!target.IsId || target.AttrNamed(S.TriviaInParens) != null || (!target.HasSpecialName && Les2Printer.IsNormalIdentifier(target.Name))) 							) 						 							{ 								haveSubPatterns = true; 								subPatterns = pattern.Args; 								pattern = pattern.Target; 							} else 								cmpExprOrBinding = pattern; 						} 					} 				}
Magic Number,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The following statement contains a magic number: for (int pass = 1; pass <= 3; pass++) { 					LNode inRange2 = inRange' isType2 = isType; 					{ 						LNode patternL; 						if (pattern.Calls(CodeSymbols.In' 2) && (patternL = pattern.Args[0]) != null && (inRange = pattern.Args[1]) != null || pattern.Calls((Symbol) "in"' 2) && (patternL = pattern.Args[0]) != null && (inRange = pattern.Args[1]) != null) { 							pattern = patternL; 							if (inRange2 != null) 								_context.Sink.Error(inRange2' "match-case does not support multiple 'in' operators"); 						} else if (pattern.Calls(CodeSymbols.Is' 2) && (cmpExprOrBinding = pattern.Args[0]) != null && (isType = pattern.Args[1]) != null || pattern.Calls((Symbol) "is"' 2) && (cmpExprOrBinding = pattern.Args[0]) != null && (isType = pattern.Args[1]) != null) { 							pattern = cmpExprOrBinding; 							if (isType2 != null) 								_context.Sink.Error(isType2' "match-case does not support multiple 'is' operators"); 						} else if (pattern.Calls(CodeSymbols.Is' 1) && (isType = pattern.Args[0]) != null || pattern.Calls((Symbol) "is"' 1) && (isType = pattern.Args[0]) != null) { 							if (isType2 != null) 								_context.Sink.Error(isType2' "match-case does not support multiple 'is' operators"); 							goto doneAnalysis; 						} else if (pattern.Calls(CodeSymbols.DotDotDot' 2) || pattern.Calls(CodeSymbols.DotDot' 2) || pattern.Calls(CodeSymbols.DotDotDot' 1) || pattern.Calls(CodeSymbols.DotDot' 1)) { 							inRange = pattern; 							goto doneAnalysis; 						} else if (pattern.Calls(CodeSymbols.Tuple)) { 							subPatterns = pattern.Args; 							cmpExprOrBinding = null; 						} else { 							// It's very tempting to detect NodeStyle.PrefixNotation to distinguish'  							// say' A.B<C> from id(A' B' C)' but I'm reluctant to do so. BaseStyle  							// is by convention "unsemantic" and not guaranteed to be preserved  							// across serializations or supported the same way by different parsers.  							// So instead of asking "is this in PrefixNotation?" I ask "does the  							// target appear to be a normal identifier?"  							LNode target = pattern.Target; 							if (!haveSubPatterns && pattern.IsCall && (!target.IsId || target.AttrNamed(S.TriviaInParens) != null || (!target.HasSpecialName && Les2Printer.IsNormalIdentifier(target.Name))) 							) 						 							{ 								haveSubPatterns = true; 								subPatterns = pattern.Args; 								pattern = pattern.Target; 							} else 								cmpExprOrBinding = pattern; 						} 					} 				}
Magic Number,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The following statement contains a magic number: for (int pass = 1; pass <= 3; pass++) { 					LNode inRange2 = inRange' isType2 = isType; 					{ 						LNode patternL; 						if (pattern.Calls(CodeSymbols.In' 2) && (patternL = pattern.Args[0]) != null && (inRange = pattern.Args[1]) != null || pattern.Calls((Symbol) "in"' 2) && (patternL = pattern.Args[0]) != null && (inRange = pattern.Args[1]) != null) { 							pattern = patternL; 							if (inRange2 != null) 								_context.Sink.Error(inRange2' "match-case does not support multiple 'in' operators"); 						} else if (pattern.Calls(CodeSymbols.Is' 2) && (cmpExprOrBinding = pattern.Args[0]) != null && (isType = pattern.Args[1]) != null || pattern.Calls((Symbol) "is"' 2) && (cmpExprOrBinding = pattern.Args[0]) != null && (isType = pattern.Args[1]) != null) { 							pattern = cmpExprOrBinding; 							if (isType2 != null) 								_context.Sink.Error(isType2' "match-case does not support multiple 'is' operators"); 						} else if (pattern.Calls(CodeSymbols.Is' 1) && (isType = pattern.Args[0]) != null || pattern.Calls((Symbol) "is"' 1) && (isType = pattern.Args[0]) != null) { 							if (isType2 != null) 								_context.Sink.Error(isType2' "match-case does not support multiple 'is' operators"); 							goto doneAnalysis; 						} else if (pattern.Calls(CodeSymbols.DotDotDot' 2) || pattern.Calls(CodeSymbols.DotDot' 2) || pattern.Calls(CodeSymbols.DotDotDot' 1) || pattern.Calls(CodeSymbols.DotDot' 1)) { 							inRange = pattern; 							goto doneAnalysis; 						} else if (pattern.Calls(CodeSymbols.Tuple)) { 							subPatterns = pattern.Args; 							cmpExprOrBinding = null; 						} else { 							// It's very tempting to detect NodeStyle.PrefixNotation to distinguish'  							// say' A.B<C> from id(A' B' C)' but I'm reluctant to do so. BaseStyle  							// is by convention "unsemantic" and not guaranteed to be preserved  							// across serializations or supported the same way by different parsers.  							// So instead of asking "is this in PrefixNotation?" I ask "does the  							// target appear to be a normal identifier?"  							LNode target = pattern.Target; 							if (!haveSubPatterns && pattern.IsCall && (!target.IsId || target.AttrNamed(S.TriviaInParens) != null || (!target.HasSpecialName && Les2Printer.IsNormalIdentifier(target.Name))) 							) 						 							{ 								haveSubPatterns = true; 								subPatterns = pattern.Args; 								pattern = pattern.Target; 							} else 								cmpExprOrBinding = pattern; 						} 					} 				}
Magic Number,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The following statement contains a magic number: for (int pass = 1; pass <= 3; pass++) { 					LNode inRange2 = inRange' isType2 = isType; 					{ 						LNode patternL; 						if (pattern.Calls(CodeSymbols.In' 2) && (patternL = pattern.Args[0]) != null && (inRange = pattern.Args[1]) != null || pattern.Calls((Symbol) "in"' 2) && (patternL = pattern.Args[0]) != null && (inRange = pattern.Args[1]) != null) { 							pattern = patternL; 							if (inRange2 != null) 								_context.Sink.Error(inRange2' "match-case does not support multiple 'in' operators"); 						} else if (pattern.Calls(CodeSymbols.Is' 2) && (cmpExprOrBinding = pattern.Args[0]) != null && (isType = pattern.Args[1]) != null || pattern.Calls((Symbol) "is"' 2) && (cmpExprOrBinding = pattern.Args[0]) != null && (isType = pattern.Args[1]) != null) { 							pattern = cmpExprOrBinding; 							if (isType2 != null) 								_context.Sink.Error(isType2' "match-case does not support multiple 'is' operators"); 						} else if (pattern.Calls(CodeSymbols.Is' 1) && (isType = pattern.Args[0]) != null || pattern.Calls((Symbol) "is"' 1) && (isType = pattern.Args[0]) != null) { 							if (isType2 != null) 								_context.Sink.Error(isType2' "match-case does not support multiple 'is' operators"); 							goto doneAnalysis; 						} else if (pattern.Calls(CodeSymbols.DotDotDot' 2) || pattern.Calls(CodeSymbols.DotDot' 2) || pattern.Calls(CodeSymbols.DotDotDot' 1) || pattern.Calls(CodeSymbols.DotDot' 1)) { 							inRange = pattern; 							goto doneAnalysis; 						} else if (pattern.Calls(CodeSymbols.Tuple)) { 							subPatterns = pattern.Args; 							cmpExprOrBinding = null; 						} else { 							// It's very tempting to detect NodeStyle.PrefixNotation to distinguish'  							// say' A.B<C> from id(A' B' C)' but I'm reluctant to do so. BaseStyle  							// is by convention "unsemantic" and not guaranteed to be preserved  							// across serializations or supported the same way by different parsers.  							// So instead of asking "is this in PrefixNotation?" I ask "does the  							// target appear to be a normal identifier?"  							LNode target = pattern.Target; 							if (!haveSubPatterns && pattern.IsCall && (!target.IsId || target.AttrNamed(S.TriviaInParens) != null || (!target.HasSpecialName && Les2Printer.IsNormalIdentifier(target.Name))) 							) 						 							{ 								haveSubPatterns = true; 								subPatterns = pattern.Args; 								pattern = pattern.Target; 							} else 								cmpExprOrBinding = pattern; 						} 					} 				}
Magic Number,LeMP,CodeGeneratorForMatchCase,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\MatchMacro.out.cs,GetPatternComponents,The following statement contains a magic number: for (int pass = 1; pass <= 3; pass++) { 					LNode inRange2 = inRange' isType2 = isType; 					{ 						LNode patternL; 						if (pattern.Calls(CodeSymbols.In' 2) && (patternL = pattern.Args[0]) != null && (inRange = pattern.Args[1]) != null || pattern.Calls((Symbol) "in"' 2) && (patternL = pattern.Args[0]) != null && (inRange = pattern.Args[1]) != null) { 							pattern = patternL; 							if (inRange2 != null) 								_context.Sink.Error(inRange2' "match-case does not support multiple 'in' operators"); 						} else if (pattern.Calls(CodeSymbols.Is' 2) && (cmpExprOrBinding = pattern.Args[0]) != null && (isType = pattern.Args[1]) != null || pattern.Calls((Symbol) "is"' 2) && (cmpExprOrBinding = pattern.Args[0]) != null && (isType = pattern.Args[1]) != null) { 							pattern = cmpExprOrBinding; 							if (isType2 != null) 								_context.Sink.Error(isType2' "match-case does not support multiple 'is' operators"); 						} else if (pattern.Calls(CodeSymbols.Is' 1) && (isType = pattern.Args[0]) != null || pattern.Calls((Symbol) "is"' 1) && (isType = pattern.Args[0]) != null) { 							if (isType2 != null) 								_context.Sink.Error(isType2' "match-case does not support multiple 'is' operators"); 							goto doneAnalysis; 						} else if (pattern.Calls(CodeSymbols.DotDotDot' 2) || pattern.Calls(CodeSymbols.DotDot' 2) || pattern.Calls(CodeSymbols.DotDotDot' 1) || pattern.Calls(CodeSymbols.DotDot' 1)) { 							inRange = pattern; 							goto doneAnalysis; 						} else if (pattern.Calls(CodeSymbols.Tuple)) { 							subPatterns = pattern.Args; 							cmpExprOrBinding = null; 						} else { 							// It's very tempting to detect NodeStyle.PrefixNotation to distinguish'  							// say' A.B<C> from id(A' B' C)' but I'm reluctant to do so. BaseStyle  							// is by convention "unsemantic" and not guaranteed to be preserved  							// across serializations or supported the same way by different parsers.  							// So instead of asking "is this in PrefixNotation?" I ask "does the  							// target appear to be a normal identifier?"  							LNode target = pattern.Target; 							if (!haveSubPatterns && pattern.IsCall && (!target.IsId || target.AttrNamed(S.TriviaInParens) != null || (!target.HasSpecialName && Les2Printer.IsNormalIdentifier(target.Name))) 							) 						 							{ 								haveSubPatterns = true; 								subPatterns = pattern.Args; 								pattern = pattern.Target; 							} else 								cmpExprOrBinding = pattern; 						} 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressions,The following statement contains a magic number: if (EcsValidators.SpaceDefinitionKind(stmt' out name' out bases' out body) != null) { 					// Space definition: class' struct' etc. 					return body == null ? stmt : stmt.WithArgChanged(2' EliminateSequenceExpressions(body' true)); 				} else if (EcsValidators.MethodDefinitionKind(stmt' out retType' out name' out argList' out body' true) != null) { 					// Method definition 					return body == null ? stmt : stmt.WithArgChanged(3' EliminateSequenceExpressionsInLambdaExpr(body' retType)); 				} else if (EcsValidators.IsPropertyDefinition(stmt' out retType' out name' out argList' out body' out initValue)) { 					// Property definition 					stmt = stmt.WithArgChanged(3'  					body.WithArgs(part => { 						if (part.ArgCount == 1 && part[0].Calls(S.Braces)) 							part = part.WithArgChanged(0' EliminateSequenceExpressions(part[0]' false)); 						return part; 					})); 					if (initValue != null) { 						var initMethod = EliminateRunSeqFromInitializer(retType' name' ref initValue); 						if (initMethod != null) { 							stmt = stmt.WithArgChanged(4' initValue); 							return LNode.Call((Symbol) "#runSequence"' LNode.List(stmt' initMethod)); 						} 					} 					return stmt; 				} else if (stmt.Calls(CodeSymbols.Braces)) { 					return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' isDeclContext)); 				} else if (!isDeclContext) { 					return EliminateSequenceExpressionsInExecStmt(stmt); 				} else if (stmt.CallsMin(S.Var' 2)) { 					// Eliminate blocks from field member 					var results = new List<LNode> {  						stmt 					}; 					var vars = stmt.Args; 					var varType = vars[0]; 					for (int i = 1; i < vars.Count; i++) { 						var @var = vars[i]; 						if (@var.Calls(CodeSymbols.Assign' 2) && (name = @var.Args[0]) != null && (initValue = @var.Args[1]) != null) { 							var initMethod = EliminateRunSeqFromInitializer(varType' name' ref initValue); 							if (initMethod != null) { 								results.Add(initMethod); 								vars[i] = vars[i].WithArgChanged(1' initValue); 							} 						} 					} 					if (results.Count > 1) { 						results[0] = stmt.WithArgs(vars); 						return LNode.List(results).AsLNode(__numrunSequence); 					} 					return stmt; 				} else 					return stmt;
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressions,The following statement contains a magic number: if (EcsValidators.SpaceDefinitionKind(stmt' out name' out bases' out body) != null) { 					// Space definition: class' struct' etc. 					return body == null ? stmt : stmt.WithArgChanged(2' EliminateSequenceExpressions(body' true)); 				} else if (EcsValidators.MethodDefinitionKind(stmt' out retType' out name' out argList' out body' true) != null) { 					// Method definition 					return body == null ? stmt : stmt.WithArgChanged(3' EliminateSequenceExpressionsInLambdaExpr(body' retType)); 				} else if (EcsValidators.IsPropertyDefinition(stmt' out retType' out name' out argList' out body' out initValue)) { 					// Property definition 					stmt = stmt.WithArgChanged(3'  					body.WithArgs(part => { 						if (part.ArgCount == 1 && part[0].Calls(S.Braces)) 							part = part.WithArgChanged(0' EliminateSequenceExpressions(part[0]' false)); 						return part; 					})); 					if (initValue != null) { 						var initMethod = EliminateRunSeqFromInitializer(retType' name' ref initValue); 						if (initMethod != null) { 							stmt = stmt.WithArgChanged(4' initValue); 							return LNode.Call((Symbol) "#runSequence"' LNode.List(stmt' initMethod)); 						} 					} 					return stmt; 				} else if (stmt.Calls(CodeSymbols.Braces)) { 					return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' isDeclContext)); 				} else if (!isDeclContext) { 					return EliminateSequenceExpressionsInExecStmt(stmt); 				} else if (stmt.CallsMin(S.Var' 2)) { 					// Eliminate blocks from field member 					var results = new List<LNode> {  						stmt 					}; 					var vars = stmt.Args; 					var varType = vars[0]; 					for (int i = 1; i < vars.Count; i++) { 						var @var = vars[i]; 						if (@var.Calls(CodeSymbols.Assign' 2) && (name = @var.Args[0]) != null && (initValue = @var.Args[1]) != null) { 							var initMethod = EliminateRunSeqFromInitializer(varType' name' ref initValue); 							if (initMethod != null) { 								results.Add(initMethod); 								vars[i] = vars[i].WithArgChanged(1' initValue); 							} 						} 					} 					if (results.Count > 1) { 						results[0] = stmt.WithArgs(vars); 						return LNode.List(results).AsLNode(__numrunSequence); 					} 					return stmt; 				} else 					return stmt;
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressions,The following statement contains a magic number: if (EcsValidators.SpaceDefinitionKind(stmt' out name' out bases' out body) != null) { 					// Space definition: class' struct' etc. 					return body == null ? stmt : stmt.WithArgChanged(2' EliminateSequenceExpressions(body' true)); 				} else if (EcsValidators.MethodDefinitionKind(stmt' out retType' out name' out argList' out body' true) != null) { 					// Method definition 					return body == null ? stmt : stmt.WithArgChanged(3' EliminateSequenceExpressionsInLambdaExpr(body' retType)); 				} else if (EcsValidators.IsPropertyDefinition(stmt' out retType' out name' out argList' out body' out initValue)) { 					// Property definition 					stmt = stmt.WithArgChanged(3'  					body.WithArgs(part => { 						if (part.ArgCount == 1 && part[0].Calls(S.Braces)) 							part = part.WithArgChanged(0' EliminateSequenceExpressions(part[0]' false)); 						return part; 					})); 					if (initValue != null) { 						var initMethod = EliminateRunSeqFromInitializer(retType' name' ref initValue); 						if (initMethod != null) { 							stmt = stmt.WithArgChanged(4' initValue); 							return LNode.Call((Symbol) "#runSequence"' LNode.List(stmt' initMethod)); 						} 					} 					return stmt; 				} else if (stmt.Calls(CodeSymbols.Braces)) { 					return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' isDeclContext)); 				} else if (!isDeclContext) { 					return EliminateSequenceExpressionsInExecStmt(stmt); 				} else if (stmt.CallsMin(S.Var' 2)) { 					// Eliminate blocks from field member 					var results = new List<LNode> {  						stmt 					}; 					var vars = stmt.Args; 					var varType = vars[0]; 					for (int i = 1; i < vars.Count; i++) { 						var @var = vars[i]; 						if (@var.Calls(CodeSymbols.Assign' 2) && (name = @var.Args[0]) != null && (initValue = @var.Args[1]) != null) { 							var initMethod = EliminateRunSeqFromInitializer(varType' name' ref initValue); 							if (initMethod != null) { 								results.Add(initMethod); 								vars[i] = vars[i].WithArgChanged(1' initValue); 							} 						} 					} 					if (results.Count > 1) { 						results[0] = stmt.WithArgs(vars); 						return LNode.List(results).AsLNode(__numrunSequence); 					} 					return stmt; 				} else 					return stmt;
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressions,The following statement contains a magic number: if (EcsValidators.SpaceDefinitionKind(stmt' out name' out bases' out body) != null) { 					// Space definition: class' struct' etc. 					return body == null ? stmt : stmt.WithArgChanged(2' EliminateSequenceExpressions(body' true)); 				} else if (EcsValidators.MethodDefinitionKind(stmt' out retType' out name' out argList' out body' true) != null) { 					// Method definition 					return body == null ? stmt : stmt.WithArgChanged(3' EliminateSequenceExpressionsInLambdaExpr(body' retType)); 				} else if (EcsValidators.IsPropertyDefinition(stmt' out retType' out name' out argList' out body' out initValue)) { 					// Property definition 					stmt = stmt.WithArgChanged(3'  					body.WithArgs(part => { 						if (part.ArgCount == 1 && part[0].Calls(S.Braces)) 							part = part.WithArgChanged(0' EliminateSequenceExpressions(part[0]' false)); 						return part; 					})); 					if (initValue != null) { 						var initMethod = EliminateRunSeqFromInitializer(retType' name' ref initValue); 						if (initMethod != null) { 							stmt = stmt.WithArgChanged(4' initValue); 							return LNode.Call((Symbol) "#runSequence"' LNode.List(stmt' initMethod)); 						} 					} 					return stmt; 				} else if (stmt.Calls(CodeSymbols.Braces)) { 					return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' isDeclContext)); 				} else if (!isDeclContext) { 					return EliminateSequenceExpressionsInExecStmt(stmt); 				} else if (stmt.CallsMin(S.Var' 2)) { 					// Eliminate blocks from field member 					var results = new List<LNode> {  						stmt 					}; 					var vars = stmt.Args; 					var varType = vars[0]; 					for (int i = 1; i < vars.Count; i++) { 						var @var = vars[i]; 						if (@var.Calls(CodeSymbols.Assign' 2) && (name = @var.Args[0]) != null && (initValue = @var.Args[1]) != null) { 							var initMethod = EliminateRunSeqFromInitializer(varType' name' ref initValue); 							if (initMethod != null) { 								results.Add(initMethod); 								vars[i] = vars[i].WithArgChanged(1' initValue); 							} 						} 					} 					if (results.Count > 1) { 						results[0] = stmt.WithArgs(vars); 						return LNode.List(results).AsLNode(__numrunSequence); 					} 					return stmt; 				} else 					return stmt;
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressions,The following statement contains a magic number: if (EcsValidators.SpaceDefinitionKind(stmt' out name' out bases' out body) != null) { 					// Space definition: class' struct' etc. 					return body == null ? stmt : stmt.WithArgChanged(2' EliminateSequenceExpressions(body' true)); 				} else if (EcsValidators.MethodDefinitionKind(stmt' out retType' out name' out argList' out body' true) != null) { 					// Method definition 					return body == null ? stmt : stmt.WithArgChanged(3' EliminateSequenceExpressionsInLambdaExpr(body' retType)); 				} else if (EcsValidators.IsPropertyDefinition(stmt' out retType' out name' out argList' out body' out initValue)) { 					// Property definition 					stmt = stmt.WithArgChanged(3'  					body.WithArgs(part => { 						if (part.ArgCount == 1 && part[0].Calls(S.Braces)) 							part = part.WithArgChanged(0' EliminateSequenceExpressions(part[0]' false)); 						return part; 					})); 					if (initValue != null) { 						var initMethod = EliminateRunSeqFromInitializer(retType' name' ref initValue); 						if (initMethod != null) { 							stmt = stmt.WithArgChanged(4' initValue); 							return LNode.Call((Symbol) "#runSequence"' LNode.List(stmt' initMethod)); 						} 					} 					return stmt; 				} else if (stmt.Calls(CodeSymbols.Braces)) { 					return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' isDeclContext)); 				} else if (!isDeclContext) { 					return EliminateSequenceExpressionsInExecStmt(stmt); 				} else if (stmt.CallsMin(S.Var' 2)) { 					// Eliminate blocks from field member 					var results = new List<LNode> {  						stmt 					}; 					var vars = stmt.Args; 					var varType = vars[0]; 					for (int i = 1; i < vars.Count; i++) { 						var @var = vars[i]; 						if (@var.Calls(CodeSymbols.Assign' 2) && (name = @var.Args[0]) != null && (initValue = @var.Args[1]) != null) { 							var initMethod = EliminateRunSeqFromInitializer(varType' name' ref initValue); 							if (initMethod != null) { 								results.Add(initMethod); 								vars[i] = vars[i].WithArgChanged(1' initValue); 							} 						} 					} 					if (results.Count > 1) { 						results[0] = stmt.WithArgs(vars); 						return LNode.List(results).AsLNode(__numrunSequence); 					} 					return stmt; 				} else 					return stmt;
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressions,The following statement contains a magic number: if (EcsValidators.SpaceDefinitionKind(stmt' out name' out bases' out body) != null) { 					// Space definition: class' struct' etc. 					return body == null ? stmt : stmt.WithArgChanged(2' EliminateSequenceExpressions(body' true)); 				} else if (EcsValidators.MethodDefinitionKind(stmt' out retType' out name' out argList' out body' true) != null) { 					// Method definition 					return body == null ? stmt : stmt.WithArgChanged(3' EliminateSequenceExpressionsInLambdaExpr(body' retType)); 				} else if (EcsValidators.IsPropertyDefinition(stmt' out retType' out name' out argList' out body' out initValue)) { 					// Property definition 					stmt = stmt.WithArgChanged(3'  					body.WithArgs(part => { 						if (part.ArgCount == 1 && part[0].Calls(S.Braces)) 							part = part.WithArgChanged(0' EliminateSequenceExpressions(part[0]' false)); 						return part; 					})); 					if (initValue != null) { 						var initMethod = EliminateRunSeqFromInitializer(retType' name' ref initValue); 						if (initMethod != null) { 							stmt = stmt.WithArgChanged(4' initValue); 							return LNode.Call((Symbol) "#runSequence"' LNode.List(stmt' initMethod)); 						} 					} 					return stmt; 				} else if (stmt.Calls(CodeSymbols.Braces)) { 					return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' isDeclContext)); 				} else if (!isDeclContext) { 					return EliminateSequenceExpressionsInExecStmt(stmt); 				} else if (stmt.CallsMin(S.Var' 2)) { 					// Eliminate blocks from field member 					var results = new List<LNode> {  						stmt 					}; 					var vars = stmt.Args; 					var varType = vars[0]; 					for (int i = 1; i < vars.Count; i++) { 						var @var = vars[i]; 						if (@var.Calls(CodeSymbols.Assign' 2) && (name = @var.Args[0]) != null && (initValue = @var.Args[1]) != null) { 							var initMethod = EliminateRunSeqFromInitializer(varType' name' ref initValue); 							if (initMethod != null) { 								results.Add(initMethod); 								vars[i] = vars[i].WithArgChanged(1' initValue); 							} 						} 					} 					if (results.Count > 1) { 						results[0] = stmt.WithArgs(vars); 						return LNode.List(results).AsLNode(__numrunSequence); 					} 					return stmt; 				} else 					return stmt;
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The following statement contains a magic number: { 					LNode block' collection' cond' init' initValue' loopVar' name' tmp_11' tmp_12' type; 					VList<LNode> attrs' incs' inits; 					if (stmt.Calls(CodeSymbols.Braces)) 						return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' false)); 					else if (stmt.CallsMin(CodeSymbols.If' 1) || stmt.Calls(CodeSymbols.UsingStmt' 2) || stmt.Calls(CodeSymbols.Lock' 2) || stmt.Calls(CodeSymbols.Switch' 2) && stmt.Args[1].Calls(CodeSymbols.Braces)) 						return ProcessBlockCallStmt(stmt' 1); 					else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fixed' 2) && (init = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						init = EliminateSequenceExpressionsInExecStmt(init); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (init.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(init.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.Fixed' LNode.List(init.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.While' 2) && (cond = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						cond = BubbleUpBlocks(cond); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (cond.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList)' LNode.Missing' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(cond.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.If' LNode.List(cond.Args.Last' block' LNode.Call(CodeSymbols.Break))))).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.DoWhile' 2) && (block = stmt.Args[0]) != null && (cond = stmt.Args[1]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						cond = BubbleUpBlocks(cond); 						if (cond.CallsMin(__numrunSequence' 1)) { 							var continue_N = F.Id(NextTempName(Context' "continue_")); 							var bodyStmts = block.AsList(S.Braces); 							bodyStmts.AddRange(cond.Args.WithoutLast(1)); 							bodyStmts.Add(LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' cond.Args.Last)).SetStyle(NodeStyle.Operator)); 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(LNode.Id(CodeSymbols.Bool)' LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' LNode.Literal(true)))))))' continue_N' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List(bodyStmts)).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(0' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.For' 4) && stmt.Args[0].Calls(CodeSymbols.AltList) && (cond = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (block = stmt.Args[3]) != null) { 						inits = stmt.Args[0].Args; 						incs = stmt.Args[2].Args; 						return ESEInForLoop(stmt' attrs' inits' cond' incs' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.ForEach' 3) && (tmp_11 = stmt.Args[0]) != null && tmp_11.Calls(CodeSymbols.Var' 2) && (type = tmp_11.Args[0]) != null && (loopVar = tmp_11.Args[1]) != null && (collection = stmt.Args[1]) != null && (block = stmt.Args[2]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						collection = BubbleUpBlocks(collection); 						if (collection.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(collection.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.ForEach' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(type' loopVar))' collection.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else { 							return stmt.WithArgChanged(stmt.Args.Count - 1' block); 						} 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Var' 2) && (type = stmt.Args[0]) != null && (tmp_12 = stmt.Args[1]) != null && tmp_12.Calls(CodeSymbols.Assign' 2) && (name = tmp_12.Args[0]) != null && (initValue = tmp_12.Args[1]) != null) { 						var initValue_apos = BubbleUpBlocks(initValue); 						if (initValue_apos != initValue) { 							{ 								LNode last; 								VList<LNode> stmts; 								if (initValue_apos.CallsMin((Symbol) "#runSequence"' 1) && (last = initValue_apos.Args[initValue_apos.Args.Count - 1]) != null) { 									stmts = initValue_apos.Args.WithoutLast(1); 									return LNode.Call((Symbol) "#runSequence"' LNode.List().AddRange(stmts).Add(LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' last)))))); 								} else 									return LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' initValue_apos)))); 							} 						} 					} else if (stmt.CallsMin(S.Try' 2)) { 						return ESEInTryStmt(stmt); 					} else if (stmt.HasSpecialName && stmt.ArgCount >= 1 && stmt.Args.Last.Calls(S.Braces)) { 						return ProcessBlockCallStmt(stmt' stmt.ArgCount - 1); 					} else { 						// Ordinary expression statement 						return BubbleUpBlocks(stmt' stmtContext: true); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The following statement contains a magic number: { 					LNode block' collection' cond' init' initValue' loopVar' name' tmp_11' tmp_12' type; 					VList<LNode> attrs' incs' inits; 					if (stmt.Calls(CodeSymbols.Braces)) 						return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' false)); 					else if (stmt.CallsMin(CodeSymbols.If' 1) || stmt.Calls(CodeSymbols.UsingStmt' 2) || stmt.Calls(CodeSymbols.Lock' 2) || stmt.Calls(CodeSymbols.Switch' 2) && stmt.Args[1].Calls(CodeSymbols.Braces)) 						return ProcessBlockCallStmt(stmt' 1); 					else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fixed' 2) && (init = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						init = EliminateSequenceExpressionsInExecStmt(init); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (init.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(init.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.Fixed' LNode.List(init.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.While' 2) && (cond = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						cond = BubbleUpBlocks(cond); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (cond.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList)' LNode.Missing' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(cond.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.If' LNode.List(cond.Args.Last' block' LNode.Call(CodeSymbols.Break))))).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.DoWhile' 2) && (block = stmt.Args[0]) != null && (cond = stmt.Args[1]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						cond = BubbleUpBlocks(cond); 						if (cond.CallsMin(__numrunSequence' 1)) { 							var continue_N = F.Id(NextTempName(Context' "continue_")); 							var bodyStmts = block.AsList(S.Braces); 							bodyStmts.AddRange(cond.Args.WithoutLast(1)); 							bodyStmts.Add(LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' cond.Args.Last)).SetStyle(NodeStyle.Operator)); 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(LNode.Id(CodeSymbols.Bool)' LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' LNode.Literal(true)))))))' continue_N' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List(bodyStmts)).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(0' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.For' 4) && stmt.Args[0].Calls(CodeSymbols.AltList) && (cond = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (block = stmt.Args[3]) != null) { 						inits = stmt.Args[0].Args; 						incs = stmt.Args[2].Args; 						return ESEInForLoop(stmt' attrs' inits' cond' incs' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.ForEach' 3) && (tmp_11 = stmt.Args[0]) != null && tmp_11.Calls(CodeSymbols.Var' 2) && (type = tmp_11.Args[0]) != null && (loopVar = tmp_11.Args[1]) != null && (collection = stmt.Args[1]) != null && (block = stmt.Args[2]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						collection = BubbleUpBlocks(collection); 						if (collection.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(collection.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.ForEach' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(type' loopVar))' collection.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else { 							return stmt.WithArgChanged(stmt.Args.Count - 1' block); 						} 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Var' 2) && (type = stmt.Args[0]) != null && (tmp_12 = stmt.Args[1]) != null && tmp_12.Calls(CodeSymbols.Assign' 2) && (name = tmp_12.Args[0]) != null && (initValue = tmp_12.Args[1]) != null) { 						var initValue_apos = BubbleUpBlocks(initValue); 						if (initValue_apos != initValue) { 							{ 								LNode last; 								VList<LNode> stmts; 								if (initValue_apos.CallsMin((Symbol) "#runSequence"' 1) && (last = initValue_apos.Args[initValue_apos.Args.Count - 1]) != null) { 									stmts = initValue_apos.Args.WithoutLast(1); 									return LNode.Call((Symbol) "#runSequence"' LNode.List().AddRange(stmts).Add(LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' last)))))); 								} else 									return LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' initValue_apos)))); 							} 						} 					} else if (stmt.CallsMin(S.Try' 2)) { 						return ESEInTryStmt(stmt); 					} else if (stmt.HasSpecialName && stmt.ArgCount >= 1 && stmt.Args.Last.Calls(S.Braces)) { 						return ProcessBlockCallStmt(stmt' stmt.ArgCount - 1); 					} else { 						// Ordinary expression statement 						return BubbleUpBlocks(stmt' stmtContext: true); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The following statement contains a magic number: { 					LNode block' collection' cond' init' initValue' loopVar' name' tmp_11' tmp_12' type; 					VList<LNode> attrs' incs' inits; 					if (stmt.Calls(CodeSymbols.Braces)) 						return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' false)); 					else if (stmt.CallsMin(CodeSymbols.If' 1) || stmt.Calls(CodeSymbols.UsingStmt' 2) || stmt.Calls(CodeSymbols.Lock' 2) || stmt.Calls(CodeSymbols.Switch' 2) && stmt.Args[1].Calls(CodeSymbols.Braces)) 						return ProcessBlockCallStmt(stmt' 1); 					else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fixed' 2) && (init = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						init = EliminateSequenceExpressionsInExecStmt(init); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (init.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(init.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.Fixed' LNode.List(init.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.While' 2) && (cond = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						cond = BubbleUpBlocks(cond); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (cond.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList)' LNode.Missing' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(cond.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.If' LNode.List(cond.Args.Last' block' LNode.Call(CodeSymbols.Break))))).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.DoWhile' 2) && (block = stmt.Args[0]) != null && (cond = stmt.Args[1]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						cond = BubbleUpBlocks(cond); 						if (cond.CallsMin(__numrunSequence' 1)) { 							var continue_N = F.Id(NextTempName(Context' "continue_")); 							var bodyStmts = block.AsList(S.Braces); 							bodyStmts.AddRange(cond.Args.WithoutLast(1)); 							bodyStmts.Add(LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' cond.Args.Last)).SetStyle(NodeStyle.Operator)); 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(LNode.Id(CodeSymbols.Bool)' LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' LNode.Literal(true)))))))' continue_N' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List(bodyStmts)).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(0' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.For' 4) && stmt.Args[0].Calls(CodeSymbols.AltList) && (cond = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (block = stmt.Args[3]) != null) { 						inits = stmt.Args[0].Args; 						incs = stmt.Args[2].Args; 						return ESEInForLoop(stmt' attrs' inits' cond' incs' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.ForEach' 3) && (tmp_11 = stmt.Args[0]) != null && tmp_11.Calls(CodeSymbols.Var' 2) && (type = tmp_11.Args[0]) != null && (loopVar = tmp_11.Args[1]) != null && (collection = stmt.Args[1]) != null && (block = stmt.Args[2]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						collection = BubbleUpBlocks(collection); 						if (collection.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(collection.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.ForEach' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(type' loopVar))' collection.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else { 							return stmt.WithArgChanged(stmt.Args.Count - 1' block); 						} 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Var' 2) && (type = stmt.Args[0]) != null && (tmp_12 = stmt.Args[1]) != null && tmp_12.Calls(CodeSymbols.Assign' 2) && (name = tmp_12.Args[0]) != null && (initValue = tmp_12.Args[1]) != null) { 						var initValue_apos = BubbleUpBlocks(initValue); 						if (initValue_apos != initValue) { 							{ 								LNode last; 								VList<LNode> stmts; 								if (initValue_apos.CallsMin((Symbol) "#runSequence"' 1) && (last = initValue_apos.Args[initValue_apos.Args.Count - 1]) != null) { 									stmts = initValue_apos.Args.WithoutLast(1); 									return LNode.Call((Symbol) "#runSequence"' LNode.List().AddRange(stmts).Add(LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' last)))))); 								} else 									return LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' initValue_apos)))); 							} 						} 					} else if (stmt.CallsMin(S.Try' 2)) { 						return ESEInTryStmt(stmt); 					} else if (stmt.HasSpecialName && stmt.ArgCount >= 1 && stmt.Args.Last.Calls(S.Braces)) { 						return ProcessBlockCallStmt(stmt' stmt.ArgCount - 1); 					} else { 						// Ordinary expression statement 						return BubbleUpBlocks(stmt' stmtContext: true); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The following statement contains a magic number: { 					LNode block' collection' cond' init' initValue' loopVar' name' tmp_11' tmp_12' type; 					VList<LNode> attrs' incs' inits; 					if (stmt.Calls(CodeSymbols.Braces)) 						return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' false)); 					else if (stmt.CallsMin(CodeSymbols.If' 1) || stmt.Calls(CodeSymbols.UsingStmt' 2) || stmt.Calls(CodeSymbols.Lock' 2) || stmt.Calls(CodeSymbols.Switch' 2) && stmt.Args[1].Calls(CodeSymbols.Braces)) 						return ProcessBlockCallStmt(stmt' 1); 					else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fixed' 2) && (init = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						init = EliminateSequenceExpressionsInExecStmt(init); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (init.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(init.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.Fixed' LNode.List(init.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.While' 2) && (cond = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						cond = BubbleUpBlocks(cond); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (cond.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList)' LNode.Missing' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(cond.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.If' LNode.List(cond.Args.Last' block' LNode.Call(CodeSymbols.Break))))).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.DoWhile' 2) && (block = stmt.Args[0]) != null && (cond = stmt.Args[1]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						cond = BubbleUpBlocks(cond); 						if (cond.CallsMin(__numrunSequence' 1)) { 							var continue_N = F.Id(NextTempName(Context' "continue_")); 							var bodyStmts = block.AsList(S.Braces); 							bodyStmts.AddRange(cond.Args.WithoutLast(1)); 							bodyStmts.Add(LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' cond.Args.Last)).SetStyle(NodeStyle.Operator)); 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(LNode.Id(CodeSymbols.Bool)' LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' LNode.Literal(true)))))))' continue_N' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List(bodyStmts)).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(0' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.For' 4) && stmt.Args[0].Calls(CodeSymbols.AltList) && (cond = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (block = stmt.Args[3]) != null) { 						inits = stmt.Args[0].Args; 						incs = stmt.Args[2].Args; 						return ESEInForLoop(stmt' attrs' inits' cond' incs' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.ForEach' 3) && (tmp_11 = stmt.Args[0]) != null && tmp_11.Calls(CodeSymbols.Var' 2) && (type = tmp_11.Args[0]) != null && (loopVar = tmp_11.Args[1]) != null && (collection = stmt.Args[1]) != null && (block = stmt.Args[2]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						collection = BubbleUpBlocks(collection); 						if (collection.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(collection.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.ForEach' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(type' loopVar))' collection.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else { 							return stmt.WithArgChanged(stmt.Args.Count - 1' block); 						} 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Var' 2) && (type = stmt.Args[0]) != null && (tmp_12 = stmt.Args[1]) != null && tmp_12.Calls(CodeSymbols.Assign' 2) && (name = tmp_12.Args[0]) != null && (initValue = tmp_12.Args[1]) != null) { 						var initValue_apos = BubbleUpBlocks(initValue); 						if (initValue_apos != initValue) { 							{ 								LNode last; 								VList<LNode> stmts; 								if (initValue_apos.CallsMin((Symbol) "#runSequence"' 1) && (last = initValue_apos.Args[initValue_apos.Args.Count - 1]) != null) { 									stmts = initValue_apos.Args.WithoutLast(1); 									return LNode.Call((Symbol) "#runSequence"' LNode.List().AddRange(stmts).Add(LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' last)))))); 								} else 									return LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' initValue_apos)))); 							} 						} 					} else if (stmt.CallsMin(S.Try' 2)) { 						return ESEInTryStmt(stmt); 					} else if (stmt.HasSpecialName && stmt.ArgCount >= 1 && stmt.Args.Last.Calls(S.Braces)) { 						return ProcessBlockCallStmt(stmt' stmt.ArgCount - 1); 					} else { 						// Ordinary expression statement 						return BubbleUpBlocks(stmt' stmtContext: true); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The following statement contains a magic number: { 					LNode block' collection' cond' init' initValue' loopVar' name' tmp_11' tmp_12' type; 					VList<LNode> attrs' incs' inits; 					if (stmt.Calls(CodeSymbols.Braces)) 						return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' false)); 					else if (stmt.CallsMin(CodeSymbols.If' 1) || stmt.Calls(CodeSymbols.UsingStmt' 2) || stmt.Calls(CodeSymbols.Lock' 2) || stmt.Calls(CodeSymbols.Switch' 2) && stmt.Args[1].Calls(CodeSymbols.Braces)) 						return ProcessBlockCallStmt(stmt' 1); 					else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fixed' 2) && (init = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						init = EliminateSequenceExpressionsInExecStmt(init); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (init.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(init.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.Fixed' LNode.List(init.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.While' 2) && (cond = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						cond = BubbleUpBlocks(cond); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (cond.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList)' LNode.Missing' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(cond.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.If' LNode.List(cond.Args.Last' block' LNode.Call(CodeSymbols.Break))))).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.DoWhile' 2) && (block = stmt.Args[0]) != null && (cond = stmt.Args[1]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						cond = BubbleUpBlocks(cond); 						if (cond.CallsMin(__numrunSequence' 1)) { 							var continue_N = F.Id(NextTempName(Context' "continue_")); 							var bodyStmts = block.AsList(S.Braces); 							bodyStmts.AddRange(cond.Args.WithoutLast(1)); 							bodyStmts.Add(LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' cond.Args.Last)).SetStyle(NodeStyle.Operator)); 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(LNode.Id(CodeSymbols.Bool)' LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' LNode.Literal(true)))))))' continue_N' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List(bodyStmts)).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(0' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.For' 4) && stmt.Args[0].Calls(CodeSymbols.AltList) && (cond = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (block = stmt.Args[3]) != null) { 						inits = stmt.Args[0].Args; 						incs = stmt.Args[2].Args; 						return ESEInForLoop(stmt' attrs' inits' cond' incs' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.ForEach' 3) && (tmp_11 = stmt.Args[0]) != null && tmp_11.Calls(CodeSymbols.Var' 2) && (type = tmp_11.Args[0]) != null && (loopVar = tmp_11.Args[1]) != null && (collection = stmt.Args[1]) != null && (block = stmt.Args[2]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						collection = BubbleUpBlocks(collection); 						if (collection.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(collection.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.ForEach' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(type' loopVar))' collection.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else { 							return stmt.WithArgChanged(stmt.Args.Count - 1' block); 						} 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Var' 2) && (type = stmt.Args[0]) != null && (tmp_12 = stmt.Args[1]) != null && tmp_12.Calls(CodeSymbols.Assign' 2) && (name = tmp_12.Args[0]) != null && (initValue = tmp_12.Args[1]) != null) { 						var initValue_apos = BubbleUpBlocks(initValue); 						if (initValue_apos != initValue) { 							{ 								LNode last; 								VList<LNode> stmts; 								if (initValue_apos.CallsMin((Symbol) "#runSequence"' 1) && (last = initValue_apos.Args[initValue_apos.Args.Count - 1]) != null) { 									stmts = initValue_apos.Args.WithoutLast(1); 									return LNode.Call((Symbol) "#runSequence"' LNode.List().AddRange(stmts).Add(LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' last)))))); 								} else 									return LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' initValue_apos)))); 							} 						} 					} else if (stmt.CallsMin(S.Try' 2)) { 						return ESEInTryStmt(stmt); 					} else if (stmt.HasSpecialName && stmt.ArgCount >= 1 && stmt.Args.Last.Calls(S.Braces)) { 						return ProcessBlockCallStmt(stmt' stmt.ArgCount - 1); 					} else { 						// Ordinary expression statement 						return BubbleUpBlocks(stmt' stmtContext: true); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The following statement contains a magic number: { 					LNode block' collection' cond' init' initValue' loopVar' name' tmp_11' tmp_12' type; 					VList<LNode> attrs' incs' inits; 					if (stmt.Calls(CodeSymbols.Braces)) 						return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' false)); 					else if (stmt.CallsMin(CodeSymbols.If' 1) || stmt.Calls(CodeSymbols.UsingStmt' 2) || stmt.Calls(CodeSymbols.Lock' 2) || stmt.Calls(CodeSymbols.Switch' 2) && stmt.Args[1].Calls(CodeSymbols.Braces)) 						return ProcessBlockCallStmt(stmt' 1); 					else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fixed' 2) && (init = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						init = EliminateSequenceExpressionsInExecStmt(init); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (init.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(init.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.Fixed' LNode.List(init.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.While' 2) && (cond = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						cond = BubbleUpBlocks(cond); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (cond.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList)' LNode.Missing' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(cond.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.If' LNode.List(cond.Args.Last' block' LNode.Call(CodeSymbols.Break))))).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.DoWhile' 2) && (block = stmt.Args[0]) != null && (cond = stmt.Args[1]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						cond = BubbleUpBlocks(cond); 						if (cond.CallsMin(__numrunSequence' 1)) { 							var continue_N = F.Id(NextTempName(Context' "continue_")); 							var bodyStmts = block.AsList(S.Braces); 							bodyStmts.AddRange(cond.Args.WithoutLast(1)); 							bodyStmts.Add(LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' cond.Args.Last)).SetStyle(NodeStyle.Operator)); 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(LNode.Id(CodeSymbols.Bool)' LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' LNode.Literal(true)))))))' continue_N' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List(bodyStmts)).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(0' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.For' 4) && stmt.Args[0].Calls(CodeSymbols.AltList) && (cond = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (block = stmt.Args[3]) != null) { 						inits = stmt.Args[0].Args; 						incs = stmt.Args[2].Args; 						return ESEInForLoop(stmt' attrs' inits' cond' incs' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.ForEach' 3) && (tmp_11 = stmt.Args[0]) != null && tmp_11.Calls(CodeSymbols.Var' 2) && (type = tmp_11.Args[0]) != null && (loopVar = tmp_11.Args[1]) != null && (collection = stmt.Args[1]) != null && (block = stmt.Args[2]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						collection = BubbleUpBlocks(collection); 						if (collection.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(collection.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.ForEach' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(type' loopVar))' collection.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else { 							return stmt.WithArgChanged(stmt.Args.Count - 1' block); 						} 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Var' 2) && (type = stmt.Args[0]) != null && (tmp_12 = stmt.Args[1]) != null && tmp_12.Calls(CodeSymbols.Assign' 2) && (name = tmp_12.Args[0]) != null && (initValue = tmp_12.Args[1]) != null) { 						var initValue_apos = BubbleUpBlocks(initValue); 						if (initValue_apos != initValue) { 							{ 								LNode last; 								VList<LNode> stmts; 								if (initValue_apos.CallsMin((Symbol) "#runSequence"' 1) && (last = initValue_apos.Args[initValue_apos.Args.Count - 1]) != null) { 									stmts = initValue_apos.Args.WithoutLast(1); 									return LNode.Call((Symbol) "#runSequence"' LNode.List().AddRange(stmts).Add(LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' last)))))); 								} else 									return LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' initValue_apos)))); 							} 						} 					} else if (stmt.CallsMin(S.Try' 2)) { 						return ESEInTryStmt(stmt); 					} else if (stmt.HasSpecialName && stmt.ArgCount >= 1 && stmt.Args.Last.Calls(S.Braces)) { 						return ProcessBlockCallStmt(stmt' stmt.ArgCount - 1); 					} else { 						// Ordinary expression statement 						return BubbleUpBlocks(stmt' stmtContext: true); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The following statement contains a magic number: { 					LNode block' collection' cond' init' initValue' loopVar' name' tmp_11' tmp_12' type; 					VList<LNode> attrs' incs' inits; 					if (stmt.Calls(CodeSymbols.Braces)) 						return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' false)); 					else if (stmt.CallsMin(CodeSymbols.If' 1) || stmt.Calls(CodeSymbols.UsingStmt' 2) || stmt.Calls(CodeSymbols.Lock' 2) || stmt.Calls(CodeSymbols.Switch' 2) && stmt.Args[1].Calls(CodeSymbols.Braces)) 						return ProcessBlockCallStmt(stmt' 1); 					else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fixed' 2) && (init = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						init = EliminateSequenceExpressionsInExecStmt(init); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (init.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(init.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.Fixed' LNode.List(init.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.While' 2) && (cond = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						cond = BubbleUpBlocks(cond); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (cond.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList)' LNode.Missing' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(cond.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.If' LNode.List(cond.Args.Last' block' LNode.Call(CodeSymbols.Break))))).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.DoWhile' 2) && (block = stmt.Args[0]) != null && (cond = stmt.Args[1]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						cond = BubbleUpBlocks(cond); 						if (cond.CallsMin(__numrunSequence' 1)) { 							var continue_N = F.Id(NextTempName(Context' "continue_")); 							var bodyStmts = block.AsList(S.Braces); 							bodyStmts.AddRange(cond.Args.WithoutLast(1)); 							bodyStmts.Add(LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' cond.Args.Last)).SetStyle(NodeStyle.Operator)); 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(LNode.Id(CodeSymbols.Bool)' LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' LNode.Literal(true)))))))' continue_N' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List(bodyStmts)).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(0' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.For' 4) && stmt.Args[0].Calls(CodeSymbols.AltList) && (cond = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (block = stmt.Args[3]) != null) { 						inits = stmt.Args[0].Args; 						incs = stmt.Args[2].Args; 						return ESEInForLoop(stmt' attrs' inits' cond' incs' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.ForEach' 3) && (tmp_11 = stmt.Args[0]) != null && tmp_11.Calls(CodeSymbols.Var' 2) && (type = tmp_11.Args[0]) != null && (loopVar = tmp_11.Args[1]) != null && (collection = stmt.Args[1]) != null && (block = stmt.Args[2]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						collection = BubbleUpBlocks(collection); 						if (collection.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(collection.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.ForEach' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(type' loopVar))' collection.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else { 							return stmt.WithArgChanged(stmt.Args.Count - 1' block); 						} 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Var' 2) && (type = stmt.Args[0]) != null && (tmp_12 = stmt.Args[1]) != null && tmp_12.Calls(CodeSymbols.Assign' 2) && (name = tmp_12.Args[0]) != null && (initValue = tmp_12.Args[1]) != null) { 						var initValue_apos = BubbleUpBlocks(initValue); 						if (initValue_apos != initValue) { 							{ 								LNode last; 								VList<LNode> stmts; 								if (initValue_apos.CallsMin((Symbol) "#runSequence"' 1) && (last = initValue_apos.Args[initValue_apos.Args.Count - 1]) != null) { 									stmts = initValue_apos.Args.WithoutLast(1); 									return LNode.Call((Symbol) "#runSequence"' LNode.List().AddRange(stmts).Add(LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' last)))))); 								} else 									return LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' initValue_apos)))); 							} 						} 					} else if (stmt.CallsMin(S.Try' 2)) { 						return ESEInTryStmt(stmt); 					} else if (stmt.HasSpecialName && stmt.ArgCount >= 1 && stmt.Args.Last.Calls(S.Braces)) { 						return ProcessBlockCallStmt(stmt' stmt.ArgCount - 1); 					} else { 						// Ordinary expression statement 						return BubbleUpBlocks(stmt' stmtContext: true); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The following statement contains a magic number: { 					LNode block' collection' cond' init' initValue' loopVar' name' tmp_11' tmp_12' type; 					VList<LNode> attrs' incs' inits; 					if (stmt.Calls(CodeSymbols.Braces)) 						return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' false)); 					else if (stmt.CallsMin(CodeSymbols.If' 1) || stmt.Calls(CodeSymbols.UsingStmt' 2) || stmt.Calls(CodeSymbols.Lock' 2) || stmt.Calls(CodeSymbols.Switch' 2) && stmt.Args[1].Calls(CodeSymbols.Braces)) 						return ProcessBlockCallStmt(stmt' 1); 					else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fixed' 2) && (init = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						init = EliminateSequenceExpressionsInExecStmt(init); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (init.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(init.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.Fixed' LNode.List(init.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.While' 2) && (cond = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						cond = BubbleUpBlocks(cond); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (cond.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList)' LNode.Missing' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(cond.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.If' LNode.List(cond.Args.Last' block' LNode.Call(CodeSymbols.Break))))).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.DoWhile' 2) && (block = stmt.Args[0]) != null && (cond = stmt.Args[1]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						cond = BubbleUpBlocks(cond); 						if (cond.CallsMin(__numrunSequence' 1)) { 							var continue_N = F.Id(NextTempName(Context' "continue_")); 							var bodyStmts = block.AsList(S.Braces); 							bodyStmts.AddRange(cond.Args.WithoutLast(1)); 							bodyStmts.Add(LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' cond.Args.Last)).SetStyle(NodeStyle.Operator)); 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(LNode.Id(CodeSymbols.Bool)' LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' LNode.Literal(true)))))))' continue_N' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List(bodyStmts)).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(0' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.For' 4) && stmt.Args[0].Calls(CodeSymbols.AltList) && (cond = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (block = stmt.Args[3]) != null) { 						inits = stmt.Args[0].Args; 						incs = stmt.Args[2].Args; 						return ESEInForLoop(stmt' attrs' inits' cond' incs' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.ForEach' 3) && (tmp_11 = stmt.Args[0]) != null && tmp_11.Calls(CodeSymbols.Var' 2) && (type = tmp_11.Args[0]) != null && (loopVar = tmp_11.Args[1]) != null && (collection = stmt.Args[1]) != null && (block = stmt.Args[2]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						collection = BubbleUpBlocks(collection); 						if (collection.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(collection.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.ForEach' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(type' loopVar))' collection.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else { 							return stmt.WithArgChanged(stmt.Args.Count - 1' block); 						} 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Var' 2) && (type = stmt.Args[0]) != null && (tmp_12 = stmt.Args[1]) != null && tmp_12.Calls(CodeSymbols.Assign' 2) && (name = tmp_12.Args[0]) != null && (initValue = tmp_12.Args[1]) != null) { 						var initValue_apos = BubbleUpBlocks(initValue); 						if (initValue_apos != initValue) { 							{ 								LNode last; 								VList<LNode> stmts; 								if (initValue_apos.CallsMin((Symbol) "#runSequence"' 1) && (last = initValue_apos.Args[initValue_apos.Args.Count - 1]) != null) { 									stmts = initValue_apos.Args.WithoutLast(1); 									return LNode.Call((Symbol) "#runSequence"' LNode.List().AddRange(stmts).Add(LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' last)))))); 								} else 									return LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' initValue_apos)))); 							} 						} 					} else if (stmt.CallsMin(S.Try' 2)) { 						return ESEInTryStmt(stmt); 					} else if (stmt.HasSpecialName && stmt.ArgCount >= 1 && stmt.Args.Last.Calls(S.Braces)) { 						return ProcessBlockCallStmt(stmt' stmt.ArgCount - 1); 					} else { 						// Ordinary expression statement 						return BubbleUpBlocks(stmt' stmtContext: true); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The following statement contains a magic number: { 					LNode block' collection' cond' init' initValue' loopVar' name' tmp_11' tmp_12' type; 					VList<LNode> attrs' incs' inits; 					if (stmt.Calls(CodeSymbols.Braces)) 						return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' false)); 					else if (stmt.CallsMin(CodeSymbols.If' 1) || stmt.Calls(CodeSymbols.UsingStmt' 2) || stmt.Calls(CodeSymbols.Lock' 2) || stmt.Calls(CodeSymbols.Switch' 2) && stmt.Args[1].Calls(CodeSymbols.Braces)) 						return ProcessBlockCallStmt(stmt' 1); 					else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fixed' 2) && (init = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						init = EliminateSequenceExpressionsInExecStmt(init); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (init.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(init.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.Fixed' LNode.List(init.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.While' 2) && (cond = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						cond = BubbleUpBlocks(cond); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (cond.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList)' LNode.Missing' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(cond.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.If' LNode.List(cond.Args.Last' block' LNode.Call(CodeSymbols.Break))))).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.DoWhile' 2) && (block = stmt.Args[0]) != null && (cond = stmt.Args[1]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						cond = BubbleUpBlocks(cond); 						if (cond.CallsMin(__numrunSequence' 1)) { 							var continue_N = F.Id(NextTempName(Context' "continue_")); 							var bodyStmts = block.AsList(S.Braces); 							bodyStmts.AddRange(cond.Args.WithoutLast(1)); 							bodyStmts.Add(LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' cond.Args.Last)).SetStyle(NodeStyle.Operator)); 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(LNode.Id(CodeSymbols.Bool)' LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' LNode.Literal(true)))))))' continue_N' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List(bodyStmts)).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(0' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.For' 4) && stmt.Args[0].Calls(CodeSymbols.AltList) && (cond = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (block = stmt.Args[3]) != null) { 						inits = stmt.Args[0].Args; 						incs = stmt.Args[2].Args; 						return ESEInForLoop(stmt' attrs' inits' cond' incs' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.ForEach' 3) && (tmp_11 = stmt.Args[0]) != null && tmp_11.Calls(CodeSymbols.Var' 2) && (type = tmp_11.Args[0]) != null && (loopVar = tmp_11.Args[1]) != null && (collection = stmt.Args[1]) != null && (block = stmt.Args[2]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						collection = BubbleUpBlocks(collection); 						if (collection.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(collection.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.ForEach' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(type' loopVar))' collection.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else { 							return stmt.WithArgChanged(stmt.Args.Count - 1' block); 						} 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Var' 2) && (type = stmt.Args[0]) != null && (tmp_12 = stmt.Args[1]) != null && tmp_12.Calls(CodeSymbols.Assign' 2) && (name = tmp_12.Args[0]) != null && (initValue = tmp_12.Args[1]) != null) { 						var initValue_apos = BubbleUpBlocks(initValue); 						if (initValue_apos != initValue) { 							{ 								LNode last; 								VList<LNode> stmts; 								if (initValue_apos.CallsMin((Symbol) "#runSequence"' 1) && (last = initValue_apos.Args[initValue_apos.Args.Count - 1]) != null) { 									stmts = initValue_apos.Args.WithoutLast(1); 									return LNode.Call((Symbol) "#runSequence"' LNode.List().AddRange(stmts).Add(LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' last)))))); 								} else 									return LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' initValue_apos)))); 							} 						} 					} else if (stmt.CallsMin(S.Try' 2)) { 						return ESEInTryStmt(stmt); 					} else if (stmt.HasSpecialName && stmt.ArgCount >= 1 && stmt.Args.Last.Calls(S.Braces)) { 						return ProcessBlockCallStmt(stmt' stmt.ArgCount - 1); 					} else { 						// Ordinary expression statement 						return BubbleUpBlocks(stmt' stmtContext: true); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The following statement contains a magic number: { 					LNode block' collection' cond' init' initValue' loopVar' name' tmp_11' tmp_12' type; 					VList<LNode> attrs' incs' inits; 					if (stmt.Calls(CodeSymbols.Braces)) 						return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' false)); 					else if (stmt.CallsMin(CodeSymbols.If' 1) || stmt.Calls(CodeSymbols.UsingStmt' 2) || stmt.Calls(CodeSymbols.Lock' 2) || stmt.Calls(CodeSymbols.Switch' 2) && stmt.Args[1].Calls(CodeSymbols.Braces)) 						return ProcessBlockCallStmt(stmt' 1); 					else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fixed' 2) && (init = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						init = EliminateSequenceExpressionsInExecStmt(init); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (init.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(init.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.Fixed' LNode.List(init.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.While' 2) && (cond = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						cond = BubbleUpBlocks(cond); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (cond.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList)' LNode.Missing' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(cond.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.If' LNode.List(cond.Args.Last' block' LNode.Call(CodeSymbols.Break))))).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.DoWhile' 2) && (block = stmt.Args[0]) != null && (cond = stmt.Args[1]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						cond = BubbleUpBlocks(cond); 						if (cond.CallsMin(__numrunSequence' 1)) { 							var continue_N = F.Id(NextTempName(Context' "continue_")); 							var bodyStmts = block.AsList(S.Braces); 							bodyStmts.AddRange(cond.Args.WithoutLast(1)); 							bodyStmts.Add(LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' cond.Args.Last)).SetStyle(NodeStyle.Operator)); 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(LNode.Id(CodeSymbols.Bool)' LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' LNode.Literal(true)))))))' continue_N' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List(bodyStmts)).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(0' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.For' 4) && stmt.Args[0].Calls(CodeSymbols.AltList) && (cond = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (block = stmt.Args[3]) != null) { 						inits = stmt.Args[0].Args; 						incs = stmt.Args[2].Args; 						return ESEInForLoop(stmt' attrs' inits' cond' incs' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.ForEach' 3) && (tmp_11 = stmt.Args[0]) != null && tmp_11.Calls(CodeSymbols.Var' 2) && (type = tmp_11.Args[0]) != null && (loopVar = tmp_11.Args[1]) != null && (collection = stmt.Args[1]) != null && (block = stmt.Args[2]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						collection = BubbleUpBlocks(collection); 						if (collection.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(collection.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.ForEach' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(type' loopVar))' collection.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else { 							return stmt.WithArgChanged(stmt.Args.Count - 1' block); 						} 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Var' 2) && (type = stmt.Args[0]) != null && (tmp_12 = stmt.Args[1]) != null && tmp_12.Calls(CodeSymbols.Assign' 2) && (name = tmp_12.Args[0]) != null && (initValue = tmp_12.Args[1]) != null) { 						var initValue_apos = BubbleUpBlocks(initValue); 						if (initValue_apos != initValue) { 							{ 								LNode last; 								VList<LNode> stmts; 								if (initValue_apos.CallsMin((Symbol) "#runSequence"' 1) && (last = initValue_apos.Args[initValue_apos.Args.Count - 1]) != null) { 									stmts = initValue_apos.Args.WithoutLast(1); 									return LNode.Call((Symbol) "#runSequence"' LNode.List().AddRange(stmts).Add(LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' last)))))); 								} else 									return LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' initValue_apos)))); 							} 						} 					} else if (stmt.CallsMin(S.Try' 2)) { 						return ESEInTryStmt(stmt); 					} else if (stmt.HasSpecialName && stmt.ArgCount >= 1 && stmt.Args.Last.Calls(S.Braces)) { 						return ProcessBlockCallStmt(stmt' stmt.ArgCount - 1); 					} else { 						// Ordinary expression statement 						return BubbleUpBlocks(stmt' stmtContext: true); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The following statement contains a magic number: { 					LNode block' collection' cond' init' initValue' loopVar' name' tmp_11' tmp_12' type; 					VList<LNode> attrs' incs' inits; 					if (stmt.Calls(CodeSymbols.Braces)) 						return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' false)); 					else if (stmt.CallsMin(CodeSymbols.If' 1) || stmt.Calls(CodeSymbols.UsingStmt' 2) || stmt.Calls(CodeSymbols.Lock' 2) || stmt.Calls(CodeSymbols.Switch' 2) && stmt.Args[1].Calls(CodeSymbols.Braces)) 						return ProcessBlockCallStmt(stmt' 1); 					else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fixed' 2) && (init = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						init = EliminateSequenceExpressionsInExecStmt(init); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (init.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(init.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.Fixed' LNode.List(init.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.While' 2) && (cond = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						cond = BubbleUpBlocks(cond); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (cond.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList)' LNode.Missing' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(cond.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.If' LNode.List(cond.Args.Last' block' LNode.Call(CodeSymbols.Break))))).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.DoWhile' 2) && (block = stmt.Args[0]) != null && (cond = stmt.Args[1]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						cond = BubbleUpBlocks(cond); 						if (cond.CallsMin(__numrunSequence' 1)) { 							var continue_N = F.Id(NextTempName(Context' "continue_")); 							var bodyStmts = block.AsList(S.Braces); 							bodyStmts.AddRange(cond.Args.WithoutLast(1)); 							bodyStmts.Add(LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' cond.Args.Last)).SetStyle(NodeStyle.Operator)); 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(LNode.Id(CodeSymbols.Bool)' LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' LNode.Literal(true)))))))' continue_N' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List(bodyStmts)).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(0' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.For' 4) && stmt.Args[0].Calls(CodeSymbols.AltList) && (cond = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (block = stmt.Args[3]) != null) { 						inits = stmt.Args[0].Args; 						incs = stmt.Args[2].Args; 						return ESEInForLoop(stmt' attrs' inits' cond' incs' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.ForEach' 3) && (tmp_11 = stmt.Args[0]) != null && tmp_11.Calls(CodeSymbols.Var' 2) && (type = tmp_11.Args[0]) != null && (loopVar = tmp_11.Args[1]) != null && (collection = stmt.Args[1]) != null && (block = stmt.Args[2]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						collection = BubbleUpBlocks(collection); 						if (collection.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(collection.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.ForEach' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(type' loopVar))' collection.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else { 							return stmt.WithArgChanged(stmt.Args.Count - 1' block); 						} 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Var' 2) && (type = stmt.Args[0]) != null && (tmp_12 = stmt.Args[1]) != null && tmp_12.Calls(CodeSymbols.Assign' 2) && (name = tmp_12.Args[0]) != null && (initValue = tmp_12.Args[1]) != null) { 						var initValue_apos = BubbleUpBlocks(initValue); 						if (initValue_apos != initValue) { 							{ 								LNode last; 								VList<LNode> stmts; 								if (initValue_apos.CallsMin((Symbol) "#runSequence"' 1) && (last = initValue_apos.Args[initValue_apos.Args.Count - 1]) != null) { 									stmts = initValue_apos.Args.WithoutLast(1); 									return LNode.Call((Symbol) "#runSequence"' LNode.List().AddRange(stmts).Add(LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' last)))))); 								} else 									return LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' initValue_apos)))); 							} 						} 					} else if (stmt.CallsMin(S.Try' 2)) { 						return ESEInTryStmt(stmt); 					} else if (stmt.HasSpecialName && stmt.ArgCount >= 1 && stmt.Args.Last.Calls(S.Braces)) { 						return ProcessBlockCallStmt(stmt' stmt.ArgCount - 1); 					} else { 						// Ordinary expression statement 						return BubbleUpBlocks(stmt' stmtContext: true); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The following statement contains a magic number: { 					LNode block' collection' cond' init' initValue' loopVar' name' tmp_11' tmp_12' type; 					VList<LNode> attrs' incs' inits; 					if (stmt.Calls(CodeSymbols.Braces)) 						return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' false)); 					else if (stmt.CallsMin(CodeSymbols.If' 1) || stmt.Calls(CodeSymbols.UsingStmt' 2) || stmt.Calls(CodeSymbols.Lock' 2) || stmt.Calls(CodeSymbols.Switch' 2) && stmt.Args[1].Calls(CodeSymbols.Braces)) 						return ProcessBlockCallStmt(stmt' 1); 					else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fixed' 2) && (init = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						init = EliminateSequenceExpressionsInExecStmt(init); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (init.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(init.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.Fixed' LNode.List(init.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.While' 2) && (cond = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						cond = BubbleUpBlocks(cond); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (cond.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList)' LNode.Missing' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(cond.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.If' LNode.List(cond.Args.Last' block' LNode.Call(CodeSymbols.Break))))).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.DoWhile' 2) && (block = stmt.Args[0]) != null && (cond = stmt.Args[1]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						cond = BubbleUpBlocks(cond); 						if (cond.CallsMin(__numrunSequence' 1)) { 							var continue_N = F.Id(NextTempName(Context' "continue_")); 							var bodyStmts = block.AsList(S.Braces); 							bodyStmts.AddRange(cond.Args.WithoutLast(1)); 							bodyStmts.Add(LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' cond.Args.Last)).SetStyle(NodeStyle.Operator)); 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(LNode.Id(CodeSymbols.Bool)' LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' LNode.Literal(true)))))))' continue_N' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List(bodyStmts)).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(0' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.For' 4) && stmt.Args[0].Calls(CodeSymbols.AltList) && (cond = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (block = stmt.Args[3]) != null) { 						inits = stmt.Args[0].Args; 						incs = stmt.Args[2].Args; 						return ESEInForLoop(stmt' attrs' inits' cond' incs' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.ForEach' 3) && (tmp_11 = stmt.Args[0]) != null && tmp_11.Calls(CodeSymbols.Var' 2) && (type = tmp_11.Args[0]) != null && (loopVar = tmp_11.Args[1]) != null && (collection = stmt.Args[1]) != null && (block = stmt.Args[2]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						collection = BubbleUpBlocks(collection); 						if (collection.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(collection.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.ForEach' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(type' loopVar))' collection.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else { 							return stmt.WithArgChanged(stmt.Args.Count - 1' block); 						} 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Var' 2) && (type = stmt.Args[0]) != null && (tmp_12 = stmt.Args[1]) != null && tmp_12.Calls(CodeSymbols.Assign' 2) && (name = tmp_12.Args[0]) != null && (initValue = tmp_12.Args[1]) != null) { 						var initValue_apos = BubbleUpBlocks(initValue); 						if (initValue_apos != initValue) { 							{ 								LNode last; 								VList<LNode> stmts; 								if (initValue_apos.CallsMin((Symbol) "#runSequence"' 1) && (last = initValue_apos.Args[initValue_apos.Args.Count - 1]) != null) { 									stmts = initValue_apos.Args.WithoutLast(1); 									return LNode.Call((Symbol) "#runSequence"' LNode.List().AddRange(stmts).Add(LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' last)))))); 								} else 									return LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' initValue_apos)))); 							} 						} 					} else if (stmt.CallsMin(S.Try' 2)) { 						return ESEInTryStmt(stmt); 					} else if (stmt.HasSpecialName && stmt.ArgCount >= 1 && stmt.Args.Last.Calls(S.Braces)) { 						return ProcessBlockCallStmt(stmt' stmt.ArgCount - 1); 					} else { 						// Ordinary expression statement 						return BubbleUpBlocks(stmt' stmtContext: true); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The following statement contains a magic number: { 					LNode block' collection' cond' init' initValue' loopVar' name' tmp_11' tmp_12' type; 					VList<LNode> attrs' incs' inits; 					if (stmt.Calls(CodeSymbols.Braces)) 						return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' false)); 					else if (stmt.CallsMin(CodeSymbols.If' 1) || stmt.Calls(CodeSymbols.UsingStmt' 2) || stmt.Calls(CodeSymbols.Lock' 2) || stmt.Calls(CodeSymbols.Switch' 2) && stmt.Args[1].Calls(CodeSymbols.Braces)) 						return ProcessBlockCallStmt(stmt' 1); 					else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fixed' 2) && (init = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						init = EliminateSequenceExpressionsInExecStmt(init); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (init.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(init.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.Fixed' LNode.List(init.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.While' 2) && (cond = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						cond = BubbleUpBlocks(cond); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (cond.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList)' LNode.Missing' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(cond.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.If' LNode.List(cond.Args.Last' block' LNode.Call(CodeSymbols.Break))))).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.DoWhile' 2) && (block = stmt.Args[0]) != null && (cond = stmt.Args[1]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						cond = BubbleUpBlocks(cond); 						if (cond.CallsMin(__numrunSequence' 1)) { 							var continue_N = F.Id(NextTempName(Context' "continue_")); 							var bodyStmts = block.AsList(S.Braces); 							bodyStmts.AddRange(cond.Args.WithoutLast(1)); 							bodyStmts.Add(LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' cond.Args.Last)).SetStyle(NodeStyle.Operator)); 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(LNode.Id(CodeSymbols.Bool)' LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' LNode.Literal(true)))))))' continue_N' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List(bodyStmts)).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(0' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.For' 4) && stmt.Args[0].Calls(CodeSymbols.AltList) && (cond = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (block = stmt.Args[3]) != null) { 						inits = stmt.Args[0].Args; 						incs = stmt.Args[2].Args; 						return ESEInForLoop(stmt' attrs' inits' cond' incs' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.ForEach' 3) && (tmp_11 = stmt.Args[0]) != null && tmp_11.Calls(CodeSymbols.Var' 2) && (type = tmp_11.Args[0]) != null && (loopVar = tmp_11.Args[1]) != null && (collection = stmt.Args[1]) != null && (block = stmt.Args[2]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						collection = BubbleUpBlocks(collection); 						if (collection.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(collection.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.ForEach' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(type' loopVar))' collection.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else { 							return stmt.WithArgChanged(stmt.Args.Count - 1' block); 						} 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Var' 2) && (type = stmt.Args[0]) != null && (tmp_12 = stmt.Args[1]) != null && tmp_12.Calls(CodeSymbols.Assign' 2) && (name = tmp_12.Args[0]) != null && (initValue = tmp_12.Args[1]) != null) { 						var initValue_apos = BubbleUpBlocks(initValue); 						if (initValue_apos != initValue) { 							{ 								LNode last; 								VList<LNode> stmts; 								if (initValue_apos.CallsMin((Symbol) "#runSequence"' 1) && (last = initValue_apos.Args[initValue_apos.Args.Count - 1]) != null) { 									stmts = initValue_apos.Args.WithoutLast(1); 									return LNode.Call((Symbol) "#runSequence"' LNode.List().AddRange(stmts).Add(LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' last)))))); 								} else 									return LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' initValue_apos)))); 							} 						} 					} else if (stmt.CallsMin(S.Try' 2)) { 						return ESEInTryStmt(stmt); 					} else if (stmt.HasSpecialName && stmt.ArgCount >= 1 && stmt.Args.Last.Calls(S.Braces)) { 						return ProcessBlockCallStmt(stmt' stmt.ArgCount - 1); 					} else { 						// Ordinary expression statement 						return BubbleUpBlocks(stmt' stmtContext: true); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The following statement contains a magic number: { 					LNode block' collection' cond' init' initValue' loopVar' name' tmp_11' tmp_12' type; 					VList<LNode> attrs' incs' inits; 					if (stmt.Calls(CodeSymbols.Braces)) 						return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' false)); 					else if (stmt.CallsMin(CodeSymbols.If' 1) || stmt.Calls(CodeSymbols.UsingStmt' 2) || stmt.Calls(CodeSymbols.Lock' 2) || stmt.Calls(CodeSymbols.Switch' 2) && stmt.Args[1].Calls(CodeSymbols.Braces)) 						return ProcessBlockCallStmt(stmt' 1); 					else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fixed' 2) && (init = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						init = EliminateSequenceExpressionsInExecStmt(init); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (init.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(init.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.Fixed' LNode.List(init.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.While' 2) && (cond = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						cond = BubbleUpBlocks(cond); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (cond.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList)' LNode.Missing' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(cond.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.If' LNode.List(cond.Args.Last' block' LNode.Call(CodeSymbols.Break))))).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.DoWhile' 2) && (block = stmt.Args[0]) != null && (cond = stmt.Args[1]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						cond = BubbleUpBlocks(cond); 						if (cond.CallsMin(__numrunSequence' 1)) { 							var continue_N = F.Id(NextTempName(Context' "continue_")); 							var bodyStmts = block.AsList(S.Braces); 							bodyStmts.AddRange(cond.Args.WithoutLast(1)); 							bodyStmts.Add(LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' cond.Args.Last)).SetStyle(NodeStyle.Operator)); 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(LNode.Id(CodeSymbols.Bool)' LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' LNode.Literal(true)))))))' continue_N' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List(bodyStmts)).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(0' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.For' 4) && stmt.Args[0].Calls(CodeSymbols.AltList) && (cond = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (block = stmt.Args[3]) != null) { 						inits = stmt.Args[0].Args; 						incs = stmt.Args[2].Args; 						return ESEInForLoop(stmt' attrs' inits' cond' incs' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.ForEach' 3) && (tmp_11 = stmt.Args[0]) != null && tmp_11.Calls(CodeSymbols.Var' 2) && (type = tmp_11.Args[0]) != null && (loopVar = tmp_11.Args[1]) != null && (collection = stmt.Args[1]) != null && (block = stmt.Args[2]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						collection = BubbleUpBlocks(collection); 						if (collection.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(collection.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.ForEach' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(type' loopVar))' collection.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else { 							return stmt.WithArgChanged(stmt.Args.Count - 1' block); 						} 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Var' 2) && (type = stmt.Args[0]) != null && (tmp_12 = stmt.Args[1]) != null && tmp_12.Calls(CodeSymbols.Assign' 2) && (name = tmp_12.Args[0]) != null && (initValue = tmp_12.Args[1]) != null) { 						var initValue_apos = BubbleUpBlocks(initValue); 						if (initValue_apos != initValue) { 							{ 								LNode last; 								VList<LNode> stmts; 								if (initValue_apos.CallsMin((Symbol) "#runSequence"' 1) && (last = initValue_apos.Args[initValue_apos.Args.Count - 1]) != null) { 									stmts = initValue_apos.Args.WithoutLast(1); 									return LNode.Call((Symbol) "#runSequence"' LNode.List().AddRange(stmts).Add(LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' last)))))); 								} else 									return LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' initValue_apos)))); 							} 						} 					} else if (stmt.CallsMin(S.Try' 2)) { 						return ESEInTryStmt(stmt); 					} else if (stmt.HasSpecialName && stmt.ArgCount >= 1 && stmt.Args.Last.Calls(S.Braces)) { 						return ProcessBlockCallStmt(stmt' stmt.ArgCount - 1); 					} else { 						// Ordinary expression statement 						return BubbleUpBlocks(stmt' stmtContext: true); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The following statement contains a magic number: { 					LNode block' collection' cond' init' initValue' loopVar' name' tmp_11' tmp_12' type; 					VList<LNode> attrs' incs' inits; 					if (stmt.Calls(CodeSymbols.Braces)) 						return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' false)); 					else if (stmt.CallsMin(CodeSymbols.If' 1) || stmt.Calls(CodeSymbols.UsingStmt' 2) || stmt.Calls(CodeSymbols.Lock' 2) || stmt.Calls(CodeSymbols.Switch' 2) && stmt.Args[1].Calls(CodeSymbols.Braces)) 						return ProcessBlockCallStmt(stmt' 1); 					else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fixed' 2) && (init = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						init = EliminateSequenceExpressionsInExecStmt(init); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (init.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(init.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.Fixed' LNode.List(init.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.While' 2) && (cond = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						cond = BubbleUpBlocks(cond); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (cond.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList)' LNode.Missing' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(cond.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.If' LNode.List(cond.Args.Last' block' LNode.Call(CodeSymbols.Break))))).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.DoWhile' 2) && (block = stmt.Args[0]) != null && (cond = stmt.Args[1]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						cond = BubbleUpBlocks(cond); 						if (cond.CallsMin(__numrunSequence' 1)) { 							var continue_N = F.Id(NextTempName(Context' "continue_")); 							var bodyStmts = block.AsList(S.Braces); 							bodyStmts.AddRange(cond.Args.WithoutLast(1)); 							bodyStmts.Add(LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' cond.Args.Last)).SetStyle(NodeStyle.Operator)); 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(LNode.Id(CodeSymbols.Bool)' LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' LNode.Literal(true)))))))' continue_N' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List(bodyStmts)).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(0' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.For' 4) && stmt.Args[0].Calls(CodeSymbols.AltList) && (cond = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (block = stmt.Args[3]) != null) { 						inits = stmt.Args[0].Args; 						incs = stmt.Args[2].Args; 						return ESEInForLoop(stmt' attrs' inits' cond' incs' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.ForEach' 3) && (tmp_11 = stmt.Args[0]) != null && tmp_11.Calls(CodeSymbols.Var' 2) && (type = tmp_11.Args[0]) != null && (loopVar = tmp_11.Args[1]) != null && (collection = stmt.Args[1]) != null && (block = stmt.Args[2]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						collection = BubbleUpBlocks(collection); 						if (collection.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(collection.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.ForEach' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(type' loopVar))' collection.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else { 							return stmt.WithArgChanged(stmt.Args.Count - 1' block); 						} 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Var' 2) && (type = stmt.Args[0]) != null && (tmp_12 = stmt.Args[1]) != null && tmp_12.Calls(CodeSymbols.Assign' 2) && (name = tmp_12.Args[0]) != null && (initValue = tmp_12.Args[1]) != null) { 						var initValue_apos = BubbleUpBlocks(initValue); 						if (initValue_apos != initValue) { 							{ 								LNode last; 								VList<LNode> stmts; 								if (initValue_apos.CallsMin((Symbol) "#runSequence"' 1) && (last = initValue_apos.Args[initValue_apos.Args.Count - 1]) != null) { 									stmts = initValue_apos.Args.WithoutLast(1); 									return LNode.Call((Symbol) "#runSequence"' LNode.List().AddRange(stmts).Add(LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' last)))))); 								} else 									return LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' initValue_apos)))); 							} 						} 					} else if (stmt.CallsMin(S.Try' 2)) { 						return ESEInTryStmt(stmt); 					} else if (stmt.HasSpecialName && stmt.ArgCount >= 1 && stmt.Args.Last.Calls(S.Braces)) { 						return ProcessBlockCallStmt(stmt' stmt.ArgCount - 1); 					} else { 						// Ordinary expression statement 						return BubbleUpBlocks(stmt' stmtContext: true); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,EliminateSequenceExpressionsInExecStmt,The following statement contains a magic number: { 					LNode block' collection' cond' init' initValue' loopVar' name' tmp_11' tmp_12' type; 					VList<LNode> attrs' incs' inits; 					if (stmt.Calls(CodeSymbols.Braces)) 						return stmt.WithArgs(EliminateSequenceExpressions(stmt.Args' false)); 					else if (stmt.CallsMin(CodeSymbols.If' 1) || stmt.Calls(CodeSymbols.UsingStmt' 2) || stmt.Calls(CodeSymbols.Lock' 2) || stmt.Calls(CodeSymbols.Switch' 2) && stmt.Args[1].Calls(CodeSymbols.Braces)) 						return ProcessBlockCallStmt(stmt' 1); 					else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Fixed' 2) && (init = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						init = EliminateSequenceExpressionsInExecStmt(init); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (init.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(init.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.Fixed' LNode.List(init.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.While' 2) && (cond = stmt.Args[0]) != null && (block = stmt.Args[1]) != null) { 						cond = BubbleUpBlocks(cond); 						block = EliminateSequenceExpressionsInChildStmt(block); 						if (cond.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList)' LNode.Missing' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(cond.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.If' LNode.List(cond.Args.Last' block' LNode.Call(CodeSymbols.Break))))).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(1' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.DoWhile' 2) && (block = stmt.Args[0]) != null && (cond = stmt.Args[1]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						cond = BubbleUpBlocks(cond); 						if (cond.CallsMin(__numrunSequence' 1)) { 							var continue_N = F.Id(NextTempName(Context' "continue_")); 							var bodyStmts = block.AsList(S.Braces); 							bodyStmts.AddRange(cond.Args.WithoutLast(1)); 							bodyStmts.Add(LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' cond.Args.Last)).SetStyle(NodeStyle.Operator)); 							return LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(LNode.Id(CodeSymbols.Bool)' LNode.Call(CodeSymbols.Assign' LNode.List(continue_N' LNode.Literal(true)))))))' continue_N' LNode.Call(CodeSymbols.AltList)' LNode.Call(CodeSymbols.Braces' LNode.List(bodyStmts)).SetStyle(NodeStyle.Statement))); 						} else 							return stmt.WithArgChanged(0' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.For' 4) && stmt.Args[0].Calls(CodeSymbols.AltList) && (cond = stmt.Args[1]) != null && stmt.Args[2].Calls(CodeSymbols.AltList) && (block = stmt.Args[3]) != null) { 						inits = stmt.Args[0].Args; 						incs = stmt.Args[2].Args; 						return ESEInForLoop(stmt' attrs' inits' cond' incs' block); 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.ForEach' 3) && (tmp_11 = stmt.Args[0]) != null && tmp_11.Calls(CodeSymbols.Var' 2) && (type = tmp_11.Args[0]) != null && (loopVar = tmp_11.Args[1]) != null && (collection = stmt.Args[1]) != null && (block = stmt.Args[2]) != null) { 						block = EliminateSequenceExpressionsInChildStmt(block); 						collection = BubbleUpBlocks(collection); 						if (collection.CallsMin(__numrunSequence' 1)) { 							return LNode.Call(LNode.List(attrs)' CodeSymbols.Braces' LNode.List().AddRange(collection.Args.WithoutLast(1)).Add(LNode.Call(CodeSymbols.ForEach' LNode.List(LNode.Call(CodeSymbols.Var' LNode.List(type' loopVar))' collection.Args.Last' block)))).SetStyle(NodeStyle.Statement); 						} else { 							return stmt.WithArgChanged(stmt.Args.Count - 1' block); 						} 					} else if ((attrs = stmt.Attrs).IsEmpty | true && stmt.Calls(CodeSymbols.Var' 2) && (type = stmt.Args[0]) != null && (tmp_12 = stmt.Args[1]) != null && tmp_12.Calls(CodeSymbols.Assign' 2) && (name = tmp_12.Args[0]) != null && (initValue = tmp_12.Args[1]) != null) { 						var initValue_apos = BubbleUpBlocks(initValue); 						if (initValue_apos != initValue) { 							{ 								LNode last; 								VList<LNode> stmts; 								if (initValue_apos.CallsMin((Symbol) "#runSequence"' 1) && (last = initValue_apos.Args[initValue_apos.Args.Count - 1]) != null) { 									stmts = initValue_apos.Args.WithoutLast(1); 									return LNode.Call((Symbol) "#runSequence"' LNode.List().AddRange(stmts).Add(LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' last)))))); 								} else 									return LNode.Call(LNode.List(attrs)' CodeSymbols.Var' LNode.List(type' LNode.Call(CodeSymbols.Assign' LNode.List(name' initValue_apos)))); 							} 						} 					} else if (stmt.CallsMin(S.Try' 2)) { 						return ESEInTryStmt(stmt); 					} else if (stmt.HasSpecialName && stmt.ArgCount >= 1 && stmt.Args.Last.Calls(S.Braces)) { 						return ProcessBlockCallStmt(stmt' stmt.ArgCount - 1); 					} else { 						// Ordinary expression statement 						return BubbleUpBlocks(stmt' stmtContext: true); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,ESEInForLoop,The following statement contains a magic number: if (init_apos != init || cond_apos != cond || inc_apos != inc) { 					init = init_apos; 					if (inc_apos != inc) { 						var blockStmts = block.AsList(S.Braces).AddRange(inc_apos); 						block = blockStmts.AsLNode(S.Braces); 						inc = LNode.List(); 					} 					if (cond_apos.CallsMin(__numrunSequence' 1)) { 						var preCond = cond_apos.Args.WithoutLast(1); 						cond = cond_apos.Args.Last; 						stmt = LNode.Call(CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(init))' LNode.Missing' LNode.Call(CodeSymbols.AltList' LNode.List(inc))' LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(preCond).Add(LNode.Call(CodeSymbols.If' LNode.List(cond' block' LNode.Call(CodeSymbols.Break))))).SetStyle(NodeStyle.Statement))); 					} else { 						stmt = LNode.Call(LNode.List(attrs)' CodeSymbols.For' LNode.List(LNode.Call(CodeSymbols.AltList' LNode.List(init))' cond' LNode.Call(CodeSymbols.AltList' LNode.List(inc))' block)); 					} 					if (preInit.Count != 0) { 						stmt = LNode.Call(CodeSymbols.Braces' LNode.List().AddRange(preInit).Add(stmt)).SetStyle(NodeStyle.Statement); 					} 					return stmt; 				} else { 					return stmt.WithArgChanged(3' block); 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,ESEInTryStmt,The following statement contains a magic number: for (int i = 1; i < args.Count; i++) { 					var part = args[i]; 					if (part.Calls(S.Finally' 1) || part.Calls(S.Catch' 3)) { 						int lasti = part.ArgCount - 1; 						args[i] = part.WithArgChanged(lasti' EliminateSequenceExpressionsInChildStmt(part.Args[lasti])); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUpBlocks,The following statement contains a magic number: if (!stmtContext) { 					{ 						LNode tmp_14' value' varName' varType; 						VList<LNode> attrs; 						if (expr.Calls(CodeSymbols.Braces)) { 							Context.Sink.Warning(expr' "A braced block is not supported directly within an expression. Did you mean to use `#runSequence {...}`?"); 							result = expr; 						 						} else if ((attrs = expr.Attrs).IsEmpty | true && attrs.NodeNamed(S.Out) != null && expr.Calls(CodeSymbols.Var' 2) && (varType = expr.Args[0]) != null && (varName = expr.Args[1]) != null && varName.IsId) { 							if (varType.IsIdNamed(S.Missing)) 								Context.Sink.Error(expr' "#useSequenceExpressions: the data type of this variable declaration cannot be inferred and must be stated explicitly."); 							result = LNode.Call(LNode.List(_trivia_pure)' (Symbol) "#runSequence"' LNode.List(expr.WithoutAttrNamed(S.Out)' varName.PlusAttrs(LNode.List(LNode.Id(CodeSymbols.Out))))); 						 						} else if ((attrs = expr.Attrs).IsEmpty | true && expr.Calls(CodeSymbols.Var' 2) && (varType = expr.Args[0]) != null && (tmp_14 = expr.Args[1]) != null && tmp_14.Calls(CodeSymbols.Assign' 2) && (varName = tmp_14.Args[0]) != null && (value = tmp_14.Args[1]) != null) 							if (stmtContext) 								result = expr;	// no-op 							else 								result = ConvertVarDeclToRunSequence(attrs' varType' varName' value); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUpBlocks,The following statement contains a magic number: if (!stmtContext) { 					{ 						LNode tmp_14' value' varName' varType; 						VList<LNode> attrs; 						if (expr.Calls(CodeSymbols.Braces)) { 							Context.Sink.Warning(expr' "A braced block is not supported directly within an expression. Did you mean to use `#runSequence {...}`?"); 							result = expr; 						 						} else if ((attrs = expr.Attrs).IsEmpty | true && attrs.NodeNamed(S.Out) != null && expr.Calls(CodeSymbols.Var' 2) && (varType = expr.Args[0]) != null && (varName = expr.Args[1]) != null && varName.IsId) { 							if (varType.IsIdNamed(S.Missing)) 								Context.Sink.Error(expr' "#useSequenceExpressions: the data type of this variable declaration cannot be inferred and must be stated explicitly."); 							result = LNode.Call(LNode.List(_trivia_pure)' (Symbol) "#runSequence"' LNode.List(expr.WithoutAttrNamed(S.Out)' varName.PlusAttrs(LNode.List(LNode.Id(CodeSymbols.Out))))); 						 						} else if ((attrs = expr.Attrs).IsEmpty | true && expr.Calls(CodeSymbols.Var' 2) && (varType = expr.Args[0]) != null && (tmp_14 = expr.Args[1]) != null && tmp_14.Calls(CodeSymbols.Assign' 2) && (varName = tmp_14.Args[0]) != null && (value = tmp_14.Args[1]) != null) 							if (stmtContext) 								result = expr;	// no-op 							else 								result = ConvertVarDeclToRunSequence(attrs' varType' varName' value); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUpBlocks,The following statement contains a magic number: if (!stmtContext) { 					{ 						LNode tmp_14' value' varName' varType; 						VList<LNode> attrs; 						if (expr.Calls(CodeSymbols.Braces)) { 							Context.Sink.Warning(expr' "A braced block is not supported directly within an expression. Did you mean to use `#runSequence {...}`?"); 							result = expr; 						 						} else if ((attrs = expr.Attrs).IsEmpty | true && attrs.NodeNamed(S.Out) != null && expr.Calls(CodeSymbols.Var' 2) && (varType = expr.Args[0]) != null && (varName = expr.Args[1]) != null && varName.IsId) { 							if (varType.IsIdNamed(S.Missing)) 								Context.Sink.Error(expr' "#useSequenceExpressions: the data type of this variable declaration cannot be inferred and must be stated explicitly."); 							result = LNode.Call(LNode.List(_trivia_pure)' (Symbol) "#runSequence"' LNode.List(expr.WithoutAttrNamed(S.Out)' varName.PlusAttrs(LNode.List(LNode.Id(CodeSymbols.Out))))); 						 						} else if ((attrs = expr.Attrs).IsEmpty | true && expr.Calls(CodeSymbols.Var' 2) && (varType = expr.Args[0]) != null && (tmp_14 = expr.Args[1]) != null && tmp_14.Calls(CodeSymbols.Assign' 2) && (varName = tmp_14.Args[0]) != null && (value = tmp_14.Args[1]) != null) 							if (stmtContext) 								result = expr;	// no-op 							else 								result = ConvertVarDeclToRunSequence(attrs' varType' varName' value); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUpBlocks,The following statement contains a magic number: if (result == null) { 					{ 						LNode args' code' value' varName; 						VList<LNode> attrs; 						if ((attrs = expr.Attrs).IsEmpty | true && expr.Calls(CodeSymbols.ColonColon' 2) && (value = expr.Args[0]) != null && IsQuickBindLhs(value) && (varName = expr.Args[1]) != null && varName.IsId) 							result = ConvertVarDeclToRunSequence(attrs' F.Missing' varName' value); 						 						else if ((attrs = expr.Attrs).IsEmpty | true && expr.Calls(CodeSymbols.Lambda' 2) && (args = expr.Args[0]) != null && (code = expr.Args[1]) != null) 							result = expr.WithArgChanged(1' EliminateSequenceExpressionsInLambdaExpr(code' F.Missing)); 						 						else if (expr.Calls(__numrunSequence)) 							result = expr; 						else 							result = BubbleUp_GeneralCall(expr); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUpBlocks,The following statement contains a magic number: if (result == null) { 					{ 						LNode args' code' value' varName; 						VList<LNode> attrs; 						if ((attrs = expr.Attrs).IsEmpty | true && expr.Calls(CodeSymbols.ColonColon' 2) && (value = expr.Args[0]) != null && IsQuickBindLhs(value) && (varName = expr.Args[1]) != null && varName.IsId) 							result = ConvertVarDeclToRunSequence(attrs' F.Missing' varName' value); 						 						else if ((attrs = expr.Attrs).IsEmpty | true && expr.Calls(CodeSymbols.Lambda' 2) && (args = expr.Args[0]) != null && (code = expr.Args[1]) != null) 							result = expr.WithArgChanged(1' EliminateSequenceExpressionsInLambdaExpr(code' F.Missing)); 						 						else if (expr.Calls(__numrunSequence)) 							result = expr; 						else 							result = BubbleUp_GeneralCall(expr); 					} 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUp_GeneralCall2,The following statement contains a magic number: if (lastRunSeq >= 0) { 					// last index of #runSequence that is not marked pure 					int lastRunSeqImpure = args.First(lastRunSeq + 1).LastIndexWhere(a =>  					a.CallsMin(__numrunSequence' 1) && a.AttrNamed(_trivia_pure.Name) == null); 				 					if (lastRunSeq > 0 &&  					(args.Count == 2 && (target.IsIdNamed(S.And) || target.IsIdNamed(S.Or)) || args.Count == 3 && target.IsIdNamed(S.QuestionMark))) 					{ 						Context.Sink.Error(target'  						"#useSequenceExpressions is not designed to support sequences or variable declarations on the right-hand side of the `&&`' `||` or `?` operators. The generated code will be incorrect."); 					} 				 					var argsW = args.ToList(); 					for (int i = 0; i <= lastRunSeq; i++) { 						LNode arg = argsW[i]; 						if (!arg.IsLiteral) { 							if (arg.CallsMin(__numrunSequence' 1)) { 								combinedSequence.AddRange(arg.Args.WithoutLast(1)); 								argsW[i] = arg = arg.Args.Last; 							} 							if (i < lastRunSeqImpure) { 								if (i == 0 && (expr.CallsMin(S.IndexBracks' 1) || expr.CallsMin(S.NullIndexBracks' 1))) { 									// Consider foo[#runSequence(f()' i)]. In case this appears in 									// an lvalue context and `foo` is a struct' we cannot store `foo` in  									// a temporary' as this may silently change the code's behavior. 									// Better to take the risk of evaluating `foo` after `f()`. 								 } else { 									if (isAssignment || arg.Attrs.Any(a => a.IsIdNamed(S.Ref) || a.IsIdNamed(S.Out))) 										argsW[i] = MaybeCreateTemporaryForLValue(arg' ref combinedSequence); 									else { 										// Create a temporary variable to hold this argument 										LNode tmpVarName' tmpVarDecl = TempVarDecl(Context' arg' out tmpVarName); 										combinedSequence.Add(tmpVarDecl); 										argsW[i] = tmpVarName.PlusAttr(_trivia_isTmpVar); 									} 								} 							} 						} 					} 				 					expr = expr.WithArgs(LNode.List(argsW)); 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,BubbleUp_GeneralCall2,The following statement contains a magic number: if (lastRunSeq >= 0) { 					// last index of #runSequence that is not marked pure 					int lastRunSeqImpure = args.First(lastRunSeq + 1).LastIndexWhere(a =>  					a.CallsMin(__numrunSequence' 1) && a.AttrNamed(_trivia_pure.Name) == null); 				 					if (lastRunSeq > 0 &&  					(args.Count == 2 && (target.IsIdNamed(S.And) || target.IsIdNamed(S.Or)) || args.Count == 3 && target.IsIdNamed(S.QuestionMark))) 					{ 						Context.Sink.Error(target'  						"#useSequenceExpressions is not designed to support sequences or variable declarations on the right-hand side of the `&&`' `||` or `?` operators. The generated code will be incorrect."); 					} 				 					var argsW = args.ToList(); 					for (int i = 0; i <= lastRunSeq; i++) { 						LNode arg = argsW[i]; 						if (!arg.IsLiteral) { 							if (arg.CallsMin(__numrunSequence' 1)) { 								combinedSequence.AddRange(arg.Args.WithoutLast(1)); 								argsW[i] = arg = arg.Args.Last; 							} 							if (i < lastRunSeqImpure) { 								if (i == 0 && (expr.CallsMin(S.IndexBracks' 1) || expr.CallsMin(S.NullIndexBracks' 1))) { 									// Consider foo[#runSequence(f()' i)]. In case this appears in 									// an lvalue context and `foo` is a struct' we cannot store `foo` in  									// a temporary' as this may silently change the code's behavior. 									// Better to take the risk of evaluating `foo` after `f()`. 								 } else { 									if (isAssignment || arg.Attrs.Any(a => a.IsIdNamed(S.Ref) || a.IsIdNamed(S.Out))) 										argsW[i] = MaybeCreateTemporaryForLValue(arg' ref combinedSequence); 									else { 										// Create a temporary variable to hold this argument 										LNode tmpVarName' tmpVarDecl = TempVarDecl(Context' arg' out tmpVarName); 										combinedSequence.Add(tmpVarDecl); 										argsW[i] = tmpVarName.PlusAttr(_trivia_isTmpVar); 									} 								} 							} 						} 					} 				 					expr = expr.WithArgs(LNode.List(argsW)); 				}
Magic Number,LeMP,EliminateRunSequences,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\UseSequenceExpressions.out.cs,MaybeCreateTemporaryForLValue,The following statement contains a magic number: { 					LNode _' lhs; 					if (expr.Calls(CodeSymbols.Dot' 2) && (lhs = expr.Args[0]) != null || expr.CallsMin(CodeSymbols.Of' 1) && (lhs = expr.Args[0]) != null) 						return expr.WithArgChanged(0' MaybeCreateTemporaryForLValue(lhs' ref stmtSequence)); 					else if ((_ = expr) != null && !_.IsCall) 						return expr; 					else { 						var args = expr.Args.ToWList(); 						int i = 0; 						if (expr.CallsMin(S.IndexBracks' 1) || expr.CallsMin(S.NullIndexBracks' 1)) { 							// Consider foo[i]. We cannot always store `foo` in a temporary' as 							// this may change the code's behavior in case `foo` is a struct. 							i = 1; 						} 						for (; i < args.Count; i++) { 							if (!args[i].IsLiteral && !args[i].Attrs.Contains(_trivia_isTmpVar)) { 								LNode tmpVarName; 								stmtSequence.Add(TempVarDecl(Context' args[i]' out tmpVarName)); 								args[i] = tmpVarName.PlusAttr(_trivia_isTmpVar); 							} 						} 						return expr.WithArgs(args.ToVList()); 					} 				}
Magic Number,LeMP.CSharp6,CSharp6Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\CSharp6Macro.cs,NullDot,The following statement contains a magic number: if (!node.Calls(S.NullDot' 2)) 				return null;
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,TranslateSpaceDefinition,The following statement contains a magic number: if (args.Count == 1 ? !isAlias : (args.Count != 2 || !body.Calls(S.Braces))) { 				if (isNamespace && args.Count == 1) { 					// Special case: a namespace can auto-wrap whatever statements follow. 					body = F.Braces(context.RemainingNodes); 					context.DropRemainingNodes = true; 				} else 					return Reject(context' node' "A type definition must have the form kind(Name' { Body }) or kind(Name(Bases)' { Body }) (where kind is struct/class/enum/trait/alias)"); 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,TranslateSpaceDefinition,The following statement contains a magic number: if (isAlias) { 				if (!nameEtc.Calls(S.Assign' 2)) 					return Reject(context' node' "An 'alias' (or 'using') definition must have the form alias(NewName = OldName' { Body }) or alias(NewName(Interfaces) = OldName' { Body })"); 				oldName = nameEtc.Args[1]; 				nameEtc = nameEtc.Args[0]; 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,IsComplexId,The following statement contains a magic number: if (id.IsCall) { 				if (id.Name == S.Of) { 					if (allowOf) 						return (id.HasSimpleHead() || IsComplexId(id.Target' false)) && id.Args.All(a => IsComplexId(a)); 					return false; 				} else if (id.Calls(S.Dot' 2)) { 					return id.Args.Last.IsId && IsComplexId(id.Args[0]); 				} else if (id.Calls(S.Substitute' 1)) { 					return true; 				} else 					return false; 			} else 				return id.IsId;
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,DefOrConstructor,The following statement contains a magic number: if (!parts.Count.IsInRange(1' 2) || !sig.IsCall || (body != null && !body.Calls(S.Braces))) 				return null;
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,DefOrConstructor,The following statement contains a magic number: if (sig.Calls(S.Forward' 2)) { 				forwardTo = sig.Args[1]; 				sig = sig.Args[0]; 				if (body != null) 					return Reject(sink' sig.Target' "Cannot use ==> and a method body {...} at the same time."); 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,DefOrConstructor,The following statement contains a magic number: if (sig.Calls(S._RightArrow' 2) || sig.Calls(S.ColonColon' 2)) { 				retVal = sig.Args[1]; 				sig = sig.Args[0]; 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,DefOrConstructor,The following statement contains a magic number: if (sig.Calls(S._RightArrow' 2) || sig.Calls(S.ColonColon' 2)) { 				retVal = sig.Args[1]; 				sig = sig.Args[0]; 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,prop,The following statement contains a magic number: if (parts.Count != 2 || !body.Calls(S.Braces)) 				return Reject(sink' node' "A property definition must have the form prop(Name' { Body })' or prop(Name::type' { Body })");
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,prop,The following statement contains a magic number: if (sig.Calls(S._RightArrow' 2) || sig.Calls(S.ColonColon' 2)) { 				name = sig.Args[0]; 				retVal = sig.Args[1]; 			} else { 				name = sig; 				retVal = F.Missing; 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,prop,The following statement contains a magic number: if (sig.Calls(S._RightArrow' 2) || sig.Calls(S.ColonColon' 2)) { 				name = sig.Args[0]; 				retVal = sig.Args[1]; 			} else { 				name = sig; 				retVal = F.Missing; 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,var,The following statement contains a magic number: for (int i = 0; i < parts.Count; i++) { 				LNode part = parts[i]' type = null' init = null; 				if (part.Calls(S.Assign' 2)) { 					init = part.Args[1]; 					part = part.Args[0]; 				} 				if (part.Calls(S.ColonColon' 2)) { 					type = part.Args[1]; 					part = part.Args[0]; 				} 				if (init == null && part.Calls(S.Assign' 2)) { 					init = part.Args[1]; 					part = part.Args[0]; 				} 				if (!part.IsId) 					return Reject(sink' part' "Expected a simple variable name here"); 				if (type != null && !IsComplexId(type)) 					return Reject(sink' type' "Expected a type name here"); 				type = type ?? F.Missing;  				var nameAndInit = init == null ? part : F.Call(S.Assign' part' init); 				if (varStmt != null && varStmt.Args[0].Equals(type)) { 					// same type used again' e.g. var(x::int' y::int) => #var(int' x' y) 					varStmt = varStmt.WithArgs(varStmt.Args.Add(nameAndInit)); 				} else { 					// first item var(x::int) => #var(int' x) or type changed (var(a::A' b::B) => #var(A' a); #var(B' b)) 					if (varStmt != null) { 						varStmts = varStmts ?? new WList<LNode>(); 						varStmts.Add(varStmt); 					} 					varStmt = node.With(S.Var' type' nameAndInit).SetBaseStyle(NodeStyle.Default); 				} 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,var,The following statement contains a magic number: for (int i = 0; i < parts.Count; i++) { 				LNode part = parts[i]' type = null' init = null; 				if (part.Calls(S.Assign' 2)) { 					init = part.Args[1]; 					part = part.Args[0]; 				} 				if (part.Calls(S.ColonColon' 2)) { 					type = part.Args[1]; 					part = part.Args[0]; 				} 				if (init == null && part.Calls(S.Assign' 2)) { 					init = part.Args[1]; 					part = part.Args[0]; 				} 				if (!part.IsId) 					return Reject(sink' part' "Expected a simple variable name here"); 				if (type != null && !IsComplexId(type)) 					return Reject(sink' type' "Expected a type name here"); 				type = type ?? F.Missing;  				var nameAndInit = init == null ? part : F.Call(S.Assign' part' init); 				if (varStmt != null && varStmt.Args[0].Equals(type)) { 					// same type used again' e.g. var(x::int' y::int) => #var(int' x' y) 					varStmt = varStmt.WithArgs(varStmt.Args.Add(nameAndInit)); 				} else { 					// first item var(x::int) => #var(int' x) or type changed (var(a::A' b::B) => #var(A' a); #var(B' b)) 					if (varStmt != null) { 						varStmts = varStmts ?? new WList<LNode>(); 						varStmts.Add(varStmt); 					} 					varStmt = node.With(S.Var' type' nameAndInit).SetBaseStyle(NodeStyle.Default); 				} 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,var,The following statement contains a magic number: for (int i = 0; i < parts.Count; i++) { 				LNode part = parts[i]' type = null' init = null; 				if (part.Calls(S.Assign' 2)) { 					init = part.Args[1]; 					part = part.Args[0]; 				} 				if (part.Calls(S.ColonColon' 2)) { 					type = part.Args[1]; 					part = part.Args[0]; 				} 				if (init == null && part.Calls(S.Assign' 2)) { 					init = part.Args[1]; 					part = part.Args[0]; 				} 				if (!part.IsId) 					return Reject(sink' part' "Expected a simple variable name here"); 				if (type != null && !IsComplexId(type)) 					return Reject(sink' type' "Expected a type name here"); 				type = type ?? F.Missing;  				var nameAndInit = init == null ? part : F.Call(S.Assign' part' init); 				if (varStmt != null && varStmt.Args[0].Equals(type)) { 					// same type used again' e.g. var(x::int' y::int) => #var(int' x' y) 					varStmt = varStmt.WithArgs(varStmt.Args.Add(nameAndInit)); 				} else { 					// first item var(x::int) => #var(int' x) or type changed (var(a::A' b::B) => #var(A' a); #var(B' b)) 					if (varStmt != null) { 						varStmts = varStmts ?? new WList<LNode>(); 						varStmts.Add(varStmt); 					} 					varStmt = node.With(S.Var' type' nameAndInit).SetBaseStyle(NodeStyle.Default); 				} 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,for,The following statement contains a magic number: if (node.ArgCount == 2 && ((tuple = node.Args[0]).Calls(S.Tuple' 3) || tuple.Calls(S.Tuple' 2))) 				return node.With(S.For'  					asAltList(tuple.Args[0])'  					tuple.Args[1]'  					asAltList(tuple.Args[2' LNode.Missing])' 					node.Args[1]); 			else if (node.ArgCount == 4) 				return node.With(S.For' 					asAltList(node.Args[0])'  					node.Args[1]'  					asAltList(node.Args[2])' 					node.Args[3]);
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,for,The following statement contains a magic number: if (node.ArgCount == 2 && ((tuple = node.Args[0]).Calls(S.Tuple' 3) || tuple.Calls(S.Tuple' 2))) 				return node.With(S.For'  					asAltList(tuple.Args[0])'  					tuple.Args[1]'  					asAltList(tuple.Args[2' LNode.Missing])' 					node.Args[1]); 			else if (node.ArgCount == 4) 				return node.With(S.For' 					asAltList(node.Args[0])'  					node.Args[1]'  					asAltList(node.Args[2])' 					node.Args[3]);
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,for,The following statement contains a magic number: if (node.ArgCount == 2 && ((tuple = node.Args[0]).Calls(S.Tuple' 3) || tuple.Calls(S.Tuple' 2))) 				return node.With(S.For'  					asAltList(tuple.Args[0])'  					tuple.Args[1]'  					asAltList(tuple.Args[2' LNode.Missing])' 					node.Args[1]); 			else if (node.ArgCount == 4) 				return node.With(S.For' 					asAltList(node.Args[0])'  					node.Args[1]'  					asAltList(node.Args[2])' 					node.Args[3]);
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,for,The following statement contains a magic number: if (node.ArgCount == 2 && ((tuple = node.Args[0]).Calls(S.Tuple' 3) || tuple.Calls(S.Tuple' 2))) 				return node.With(S.For'  					asAltList(tuple.Args[0])'  					tuple.Args[1]'  					asAltList(tuple.Args[2' LNode.Missing])' 					node.Args[1]); 			else if (node.ArgCount == 4) 				return node.With(S.For' 					asAltList(node.Args[0])'  					node.Args[1]'  					asAltList(node.Args[2])' 					node.Args[3]);
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,for,The following statement contains a magic number: if (node.ArgCount == 2 && ((tuple = node.Args[0]).Calls(S.Tuple' 3) || tuple.Calls(S.Tuple' 2))) 				return node.With(S.For'  					asAltList(tuple.Args[0])'  					tuple.Args[1]'  					asAltList(tuple.Args[2' LNode.Missing])' 					node.Args[1]); 			else if (node.ArgCount == 4) 				return node.With(S.For' 					asAltList(node.Args[0])'  					node.Args[1]'  					asAltList(node.Args[2])' 					node.Args[3]);
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,for,The following statement contains a magic number: if (node.ArgCount == 2 && ((tuple = node.Args[0]).Calls(S.Tuple' 3) || tuple.Calls(S.Tuple' 2))) 				return node.With(S.For'  					asAltList(tuple.Args[0])'  					tuple.Args[1]'  					asAltList(tuple.Args[2' LNode.Missing])' 					node.Args[1]); 			else if (node.ArgCount == 4) 				return node.With(S.For' 					asAltList(node.Args[0])'  					node.Args[1]'  					asAltList(node.Args[2])' 					node.Args[3]);
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,for,The following statement contains a magic number: if (node.ArgCount == 2 && ((tuple = node.Args[0]).Calls(S.Tuple' 3) || tuple.Calls(S.Tuple' 2))) 				return node.With(S.For'  					asAltList(tuple.Args[0])'  					tuple.Args[1]'  					asAltList(tuple.Args[2' LNode.Missing])' 					node.Args[1]); 			else if (node.ArgCount == 4) 				return node.With(S.For' 					asAltList(node.Args[0])'  					node.Args[1]'  					asAltList(node.Args[2])' 					node.Args[3]);
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,foreach,The following statement contains a magic number: if (args.Count == 2 && args[0].Calls(_in' 2)) { 				LNode decl = args[0].Args[0]' list = args[0].Args[1]' body = args[1]; 				if (decl.IsId) 					decl = F.Var(F.Missing' decl); 				return node.With(S.ForEach' decl' list' body); 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,foreach,The following statement contains a magic number: if (args.Count == 2 && args[0].Calls(_in' 2)) { 				LNode decl = args[0].Args[0]' list = args[0].Args[1]' body = args[1]; 				if (decl.IsId) 					decl = F.Var(F.Missing' decl); 				return node.With(S.ForEach' decl' list' body); 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,do,The following statement contains a magic number: if (node.ArgCount == 2 && args.Last.Calls(_while' 1)) { 				return node.With(S.DoWhile' new VList<LNode>(node.Args[0]' node.Args[1].Args[0])); 			} else if (node.ArgCount == 3 && args.TryGet(1' null).IsIdNamed(_while)) { 				return node.With(S.DoWhile' new VList<LNode>(node.Args[0]' node.Args[2])); 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,do,The following statement contains a magic number: if (node.ArgCount == 2 && args.Last.Calls(_while' 1)) { 				return node.With(S.DoWhile' new VList<LNode>(node.Args[0]' node.Args[1].Args[0])); 			} else if (node.ArgCount == 3 && args.TryGet(1' null).IsIdNamed(_while)) { 				return node.With(S.DoWhile' new VList<LNode>(node.Args[0]' node.Args[2])); 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,do,The following statement contains a magic number: if (node.ArgCount == 2 && args.Last.Calls(_while' 1)) { 				return node.With(S.DoWhile' new VList<LNode>(node.Args[0]' node.Args[1].Args[0])); 			} else if (node.ArgCount == 3 && args.TryGet(1' null).IsIdNamed(_while)) { 				return node.With(S.DoWhile' new VList<LNode>(node.Args[0]' node.Args[2])); 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,IfUnless,The following statement contains a magic number: LNode cond = args.TryGet(0' null)' then = args.TryGet(1' null)' 				elseKW = args.TryGet(2' null)' @else = args.TryGet(3' null);
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,IfUnless,The following statement contains a magic number: LNode cond = args.TryGet(0' null)' then = args.TryGet(1' null)' 				elseKW = args.TryGet(2' null)' @else = args.TryGet(3' null);
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,IfUnless,The following statement contains a magic number: if (@else.IsId && args.Count > 4) 				@else = LNode.Call(@else.Name' new VList<LNode>(args.Slice(4))' node);
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,IfUnless,The following statement contains a magic number: if (@else.IsId && args.Count > 4) 				@else = LNode.Call(@else.Name' new VList<LNode>(args.Slice(4))' node);
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,case,The following statement contains a magic number: if (node.ArgCount >= 2 && node.Args.Last.Calls(S.Braces)) 				return F.Call(S.Splice' new VList<LNode>(node.WithArgs(node.Args.WithoutLast(1))' node.Args.Last));
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,GotoCase,The following statement contains a magic number: if (node.ArgCount == 2 && node.Args[0].IsIdNamed(_case)) 				return node.With(S.GotoCase' node.Args[1]);
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,try,The following statement contains a magic number: for (int i = parts.Count-2; i >= 1; i -= 2) 			{ 				var p = parts[i]; 				if (p.IsIdNamed(_finally)) { 					if (clauses.Count != 0 || finallyCode != null) 						sink.Error(p' "The finally clause must come last' there can only be one of them."); 					finallyCode = parts[i+1]; 				} else if (p.Name == _catch) { 					if (p.ArgCount > 0) { 						if (p.ArgCount > 1) 							sink.Error(p' "Expected catch() to take one argument."); 						// This is a normal catch clause 						clauses.Insert(0' F.Call(S.Catch' p.Args[0]' F.Missing' parts[i + 1])); 					} else { 						// This is a catch-all clause (the type argument is missing) 						if (clauses.Count != 0) 							sink.Error(p' "The catch-all clause must be the last catch clause."); 						clauses.Add(F.Call(S.Catch' F.Missing' F.Missing' parts[i + 1])); 					} 				} else if (i > 1 && parts[i-1].IsIdNamed(_catch)) { 					// This is a normal catch clause 					clauses.Insert(0' F.Call(S.Catch' AutoRemoveParens(p)' F.Missing' parts[i+1])); 					i--; 				} else { 					return Reject(sink' p' "Expected catch or finally clause here. Clause is missing or malformed."); 				} 				if (i == 2) 					return Reject(sink' parts[1]' "Expected catch or finally clause here. Clause is missing or malformed."); 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,try,The following statement contains a magic number: for (int i = parts.Count-2; i >= 1; i -= 2) 			{ 				var p = parts[i]; 				if (p.IsIdNamed(_finally)) { 					if (clauses.Count != 0 || finallyCode != null) 						sink.Error(p' "The finally clause must come last' there can only be one of them."); 					finallyCode = parts[i+1]; 				} else if (p.Name == _catch) { 					if (p.ArgCount > 0) { 						if (p.ArgCount > 1) 							sink.Error(p' "Expected catch() to take one argument."); 						// This is a normal catch clause 						clauses.Insert(0' F.Call(S.Catch' p.Args[0]' F.Missing' parts[i + 1])); 					} else { 						// This is a catch-all clause (the type argument is missing) 						if (clauses.Count != 0) 							sink.Error(p' "The catch-all clause must be the last catch clause."); 						clauses.Add(F.Call(S.Catch' F.Missing' F.Missing' parts[i + 1])); 					} 				} else if (i > 1 && parts[i-1].IsIdNamed(_catch)) { 					// This is a normal catch clause 					clauses.Insert(0' F.Call(S.Catch' AutoRemoveParens(p)' F.Missing' parts[i+1])); 					i--; 				} else { 					return Reject(sink' p' "Expected catch or finally clause here. Clause is missing or malformed."); 				} 				if (i == 2) 					return Reject(sink' parts[1]' "Expected catch or finally clause here. Clause is missing or malformed."); 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,try,The following statement contains a magic number: for (int i = parts.Count-2; i >= 1; i -= 2) 			{ 				var p = parts[i]; 				if (p.IsIdNamed(_finally)) { 					if (clauses.Count != 0 || finallyCode != null) 						sink.Error(p' "The finally clause must come last' there can only be one of them."); 					finallyCode = parts[i+1]; 				} else if (p.Name == _catch) { 					if (p.ArgCount > 0) { 						if (p.ArgCount > 1) 							sink.Error(p' "Expected catch() to take one argument."); 						// This is a normal catch clause 						clauses.Insert(0' F.Call(S.Catch' p.Args[0]' F.Missing' parts[i + 1])); 					} else { 						// This is a catch-all clause (the type argument is missing) 						if (clauses.Count != 0) 							sink.Error(p' "The catch-all clause must be the last catch clause."); 						clauses.Add(F.Call(S.Catch' F.Missing' F.Missing' parts[i + 1])); 					} 				} else if (i > 1 && parts[i-1].IsIdNamed(_catch)) { 					// This is a normal catch clause 					clauses.Insert(0' F.Call(S.Catch' AutoRemoveParens(p)' F.Missing' parts[i+1])); 					i--; 				} else { 					return Reject(sink' p' "Expected catch or finally clause here. Clause is missing or malformed."); 				} 				if (i == 2) 					return Reject(sink' parts[1]' "Expected catch or finally clause here. Clause is missing or malformed."); 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,using2,The following statement contains a magic number: if (node.ArgCount == 2) 				return node.WithTarget(S.UsingStmt);
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,new,The following statement contains a magic number: if (consExpr == null || node.ArgCount > 2 || (csharpInitializer != null && !csharpInitializer.Calls(S.Braces))) 				return null;
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,cast,The following statement contains a magic number: if (node.ArgCount == 2) 				return node.WithTarget(S.Cast);
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,as,The following statement contains a magic number: if (node.ArgCount == 2) 				return node.WithTarget(S.As);
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,is,The following statement contains a magic number: if (node.ArgCount == 2) 				return node.WithTarget(S.Is);
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,QuestionMark,The following statement contains a magic number: if (node.ArgCount == 2 && node.Args[1].Calls(S.Colon' 2)) 				return node.With(S.QuestionMark' node.Args[0]' node.Args[1].Args[0]' node.Args[1].Args[1]);
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,QuestionMark,The following statement contains a magic number: if (node.ArgCount == 2 && node.Args[1].Calls(S.Colon' 2)) 				return node.With(S.QuestionMark' node.Args[0]' node.Args[1].Args[0]' node.Args[1].Args[1]);
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,NamedArg,The following statement contains a magic number: if (node.Calls(S.Colon' 2) && node.Args[0].IsId) 				return node.WithName(S.NamedArg);
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,of,The following statement contains a magic number: if (node.ArgCount == 2 && (kind = node.Args[0]).IsId) { 				if (kind.IsIdNamed(_array)) return node.WithArgChanged(0' kind.WithName(S.Array)); 				if (kind.IsIdNamed(_opt))   return node.WithArgChanged(0' kind.WithName(S.QuestionMark)); 				if (kind.IsIdNamed(_ptr))   return node.WithArgChanged(0' kind.WithName(S._Pointer)); 			} else if (node.ArgCount == 3 && (kind = node.Args[0]).IsIdNamed(_array) && node.Args[1].IsLiteral) { 				return node.WithArgs(kind.WithName(S.GetArrayKeyword((int)node.Args[1].Value))' node.Args[2]); 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,of,The following statement contains a magic number: if (node.ArgCount == 2 && (kind = node.Args[0]).IsId) { 				if (kind.IsIdNamed(_array)) return node.WithArgChanged(0' kind.WithName(S.Array)); 				if (kind.IsIdNamed(_opt))   return node.WithArgChanged(0' kind.WithName(S.QuestionMark)); 				if (kind.IsIdNamed(_ptr))   return node.WithArgChanged(0' kind.WithName(S._Pointer)); 			} else if (node.ArgCount == 3 && (kind = node.Args[0]).IsIdNamed(_array) && node.Args[1].IsLiteral) { 				return node.WithArgs(kind.WithName(S.GetArrayKeyword((int)node.Args[1].Value))' node.Args[2]); 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,of,The following statement contains a magic number: if (node.ArgCount == 2 && (kind = node.Args[0]).IsId) { 				if (kind.IsIdNamed(_array)) return node.WithArgChanged(0' kind.WithName(S.Array)); 				if (kind.IsIdNamed(_opt))   return node.WithArgChanged(0' kind.WithName(S.QuestionMark)); 				if (kind.IsIdNamed(_ptr))   return node.WithArgChanged(0' kind.WithName(S._Pointer)); 			} else if (node.ArgCount == 3 && (kind = node.Args[0]).IsIdNamed(_array) && node.Args[1].IsLiteral) { 				return node.WithArgs(kind.WithName(S.GetArrayKeyword((int)node.Args[1].Value))' node.Args[2]); 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,ColonColon,The following statement contains a magic number: if (a.Count == 2) { 				if (a[0].IsId) { 					var r = node.With(S.Var' a[1]' a[0]); 					r.BaseStyle = NodeStyle.Operator; 					return r; 				} else if (a[0].CallsMin(S.Tuple' 1)) { 					var r = node.With(S.Var' new VList<LNode>(a[1]).AddRange(a[0].Args)); 					r.BaseStyle = NodeStyle.Operator; 					return r; 				} else 					return Reject(context' node' "Expected a variable name or tuple to the left of `::`"); 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,ColonColonInit,The following statement contains a magic number: if (a.Count == 2) { 				LNode name = a[0]' value = a[1]; 				if (name.Calls(S.ColonColon' 2)) 					return node.With(S.Var' name.Args[1]' F.Call(S.Assign' name.Args[0]' value)); 			}
Magic Number,LeMP.Prelude.Les,Macros,C:\repos\qwertie_Loyc\Main\LeMP.StdMacros\Prelude.Les.cs,ColonColonInit,The following statement contains a magic number: if (a.Count == 2) { 				LNode name = a[0]' value = a[1]; 				if (name.Calls(S.ColonColon' 2)) 					return node.With(S.Var' name.Args[1]' F.Call(S.Assign' name.Args[0]' value)); 			}
