Implementation smell,Namespace,Class,File,Method,Description
Long Method,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,NextToken,The method has 269 lines of code.
Long Method,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The method has 317 lines of code.
Long Method,Loyc.Syntax.Les,Les3Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,Expr,The method has 108 lines of code.
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DecDigits,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,HexDigits,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,Scan_HexDigits,Cyclomatic complexity of the method is 13
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,HexNumber,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseIntegerValue,Cyclomatic complexity of the method is 10
Complex Method,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,DecDigits,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,HexDigits,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,HexNumber,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les3PrettyPrinter,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3PrettyPrinter.cs,PrintToHtmlCore,Cyclomatic complexity of the method is 12
Complex Method,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,DoubleToString_HexOrBinary,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les2Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,WriteAttrs,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Syntax.Les,Les2PrecedenceMap,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\LesPrecedenceMap.cs,FindPrecedence,Cyclomatic complexity of the method is 15
Complex Method,Loyc.Syntax.Lexing,BaseILexer<CharSrc;Token>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseILexer.cs,ScanIndent,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Syntax.Lexing,IndentTokenGenerator<Token>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\IndentTokenGenerator.cs,HandleNextToken,Cyclomatic complexity of the method is 17
Complex Method,Loyc.Syntax,LNode,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNode.cs,Equals,Cyclomatic complexity of the method is 15
Complex Method,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloatParts,Cyclomatic complexity of the method is 11
Complex Method,Loyc.Syntax,StandardTriviaInjector,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\StandardTriviaInjector.cs,AttachTriviaTo,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Syntax,AbstractTriviaInjector<Trivia>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\AbstractTriviaInjector.cs,RunCore,Cyclomatic complexity of the method is 13
Complex Method,Loyc.Syntax,AbstractTriviaInjector<Trivia>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\AbstractTriviaInjector.cs,InjectTriviaInChildren,Cyclomatic complexity of the method is 12
Long Parameter List,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,UnescapeQuotedString,The method has 5 parameters. Parameters: sourceText' onError' sb' indentation' les3TQIndents
Long Parameter List,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,UnescapeString,The method has 7 parameters. Parameters: sourceText' quoteType' isTripleQuoted' onError' sb' indentation' les3TQIndents
Long Parameter List,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseNumberCore,The method has 6 parameters. Parameters: source' isNegative' numberBase' isFloat' typeSuffix' error
Long Parameter List,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseIntegerValue,The method has 5 parameters. Parameters: source' isNegative' numberBase' typeSuffix' error
Long Parameter List,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseSpecialFloatValue,The method has 5 parameters. Parameters: source' isNegative' radix' typeSuffix' error
Long Parameter List,Loyc.Syntax.Les,Les3LanguageService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3LanguageService.cs,Print,The method has 5 parameters. Parameters: node' target' sink' mode' options
Long Parameter List,Loyc.Syntax.Les,Les3LanguageService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3LanguageService.cs,Print,The method has 5 parameters. Parameters: nodes' target' sink' mode' options
Long Parameter List,Loyc.Syntax.Les,Les3LanguageService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3LanguageService.cs,Print,The method has 5 parameters. Parameters: node' target' sink' mode' options
Long Parameter List,Loyc.Syntax.Les,Les3LanguageService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3LanguageService.cs,Print,The method has 5 parameters. Parameters: nodes' target' sink' mode' options
Long Parameter List,Loyc.Syntax.Les,Les3LanguageService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3LanguageService.cs,Parse,The method has 5 parameters. Parameters: text' fileName' msgs' inputType' preserveComments
Long Parameter List,Loyc.Syntax.Les,Les3PrettyPrinter,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3PrettyPrinter.cs,PrintToHtml,The method has 5 parameters. Parameters: nodes' output' addPreCode' sink' options
Long Parameter List,Loyc.Syntax.Les,Les3PrettyPrinter,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3PrettyPrinter.cs,PrintToHtmlCore,The method has 5 parameters. Parameters: input' output' addPreCode' newline' colorCodesToCssClasses
Long Parameter List,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,DoubleToString_HexOrBinary,The method has 6 parameters. Parameters: result' value' prefix' bitsPerDigit' isFloat' forcePNotation
Long Parameter List,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintArgListCore,The method has 6 parameters. Parameters: args' leftDelim' rightDelim' style' spacesInside' leftBracket
Long Parameter List,Loyc.Syntax.Les,Les2LanguageService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LanguageService.cs,Print,The method has 5 parameters. Parameters: node' target' sink' mode' options
Long Parameter List,Loyc.Syntax.Les,Les2LanguageService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LanguageService.cs,Print,The method has 5 parameters. Parameters: node' target' sink' mode' options
Long Parameter List,Loyc.Syntax.Les,Les2LanguageService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LanguageService.cs,Print,The method has 5 parameters. Parameters: nodes' target' msgs' mode' options
Long Parameter List,Loyc.Syntax.Les,Les2LanguageService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LanguageService.cs,Parse,The method has 5 parameters. Parameters: text' fileName' msgs' inputType' preserveComments
Long Parameter List,Loyc.Syntax.Les,Les2Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,Print,The method has 5 parameters. Parameters: node' target' sink' mode' options
Long Parameter List,Loyc.Syntax.Les,Les2Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,PrintArgList,The method has 5 parameters. Parameters: args' stmtMode' leftDelim' rightDelim' target
Long Parameter List,Loyc.Syntax.Les,Les2PrecedenceMap,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\LesPrecedenceMap.cs,FindPrecedence,The method has 5 parameters. Parameters: table' symbol' default' cacheWordOp' les3InfixOp
Long Parameter List,Loyc.Syntax.Lexing,IndentTokenGenerator,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\IndentTokenGenerator.cs,IndentTokenGenerator,The method has 5 parameters. Parameters: lexer' allIndentTriggers' eolToken' indentToken' dedentToken
Long Parameter List,Loyc.Syntax.Lexing,Token,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\Token.cs,Token,The method has 5 parameters. Parameters: type' startIndex' length' style' value
Long Parameter List,LeMP,IMacroContext,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LeMP\IMacroContext.cs,PreProcess,The method has 5 parameters. Parameters: input' asRoot' resetOpenNamespaces' resetProperties' areAttributes
Long Parameter List,LeMP,IMacroContext,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LeMP\IMacroContext.cs,PreProcess,The method has 5 parameters. Parameters: input' asRoot' resetOpenNamespaces' resetProperties' isTarget
Long Parameter List,Loyc.Syntax,ILNodePrinter,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\ILNodePrinter.cs,Print,The method has 5 parameters. Parameters: node' target' sink' mode' options
Long Parameter List,Loyc.Syntax,ILNodePrinter,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\ILNodePrinter.cs,Print,The method has 5 parameters. Parameters: nodes' target' sink' mode' options
Long Parameter List,Loyc.Syntax,LNodePrinter,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\ILNodePrinter.cs,Print,The method has 5 parameters. Parameters: printer' node' sink' mode' options
Long Parameter List,Loyc.Syntax,LNodePrinter,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\ILNodePrinter.cs,Print,The method has 5 parameters. Parameters: printer' nodes' sink' mode' options
Long Parameter List,Loyc.Syntax,LNodePrinter,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\ILNodePrinter.cs,PrintMultiple,The method has 6 parameters. Parameters: printer' nodes' sb' sink' mode' options
Long Parameter List,Loyc.Syntax,IParsingService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\IParsingService.cs,Parse,The method has 5 parameters. Parameters: text' fileName' msgs' mode' preserveComments
Long Parameter List,Loyc.Syntax,ParsingService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\IParsingService.cs,Parse,The method has 5 parameters. Parameters: parser' input' msgs' inputType' preserveComments
Long Parameter List,Loyc.Syntax,ParsingService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\IParsingService.cs,ParseSingle,The method has 5 parameters. Parameters: parser' expr' msgs' inputType' preserveComments
Long Parameter List,Loyc.Syntax,ParsingService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\IParsingService.cs,ParseSingle,The method has 6 parameters. Parameters: parser' text' fileName' msgs' inputType' preserveComments
Long Parameter List,Loyc.Syntax,ParsingService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\IParsingService.cs,Parse,The method has 6 parameters. Parameters: parser' stream' fileName' inputType' msgs' preserveComments
Long Parameter List,Loyc.Syntax,ParsingService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\IParsingService.cs,ParseFile,The method has 5 parameters. Parameters: parser' fileName' msgs' inputType' preserveComments
Long Parameter List,Loyc.Syntax,LNode,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNode.cs,Call,The method has 5 parameters. Parameters: name' range' targetStart' targetEnd' style
Long Parameter List,Loyc.Syntax,LNode,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNode.cs,Call,The method has 6 parameters. Parameters: name' args' range' targetStart' targetEnd' style
Long Parameter List,Loyc.Syntax,LNode,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNode.cs,Call,The method has 5 parameters. Parameters: attrs' name' args' range' style
Long Parameter List,Loyc.Syntax,LNode,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNode.cs,Call,The method has 5 parameters. Parameters: attrs' target' args' range' style
Long Parameter List,Loyc.Syntax,LNode,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNode.cs,Call,The method has 5 parameters. Parameters: attrs' name' args' file' style
Long Parameter List,Loyc.Syntax,LNode,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNode.cs,Call,The method has 5 parameters. Parameters: attrs' target' args' file' style
Long Parameter List,Loyc.Syntax,LNodeExt,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeExt.cs,MatchThenParams,The method has 5 parameters. Parameters: cArgs' pArgs' paramsCap' captures' attrs
Long Parameter List,Loyc.Syntax,LNodeExt,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeExt.cs,CaptureGroup,The method has 6 parameters. Parameters: c' p' cArgs' pArgs' captures' attrs
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 5 parameters. Parameters: target' _1' _2' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 6 parameters. Parameters: target' _1' _2' _3' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 7 parameters. Parameters: target' _1' _2' _3' _4' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 7 parameters. Parameters: target' args' startIndex' endIndex' targetStart' targetEnd' style
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 5 parameters. Parameters: target' _1' _2' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 6 parameters. Parameters: target' _1' _2' _3' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 7 parameters. Parameters: target' _1' _2' _3' _4' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 6 parameters. Parameters: target' startIndex' endIndex' targetStart' targetEnd' style
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 7 parameters. Parameters: target' _1' startIndex' endIndex' targetStart' targetEnd' style
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 8 parameters. Parameters: target' _1' _2' startIndex' endIndex' targetStart' targetEnd' style
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 5 parameters. Parameters: target' _1' _2' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 6 parameters. Parameters: target' _1' _2' _3' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 7 parameters. Parameters: target' _1' _2' _3' _4' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 5 parameters. Parameters: target' args' startIndex' endIndex' style
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 5 parameters. Parameters: target' args' startIndex' endIndex' style
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 5 parameters. Parameters: target' _1' startIndex' endIndex' style
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The method has 6 parameters. Parameters: target' _1' _2' startIndex' endIndex' style
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Dot,The method has 7 parameters. Parameters: prefix' symbol' startIndex' endIndex' dotStart' dotEnd' style
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Fn,The method has 6 parameters. Parameters: retType' name' argList' body' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Fn,The method has 6 parameters. Parameters: retType' name' argList' body' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Property,The method has 5 parameters. Parameters: type' name' body' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Property,The method has 7 parameters. Parameters: type' name' argList' body' initializer' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Var,The method has 5 parameters. Parameters: type' name' initValue' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Var,The method has 5 parameters. Parameters: type' name' initValue' startIndex' endIndex
Long Parameter List,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Var,The method has 5 parameters. Parameters: type' name' initValue' startIndex' endIndex
Long Parameter List,Loyc.Syntax,StdSimpleCallNode,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\StdNodes.cs,StdSimpleCallNode,The method has 6 parameters. Parameters: name' args' range' targetStart' targetEnd' style
Long Parameter List,Loyc.Syntax,StdSimpleCallNodeWithAttrs,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\StdNodes.cs,StdSimpleCallNodeWithAttrs,The method has 5 parameters. Parameters: attrs' name' args' range' style
Long Parameter List,Loyc.Syntax,StdSimpleCallNodeWithAttrs,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\StdNodes.cs,StdSimpleCallNodeWithAttrs,The method has 5 parameters. Parameters: attrs' targetToken' args' range' style
Long Parameter List,Loyc.Syntax,StdComplexCallNodeWithAttrs,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\StdNodes.cs,StdComplexCallNodeWithAttrs,The method has 5 parameters. Parameters: attrs' target' args' range' style
Long Parameter List,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseInt,The method has 5 parameters. Parameters: s' index' result' radix' skipSpaces
Long Parameter List,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseUInt,The method has 5 parameters. Parameters: s' result' radix' flags' numDigits
Long Parameter List,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseUInt,The method has 5 parameters. Parameters: s' result' radix' flags' numDigits
Long Parameter List,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloatParts,The method has 9 parameters. Parameters: source' radix' negative' mantissa' exponentBaseR' exponentBase2' exponentBase10' numDigits' flags
Long Parameter List,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloatParts,The method has 8 parameters. Parameters: source' radix' negative' mantissa' exponentBase2' exponentBase10' numDigits' flags
Long Parameter List,Loyc.Syntax,StandardTriviaInjector,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\StandardTriviaInjector.cs,StandardTriviaInjector,The method has 6 parameters. Parameters: sortedTrivia' sourceFile' newlineTypeInt' mlCommentPrefix' mlCommentSuffix' slCommentPrefix
Long Parameter List,Loyc.Syntax,StandardTriviaInjector,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\StandardTriviaInjector.cs,AttachTriviaTo,The method has 5 parameters. Parameters: node' trivia' loc' parent' indexInParent
Long Parameter List,Loyc.Syntax,AbstractTriviaInjector<Trivia>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\AbstractTriviaInjector.cs,AttachTriviaTo,The method has 5 parameters. Parameters: node' trivia' loc' parent' indexInParent
Long Parameter List,Loyc.Syntax,AbstractTriviaInjector<Trivia>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\AbstractTriviaInjector.cs,AttachTriviaTo,The method has 5 parameters. Parameters: node' trivia' loc' parent' indexInParent
Long Parameter List,Loyc.Syntax,AbstractTriviaInjector<Trivia>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\AbstractTriviaInjector.cs,TryAttachTriviaTo,The method has 5 parameters. Parameters: prev' triviaList' loc' parent' prevIndexInParent
Long Parameter List,Loyc.Syntax,AbstractTriviaInjector<Trivia>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\AbstractTriviaInjector.cs,InjectTriviaInChildren,The method has 5 parameters. Parameters: parent' triviaRange' trivia' indexInParent' node
Long Parameter List,Loyc.Syntax,StreamCharSource,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\SourceFiles\StreamCharSource.cs,AutoResizeAndGetChars,The method has 5 parameters. Parameters: buf' outChars' outIndex' neededOutSize' flush
Long Identifier,Loyc.Syntax.Les,Les3PrinterOptions,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,,The length of the parameter SpacesBetweenAppendedStatements is 31.
Long Identifier,Loyc.Syntax.Les,Les3PrinterOptions,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,,The length of the parameter SpaceAroundInfixStopPrecedence is 30.
Long Identifier,Loyc.Syntax.Les,Les3PrinterOptions,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,,The length of the parameter SpaceAfterPrefixStopPrecedence is 30.
Long Identifier,Loyc.Syntax.Les,Les2PrinterOptions,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,,The length of the parameter SpacesBetweenAppendedStatements is 31.
Long Identifier,Loyc.Syntax.Les,Les2PrinterOptions,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,,The length of the parameter SpaceAroundInfixStopPrecedence is 30.
Long Identifier,Loyc.Syntax.Les,Les2PrinterOptions,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,,The length of the parameter SpaceAfterPrefixStopPrecedence is 30.
Long Statement,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,TQString,The length of the statement  "			// Line 100: (["] ["] ["] nongreedy(Newline / [^\$])* ["] ["] ["] | ['] ['] ['] nongreedy(Newline / [^\$])* ['] ['] ['])" is 120.
Long Statement,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,NextToken,The length of the statement  "			// Line 167: ( &{InputPosition == 0} Shebang / Symbol / Id / Newline / SLComment / MLComment / Number / TQString / DQString / SQString / BQOperator / Comma / Semicolon / LParen / [)] / [[] / [\]] / [{] / [}] / At / Operator )" is 225.
Long Statement,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,UnescapeString,The length of the statement  "						onError(i0' @"Unrecognized escape sequence '\{0}' in string".Localized(PrintHelpers.EscapeCStyle(sourceText[0' ' '].ToString()' EscapeC.Control)));" is 147.
Long Statement,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,GetOpNameAndType,The length of the statement  "			else if (last == '=' && (length == 1 || (first != '=' && first != '!' && !(length == 2 && (first == '<' || first == '>')))))" is 124.
Long Statement,Loyc.Syntax.Les,Les2Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2ParserGrammar.out.cs,Expr,The length of the statement  "			// Line 131: greedy( &{context.CanParse(prec = InfixPrecedenceOf(LT($LI)))} (TT.Assignment|TT.BQOperator|TT.Dot|TT.NormalOp) Expr | &{context.CanParse(P.Primary)} FinishPrimaryExpr | &{context.CanParse(P.Of)} TT.Not (TT.LParen ExprList TT.RParen / Expr) | &{context.CanParse(SuffixPrecedenceOf(LT($LI)))} TT.PreOrSufOp )*" is 321.
Long Statement,Loyc.Syntax.Les,Les2Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2ParserGrammar.out.cs,Expr,The length of the statement  "							e = F.Call(ToSuffixOpName((Symbol) t.Value)' e' e.Range.StartIndex' t.EndIndex' t.StartIndex' t.EndIndex' NodeStyle.Operator);" is 126.
Long Statement,Loyc.Syntax.Les,Les2Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2ParserGrammar.out.cs,FinishPrimaryExpr,The length of the statement  "				e = F.Call(S.IndexBracks' args' e.Range.StartIndex' c.EndIndex' lit_lsqb.StartIndex' lit_lsqb.EndIndex' NodeStyle.Operator);" is 124.
Long Statement,Loyc.Syntax.Les,Les2Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2ParserGrammar.out.cs,Particle,The length of the statement  "			// Line 191: ( TT.Id | TT.Literal | TT.At (TT.LBrack TokenTree TT.RBrack | TT.LBrace TokenTree TT.RBrace) | TT.LBrace StmtList TT.RBrace | TT.LBrack ExprList TT.RBrack | (TT.LParen|TT.SpaceLParen) ExprList TT.RParen )" is 217.
Long Statement,Loyc.Syntax.Les,Les2Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2ParserGrammar.out.cs,TokenTree,The length of the statement  "			// Line 233: nongreedy((TT.LBrace|TT.LBrack|TT.LParen|TT.SpaceLParen) TokenTree (TT.RBrace|TT.RBrack|TT.RParen) / ~(EOF))*" is 122.
Long Statement,Loyc.Syntax.Les,Les3LanguageService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3LanguageService.cs,Parse,The length of the statement  "				var injector = new StandardTriviaInjector(saver.TriviaList' input.SourceFile' (int)TokenType.Newline' "/*"' "*/"' "//");" is 120.
Long Statement,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,TQString,The length of the statement  "			// Line 102: (["] ["] ["] nongreedy(Newline / [^\$])* ["] ["] ["] | ['] ['] ['] nongreedy(Newline / [^\$])* ['] ['] ['])" is 120.
Long Statement,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,Operator,The length of the statement  "			// Line 123: (([$])? ([!%&*+\-/:<-?^|~] | [.] [^0-9] =>  greedy([.])*) ([!%&*+\-/:<-?^|~] | [.] [^0-9] =>  greedy([.])*)* / [$])" is 128.
Long Statement,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The length of the statement  "			// Line 192: ( Shebang / SpecialLiteral / [`] => Id / Id / Newline / SLComment / MLComment / Number / TQString / DQString / SQString / SQOperator / ['] / [;] / [(] / [)] / [[] / [\]] / [{] / [}] / [@] / Keyword / Operator )" is 223.
Long Statement,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,InitLiteralParsers,The length of the statement  "			Func<UString' object> u   = s => { ulong n; return ParseULong(s' out n) ? ((uint)n == n ? (object)(uint)n : (object)(ulong)n) : null; };" is 136.
Long Statement,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,InitLiteralParsers,The length of the statement  "			Func<UString' object> f32 = s => { double n; return ParseDouble(s' out n) && n >= float.MinValue && n <= float.MaxValue ? (object)(float)n : null; };" is 149.
Long Statement,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetOpNameAndType,The length of the statement  "			else if (last == '=' && (length == 1 || (first != '=' && first != '!' && !(length == 2 && (first == '<' || first == '>')))))" is 124.
Long Statement,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,PrintErrorIfTypeMarkerIsKeywordLiteral,The length of the statement  "				ErrorSink.Write(Severity.Error' IndexToPositionObject(_startPosition)' "Keyword '{0}' used as a type marker"' boolOrNull);" is 122.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,ExprList,The length of the statement  "			// Line 83: ((&{isBracedBlock} (TT.RBrack|TT.RParen))? (TT.Comma|TT.Newline|TT.Semicolon) NewlinesOpt ({..} / TopExpr) ErrorTokensOpt)*" is 135.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,Expr,The length of the statement  "			// Line 153: (KeywordExpression | PrefixExpr greedy( &{context.CanParse(P.Primary)} FinishPrimaryExpr | &{CanParse(context' $LI' out prec)} InfixOperatorName Expr | &{context.CanParse(_prec.Find(OperatorShape.Suffix' LT($LI).Value))} TT.PreOrSufOp | &{context.CanParse(P.Of)} TT.Not (TT.LParen ExprList TT.RParen / Expr) )*)" is 324.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,Expr,The length of the statement  "				// Line 158: greedy( &{context.CanParse(P.Primary)} FinishPrimaryExpr | &{CanParse(context' $LI' out prec)} InfixOperatorName Expr | &{context.CanParse(_prec.Find(OperatorShape.Suffix' LT($LI).Value))} TT.PreOrSufOp | &{context.CanParse(P.Of)} TT.Not (TT.LParen ExprList TT.RParen / Expr) )*" is 291.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,Expr,The length of the statement  "								e = F.Call(_prec.ToSuffixOpName((Symbol) t.Value)' e' e.Range.StartIndex' t.EndIndex' t.StartIndex' t.EndIndex' NodeStyle.Operator);" is 132.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,InfixOperatorName,The length of the statement  "			// Line 181: ( (TT.Assignment|TT.Dot|TT.NormalOp) (TT.Newline)* | &{(TT) LA($LI + 1) != TT.Newline} TT.Colon | &!{IsContinuator(LT($LI).Value)} TT.Id (&{op.EndIndex == LT0.StartIndex} (TT.Assignment|TT.Dot|TT.NormalOp) / {..}) (TT.Newline (TT.Newline)* / {..}) )" is 262.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,InfixOperatorName,The length of the statement  "								Error(0' "Syntax error. {0}' is used like an operator but is followed by a newline' which is not allowed unless the expression is placed in parentheses.".Localized(result));" is 173.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,CallArgs,The length of the statement  "			result = MarkCall(F.Call(target' args' target.Range.StartIndex' lit_rpar.EndIndex).SetBaseStyle(NodeStyle.PrefixNotation));" is 123.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,Particle,The length of the statement  "			// Line 238: ( (TT.BQId|TT.Id) | TT.Literal | TT.SingleQuoteOp TokenList | BracedBlock | SquareBracketList | TT.LParen ExprList TT.RParen )" is 139.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,Particle,The length of the statement  "					result = F.Call((Symbol) op.Value' got_TokenList' op.StartIndex' got_TokenList.IsEmpty ? op.EndIndex : got_TokenList.Last.Range.EndIndex);" is 138.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,SquareBracketList,The length of the statement  "			result = F.Call(S.Array' list' lit_lsqb.StartIndex' lit_rsqb.EndIndex' lit_lsqb.StartIndex' lit_lsqb.EndIndex).SetStyle(NodeStyle.Expression);" is 142.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,TokenListParticle,The length of the statement  "			// Line 280: ( TT.LParen TokenListEx TT.RParen / SquareBracketList / BracedBlock / TT.Literal / ~(EOF|TT.Comma|TT.Newline|TT.RBrace|TT.RBrack|TT.RParen|TT.Semicolon) )" is 167.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,BracedBlock,The length of the statement  "			return F.Call(S.Braces' stmts' lit_lcub.StartIndex' lit_rcub.EndIndex' lit_lcub.StartIndex' lit_lcub.EndIndex).SetStyle(NodeStyle.Statement);" is 141.
Long Statement,Loyc.Syntax.Les,Les3Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,CanParse,The length of the statement  "				Error(li' "Operator \"{0}\" cannot be mixed with the infix operator to its left. Add parentheses to clarify the code's meaning."' LT(li).Value);" is 144.
Long Statement,Loyc.Syntax.Les,Les3PrettyPrinter,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3PrettyPrinter.cs,PrintToHtmlCore,The length of the statement  "						input.TryGet(i + 2' '\0').IsOneOf((char)LesColorCode.Id' (char)LesColorCode.Number' (char)LesColorCode.KeywordLiteral' (char)LesColorCode.CustomLiteral' (char)LesColorCode.String))" is 180.
Long Statement,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintCallAsNormalOp,The length of the statement  "			Precedence prec = Les3PrecedenceMap.Default.Find(shape' opName' cacheWordOp: true' les3InfixOp: shape == OperatorShape.Infix);" is 126.
Long Statement,Loyc.Syntax.Les,CustomLiteral,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\SpecialLiteral.cs,ToString,The length of the statement  "				return LiteralTypeAsLes3Identifier() + "\"" + PrintHelpers.EscapeCStyle((string)Value' EscapeC.Control | EscapeC.DoubleQuotes) + "\"";" is 134.
Long Statement,Loyc.Syntax.Les,Les2LanguageService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LanguageService.cs,Parse,The length of the statement  "				var injector = new StandardTriviaInjector(saver.TriviaList' saver.SourceFile' (int)TokenType.Newline' "/*"' "*/"' "//");" is 120.
Long Statement,Loyc.Syntax.Les,Les2Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,PrintShortInteger,The length of the statement  "			ErrorSink.Write(Severity.Warning' null' "LesNodePrinter: Encountered literal of type '{0}'. It will be printed as 'Int32'."' type);" is 131.
Long Statement,Loyc.Syntax,ParsingService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\IParsingService.cs,ExtensionMatches,The length of the statement  "			return fn.Length > ext.Length && fn[fn.Length - ext.Length - 1] == '.' && fn.EndsWith(ext' StringComparison.OrdinalIgnoreCase);" is 127.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdComplexCallNode(target' new VList<LNode>(args)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 121.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdComplexCallNode(target' new VList<LNode>(_1' _2)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 123.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdComplexCallNode(target' new VList<LNode>(_1' _2).Add(_3)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 131.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdComplexCallNode(target' new VList<LNode>(_1' _2).Add(_3).Add(_4)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 139.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdComplexCallNode(target' new VList<LNode>(list)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 121.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' args' new SourceRange(_file' startIndex' endIndex - startIndex)' targetStart' targetEnd' style);" is 133.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' new VList<LNode>(_1' _2)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 122.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' new VList<LNode>(_1' _2).Add(_3)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 130.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' new VList<LNode>(_1' _2).Add(_3).Add(_4)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 138.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' VList<LNode>.Empty' new SourceRange(_file' startIndex' endIndex - startIndex)' targetStart' targetEnd' style);" is 147.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' new VList<LNode>(_1)' new SourceRange(_file' startIndex' endIndex - startIndex)' targetStart' targetEnd' style);" is 149.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' new VList<LNode>(_1' _2)' new SourceRange(_file' startIndex' endIndex - startIndex)' targetStart' targetEnd' style);" is 153.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' new VList<LNode>(args)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 120.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' new VList<LNode>(args)' new SourceRange(_file' startIndex' endIndex - startIndex)' style);" is 127.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' VList<LNode>.Empty' new SourceRange(_file' startIndex' endIndex - startIndex)' style);" is 123.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' new VList<LNode>(_1)' new SourceRange(_file' startIndex' endIndex - startIndex)' style);" is 125.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Call,The length of the statement  "			return new StdSimpleCallNode(target' new VList<LNode>(_1' _2)' new SourceRange(_file' startIndex' endIndex - startIndex)' style);" is 129.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Dot,The length of the statement  "			return new StdSimpleCallNode(S.Dot' new VList<LNode>(prefix' Id(symbol))' new SourceRange(_file' startIndex' endIndex - startIndex));" is 133.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Dot,The length of the statement  "			return new StdSimpleCallNode(S.Dot' new VList<LNode>(prefix' symbol)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 129.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Dot,The length of the statement  "			return new StdSimpleCallNode(S.Dot' new VList<LNode>(prefix' symbol)' new SourceRange(_file' startIndex' endIndex - startIndex)' dotStart' dotEnd' style);" is 154.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Tuple,The length of the statement  "			return new StdSimpleCallNode(S.Tuple' new VList<LNode>(contents)' new SourceRange(_file' startIndex' endIndex - startIndex));" is 125.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Fn,The length of the statement  "			return new StdSimpleCallNode(S.Fn' new VList<LNode>(list)' new SourceRange(_file' startIndex' endIndex - startIndex)' startIndex' startIndex);" is 142.
Long Statement,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Property,The length of the statement  "			return new StdSimpleCallNode(S.Property' new VList<LNode>(list)' new SourceRange(_file' startIndex' endIndex - startIndex)' startIndex' startIndex);" is 148.
Long Statement,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloatParts,The length of the statement  "			bool success = TryParseFloatParts(ref source' radix' out negative' out mantissa' out exponentBaseR' out exponentBase2' out exponentBase10' out numDigits' flags);" is 161.
Long Statement,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseDouble,The length of the statement  "			if (!TryParseFloatParts(ref source' radix' out negative' out mantissa' out exponentBase2' out exponentBase10' out numDigits' flags))" is 132.
Long Statement,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloat,The length of the statement  "			if (!TryParseFloatParts(ref source' radix' out negative' out mantissa' out exponentBase2' out exponentBase10' out numDigits' flags))" is 132.
Long Statement,Loyc.Syntax,AbstractTriviaInjector<Trivia>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\AbstractTriviaInjector.cs,InjectTriviaInChildren,The length of the statement  "					newChildren.InternalArray[i].A = AttachTriviaTo(last.A' triviaList' TriviaLocation.TrailingExtra' node' last.B) ?? last.A;" is 122.
Long Statement,Loyc.Syntax,StreamCharSource,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\SourceFiles\StreamCharSource.cs,ReadNextBlock,The length of the statement  "						throw new ArgumentException(Localize.Localized("StreamCharSource cannot use the supplied decoder because it can produce single characters from byte sequences longer than {0} characters"' MaxSeqSize));" is 200.
Long Statement,Loyc.Syntax,StreamCharSource,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\SourceFiles\StreamCharSource.cs,ReadNextBlock,The length of the statement  "					throw new ArgumentException(Localize.Localized("StreamCharSource cannot use the supplied decoder because it seems to divide characters on bit boundaries")' exc);" is 161.
Long Statement,Loyc.Syntax.Impl,PrinterState,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\PrinterState.cs,GetCheckpoint,The length of the statement  "			return new Checkpoint { _oldLineStart = _lineStartIndex' _oldLineNo = LineNo' _oldLineStartAfterIndent = _lineStartAfterIndent };" is 129.
Complex Conditional,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DecNumber,The conditional expression  "la1 == '+' || la1 == '-' || la1 >= '0' && la1 <= '9'"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,HexNumber,The conditional expression  "la1 == '+' || la1 == '-' || la1 >= '0' && la1 <= '9'"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,BinNumber,The conditional expression  "la1 == '+' || la1 == '-' || la1 >= '0' && la1 <= '9'"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,SQString,The conditional expression  "!(la0 == -1 || la0 == '\n' || la0 == '\r' || la0 == '\'')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DQString,The conditional expression  "!(la0 == -1 || la0 == '\n' || la0 == '\r' || la0 == '"')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,BQString,The conditional expression  "!(la0 == -1 || la0 == '\n' || la0 == '\r' || la0 == '`')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,GetOpNameAndType,The conditional expression  "length >= 2 && first == last && (last == '+' || last == '-' || last == '!')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,GetOpNameAndType,The conditional expression  "last == '=' && (length == 1 || (first != '=' && first != '!' && !(length == 2 && (first == '<' || first == '>'))))"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,DecNumber,The conditional expression  "la1 == '+' || la1 == '-' || la1 >= '0' && la1 <= '9'"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,HexNumber,The conditional expression  "la1 == '+' || la1 == '-' || la1 >= '0' && la1 <= '9'"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,BinNumber,The conditional expression  "la1 == '+' || la1 == '-' || la1 >= '0' && la1 <= '9'"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,DQString,The conditional expression  "!(la0 == -1 || la0 == '\n' || la0 == '\r' || la0 == '"')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,BQString,The conditional expression  "!(la0 == -1 || la0 == '\n' || la0 == '\r' || la0 == '`')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetOpNameAndType,The conditional expression  "length >= 2 && first == last && (last == '+' || last == '-' || last == '!')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetOpNameAndType,The conditional expression  "last == '=' && (length == 1 || (first != '=' && first != '!' && !(length == 2 && (first == '<' || first == '>'))))"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintIdCore,The conditional expression  "forceQuote || !IsNormalIdentifier(name) || name == sy_true || name == sy_false || name == sy_null"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintStringCore,The conditional expression  "c == quoteType && ((b == quoteType && a == quoteType) || i + 1 == text.Length)"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintStringCore,The conditional expression  "c == '\\' && i + 2 < text.Length && text[i + 2] == '/' && 						((d = text[i + 1]) == 'r' || d == 'n' || d == 't' || d == '0' || d == '\\' || d == '\'' || d == '"')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintStringCore,The conditional expression  "c >= 0xDC80 && c <= 0xDCFF && !(b >= 0xD800 && b <= 0xDBFF)"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,IsContinuator,The conditional expression  "(argc == 1 || argc == 2) && ContinuatorOps.Contains(candidate.Name) && HasTargetIdWithoutPAttrs(candidate)"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,IsAcceptableKeyword,The conditional expression  "!(c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c == '_')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,GetPrecedenceIfOperator,The conditional expression  "(naturalOp && bs != NodeStyle.PrefixNotation) || 					(bs == NodeStyle.Operator && node.Name != null)"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,AutoPrintBracesOrBracks,The conditional expression  "(name == S.Array || name == S.Braces) && node.IsCall() && !HasPAttrs(node.Target)"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,IsSpecialIdentifier,The conditional expression  "special && !backquote && (name.Name == "-inf_d" || name.Name == "-inf_f")"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,PrintStringCore,The conditional expression  "a == '\\' && b == '\\' && (c == quoteType || c == 'n' || c == 'r' || c == '\\')"  is complex.
Complex Conditional,Loyc.Syntax.Les,Les2PrecedenceMap,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\LesPrecedenceMap.cs,IsOperator,The conditional expression  "c == '/' && rejectComment && (name[i] == '/' || name[i] == '*')"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,Match,The conditional expression  "la != a && la != b && la != c && la != d"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,MatchRange,The conditional expression  "(la < aLo || la > aHi) && (la < bLo || la > bHi)"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,MatchExcept,The conditional expression  "la == -1 || la == a || la == b || la == c"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,MatchExcept,The conditional expression  "la == -1 || la == a || la == b || la == c || la == d"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,MatchExceptRange,The conditional expression  "la == -1 || (la >= aLo && la <= aHi) || (la >= bLo && la <= bHi)"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,TryMatch,The conditional expression  "la != a && la != b && la != c && la != d"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,TryMatchRange,The conditional expression  "(la < aLo || la > aHi) && (la < bLo || la > bHi)"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,TryMatchExcept,The conditional expression  "la == -1 || la == a || la == b || la == c"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,TryMatchExcept,The conditional expression  "la == -1 || la == a || la == b || la == c || la == d"  is complex.
Complex Conditional,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,TryMatchExceptRange,The conditional expression  "la == -1 || (la >= aLo && la <= aHi) || (la >= bLo && la <= bHi)"  is complex.
Complex Conditional,Loyc.Syntax,BaseParser<Token;MatchType>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\BaseParser.cs,Match,The conditional expression  "!la.Equals(a) && !la.Equals(b) && !la.Equals(c) && !la.Equals(d)"  is complex.
Complex Conditional,Loyc.Syntax,BaseParser<Token;MatchType>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\BaseParser.cs,MatchExcept,The conditional expression  "la.Equals(a) || la.Equals(b) || la.Equals(c) || la.Equals(EOF)"  is complex.
Complex Conditional,Loyc.Syntax,BaseParser<Token;MatchType>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\BaseParser.cs,MatchExcept,The conditional expression  "la.Equals(a) || la.Equals(b) || la.Equals(c) || la.Equals(d) || la.Equals(EOF)"  is complex.
Complex Conditional,Loyc.Syntax,BaseParser<Token;MatchType>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\BaseParser.cs,TryMatch,The conditional expression  "!la.Equals(a) && !la.Equals(b) && !la.Equals(c) && !la.Equals(d)"  is complex.
Complex Conditional,Loyc.Syntax,BaseParser<Token;MatchType>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\BaseParser.cs,TryMatchExcept,The conditional expression  "la.Equals(EOF) || la.Equals(a) || la.Equals(b) || la.Equals(c)"  is complex.
Complex Conditional,Loyc.Syntax,BaseParser<Token;MatchType>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\BaseParser.cs,TryMatchExcept,The conditional expression  "la.Equals(EOF) || la.Equals(a) || la.Equals(b) || la.Equals(c) || la.Equals(d)"  is complex.
Virtual Method Call from Constructor,Loyc.Syntax.Les,Les2PrecedenceMap,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\LesPrecedenceMap.cs,Les2PrecedenceMap,The constructor "Les2PrecedenceMap" calls a virtual method "Reset".
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DecNumber,The following statement contains a magic number: _numberBase = 10;
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,HexNumber,The following statement contains a magic number: _numberBase = 16;
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,BinNumber,The following statement contains a magic number: _numberBase = 2;
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,TQString,The following statement contains a magic number: if (la0 == '"') { 				Skip(); 				Match('"'); 				Match('"'); 				// Line 100: nongreedy(Newline / [^\$])* 				for (;;) { 					switch (LA0) { 					case '"': 						{ 							la1 = LA(1); 							if (la1 == '"') { 								la2 = LA(2); 								if (la2 == -1 || la2 == '"') 									goto stop; 								else 									Skip(); 							} else if (la1 == -1) 								goto stop; 							else 								Skip(); 						} 						break; 					case -1: 						goto stop; 					case '\n': case '\r': 						Newline(true); 						break; 					default: 						Skip(); 						break; 					} 				} 			stop:; 				Match('"'); 				Match('"'); 				Match('"'); 			} else { 				// line 101 				_style |= NodeStyle.TQStringLiteral; 				Match('\''); 				Match('\''); 				Match('\''); 				// Line 102: nongreedy(Newline / [^\$])* 				for (;;) { 					switch (LA0) { 					case '\'': 						{ 							la1 = LA(1); 							if (la1 == '\'') { 								la2 = LA(2); 								if (la2 == -1 || la2 == '\'') 									goto stop2; 								else 									Skip(); 							} else if (la1 == -1) 								goto stop2; 							else 								Skip(); 						} 						break; 					case -1: 						goto stop2; 					case '\n': case '\r': 						Newline(true); 						break; 					default: 						Skip(); 						break; 					} 				} 			stop2:; 				Match('\''); 				Match('\''); 				Match('\''); 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,TQString,The following statement contains a magic number: if (la0 == '"') { 				Skip(); 				Match('"'); 				Match('"'); 				// Line 100: nongreedy(Newline / [^\$])* 				for (;;) { 					switch (LA0) { 					case '"': 						{ 							la1 = LA(1); 							if (la1 == '"') { 								la2 = LA(2); 								if (la2 == -1 || la2 == '"') 									goto stop; 								else 									Skip(); 							} else if (la1 == -1) 								goto stop; 							else 								Skip(); 						} 						break; 					case -1: 						goto stop; 					case '\n': case '\r': 						Newline(true); 						break; 					default: 						Skip(); 						break; 					} 				} 			stop:; 				Match('"'); 				Match('"'); 				Match('"'); 			} else { 				// line 101 				_style |= NodeStyle.TQStringLiteral; 				Match('\''); 				Match('\''); 				Match('\''); 				// Line 102: nongreedy(Newline / [^\$])* 				for (;;) { 					switch (LA0) { 					case '\'': 						{ 							la1 = LA(1); 							if (la1 == '\'') { 								la2 = LA(2); 								if (la2 == -1 || la2 == '\'') 									goto stop2; 								else 									Skip(); 							} else if (la1 == -1) 								goto stop2; 							else 								Skip(); 						} 						break; 					case -1: 						goto stop2; 					case '\n': case '\r': 						Newline(true); 						break; 					default: 						Skip(); 						break; 					} 				} 			stop2:; 				Match('\''); 				Match('\''); 				Match('\''); 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,IdExtLetter,The following statement contains a magic number: MatchRange(128' 65532);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,IdExtLetter,The following statement contains a magic number: MatchRange(128' 65532);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,NormalId,The following statement contains a magic number: for (;;) { 				la0 = LA0; 				if (NormalId_set0.Contains(la0)) 					IdStartChar(); 				else if (la0 >= '0' && la0 <= '9') 					Skip(); 				else if (la0 == '\'') 					Skip(); 				else if (la0 >= 128 && la0 <= 65532) 					IdExtLetter(); 				else 					break; 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,NormalId,The following statement contains a magic number: for (;;) { 				la0 = LA0; 				if (NormalId_set0.Contains(la0)) 					IdStartChar(); 				else if (la0 >= '0' && la0 <= '9') 					Skip(); 				else if (la0 == '\'') 					Skip(); 				else if (la0 >= 128 && la0 <= 65532) 					IdExtLetter(); 				else 					break; 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,FancyId,The following statement contains a magic number: if (la0 == '`') 				BQString(); 			else { 				// Line 120: (LettersOrPunc | IdExtLetter) 				la0 = LA0; 				if (FancyId_set0.Contains(la0)) 					LettersOrPunc(); 				else 					IdExtLetter(); 				// Line 120: (LettersOrPunc | IdExtLetter)* 				for (;;) { 					la0 = LA0; 					if (FancyId_set0.Contains(la0)) 						LettersOrPunc(); 					else if (la0 >= 128 && la0 <= 65532) 						IdExtLetter(); 					else 						break; 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,FancyId,The following statement contains a magic number: if (la0 == '`') 				BQString(); 			else { 				// Line 120: (LettersOrPunc | IdExtLetter) 				la0 = LA0; 				if (FancyId_set0.Contains(la0)) 					LettersOrPunc(); 				else 					IdExtLetter(); 				// Line 120: (LettersOrPunc | IdExtLetter)* 				for (;;) { 					la0 = LA0; 					if (FancyId_set0.Contains(la0)) 						LettersOrPunc(); 					else if (la0 >= 128 && la0 <= 65532) 						IdExtLetter(); 					else 						break; 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,NextToken,The following statement contains a magic number: do { 				la0 = LA0; 				switch (la0) { 				case '#': 					{ 						if (InputPosition == 0) { 							la1 = LA(1); 							if (la1 == '!') { 								// line 168 								_type = TT.Shebang; 								Shebang(); 							} else 								goto matchId; 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (NextToken_set0.Contains(la2)) { 								// line 169 								_type = TT.Literal; 								Symbol(); 							} else 								goto matchAt; 						} else if (la1 == '`') { 							la2 = LA(2); 							if (!(la2 == -1 || la2 == '\n' || la2 == '\r')) 								goto matchId; 							else 								goto matchAt; 						} else if (NextToken_set1.Contains(la1)) 							goto matchId; 						else 							goto matchAt; 					} 					break; 				case '\n': case '\r': 					{ 						// line 171 						_type = TT.Newline; 						Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 172 							_type = TT.SLComment; 							SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								// line 173 								_type = TT.MLComment; 								MLComment(); 							} else 								Operator(); 						} else 							Operator(); 					} 					break; 				case '-': 					{ 						la1 = LA(1); 						if (la1 == '0') 							goto matchNumber; 						else if (la1 == '.') { 							la2 = LA(2); 							if (la2 >= '0' && la2 <= '9') 								goto matchNumber; 							else 								Operator(); 						} else if (la1 >= '1' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '0': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '1': case '2': case '3': case '4': 				case '5': case '6': case '7': case '8': 				case '9': 					goto matchNumber; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') 								goto matchTQString; 							else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchTQString; 							else 								goto matchSQString; 						} else 							goto matchSQString; 					} 				case '`': 					{ 						// line 178 						_type = TT.BQOperator; 						BQOperator(); 					} 					break; 				case ''': 					{ 						// line 179 						_type = TT.Comma; 						Comma(); 					} 					break; 				case ';': 					{ 						// line 180 						_type = TT.Semicolon; 						Semicolon(); 					} 					break; 				case '(': 					{ 						// line 181 						_type = TT.LParen; 						LParen(); 					} 					break; 				case ')': 					{ 						// line 182 						_type = TT.RParen; 						Skip(); 					} 					break; 				case '[': 					{ 						// line 183 						_type = TT.LBrack; 						Skip(); 					} 					break; 				case ']': 					{ 						// line 184 						_type = TT.RBrack; 						Skip(); 					} 					break; 				case '{': 					{ 						// line 185 						_type = TT.LBrace; 						Skip(); 					} 					break; 				case '}': 					{ 						// line 186 						_type = TT.RBrace; 						Skip(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case ':': case '<': 				case '=': case '>': case '?': case '^': 				case '|': case '~': 					Operator(); 					break; 				default: 					if (NextToken_set2.Contains(la0)) 						goto matchId; 					else { 						// line 189 						_value = null; 						// Line 190: ([\$] | [^\$]) 						la0 = LA0; 						if (la0 == -1) { 							Skip(); 							// line 190 							_type = TT.EOF; 						} else { 							Skip(); 							// line 191 							_type = TT.Unknown; 						} 					} 					break; 				} 				break; 			matchId: 				{ 					// line 170 					_type = TT.Id; 					Id(); 				} 				break; 			matchNumber: 				{ 					// line 174 					_type = TT.Literal; 					Number(); 				} 				break; 			matchTQString: 				{ 					// line 175 					_type = TT.Literal; 					TQString(); 				} 				break; 			matchDQString: 				{ 					// line 176 					_type = TT.Literal; 					DQString(); 				} 				break; 			matchSQString: 				{ 					// line 177 					_type = TT.Literal; 					SQString(); 				} 				break; 			matchAt: 				{ 					// line 187 					_type = TT.At; 					At(); 				} 			} while (false);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,NextToken,The following statement contains a magic number: do { 				la0 = LA0; 				switch (la0) { 				case '#': 					{ 						if (InputPosition == 0) { 							la1 = LA(1); 							if (la1 == '!') { 								// line 168 								_type = TT.Shebang; 								Shebang(); 							} else 								goto matchId; 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (NextToken_set0.Contains(la2)) { 								// line 169 								_type = TT.Literal; 								Symbol(); 							} else 								goto matchAt; 						} else if (la1 == '`') { 							la2 = LA(2); 							if (!(la2 == -1 || la2 == '\n' || la2 == '\r')) 								goto matchId; 							else 								goto matchAt; 						} else if (NextToken_set1.Contains(la1)) 							goto matchId; 						else 							goto matchAt; 					} 					break; 				case '\n': case '\r': 					{ 						// line 171 						_type = TT.Newline; 						Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 172 							_type = TT.SLComment; 							SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								// line 173 								_type = TT.MLComment; 								MLComment(); 							} else 								Operator(); 						} else 							Operator(); 					} 					break; 				case '-': 					{ 						la1 = LA(1); 						if (la1 == '0') 							goto matchNumber; 						else if (la1 == '.') { 							la2 = LA(2); 							if (la2 >= '0' && la2 <= '9') 								goto matchNumber; 							else 								Operator(); 						} else if (la1 >= '1' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '0': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '1': case '2': case '3': case '4': 				case '5': case '6': case '7': case '8': 				case '9': 					goto matchNumber; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') 								goto matchTQString; 							else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchTQString; 							else 								goto matchSQString; 						} else 							goto matchSQString; 					} 				case '`': 					{ 						// line 178 						_type = TT.BQOperator; 						BQOperator(); 					} 					break; 				case ''': 					{ 						// line 179 						_type = TT.Comma; 						Comma(); 					} 					break; 				case ';': 					{ 						// line 180 						_type = TT.Semicolon; 						Semicolon(); 					} 					break; 				case '(': 					{ 						// line 181 						_type = TT.LParen; 						LParen(); 					} 					break; 				case ')': 					{ 						// line 182 						_type = TT.RParen; 						Skip(); 					} 					break; 				case '[': 					{ 						// line 183 						_type = TT.LBrack; 						Skip(); 					} 					break; 				case ']': 					{ 						// line 184 						_type = TT.RBrack; 						Skip(); 					} 					break; 				case '{': 					{ 						// line 185 						_type = TT.LBrace; 						Skip(); 					} 					break; 				case '}': 					{ 						// line 186 						_type = TT.RBrace; 						Skip(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case ':': case '<': 				case '=': case '>': case '?': case '^': 				case '|': case '~': 					Operator(); 					break; 				default: 					if (NextToken_set2.Contains(la0)) 						goto matchId; 					else { 						// line 189 						_value = null; 						// Line 190: ([\$] | [^\$]) 						la0 = LA0; 						if (la0 == -1) { 							Skip(); 							// line 190 							_type = TT.EOF; 						} else { 							Skip(); 							// line 191 							_type = TT.Unknown; 						} 					} 					break; 				} 				break; 			matchId: 				{ 					// line 170 					_type = TT.Id; 					Id(); 				} 				break; 			matchNumber: 				{ 					// line 174 					_type = TT.Literal; 					Number(); 				} 				break; 			matchTQString: 				{ 					// line 175 					_type = TT.Literal; 					TQString(); 				} 				break; 			matchDQString: 				{ 					// line 176 					_type = TT.Literal; 					DQString(); 				} 				break; 			matchSQString: 				{ 					// line 177 					_type = TT.Literal; 					SQString(); 				} 				break; 			matchAt: 				{ 					// line 187 					_type = TT.At; 					At(); 				} 			} while (false);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,NextToken,The following statement contains a magic number: do { 				la0 = LA0; 				switch (la0) { 				case '#': 					{ 						if (InputPosition == 0) { 							la1 = LA(1); 							if (la1 == '!') { 								// line 168 								_type = TT.Shebang; 								Shebang(); 							} else 								goto matchId; 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (NextToken_set0.Contains(la2)) { 								// line 169 								_type = TT.Literal; 								Symbol(); 							} else 								goto matchAt; 						} else if (la1 == '`') { 							la2 = LA(2); 							if (!(la2 == -1 || la2 == '\n' || la2 == '\r')) 								goto matchId; 							else 								goto matchAt; 						} else if (NextToken_set1.Contains(la1)) 							goto matchId; 						else 							goto matchAt; 					} 					break; 				case '\n': case '\r': 					{ 						// line 171 						_type = TT.Newline; 						Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 172 							_type = TT.SLComment; 							SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								// line 173 								_type = TT.MLComment; 								MLComment(); 							} else 								Operator(); 						} else 							Operator(); 					} 					break; 				case '-': 					{ 						la1 = LA(1); 						if (la1 == '0') 							goto matchNumber; 						else if (la1 == '.') { 							la2 = LA(2); 							if (la2 >= '0' && la2 <= '9') 								goto matchNumber; 							else 								Operator(); 						} else if (la1 >= '1' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '0': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '1': case '2': case '3': case '4': 				case '5': case '6': case '7': case '8': 				case '9': 					goto matchNumber; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') 								goto matchTQString; 							else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchTQString; 							else 								goto matchSQString; 						} else 							goto matchSQString; 					} 				case '`': 					{ 						// line 178 						_type = TT.BQOperator; 						BQOperator(); 					} 					break; 				case ''': 					{ 						// line 179 						_type = TT.Comma; 						Comma(); 					} 					break; 				case ';': 					{ 						// line 180 						_type = TT.Semicolon; 						Semicolon(); 					} 					break; 				case '(': 					{ 						// line 181 						_type = TT.LParen; 						LParen(); 					} 					break; 				case ')': 					{ 						// line 182 						_type = TT.RParen; 						Skip(); 					} 					break; 				case '[': 					{ 						// line 183 						_type = TT.LBrack; 						Skip(); 					} 					break; 				case ']': 					{ 						// line 184 						_type = TT.RBrack; 						Skip(); 					} 					break; 				case '{': 					{ 						// line 185 						_type = TT.LBrace; 						Skip(); 					} 					break; 				case '}': 					{ 						// line 186 						_type = TT.RBrace; 						Skip(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case ':': case '<': 				case '=': case '>': case '?': case '^': 				case '|': case '~': 					Operator(); 					break; 				default: 					if (NextToken_set2.Contains(la0)) 						goto matchId; 					else { 						// line 189 						_value = null; 						// Line 190: ([\$] | [^\$]) 						la0 = LA0; 						if (la0 == -1) { 							Skip(); 							// line 190 							_type = TT.EOF; 						} else { 							Skip(); 							// line 191 							_type = TT.Unknown; 						} 					} 					break; 				} 				break; 			matchId: 				{ 					// line 170 					_type = TT.Id; 					Id(); 				} 				break; 			matchNumber: 				{ 					// line 174 					_type = TT.Literal; 					Number(); 				} 				break; 			matchTQString: 				{ 					// line 175 					_type = TT.Literal; 					TQString(); 				} 				break; 			matchDQString: 				{ 					// line 176 					_type = TT.Literal; 					DQString(); 				} 				break; 			matchSQString: 				{ 					// line 177 					_type = TT.Literal; 					SQString(); 				} 				break; 			matchAt: 				{ 					// line 187 					_type = TT.At; 					At(); 				} 			} while (false);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,NextToken,The following statement contains a magic number: do { 				la0 = LA0; 				switch (la0) { 				case '#': 					{ 						if (InputPosition == 0) { 							la1 = LA(1); 							if (la1 == '!') { 								// line 168 								_type = TT.Shebang; 								Shebang(); 							} else 								goto matchId; 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (NextToken_set0.Contains(la2)) { 								// line 169 								_type = TT.Literal; 								Symbol(); 							} else 								goto matchAt; 						} else if (la1 == '`') { 							la2 = LA(2); 							if (!(la2 == -1 || la2 == '\n' || la2 == '\r')) 								goto matchId; 							else 								goto matchAt; 						} else if (NextToken_set1.Contains(la1)) 							goto matchId; 						else 							goto matchAt; 					} 					break; 				case '\n': case '\r': 					{ 						// line 171 						_type = TT.Newline; 						Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 172 							_type = TT.SLComment; 							SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								// line 173 								_type = TT.MLComment; 								MLComment(); 							} else 								Operator(); 						} else 							Operator(); 					} 					break; 				case '-': 					{ 						la1 = LA(1); 						if (la1 == '0') 							goto matchNumber; 						else if (la1 == '.') { 							la2 = LA(2); 							if (la2 >= '0' && la2 <= '9') 								goto matchNumber; 							else 								Operator(); 						} else if (la1 >= '1' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '0': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '1': case '2': case '3': case '4': 				case '5': case '6': case '7': case '8': 				case '9': 					goto matchNumber; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') 								goto matchTQString; 							else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchTQString; 							else 								goto matchSQString; 						} else 							goto matchSQString; 					} 				case '`': 					{ 						// line 178 						_type = TT.BQOperator; 						BQOperator(); 					} 					break; 				case ''': 					{ 						// line 179 						_type = TT.Comma; 						Comma(); 					} 					break; 				case ';': 					{ 						// line 180 						_type = TT.Semicolon; 						Semicolon(); 					} 					break; 				case '(': 					{ 						// line 181 						_type = TT.LParen; 						LParen(); 					} 					break; 				case ')': 					{ 						// line 182 						_type = TT.RParen; 						Skip(); 					} 					break; 				case '[': 					{ 						// line 183 						_type = TT.LBrack; 						Skip(); 					} 					break; 				case ']': 					{ 						// line 184 						_type = TT.RBrack; 						Skip(); 					} 					break; 				case '{': 					{ 						// line 185 						_type = TT.LBrace; 						Skip(); 					} 					break; 				case '}': 					{ 						// line 186 						_type = TT.RBrace; 						Skip(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case ':': case '<': 				case '=': case '>': case '?': case '^': 				case '|': case '~': 					Operator(); 					break; 				default: 					if (NextToken_set2.Contains(la0)) 						goto matchId; 					else { 						// line 189 						_value = null; 						// Line 190: ([\$] | [^\$]) 						la0 = LA0; 						if (la0 == -1) { 							Skip(); 							// line 190 							_type = TT.EOF; 						} else { 							Skip(); 							// line 191 							_type = TT.Unknown; 						} 					} 					break; 				} 				break; 			matchId: 				{ 					// line 170 					_type = TT.Id; 					Id(); 				} 				break; 			matchNumber: 				{ 					// line 174 					_type = TT.Literal; 					Number(); 				} 				break; 			matchTQString: 				{ 					// line 175 					_type = TT.Literal; 					TQString(); 				} 				break; 			matchDQString: 				{ 					// line 176 					_type = TT.Literal; 					DQString(); 				} 				break; 			matchSQString: 				{ 					// line 177 					_type = TT.Literal; 					SQString(); 				} 				break; 			matchAt: 				{ 					// line 187 					_type = TT.At; 					At(); 				} 			} while (false);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,NextToken,The following statement contains a magic number: do { 				la0 = LA0; 				switch (la0) { 				case '#': 					{ 						if (InputPosition == 0) { 							la1 = LA(1); 							if (la1 == '!') { 								// line 168 								_type = TT.Shebang; 								Shebang(); 							} else 								goto matchId; 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (NextToken_set0.Contains(la2)) { 								// line 169 								_type = TT.Literal; 								Symbol(); 							} else 								goto matchAt; 						} else if (la1 == '`') { 							la2 = LA(2); 							if (!(la2 == -1 || la2 == '\n' || la2 == '\r')) 								goto matchId; 							else 								goto matchAt; 						} else if (NextToken_set1.Contains(la1)) 							goto matchId; 						else 							goto matchAt; 					} 					break; 				case '\n': case '\r': 					{ 						// line 171 						_type = TT.Newline; 						Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 172 							_type = TT.SLComment; 							SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								// line 173 								_type = TT.MLComment; 								MLComment(); 							} else 								Operator(); 						} else 							Operator(); 					} 					break; 				case '-': 					{ 						la1 = LA(1); 						if (la1 == '0') 							goto matchNumber; 						else if (la1 == '.') { 							la2 = LA(2); 							if (la2 >= '0' && la2 <= '9') 								goto matchNumber; 							else 								Operator(); 						} else if (la1 >= '1' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '0': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '1': case '2': case '3': case '4': 				case '5': case '6': case '7': case '8': 				case '9': 					goto matchNumber; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') 								goto matchTQString; 							else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchTQString; 							else 								goto matchSQString; 						} else 							goto matchSQString; 					} 				case '`': 					{ 						// line 178 						_type = TT.BQOperator; 						BQOperator(); 					} 					break; 				case ''': 					{ 						// line 179 						_type = TT.Comma; 						Comma(); 					} 					break; 				case ';': 					{ 						// line 180 						_type = TT.Semicolon; 						Semicolon(); 					} 					break; 				case '(': 					{ 						// line 181 						_type = TT.LParen; 						LParen(); 					} 					break; 				case ')': 					{ 						// line 182 						_type = TT.RParen; 						Skip(); 					} 					break; 				case '[': 					{ 						// line 183 						_type = TT.LBrack; 						Skip(); 					} 					break; 				case ']': 					{ 						// line 184 						_type = TT.RBrack; 						Skip(); 					} 					break; 				case '{': 					{ 						// line 185 						_type = TT.LBrace; 						Skip(); 					} 					break; 				case '}': 					{ 						// line 186 						_type = TT.RBrace; 						Skip(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case ':': case '<': 				case '=': case '>': case '?': case '^': 				case '|': case '~': 					Operator(); 					break; 				default: 					if (NextToken_set2.Contains(la0)) 						goto matchId; 					else { 						// line 189 						_value = null; 						// Line 190: ([\$] | [^\$]) 						la0 = LA0; 						if (la0 == -1) { 							Skip(); 							// line 190 							_type = TT.EOF; 						} else { 							Skip(); 							// line 191 							_type = TT.Unknown; 						} 					} 					break; 				} 				break; 			matchId: 				{ 					// line 170 					_type = TT.Id; 					Id(); 				} 				break; 			matchNumber: 				{ 					// line 174 					_type = TT.Literal; 					Number(); 				} 				break; 			matchTQString: 				{ 					// line 175 					_type = TT.Literal; 					TQString(); 				} 				break; 			matchDQString: 				{ 					// line 176 					_type = TT.Literal; 					DQString(); 				} 				break; 			matchSQString: 				{ 					// line 177 					_type = TT.Literal; 					SQString(); 				} 				break; 			matchAt: 				{ 					// line 187 					_type = TT.At; 					At(); 				} 			} while (false);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,NextToken,The following statement contains a magic number: do { 				la0 = LA0; 				switch (la0) { 				case '#': 					{ 						if (InputPosition == 0) { 							la1 = LA(1); 							if (la1 == '!') { 								// line 168 								_type = TT.Shebang; 								Shebang(); 							} else 								goto matchId; 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (NextToken_set0.Contains(la2)) { 								// line 169 								_type = TT.Literal; 								Symbol(); 							} else 								goto matchAt; 						} else if (la1 == '`') { 							la2 = LA(2); 							if (!(la2 == -1 || la2 == '\n' || la2 == '\r')) 								goto matchId; 							else 								goto matchAt; 						} else if (NextToken_set1.Contains(la1)) 							goto matchId; 						else 							goto matchAt; 					} 					break; 				case '\n': case '\r': 					{ 						// line 171 						_type = TT.Newline; 						Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 172 							_type = TT.SLComment; 							SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								// line 173 								_type = TT.MLComment; 								MLComment(); 							} else 								Operator(); 						} else 							Operator(); 					} 					break; 				case '-': 					{ 						la1 = LA(1); 						if (la1 == '0') 							goto matchNumber; 						else if (la1 == '.') { 							la2 = LA(2); 							if (la2 >= '0' && la2 <= '9') 								goto matchNumber; 							else 								Operator(); 						} else if (la1 >= '1' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '0': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else 							Operator(); 					} 					break; 				case '1': case '2': case '3': case '4': 				case '5': case '6': case '7': case '8': 				case '9': 					goto matchNumber; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') 								goto matchTQString; 							else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchTQString; 							else 								goto matchSQString; 						} else 							goto matchSQString; 					} 				case '`': 					{ 						// line 178 						_type = TT.BQOperator; 						BQOperator(); 					} 					break; 				case ''': 					{ 						// line 179 						_type = TT.Comma; 						Comma(); 					} 					break; 				case ';': 					{ 						// line 180 						_type = TT.Semicolon; 						Semicolon(); 					} 					break; 				case '(': 					{ 						// line 181 						_type = TT.LParen; 						LParen(); 					} 					break; 				case ')': 					{ 						// line 182 						_type = TT.RParen; 						Skip(); 					} 					break; 				case '[': 					{ 						// line 183 						_type = TT.LBrack; 						Skip(); 					} 					break; 				case ']': 					{ 						// line 184 						_type = TT.RBrack; 						Skip(); 					} 					break; 				case '{': 					{ 						// line 185 						_type = TT.LBrace; 						Skip(); 					} 					break; 				case '}': 					{ 						// line 186 						_type = TT.RBrace; 						Skip(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case ':': case '<': 				case '=': case '>': case '?': case '^': 				case '|': case '~': 					Operator(); 					break; 				default: 					if (NextToken_set2.Contains(la0)) 						goto matchId; 					else { 						// line 189 						_value = null; 						// Line 190: ([\$] | [^\$]) 						la0 = LA0; 						if (la0 == -1) { 							Skip(); 							// line 190 							_type = TT.EOF; 						} else { 							Skip(); 							// line 191 							_type = TT.Unknown; 						} 					} 					break; 				} 				break; 			matchId: 				{ 					// line 170 					_type = TT.Id; 					Id(); 				} 				break; 			matchNumber: 				{ 					// line 174 					_type = TT.Literal; 					Number(); 				} 				break; 			matchTQString: 				{ 					// line 175 					_type = TT.Literal; 					TQString(); 				} 				break; 			matchDQString: 				{ 					// line 176 					_type = TT.Literal; 					DQString(); 				} 				break; 			matchSQString: 				{ 					// line 177 					_type = TT.Literal; 					SQString(); 				} 				break; 			matchAt: 				{ 					// line 187 					_type = TT.At; 					At(); 				} 			} while (false);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,TDQStringLine,The following statement contains a magic number: for (;;) { 				switch (LA0) { 				case '\n': case '\r': 					goto stop; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == -1 || la2 == '"') 								goto stop; 							else 								Skip(); 						} else if (la1 == -1) 							goto stop; 						else 							Skip(); 					} 					break; 				case -1: 					goto stop; 				default: 					Skip(); 					break; 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,TSQStringLine,The following statement contains a magic number: for (;;) { 				switch (LA0) { 				case '\n': case '\r': 					goto stop; 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == -1 || la2 == '\'') 								goto stop; 							else 								Skip(); 						} else if (la1 == -1) 							goto stop; 						else 							Skip(); 					} 					break; 				case -1: 					goto stop; 				default: 					Skip(); 					break; 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseSQStringValue,The following statement contains a magic number: if (SkipValueParsing) 				return null; 			else { 				var text = Text(); 				if (!_parseNeeded && text.Length == 3) 					return _value = text[1]; 				else 					return _value = ParseSQStringValue(text' Error); 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseStringValue,The following statement contains a magic number: return _value = s.Length < 16 ? CG.Cache(s) : s;
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseStringCore,The following statement contains a magic number: if (_parseNeeded) { 				UString original = CharSource.Slice(_startPosition' InputPosition - _startPosition); 				value = UnescapeQuotedString(ref original' Error' IndentString' les3TQindents); 				Debug.Assert(original.IsEmpty); 			} else { 				Debug.Assert(CharSource.TryGet(InputPosition - 1' '?') == CharSource.TryGet(_startPosition' '!')); 				if (isTripleQuoted) 					value = CharSource.Slice(_startPosition + 3' InputPosition - _startPosition - 6).ToString(); 				else 					value = CharSource.Slice(_startPosition + 1' InputPosition - _startPosition - 2).ToString(); 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseStringCore,The following statement contains a magic number: if (_parseNeeded) { 				UString original = CharSource.Slice(_startPosition' InputPosition - _startPosition); 				value = UnescapeQuotedString(ref original' Error' IndentString' les3TQindents); 				Debug.Assert(original.IsEmpty); 			} else { 				Debug.Assert(CharSource.TryGet(InputPosition - 1' '?') == CharSource.TryGet(_startPosition' '!')); 				if (isTripleQuoted) 					value = CharSource.Slice(_startPosition + 3' InputPosition - _startPosition - 6).ToString(); 				else 					value = CharSource.Slice(_startPosition + 1' InputPosition - _startPosition - 2).ToString(); 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseStringCore,The following statement contains a magic number: if (_parseNeeded) { 				UString original = CharSource.Slice(_startPosition' InputPosition - _startPosition); 				value = UnescapeQuotedString(ref original' Error' IndentString' les3TQindents); 				Debug.Assert(original.IsEmpty); 			} else { 				Debug.Assert(CharSource.TryGet(InputPosition - 1' '?') == CharSource.TryGet(_startPosition' '!')); 				if (isTripleQuoted) 					value = CharSource.Slice(_startPosition + 3' InputPosition - _startPosition - 6).ToString(); 				else 					value = CharSource.Slice(_startPosition + 1' InputPosition - _startPosition - 2).ToString(); 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,UnescapeQuotedString,The following statement contains a magic number: if (sourceText[0' '\0'] == quoteType && 				sourceText[1' '\0'] == quoteType) { 				sourceText = sourceText.Substring(2); 				isTripleQuoted = true; 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,UnescapeString,The following statement contains a magic number: for (;;) { 				if (sourceText.IsEmpty) 					return false; 				int i0 = sourceText.InternalStart; 				if (!isTripleQuoted) { 					EscapeC category = 0; 					int c = ParseHelpers.UnescapeChar(ref sourceText' ref category); 					if ((c == quoteType || c == '\n') && sourceText.InternalStart == i0 + 1) { 						return c == quoteType; // end of string 					} 					if ((category & EscapeC.Unrecognized) != 0) { 						// This backslash was ignored by UnescapeChar 						onError(i0' @"Unrecognized escape sequence '\{0}' in string".Localized(PrintHelpers.EscapeCStyle(sourceText[0' ' '].ToString()' EscapeC.Control))); 					} else if ((category & EscapeC.HasInvalid6DigitEscape) != 0) 						onError(i0' @"Invalid 6-digit \u code treated as 5 digits".Localized()); 					sb.AppendCodePoint(c); 					if ((category & EscapeC.BackslashX) != 0 && c >= 0x80) 						DetectUtf8(sb); 					else if (c.IsInRange(0xDC00' 0xDFFF)) 						RecodeSurrogate(sb); 				} else { 					// Inside triple-quoted string 					int c; 					if (sourceText[2' '\0'] == '/') { 						// Detect escape sequence 						c = ParseHelpers.UnescapeChar(ref sourceText); 						if (sourceText.InternalStart > i0 + 1) 							G.Verify(sourceText.PopFirst(out fail) == '/'); 					} else { 						c = sourceText.PopFirst(out fail); 						if (fail) 							return false; 						if (c == quoteType) { 							if (sourceText[0' '\0'] == quoteType && 								sourceText[1' '\0'] == quoteType) { 								sourceText = sourceText.Substring(2); 								// end of string 								return true; 							} 						} 						if (c == '\r' || c == '\n') { 							// To ensure platform independency of source code' CR and  							// CR-LF become LF. 							if (c == '\r') { 								c = '\n'; 								var copy = sourceText.Clone(); 								if (sourceText.PopFirst(out fail) != '\n') 									sourceText = copy; 							} 							// Inside a triple-quoted string' the indentation following a newline  							// is ignored' as long as it matches the indentation of the first line. 							UString src = sourceText' ind = indentation; 							int sp; 							while ((sp = src.PopFirst(out fail)) == ind.PopFirst(out fail) && !fail) 								sourceText = src; 							if (les3TQIndents && fail) { 								// Allow an additional one tab or three spaces when initial indent matches 								if (sp == '\t') 									sourceText = src; 								else if (sp == ' ') {  									sourceText = src; 									if (src.PopFirst(out fail) == ' ') 										sourceText = src; 									if (src.PopFirst(out fail) == ' ') 										sourceText = src; 								} 							} 						} 					} 					 					sb.AppendCodePoint(c); 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,UnescapeString,The following statement contains a magic number: for (;;) { 				if (sourceText.IsEmpty) 					return false; 				int i0 = sourceText.InternalStart; 				if (!isTripleQuoted) { 					EscapeC category = 0; 					int c = ParseHelpers.UnescapeChar(ref sourceText' ref category); 					if ((c == quoteType || c == '\n') && sourceText.InternalStart == i0 + 1) { 						return c == quoteType; // end of string 					} 					if ((category & EscapeC.Unrecognized) != 0) { 						// This backslash was ignored by UnescapeChar 						onError(i0' @"Unrecognized escape sequence '\{0}' in string".Localized(PrintHelpers.EscapeCStyle(sourceText[0' ' '].ToString()' EscapeC.Control))); 					} else if ((category & EscapeC.HasInvalid6DigitEscape) != 0) 						onError(i0' @"Invalid 6-digit \u code treated as 5 digits".Localized()); 					sb.AppendCodePoint(c); 					if ((category & EscapeC.BackslashX) != 0 && c >= 0x80) 						DetectUtf8(sb); 					else if (c.IsInRange(0xDC00' 0xDFFF)) 						RecodeSurrogate(sb); 				} else { 					// Inside triple-quoted string 					int c; 					if (sourceText[2' '\0'] == '/') { 						// Detect escape sequence 						c = ParseHelpers.UnescapeChar(ref sourceText); 						if (sourceText.InternalStart > i0 + 1) 							G.Verify(sourceText.PopFirst(out fail) == '/'); 					} else { 						c = sourceText.PopFirst(out fail); 						if (fail) 							return false; 						if (c == quoteType) { 							if (sourceText[0' '\0'] == quoteType && 								sourceText[1' '\0'] == quoteType) { 								sourceText = sourceText.Substring(2); 								// end of string 								return true; 							} 						} 						if (c == '\r' || c == '\n') { 							// To ensure platform independency of source code' CR and  							// CR-LF become LF. 							if (c == '\r') { 								c = '\n'; 								var copy = sourceText.Clone(); 								if (sourceText.PopFirst(out fail) != '\n') 									sourceText = copy; 							} 							// Inside a triple-quoted string' the indentation following a newline  							// is ignored' as long as it matches the indentation of the first line. 							UString src = sourceText' ind = indentation; 							int sp; 							while ((sp = src.PopFirst(out fail)) == ind.PopFirst(out fail) && !fail) 								sourceText = src; 							if (les3TQIndents && fail) { 								// Allow an additional one tab or three spaces when initial indent matches 								if (sp == '\t') 									sourceText = src; 								else if (sp == ' ') {  									sourceText = src; 									if (src.PopFirst(out fail) == ' ') 										sourceText = src; 									if (src.PopFirst(out fail) == ' ') 										sourceText = src; 								} 							} 						} 					} 					 					sb.AppendCodePoint(c); 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: Debug.Assert(minus1.IsInRange((char)128' (char)255));
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: Debug.Assert(minus1.IsInRange((char)128' (char)255));
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: if (sb.Length > 1 && minus1.IsInRange(0xDC80' 0xDCBF)) { 				int minus2 = sb[sb.Length - 2]; 				if (minus2.IsInRange(0xDCC0' 0xDCDF)) { 					// 2-byte UTF8 character detected; decode into UTF16 					int c = ((minus2 & 0x1F) << 6) | (minus1 & 0x3F); 					if (c > 0x7F) { // ignore overlong characters 						sb.Remove(sb.Length - 1' 1); 						sb[sb.Length - 1] = (char)c; 					} 				} 				else if (sb.Length > 2 && minus2.IsInRange(0xDC80' 0xDCBF)) { 					int minus3 = sb[sb.Length - 3]; 					if (minus3.IsInRange(0xDCE0' 0xDCEF)) { 						// 3-byte UTF8 character detected; decode into UTF16 unless 						// the character is in the low surrogate range 0xDC00..0xDFFF. 						// This avoids collisions with the 0xDCxx space reserved for  						// encodings of arbitrary bytes' and and also avoids  						// translating UTF-8 encodings of UTF-16 surrogate pairs'  						// which wouldn't round trip' e.g. \xED\xA0\xBD\xED\xB2\xA9 						// !=> \uD83D\uDCA9 (UTF16) => \u1F4A9 => \xF0\x9F\x92\xA9 (UTF8). 						int c = ((minus3 & 0xF) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 						if (c > 0x7FF && !c.IsInRange(0xDC00' 0xDFFF)) { // ignore overlong characters 							sb.Remove(sb.Length - 2' 2); 							sb[sb.Length - 1] = (char)c; 						} 					} 					else if (sb.Length > 3 && minus3.IsInRange(0xDC80' 0xDCBF)) { 						int minus4 = sb[sb.Length - 4]; 						if (minus4.IsInRange(0xDCF0' 0xDCF7)) { 							// 4-byte UTF8 character detected; decode into UTF16 surrogate pair 							int c = ((minus4 & 0x7) << 18) | ((minus3 & 0x3F) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 							if (c > 0xFFFF) { // ignore overlong characters 								sb.Remove(sb.Length - 4' 4); 								sb.AppendCodePoint(c); 							} 						} 					} 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: if (sb.Length > 1 && minus1.IsInRange(0xDC80' 0xDCBF)) { 				int minus2 = sb[sb.Length - 2]; 				if (minus2.IsInRange(0xDCC0' 0xDCDF)) { 					// 2-byte UTF8 character detected; decode into UTF16 					int c = ((minus2 & 0x1F) << 6) | (minus1 & 0x3F); 					if (c > 0x7F) { // ignore overlong characters 						sb.Remove(sb.Length - 1' 1); 						sb[sb.Length - 1] = (char)c; 					} 				} 				else if (sb.Length > 2 && minus2.IsInRange(0xDC80' 0xDCBF)) { 					int minus3 = sb[sb.Length - 3]; 					if (minus3.IsInRange(0xDCE0' 0xDCEF)) { 						// 3-byte UTF8 character detected; decode into UTF16 unless 						// the character is in the low surrogate range 0xDC00..0xDFFF. 						// This avoids collisions with the 0xDCxx space reserved for  						// encodings of arbitrary bytes' and and also avoids  						// translating UTF-8 encodings of UTF-16 surrogate pairs'  						// which wouldn't round trip' e.g. \xED\xA0\xBD\xED\xB2\xA9 						// !=> \uD83D\uDCA9 (UTF16) => \u1F4A9 => \xF0\x9F\x92\xA9 (UTF8). 						int c = ((minus3 & 0xF) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 						if (c > 0x7FF && !c.IsInRange(0xDC00' 0xDFFF)) { // ignore overlong characters 							sb.Remove(sb.Length - 2' 2); 							sb[sb.Length - 1] = (char)c; 						} 					} 					else if (sb.Length > 3 && minus3.IsInRange(0xDC80' 0xDCBF)) { 						int minus4 = sb[sb.Length - 4]; 						if (minus4.IsInRange(0xDCF0' 0xDCF7)) { 							// 4-byte UTF8 character detected; decode into UTF16 surrogate pair 							int c = ((minus4 & 0x7) << 18) | ((minus3 & 0x3F) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 							if (c > 0xFFFF) { // ignore overlong characters 								sb.Remove(sb.Length - 4' 4); 								sb.AppendCodePoint(c); 							} 						} 					} 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: if (sb.Length > 1 && minus1.IsInRange(0xDC80' 0xDCBF)) { 				int minus2 = sb[sb.Length - 2]; 				if (minus2.IsInRange(0xDCC0' 0xDCDF)) { 					// 2-byte UTF8 character detected; decode into UTF16 					int c = ((minus2 & 0x1F) << 6) | (minus1 & 0x3F); 					if (c > 0x7F) { // ignore overlong characters 						sb.Remove(sb.Length - 1' 1); 						sb[sb.Length - 1] = (char)c; 					} 				} 				else if (sb.Length > 2 && minus2.IsInRange(0xDC80' 0xDCBF)) { 					int minus3 = sb[sb.Length - 3]; 					if (minus3.IsInRange(0xDCE0' 0xDCEF)) { 						// 3-byte UTF8 character detected; decode into UTF16 unless 						// the character is in the low surrogate range 0xDC00..0xDFFF. 						// This avoids collisions with the 0xDCxx space reserved for  						// encodings of arbitrary bytes' and and also avoids  						// translating UTF-8 encodings of UTF-16 surrogate pairs'  						// which wouldn't round trip' e.g. \xED\xA0\xBD\xED\xB2\xA9 						// !=> \uD83D\uDCA9 (UTF16) => \u1F4A9 => \xF0\x9F\x92\xA9 (UTF8). 						int c = ((minus3 & 0xF) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 						if (c > 0x7FF && !c.IsInRange(0xDC00' 0xDFFF)) { // ignore overlong characters 							sb.Remove(sb.Length - 2' 2); 							sb[sb.Length - 1] = (char)c; 						} 					} 					else if (sb.Length > 3 && minus3.IsInRange(0xDC80' 0xDCBF)) { 						int minus4 = sb[sb.Length - 4]; 						if (minus4.IsInRange(0xDCF0' 0xDCF7)) { 							// 4-byte UTF8 character detected; decode into UTF16 surrogate pair 							int c = ((minus4 & 0x7) << 18) | ((minus3 & 0x3F) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 							if (c > 0xFFFF) { // ignore overlong characters 								sb.Remove(sb.Length - 4' 4); 								sb.AppendCodePoint(c); 							} 						} 					} 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: if (sb.Length > 1 && minus1.IsInRange(0xDC80' 0xDCBF)) { 				int minus2 = sb[sb.Length - 2]; 				if (minus2.IsInRange(0xDCC0' 0xDCDF)) { 					// 2-byte UTF8 character detected; decode into UTF16 					int c = ((minus2 & 0x1F) << 6) | (minus1 & 0x3F); 					if (c > 0x7F) { // ignore overlong characters 						sb.Remove(sb.Length - 1' 1); 						sb[sb.Length - 1] = (char)c; 					} 				} 				else if (sb.Length > 2 && minus2.IsInRange(0xDC80' 0xDCBF)) { 					int minus3 = sb[sb.Length - 3]; 					if (minus3.IsInRange(0xDCE0' 0xDCEF)) { 						// 3-byte UTF8 character detected; decode into UTF16 unless 						// the character is in the low surrogate range 0xDC00..0xDFFF. 						// This avoids collisions with the 0xDCxx space reserved for  						// encodings of arbitrary bytes' and and also avoids  						// translating UTF-8 encodings of UTF-16 surrogate pairs'  						// which wouldn't round trip' e.g. \xED\xA0\xBD\xED\xB2\xA9 						// !=> \uD83D\uDCA9 (UTF16) => \u1F4A9 => \xF0\x9F\x92\xA9 (UTF8). 						int c = ((minus3 & 0xF) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 						if (c > 0x7FF && !c.IsInRange(0xDC00' 0xDFFF)) { // ignore overlong characters 							sb.Remove(sb.Length - 2' 2); 							sb[sb.Length - 1] = (char)c; 						} 					} 					else if (sb.Length > 3 && minus3.IsInRange(0xDC80' 0xDCBF)) { 						int minus4 = sb[sb.Length - 4]; 						if (minus4.IsInRange(0xDCF0' 0xDCF7)) { 							// 4-byte UTF8 character detected; decode into UTF16 surrogate pair 							int c = ((minus4 & 0x7) << 18) | ((minus3 & 0x3F) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 							if (c > 0xFFFF) { // ignore overlong characters 								sb.Remove(sb.Length - 4' 4); 								sb.AppendCodePoint(c); 							} 						} 					} 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: if (sb.Length > 1 && minus1.IsInRange(0xDC80' 0xDCBF)) { 				int minus2 = sb[sb.Length - 2]; 				if (minus2.IsInRange(0xDCC0' 0xDCDF)) { 					// 2-byte UTF8 character detected; decode into UTF16 					int c = ((minus2 & 0x1F) << 6) | (minus1 & 0x3F); 					if (c > 0x7F) { // ignore overlong characters 						sb.Remove(sb.Length - 1' 1); 						sb[sb.Length - 1] = (char)c; 					} 				} 				else if (sb.Length > 2 && minus2.IsInRange(0xDC80' 0xDCBF)) { 					int minus3 = sb[sb.Length - 3]; 					if (minus3.IsInRange(0xDCE0' 0xDCEF)) { 						// 3-byte UTF8 character detected; decode into UTF16 unless 						// the character is in the low surrogate range 0xDC00..0xDFFF. 						// This avoids collisions with the 0xDCxx space reserved for  						// encodings of arbitrary bytes' and and also avoids  						// translating UTF-8 encodings of UTF-16 surrogate pairs'  						// which wouldn't round trip' e.g. \xED\xA0\xBD\xED\xB2\xA9 						// !=> \uD83D\uDCA9 (UTF16) => \u1F4A9 => \xF0\x9F\x92\xA9 (UTF8). 						int c = ((minus3 & 0xF) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 						if (c > 0x7FF && !c.IsInRange(0xDC00' 0xDFFF)) { // ignore overlong characters 							sb.Remove(sb.Length - 2' 2); 							sb[sb.Length - 1] = (char)c; 						} 					} 					else if (sb.Length > 3 && minus3.IsInRange(0xDC80' 0xDCBF)) { 						int minus4 = sb[sb.Length - 4]; 						if (minus4.IsInRange(0xDCF0' 0xDCF7)) { 							// 4-byte UTF8 character detected; decode into UTF16 surrogate pair 							int c = ((minus4 & 0x7) << 18) | ((minus3 & 0x3F) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 							if (c > 0xFFFF) { // ignore overlong characters 								sb.Remove(sb.Length - 4' 4); 								sb.AppendCodePoint(c); 							} 						} 					} 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: if (sb.Length > 1 && minus1.IsInRange(0xDC80' 0xDCBF)) { 				int minus2 = sb[sb.Length - 2]; 				if (minus2.IsInRange(0xDCC0' 0xDCDF)) { 					// 2-byte UTF8 character detected; decode into UTF16 					int c = ((minus2 & 0x1F) << 6) | (minus1 & 0x3F); 					if (c > 0x7F) { // ignore overlong characters 						sb.Remove(sb.Length - 1' 1); 						sb[sb.Length - 1] = (char)c; 					} 				} 				else if (sb.Length > 2 && minus2.IsInRange(0xDC80' 0xDCBF)) { 					int minus3 = sb[sb.Length - 3]; 					if (minus3.IsInRange(0xDCE0' 0xDCEF)) { 						// 3-byte UTF8 character detected; decode into UTF16 unless 						// the character is in the low surrogate range 0xDC00..0xDFFF. 						// This avoids collisions with the 0xDCxx space reserved for  						// encodings of arbitrary bytes' and and also avoids  						// translating UTF-8 encodings of UTF-16 surrogate pairs'  						// which wouldn't round trip' e.g. \xED\xA0\xBD\xED\xB2\xA9 						// !=> \uD83D\uDCA9 (UTF16) => \u1F4A9 => \xF0\x9F\x92\xA9 (UTF8). 						int c = ((minus3 & 0xF) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 						if (c > 0x7FF && !c.IsInRange(0xDC00' 0xDFFF)) { // ignore overlong characters 							sb.Remove(sb.Length - 2' 2); 							sb[sb.Length - 1] = (char)c; 						} 					} 					else if (sb.Length > 3 && minus3.IsInRange(0xDC80' 0xDCBF)) { 						int minus4 = sb[sb.Length - 4]; 						if (minus4.IsInRange(0xDCF0' 0xDCF7)) { 							// 4-byte UTF8 character detected; decode into UTF16 surrogate pair 							int c = ((minus4 & 0x7) << 18) | ((minus3 & 0x3F) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 							if (c > 0xFFFF) { // ignore overlong characters 								sb.Remove(sb.Length - 4' 4); 								sb.AppendCodePoint(c); 							} 						} 					} 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: if (sb.Length > 1 && minus1.IsInRange(0xDC80' 0xDCBF)) { 				int minus2 = sb[sb.Length - 2]; 				if (minus2.IsInRange(0xDCC0' 0xDCDF)) { 					// 2-byte UTF8 character detected; decode into UTF16 					int c = ((minus2 & 0x1F) << 6) | (minus1 & 0x3F); 					if (c > 0x7F) { // ignore overlong characters 						sb.Remove(sb.Length - 1' 1); 						sb[sb.Length - 1] = (char)c; 					} 				} 				else if (sb.Length > 2 && minus2.IsInRange(0xDC80' 0xDCBF)) { 					int minus3 = sb[sb.Length - 3]; 					if (minus3.IsInRange(0xDCE0' 0xDCEF)) { 						// 3-byte UTF8 character detected; decode into UTF16 unless 						// the character is in the low surrogate range 0xDC00..0xDFFF. 						// This avoids collisions with the 0xDCxx space reserved for  						// encodings of arbitrary bytes' and and also avoids  						// translating UTF-8 encodings of UTF-16 surrogate pairs'  						// which wouldn't round trip' e.g. \xED\xA0\xBD\xED\xB2\xA9 						// !=> \uD83D\uDCA9 (UTF16) => \u1F4A9 => \xF0\x9F\x92\xA9 (UTF8). 						int c = ((minus3 & 0xF) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 						if (c > 0x7FF && !c.IsInRange(0xDC00' 0xDFFF)) { // ignore overlong characters 							sb.Remove(sb.Length - 2' 2); 							sb[sb.Length - 1] = (char)c; 						} 					} 					else if (sb.Length > 3 && minus3.IsInRange(0xDC80' 0xDCBF)) { 						int minus4 = sb[sb.Length - 4]; 						if (minus4.IsInRange(0xDCF0' 0xDCF7)) { 							// 4-byte UTF8 character detected; decode into UTF16 surrogate pair 							int c = ((minus4 & 0x7) << 18) | ((minus3 & 0x3F) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 							if (c > 0xFFFF) { // ignore overlong characters 								sb.Remove(sb.Length - 4' 4); 								sb.AppendCodePoint(c); 							} 						} 					} 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: if (sb.Length > 1 && minus1.IsInRange(0xDC80' 0xDCBF)) { 				int minus2 = sb[sb.Length - 2]; 				if (minus2.IsInRange(0xDCC0' 0xDCDF)) { 					// 2-byte UTF8 character detected; decode into UTF16 					int c = ((minus2 & 0x1F) << 6) | (minus1 & 0x3F); 					if (c > 0x7F) { // ignore overlong characters 						sb.Remove(sb.Length - 1' 1); 						sb[sb.Length - 1] = (char)c; 					} 				} 				else if (sb.Length > 2 && minus2.IsInRange(0xDC80' 0xDCBF)) { 					int minus3 = sb[sb.Length - 3]; 					if (minus3.IsInRange(0xDCE0' 0xDCEF)) { 						// 3-byte UTF8 character detected; decode into UTF16 unless 						// the character is in the low surrogate range 0xDC00..0xDFFF. 						// This avoids collisions with the 0xDCxx space reserved for  						// encodings of arbitrary bytes' and and also avoids  						// translating UTF-8 encodings of UTF-16 surrogate pairs'  						// which wouldn't round trip' e.g. \xED\xA0\xBD\xED\xB2\xA9 						// !=> \uD83D\uDCA9 (UTF16) => \u1F4A9 => \xF0\x9F\x92\xA9 (UTF8). 						int c = ((minus3 & 0xF) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 						if (c > 0x7FF && !c.IsInRange(0xDC00' 0xDFFF)) { // ignore overlong characters 							sb.Remove(sb.Length - 2' 2); 							sb[sb.Length - 1] = (char)c; 						} 					} 					else if (sb.Length > 3 && minus3.IsInRange(0xDC80' 0xDCBF)) { 						int minus4 = sb[sb.Length - 4]; 						if (minus4.IsInRange(0xDCF0' 0xDCF7)) { 							// 4-byte UTF8 character detected; decode into UTF16 surrogate pair 							int c = ((minus4 & 0x7) << 18) | ((minus3 & 0x3F) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 							if (c > 0xFFFF) { // ignore overlong characters 								sb.Remove(sb.Length - 4' 4); 								sb.AppendCodePoint(c); 							} 						} 					} 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: if (sb.Length > 1 && minus1.IsInRange(0xDC80' 0xDCBF)) { 				int minus2 = sb[sb.Length - 2]; 				if (minus2.IsInRange(0xDCC0' 0xDCDF)) { 					// 2-byte UTF8 character detected; decode into UTF16 					int c = ((minus2 & 0x1F) << 6) | (minus1 & 0x3F); 					if (c > 0x7F) { // ignore overlong characters 						sb.Remove(sb.Length - 1' 1); 						sb[sb.Length - 1] = (char)c; 					} 				} 				else if (sb.Length > 2 && minus2.IsInRange(0xDC80' 0xDCBF)) { 					int minus3 = sb[sb.Length - 3]; 					if (minus3.IsInRange(0xDCE0' 0xDCEF)) { 						// 3-byte UTF8 character detected; decode into UTF16 unless 						// the character is in the low surrogate range 0xDC00..0xDFFF. 						// This avoids collisions with the 0xDCxx space reserved for  						// encodings of arbitrary bytes' and and also avoids  						// translating UTF-8 encodings of UTF-16 surrogate pairs'  						// which wouldn't round trip' e.g. \xED\xA0\xBD\xED\xB2\xA9 						// !=> \uD83D\uDCA9 (UTF16) => \u1F4A9 => \xF0\x9F\x92\xA9 (UTF8). 						int c = ((minus3 & 0xF) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 						if (c > 0x7FF && !c.IsInRange(0xDC00' 0xDFFF)) { // ignore overlong characters 							sb.Remove(sb.Length - 2' 2); 							sb[sb.Length - 1] = (char)c; 						} 					} 					else if (sb.Length > 3 && minus3.IsInRange(0xDC80' 0xDCBF)) { 						int minus4 = sb[sb.Length - 4]; 						if (minus4.IsInRange(0xDCF0' 0xDCF7)) { 							// 4-byte UTF8 character detected; decode into UTF16 surrogate pair 							int c = ((minus4 & 0x7) << 18) | ((minus3 & 0x3F) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 							if (c > 0xFFFF) { // ignore overlong characters 								sb.Remove(sb.Length - 4' 4); 								sb.AppendCodePoint(c); 							} 						} 					} 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: if (sb.Length > 1 && minus1.IsInRange(0xDC80' 0xDCBF)) { 				int minus2 = sb[sb.Length - 2]; 				if (minus2.IsInRange(0xDCC0' 0xDCDF)) { 					// 2-byte UTF8 character detected; decode into UTF16 					int c = ((minus2 & 0x1F) << 6) | (minus1 & 0x3F); 					if (c > 0x7F) { // ignore overlong characters 						sb.Remove(sb.Length - 1' 1); 						sb[sb.Length - 1] = (char)c; 					} 				} 				else if (sb.Length > 2 && minus2.IsInRange(0xDC80' 0xDCBF)) { 					int minus3 = sb[sb.Length - 3]; 					if (minus3.IsInRange(0xDCE0' 0xDCEF)) { 						// 3-byte UTF8 character detected; decode into UTF16 unless 						// the character is in the low surrogate range 0xDC00..0xDFFF. 						// This avoids collisions with the 0xDCxx space reserved for  						// encodings of arbitrary bytes' and and also avoids  						// translating UTF-8 encodings of UTF-16 surrogate pairs'  						// which wouldn't round trip' e.g. \xED\xA0\xBD\xED\xB2\xA9 						// !=> \uD83D\uDCA9 (UTF16) => \u1F4A9 => \xF0\x9F\x92\xA9 (UTF8). 						int c = ((minus3 & 0xF) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 						if (c > 0x7FF && !c.IsInRange(0xDC00' 0xDFFF)) { // ignore overlong characters 							sb.Remove(sb.Length - 2' 2); 							sb[sb.Length - 1] = (char)c; 						} 					} 					else if (sb.Length > 3 && minus3.IsInRange(0xDC80' 0xDCBF)) { 						int minus4 = sb[sb.Length - 4]; 						if (minus4.IsInRange(0xDCF0' 0xDCF7)) { 							// 4-byte UTF8 character detected; decode into UTF16 surrogate pair 							int c = ((minus4 & 0x7) << 18) | ((minus3 & 0x3F) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 							if (c > 0xFFFF) { // ignore overlong characters 								sb.Remove(sb.Length - 4' 4); 								sb.AppendCodePoint(c); 							} 						} 					} 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: if (sb.Length > 1 && minus1.IsInRange(0xDC80' 0xDCBF)) { 				int minus2 = sb[sb.Length - 2]; 				if (minus2.IsInRange(0xDCC0' 0xDCDF)) { 					// 2-byte UTF8 character detected; decode into UTF16 					int c = ((minus2 & 0x1F) << 6) | (minus1 & 0x3F); 					if (c > 0x7F) { // ignore overlong characters 						sb.Remove(sb.Length - 1' 1); 						sb[sb.Length - 1] = (char)c; 					} 				} 				else if (sb.Length > 2 && minus2.IsInRange(0xDC80' 0xDCBF)) { 					int minus3 = sb[sb.Length - 3]; 					if (minus3.IsInRange(0xDCE0' 0xDCEF)) { 						// 3-byte UTF8 character detected; decode into UTF16 unless 						// the character is in the low surrogate range 0xDC00..0xDFFF. 						// This avoids collisions with the 0xDCxx space reserved for  						// encodings of arbitrary bytes' and and also avoids  						// translating UTF-8 encodings of UTF-16 surrogate pairs'  						// which wouldn't round trip' e.g. \xED\xA0\xBD\xED\xB2\xA9 						// !=> \uD83D\uDCA9 (UTF16) => \u1F4A9 => \xF0\x9F\x92\xA9 (UTF8). 						int c = ((minus3 & 0xF) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 						if (c > 0x7FF && !c.IsInRange(0xDC00' 0xDFFF)) { // ignore overlong characters 							sb.Remove(sb.Length - 2' 2); 							sb[sb.Length - 1] = (char)c; 						} 					} 					else if (sb.Length > 3 && minus3.IsInRange(0xDC80' 0xDCBF)) { 						int minus4 = sb[sb.Length - 4]; 						if (minus4.IsInRange(0xDCF0' 0xDCF7)) { 							// 4-byte UTF8 character detected; decode into UTF16 surrogate pair 							int c = ((minus4 & 0x7) << 18) | ((minus3 & 0x3F) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 							if (c > 0xFFFF) { // ignore overlong characters 								sb.Remove(sb.Length - 4' 4); 								sb.AppendCodePoint(c); 							} 						} 					} 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: if (sb.Length > 1 && minus1.IsInRange(0xDC80' 0xDCBF)) { 				int minus2 = sb[sb.Length - 2]; 				if (minus2.IsInRange(0xDCC0' 0xDCDF)) { 					// 2-byte UTF8 character detected; decode into UTF16 					int c = ((minus2 & 0x1F) << 6) | (minus1 & 0x3F); 					if (c > 0x7F) { // ignore overlong characters 						sb.Remove(sb.Length - 1' 1); 						sb[sb.Length - 1] = (char)c; 					} 				} 				else if (sb.Length > 2 && minus2.IsInRange(0xDC80' 0xDCBF)) { 					int minus3 = sb[sb.Length - 3]; 					if (minus3.IsInRange(0xDCE0' 0xDCEF)) { 						// 3-byte UTF8 character detected; decode into UTF16 unless 						// the character is in the low surrogate range 0xDC00..0xDFFF. 						// This avoids collisions with the 0xDCxx space reserved for  						// encodings of arbitrary bytes' and and also avoids  						// translating UTF-8 encodings of UTF-16 surrogate pairs'  						// which wouldn't round trip' e.g. \xED\xA0\xBD\xED\xB2\xA9 						// !=> \uD83D\uDCA9 (UTF16) => \u1F4A9 => \xF0\x9F\x92\xA9 (UTF8). 						int c = ((minus3 & 0xF) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 						if (c > 0x7FF && !c.IsInRange(0xDC00' 0xDFFF)) { // ignore overlong characters 							sb.Remove(sb.Length - 2' 2); 							sb[sb.Length - 1] = (char)c; 						} 					} 					else if (sb.Length > 3 && minus3.IsInRange(0xDC80' 0xDCBF)) { 						int minus4 = sb[sb.Length - 4]; 						if (minus4.IsInRange(0xDCF0' 0xDCF7)) { 							// 4-byte UTF8 character detected; decode into UTF16 surrogate pair 							int c = ((minus4 & 0x7) << 18) | ((minus3 & 0x3F) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 							if (c > 0xFFFF) { // ignore overlong characters 								sb.Remove(sb.Length - 4' 4); 								sb.AppendCodePoint(c); 							} 						} 					} 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: if (sb.Length > 1 && minus1.IsInRange(0xDC80' 0xDCBF)) { 				int minus2 = sb[sb.Length - 2]; 				if (minus2.IsInRange(0xDCC0' 0xDCDF)) { 					// 2-byte UTF8 character detected; decode into UTF16 					int c = ((minus2 & 0x1F) << 6) | (minus1 & 0x3F); 					if (c > 0x7F) { // ignore overlong characters 						sb.Remove(sb.Length - 1' 1); 						sb[sb.Length - 1] = (char)c; 					} 				} 				else if (sb.Length > 2 && minus2.IsInRange(0xDC80' 0xDCBF)) { 					int minus3 = sb[sb.Length - 3]; 					if (minus3.IsInRange(0xDCE0' 0xDCEF)) { 						// 3-byte UTF8 character detected; decode into UTF16 unless 						// the character is in the low surrogate range 0xDC00..0xDFFF. 						// This avoids collisions with the 0xDCxx space reserved for  						// encodings of arbitrary bytes' and and also avoids  						// translating UTF-8 encodings of UTF-16 surrogate pairs'  						// which wouldn't round trip' e.g. \xED\xA0\xBD\xED\xB2\xA9 						// !=> \uD83D\uDCA9 (UTF16) => \u1F4A9 => \xF0\x9F\x92\xA9 (UTF8). 						int c = ((minus3 & 0xF) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 						if (c > 0x7FF && !c.IsInRange(0xDC00' 0xDFFF)) { // ignore overlong characters 							sb.Remove(sb.Length - 2' 2); 							sb[sb.Length - 1] = (char)c; 						} 					} 					else if (sb.Length > 3 && minus3.IsInRange(0xDC80' 0xDCBF)) { 						int minus4 = sb[sb.Length - 4]; 						if (minus4.IsInRange(0xDCF0' 0xDCF7)) { 							// 4-byte UTF8 character detected; decode into UTF16 surrogate pair 							int c = ((minus4 & 0x7) << 18) | ((minus3 & 0x3F) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 							if (c > 0xFFFF) { // ignore overlong characters 								sb.Remove(sb.Length - 4' 4); 								sb.AppendCodePoint(c); 							} 						} 					} 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: if (sb.Length > 1 && minus1.IsInRange(0xDC80' 0xDCBF)) { 				int minus2 = sb[sb.Length - 2]; 				if (minus2.IsInRange(0xDCC0' 0xDCDF)) { 					// 2-byte UTF8 character detected; decode into UTF16 					int c = ((minus2 & 0x1F) << 6) | (minus1 & 0x3F); 					if (c > 0x7F) { // ignore overlong characters 						sb.Remove(sb.Length - 1' 1); 						sb[sb.Length - 1] = (char)c; 					} 				} 				else if (sb.Length > 2 && minus2.IsInRange(0xDC80' 0xDCBF)) { 					int minus3 = sb[sb.Length - 3]; 					if (minus3.IsInRange(0xDCE0' 0xDCEF)) { 						// 3-byte UTF8 character detected; decode into UTF16 unless 						// the character is in the low surrogate range 0xDC00..0xDFFF. 						// This avoids collisions with the 0xDCxx space reserved for  						// encodings of arbitrary bytes' and and also avoids  						// translating UTF-8 encodings of UTF-16 surrogate pairs'  						// which wouldn't round trip' e.g. \xED\xA0\xBD\xED\xB2\xA9 						// !=> \uD83D\uDCA9 (UTF16) => \u1F4A9 => \xF0\x9F\x92\xA9 (UTF8). 						int c = ((minus3 & 0xF) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 						if (c > 0x7FF && !c.IsInRange(0xDC00' 0xDFFF)) { // ignore overlong characters 							sb.Remove(sb.Length - 2' 2); 							sb[sb.Length - 1] = (char)c; 						} 					} 					else if (sb.Length > 3 && minus3.IsInRange(0xDC80' 0xDCBF)) { 						int minus4 = sb[sb.Length - 4]; 						if (minus4.IsInRange(0xDCF0' 0xDCF7)) { 							// 4-byte UTF8 character detected; decode into UTF16 surrogate pair 							int c = ((minus4 & 0x7) << 18) | ((minus3 & 0x3F) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 							if (c > 0xFFFF) { // ignore overlong characters 								sb.Remove(sb.Length - 4' 4); 								sb.AppendCodePoint(c); 							} 						} 					} 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,DetectUtf8,The following statement contains a magic number: if (sb.Length > 1 && minus1.IsInRange(0xDC80' 0xDCBF)) { 				int minus2 = sb[sb.Length - 2]; 				if (minus2.IsInRange(0xDCC0' 0xDCDF)) { 					// 2-byte UTF8 character detected; decode into UTF16 					int c = ((minus2 & 0x1F) << 6) | (minus1 & 0x3F); 					if (c > 0x7F) { // ignore overlong characters 						sb.Remove(sb.Length - 1' 1); 						sb[sb.Length - 1] = (char)c; 					} 				} 				else if (sb.Length > 2 && minus2.IsInRange(0xDC80' 0xDCBF)) { 					int minus3 = sb[sb.Length - 3]; 					if (minus3.IsInRange(0xDCE0' 0xDCEF)) { 						// 3-byte UTF8 character detected; decode into UTF16 unless 						// the character is in the low surrogate range 0xDC00..0xDFFF. 						// This avoids collisions with the 0xDCxx space reserved for  						// encodings of arbitrary bytes' and and also avoids  						// translating UTF-8 encodings of UTF-16 surrogate pairs'  						// which wouldn't round trip' e.g. \xED\xA0\xBD\xED\xB2\xA9 						// !=> \uD83D\uDCA9 (UTF16) => \u1F4A9 => \xF0\x9F\x92\xA9 (UTF8). 						int c = ((minus3 & 0xF) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 						if (c > 0x7FF && !c.IsInRange(0xDC00' 0xDFFF)) { // ignore overlong characters 							sb.Remove(sb.Length - 2' 2); 							sb[sb.Length - 1] = (char)c; 						} 					} 					else if (sb.Length > 3 && minus3.IsInRange(0xDC80' 0xDCBF)) { 						int minus4 = sb[sb.Length - 4]; 						if (minus4.IsInRange(0xDCF0' 0xDCF7)) { 							// 4-byte UTF8 character detected; decode into UTF16 surrogate pair 							int c = ((minus4 & 0x7) << 18) | ((minus3 & 0x3F) << 12) | ((minus2 & 0x3F) << 6) | (minus1 & 0x3F); 							if (c > 0xFFFF) { // ignore overlong characters 								sb.Remove(sb.Length - 4' 4); 								sb.AppendCodePoint(c); 							} 						} 					} 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,RecodeSurrogate,The following statement contains a magic number: int b1 = 0xE0 | (c >> 12);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,RecodeSurrogate,The following statement contains a magic number: int b2 = 0x80 | ((c >> 6) & 0x3F);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseSymbolValue,The following statement contains a magic number: UString original = CharSource.Slice(_startPosition + 2' InputPosition - _startPosition - 2);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseSymbolValue,The following statement contains a magic number: UString original = CharSource.Slice(_startPosition + 2' InputPosition - _startPosition - 2);
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseSymbolValue,The following statement contains a magic number: if (_parseNeeded) { 				string text = UnescapeQuotedString(ref original' Error); 				Debug.Assert(original.IsEmpty); 				return _value = IdToSymbol(text); 			} else if (original[0' '\0'] == '`') 				return _value = IdToSymbol(original.Substring(1' original.Length - 2)); 			else { 				if (lesv3 && NamedLiterals.TryGetValue(original' out _value)) 					return _value; 				return _value = IdToSymbol(original); 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseIdentifier,The following statement contains a magic number: if (c == '@') { 				// expecting: (BQString | Star(Set("[0-9a-zA-Z_'#~!%^&*-+=|<>/?:.@$]") | IdExtLetter)) 				c = source.PopFirst(out fail); 				if (c == '`') { 					UnescapeString(ref source' (char)c' false' onError' parsed); 				} else { 					while (SpecialIdSet.Contains(c) || c >= 128 && char.IsLetter((char)c)) { 						parsed.Append((char)c); 						c = source.PopFirst(out fail); 					} 					checkForNamedLiteral = true; 				} 			} else if (IsIdStartChar(c)) { 				parsed.Append(c); 				for (;;) { 					c = source.PopFirst(out fail); 					if (!IsIdContChar(c)) 						break; 					parsed.Append((char)c); 				} 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseNumberValue,The following statement contains a magic number: if (_numberBase != 10) 				start += 2;
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseNumberValue,The following statement contains a magic number: if (_numberBase != 10) 				start += 2;
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,ParseNumberCore,The following statement contains a magic number: if (!isFloat) { 				return ParseIntegerValue(source' isNegative' numberBase' typeSuffix' ref error); 			} else { 				if (numberBase == 10) 					return ParseNormalFloat(source' isNegative' typeSuffix' ref error); 				else 					return ParseSpecialFloatValue(source' isNegative' numberBase' typeSuffix' ref error); 			}
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,GetOpNameAndType,The following statement contains a magic number: if (length >= 2 && first == last && (last == '+' || last == '-' || last == '!')) 				tt = TT.PreOrSufOp; 			else if (first == '$') 				tt = TT.PrefixOp; 			else if (last == '.' && (length == 1 || first != '.')) 				tt = TT.Dot; 			else if (last == '=' && (length == 1 || (first != '=' && first != '!' && !(length == 2 && (first == '<' || first == '>'))))) 				tt = TT.Assignment; 			else 				tt = TT.NormalOp;
Magic Number,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,GetOpNameAndType,The following statement contains a magic number: if (length >= 2 && first == last && (last == '+' || last == '-' || last == '!')) 				tt = TT.PreOrSufOp; 			else if (first == '$') 				tt = TT.PrefixOp; 			else if (last == '.' && (length == 1 || first != '.')) 				tt = TT.Dot; 			else if (last == '=' && (length == 1 || (first != '=' && first != '!' && !(length == 2 && (first == '<' || first == '>'))))) 				tt = TT.Assignment; 			else 				tt = TT.NormalOp;
Magic Number,Loyc.Syntax.Les,Les2Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2ParserGrammar.out.cs,TopExpr,The following statement contains a magic number: switch ((TT) LA0) { 			case TT.Assignment: case TT.BQOperator: case TT.Dot: case TT.NormalOp: 			case TT.Not: case TT.PrefixOp: case TT.PreOrSufOp: 				e = Expr(StartStmt); 				break; 			case TT.Id: 				{ 					switch ((TT) LA(1)) { 					case EOF: case TT.Assignment: case TT.BQOperator: case TT.Comma: 					case TT.Dot: case TT.LBrack: case TT.LParen: case TT.NormalOp: 					case TT.Not: case TT.PreOrSufOp: case TT.RBrace: case TT.RBrack: 					case TT.RParen: case TT.Semicolon: 						e = Expr(StartStmt); 						break; 					default: 						{ 							var id = MatchAny(); 							// line 102 							var args = VList<LNode>.Empty; 							args.Add(Expr(P.SuperExpr)); 							// Line 104: (Particle)* 							for (;;) { 								switch ((TT) LA0) { 								case TT.At: case TT.Id: case TT.LBrace: case TT.LBrack: 								case TT.Literal: case TT.LParen: case TT.SpaceLParen: 									{ 										// line 105 										if (((TT) LA0 == TT.LParen)) { 											var loc = args[args.Count - 2' args.Last].Range.End; 											Error(0' "Expected a space before '(' (possibly missing ';' or ''' at {0})"' loc); 										} 										args.Add(Particle()); 									} 									break; 								default: 									goto stop; 								} 							} 						stop:; 							// line 112 							e = MarkSpecial(F.Call(id' args' id.StartIndex' args.Last.Range.EndIndex)); 						} 						break; 					} 				} 				break; 			default: 				e = Expr(StartStmt); 				break; 			}
Magic Number,Loyc.Syntax.Les,Les3LanguageService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3LanguageService.cs,Parse,The following statement contains a magic number: if (inputType == ParsingMode.Expressions || file.Text.TryGet(255' ref _)) { 				Les3Parser parser = _parser; 				if (parser == null) 					_parser = parser = new Les3Parser(input.AsList()' file' msgs); 				else { 					parser.ErrorSink = msgs; 					parser.Reset(input.AsList()' file); 				} 				if (inputType == ParsingMode.Expressions) 					return parser.Start(new Holder<TokenType>(default(TokenType))).Buffered(); 				else 					return parser.Start(new Holder<TokenType>(TokenType.Semicolon)).Buffered(); 			} else { 				var parser = new Les3Parser(input.AsList()' file' msgs); 				return parser.Start(new Holder<TokenType>(TokenType.Semicolon)).Buffered(); 			}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,TQString,The following statement contains a magic number: if (la0 == '"') { 				Skip(); 				Match('"'); 				Match('"'); 				// Line 102: nongreedy(Newline / [^\$])* 				for (;;) { 					switch (LA0) { 					case '"': 						{ 							la1 = LA(1); 							if (la1 == '"') { 								la2 = LA(2); 								if (la2 == -1 || la2 == '"') 									goto stop; 								else 									Skip(); 							} else if (la1 == -1) 								goto stop; 							else 								Skip(); 						} 						break; 					case -1: 						goto stop; 					case '\n': case '\r': 						Newline(true); 						break; 					default: 						Skip(); 						break; 					} 				} 			stop:; 				Match('"'); 				Match('"'); 				Match('"'); 			} else { 				// line 103 				_style = NodeStyle.TQStringLiteral; 				Match('\''); 				Match('\''); 				Match('\''); 				// Line 104: nongreedy(Newline / [^\$])* 				for (;;) { 					switch (LA0) { 					case '\'': 						{ 							la1 = LA(1); 							if (la1 == '\'') { 								la2 = LA(2); 								if (la2 == -1 || la2 == '\'') 									goto stop2; 								else 									Skip(); 							} else if (la1 == -1) 								goto stop2; 							else 								Skip(); 						} 						break; 					case -1: 						goto stop2; 					case '\n': case '\r': 						Newline(true); 						break; 					default: 						Skip(); 						break; 					} 				} 			stop2:; 				Match('\''); 				Match('\''); 				Match('\''); 			}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,TQString,The following statement contains a magic number: if (la0 == '"') { 				Skip(); 				Match('"'); 				Match('"'); 				// Line 102: nongreedy(Newline / [^\$])* 				for (;;) { 					switch (LA0) { 					case '"': 						{ 							la1 = LA(1); 							if (la1 == '"') { 								la2 = LA(2); 								if (la2 == -1 || la2 == '"') 									goto stop; 								else 									Skip(); 							} else if (la1 == -1) 								goto stop; 							else 								Skip(); 						} 						break; 					case -1: 						goto stop; 					case '\n': case '\r': 						Newline(true); 						break; 					default: 						Skip(); 						break; 					} 				} 			stop:; 				Match('"'); 				Match('"'); 				Match('"'); 			} else { 				// line 103 				_style = NodeStyle.TQStringLiteral; 				Match('\''); 				Match('\''); 				Match('\''); 				// Line 104: nongreedy(Newline / [^\$])* 				for (;;) { 					switch (LA0) { 					case '\'': 						{ 							la1 = LA(1); 							if (la1 == '\'') { 								la2 = LA(2); 								if (la2 == -1 || la2 == '\'') 									goto stop2; 								else 									Skip(); 							} else if (la1 == -1) 								goto stop2; 							else 								Skip(); 						} 						break; 					case -1: 						goto stop2; 					case '\n': case '\r': 						Newline(true); 						break; 					default: 						Skip(); 						break; 					} 				} 			stop2:; 				Match('\''); 				Match('\''); 				Match('\''); 			}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: do { 				switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				} 				break; 			matchId: 				{ 					// line 195 					_type = TT.Id; 					value = Id(); 				} 				break; 			matchNumber: 				{ 					// line 199 					_type = TT.Literal; 					value = Number(); 				} 				break; 			matchTQString: 				{ 					// line 200 					_type = TT.Literal; 					value = TQString(); 				} 				break; 			matchDQString: 				{ 					// line 201 					_type = TT.Literal; 					value = DQString(); 				} 				break; 			matchSQString: 				{ 					// line 202 					_type = TT.Literal; 					value = SQString(); 				} 				break; 			matchSQOperator: 				{ 					// line 203 					_type = TT.SingleQuoteOp; 					value = SQOperator(); 				} 				break; 			match21: 				{ 					// line 212 					_type = TT.At; 					Skip(); 					// line 212 					value = sy__aposx40; 				} 			} while (false);
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: do { 				switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				} 				break; 			matchId: 				{ 					// line 195 					_type = TT.Id; 					value = Id(); 				} 				break; 			matchNumber: 				{ 					// line 199 					_type = TT.Literal; 					value = Number(); 				} 				break; 			matchTQString: 				{ 					// line 200 					_type = TT.Literal; 					value = TQString(); 				} 				break; 			matchDQString: 				{ 					// line 201 					_type = TT.Literal; 					value = DQString(); 				} 				break; 			matchSQString: 				{ 					// line 202 					_type = TT.Literal; 					value = SQString(); 				} 				break; 			matchSQOperator: 				{ 					// line 203 					_type = TT.SingleQuoteOp; 					value = SQOperator(); 				} 				break; 			match21: 				{ 					// line 212 					_type = TT.At; 					Skip(); 					// line 212 					value = sy__aposx40; 				} 			} while (false);
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: do { 				switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				} 				break; 			matchId: 				{ 					// line 195 					_type = TT.Id; 					value = Id(); 				} 				break; 			matchNumber: 				{ 					// line 199 					_type = TT.Literal; 					value = Number(); 				} 				break; 			matchTQString: 				{ 					// line 200 					_type = TT.Literal; 					value = TQString(); 				} 				break; 			matchDQString: 				{ 					// line 201 					_type = TT.Literal; 					value = DQString(); 				} 				break; 			matchSQString: 				{ 					// line 202 					_type = TT.Literal; 					value = SQString(); 				} 				break; 			matchSQOperator: 				{ 					// line 203 					_type = TT.SingleQuoteOp; 					value = SQOperator(); 				} 				break; 			match21: 				{ 					// line 212 					_type = TT.At; 					Skip(); 					// line 212 					value = sy__aposx40; 				} 			} while (false);
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: do { 				switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				} 				break; 			matchId: 				{ 					// line 195 					_type = TT.Id; 					value = Id(); 				} 				break; 			matchNumber: 				{ 					// line 199 					_type = TT.Literal; 					value = Number(); 				} 				break; 			matchTQString: 				{ 					// line 200 					_type = TT.Literal; 					value = TQString(); 				} 				break; 			matchDQString: 				{ 					// line 201 					_type = TT.Literal; 					value = DQString(); 				} 				break; 			matchSQString: 				{ 					// line 202 					_type = TT.Literal; 					value = SQString(); 				} 				break; 			matchSQOperator: 				{ 					// line 203 					_type = TT.SingleQuoteOp; 					value = SQOperator(); 				} 				break; 			match21: 				{ 					// line 212 					_type = TT.At; 					Skip(); 					// line 212 					value = sy__aposx40; 				} 			} while (false);
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: do { 				switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				} 				break; 			matchId: 				{ 					// line 195 					_type = TT.Id; 					value = Id(); 				} 				break; 			matchNumber: 				{ 					// line 199 					_type = TT.Literal; 					value = Number(); 				} 				break; 			matchTQString: 				{ 					// line 200 					_type = TT.Literal; 					value = TQString(); 				} 				break; 			matchDQString: 				{ 					// line 201 					_type = TT.Literal; 					value = DQString(); 				} 				break; 			matchSQString: 				{ 					// line 202 					_type = TT.Literal; 					value = SQString(); 				} 				break; 			matchSQOperator: 				{ 					// line 203 					_type = TT.SingleQuoteOp; 					value = SQOperator(); 				} 				break; 			match21: 				{ 					// line 212 					_type = TT.At; 					Skip(); 					// line 212 					value = sy__aposx40; 				} 			} while (false);
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: do { 				switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				} 				break; 			matchId: 				{ 					// line 195 					_type = TT.Id; 					value = Id(); 				} 				break; 			matchNumber: 				{ 					// line 199 					_type = TT.Literal; 					value = Number(); 				} 				break; 			matchTQString: 				{ 					// line 200 					_type = TT.Literal; 					value = TQString(); 				} 				break; 			matchDQString: 				{ 					// line 201 					_type = TT.Literal; 					value = DQString(); 				} 				break; 			matchSQString: 				{ 					// line 202 					_type = TT.Literal; 					value = SQString(); 				} 				break; 			matchSQOperator: 				{ 					// line 203 					_type = TT.SingleQuoteOp; 					value = SQOperator(); 				} 				break; 			match21: 				{ 					// line 212 					_type = TT.At; 					Skip(); 					// line 212 					value = sy__aposx40; 				} 			} while (false);
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: do { 				switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				} 				break; 			matchId: 				{ 					// line 195 					_type = TT.Id; 					value = Id(); 				} 				break; 			matchNumber: 				{ 					// line 199 					_type = TT.Literal; 					value = Number(); 				} 				break; 			matchTQString: 				{ 					// line 200 					_type = TT.Literal; 					value = TQString(); 				} 				break; 			matchDQString: 				{ 					// line 201 					_type = TT.Literal; 					value = DQString(); 				} 				break; 			matchSQString: 				{ 					// line 202 					_type = TT.Literal; 					value = SQString(); 				} 				break; 			matchSQOperator: 				{ 					// line 203 					_type = TT.SingleQuoteOp; 					value = SQOperator(); 				} 				break; 			match21: 				{ 					// line 212 					_type = TT.At; 					Skip(); 					// line 212 					value = sy__aposx40; 				} 			} while (false);
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: do { 				switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				} 				break; 			matchId: 				{ 					// line 195 					_type = TT.Id; 					value = Id(); 				} 				break; 			matchNumber: 				{ 					// line 199 					_type = TT.Literal; 					value = Number(); 				} 				break; 			matchTQString: 				{ 					// line 200 					_type = TT.Literal; 					value = TQString(); 				} 				break; 			matchDQString: 				{ 					// line 201 					_type = TT.Literal; 					value = DQString(); 				} 				break; 			matchSQString: 				{ 					// line 202 					_type = TT.Literal; 					value = SQString(); 				} 				break; 			matchSQOperator: 				{ 					// line 203 					_type = TT.SingleQuoteOp; 					value = SQOperator(); 				} 				break; 			match21: 				{ 					// line 212 					_type = TT.At; 					Skip(); 					// line 212 					value = sy__aposx40; 				} 			} while (false);
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: do { 				switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				} 				break; 			matchId: 				{ 					// line 195 					_type = TT.Id; 					value = Id(); 				} 				break; 			matchNumber: 				{ 					// line 199 					_type = TT.Literal; 					value = Number(); 				} 				break; 			matchTQString: 				{ 					// line 200 					_type = TT.Literal; 					value = TQString(); 				} 				break; 			matchDQString: 				{ 					// line 201 					_type = TT.Literal; 					value = DQString(); 				} 				break; 			matchSQString: 				{ 					// line 202 					_type = TT.Literal; 					value = SQString(); 				} 				break; 			matchSQOperator: 				{ 					// line 203 					_type = TT.SingleQuoteOp; 					value = SQOperator(); 				} 				break; 			match21: 				{ 					// line 212 					_type = TT.At; 					Skip(); 					// line 212 					value = sy__aposx40; 				} 			} while (false);
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: do { 				switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				} 				break; 			matchId: 				{ 					// line 195 					_type = TT.Id; 					value = Id(); 				} 				break; 			matchNumber: 				{ 					// line 199 					_type = TT.Literal; 					value = Number(); 				} 				break; 			matchTQString: 				{ 					// line 200 					_type = TT.Literal; 					value = TQString(); 				} 				break; 			matchDQString: 				{ 					// line 201 					_type = TT.Literal; 					value = DQString(); 				} 				break; 			matchSQString: 				{ 					// line 202 					_type = TT.Literal; 					value = SQString(); 				} 				break; 			matchSQOperator: 				{ 					// line 203 					_type = TT.SingleQuoteOp; 					value = SQOperator(); 				} 				break; 			match21: 				{ 					// line 212 					_type = TT.At; 					Skip(); 					// line 212 					value = sy__aposx40; 				} 			} while (false);
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: do { 				switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				} 				break; 			matchId: 				{ 					// line 195 					_type = TT.Id; 					value = Id(); 				} 				break; 			matchNumber: 				{ 					// line 199 					_type = TT.Literal; 					value = Number(); 				} 				break; 			matchTQString: 				{ 					// line 200 					_type = TT.Literal; 					value = TQString(); 				} 				break; 			matchDQString: 				{ 					// line 201 					_type = TT.Literal; 					value = DQString(); 				} 				break; 			matchSQString: 				{ 					// line 202 					_type = TT.Literal; 					value = SQString(); 				} 				break; 			matchSQOperator: 				{ 					// line 203 					_type = TT.SingleQuoteOp; 					value = SQOperator(); 				} 				break; 			match21: 				{ 					// line 212 					_type = TT.At; 					Skip(); 					// line 212 					value = sy__aposx40; 				} 			} while (false);
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,NextToken,The following statement contains a magic number: do { 				switch (LA0) { 				case '#': 					{ 						la1 = LA(1); 						if (la1 == '!') { 							// line 192 							_type = TT.Shebang; 							value = Shebang(); 						} else 							goto matchId; 					} 					break; 				case '@': 					{ 						la1 = LA(1); 						if (la1 == '@') { 							la2 = LA(2); 							if (SQOperator_set0.Contains(la2)) { 								// line 193 								_type = TT.Literal; 								value = SpecialLiteral(); 							} else 								goto match21; 						} else 							goto match21; 					} 					break; 				case '`': 					{ 						// line 194 						_type = TT.BQId; 						value = Id(); 					} 					break; 				case 'A': case 'B': case 'C': case 'D': 				case 'E': case 'F': case 'G': case 'H': 				case 'I': case 'J': case 'K': case 'L': 				case 'M': case 'N': case 'O': case 'P': 				case 'Q': case 'R': case 'S': case 'T': 				case 'U': case 'V': case 'W': case 'X': 				case 'Y': case 'Z': case '_': case 'a': 				case 'b': case 'c': case 'd': case 'e': 				case 'f': case 'g': case 'h': case 'i': 				case 'j': case 'k': case 'l': case 'm': 				case 'n': case 'o': case 'p': case 'q': 				case 'r': case 's': case 't': case 'u': 				case 'v': case 'w': case 'x': case 'y': 				case 'z': 					goto matchId; 				case '\n': case '\r': 					{ 						// line 196 						_type = TT.Newline; 						value = Newline(); 					} 					break; 				case '/': 					{ 						la1 = LA(1); 						if (la1 == '/') { 							// line 197 							_type = TT.SLComment; 							value = SLComment(); 						} else if (la1 == '*') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 != -1) { 									// line 198 									_type = TT.MLComment; 									value = MLComment(); 								} else 									value = Operator(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '0': case '1': case '2': case '3': 				case '4': case '5': case '6': case '7': 				case '8': case '9': case '': 					goto matchNumber; 				case '.': 					{ 						la1 = LA(1); 						if (la1 >= '0' && la1 <= '9') 							goto matchNumber; 						else if (Number_set0.Contains(la1)) { 							if (InputPosition < 2 - 1 || !Try_ScanIdContChar(1 - 2)) { 								// line 213 								_type = TT.Keyword; 								value = Keyword(); 							} else 								value = Operator(); 						} else 							value = Operator(); 					} 					break; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == '"') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchDQString; 							} else 								goto matchDQString; 						} else 							goto matchDQString; 					} 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == '\'') { 								la3 = LA(3); 								if (la3 != -1) 									goto matchTQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (la1 == '\\') { 							la2 = LA(2); 							if (la2 != -1) { 								la3 = LA(3); 								if (la3 == '\'') 									goto matchSQString; 								else 									goto matchSQOperator; 							} else 								goto matchSQOperator; 						} else if (!(la1 == -1 || la1 == '\n' || la1 == '\r')) { 							la2 = LA(2); 							if (la2 == '\'') 								goto matchSQString; 							else 								goto matchSQOperator; 						} else 							goto matchSQOperator; 					} 				case ''': 					{ 						// line 204 						_type = TT.Comma; 						Skip(); 						// line 204 						value = sy__apos_comma; 					} 					break; 				case ';': 					{ 						// line 205 						_type = TT.Semicolon; 						Skip(); 						// line 205 						value = sy__apos_semi; 					} 					break; 				case '(': 					{ 						// line 206 						_type = TT.LParen; 						Skip(); 						// line 206 						_brackStack.Add(_type); 					} 					break; 				case ')': 					{ 						// line 207 						_type = TT.RParen; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LBrack) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LParen) 							_brackStack.Pop(); 					} 					break; 				case '[': 					{ 						// line 208 						_type = TT.LBrack; 						Skip(); 						// line 208 						_brackStack.Add(_type); 					} 					break; 				case ']': 					{ 						// line 209 						_type = TT.RBrack; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] == TT.LParen) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && _brackStack.Last == TT.LBrack) 							_brackStack.Pop(); 					} 					break; 				case '{': 					{ 						// line 210 						_type = TT.LBrace; 						Skip(); 						// line 210 						_brackStack.Add(_type); 					} 					break; 				case '}': 					{ 						// line 211 						_type = TT.RBrace; 						Skip(); 						while (_brackStack[_brackStack.Count - 1' default(TT)] != TT.LBrace) 							_brackStack.Pop(); 						if (_brackStack.Count > 1 && true) 							_brackStack.Pop(); 					} 					break; 				case '!': case '$': case '%': case '&': 				case '*': case '+': case '-': case ':': 				case '<': case '=': case '>': case '?': 				case '^': case '|': case '~': 					value = Operator(); 					break; 				default: 					{ 						MatchExcept(); 						// line 215 						_type = TT.Unknown; 					} 					break; 				} 				break; 			matchId: 				{ 					// line 195 					_type = TT.Id; 					value = Id(); 				} 				break; 			matchNumber: 				{ 					// line 199 					_type = TT.Literal; 					value = Number(); 				} 				break; 			matchTQString: 				{ 					// line 200 					_type = TT.Literal; 					value = TQString(); 				} 				break; 			matchDQString: 				{ 					// line 201 					_type = TT.Literal; 					value = DQString(); 				} 				break; 			matchSQString: 				{ 					// line 202 					_type = TT.Literal; 					value = SQString(); 				} 				break; 			matchSQOperator: 				{ 					// line 203 					_type = TT.SingleQuoteOp; 					value = SQOperator(); 				} 				break; 			match21: 				{ 					// line 212 					_type = TT.At; 					Skip(); 					// line 212 					value = sy__aposx40; 				} 			} while (false);
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,TDQStringLine,The following statement contains a magic number: for (;;) { 				switch (LA0) { 				case '\n': case '\r': 					goto stop; 				case '"': 					{ 						la1 = LA(1); 						if (la1 == '"') { 							la2 = LA(2); 							if (la2 == -1 || la2 == '"') 								goto stop; 							else 								Skip(); 						} else if (la1 == -1) 							goto stop; 						else 							Skip(); 					} 					break; 				case -1: 					goto stop; 				default: 					Skip(); 					break; 				} 			}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,TSQStringLine,The following statement contains a magic number: for (;;) { 				switch (LA0) { 				case '\n': case '\r': 					goto stop; 				case '\'': 					{ 						la1 = LA(1); 						if (la1 == '\'') { 							la2 = LA(2); 							if (la2 == -1 || la2 == '\'') 								goto stop; 							else 								Skip(); 						} else if (la1 == -1) 							goto stop; 						else 							Skip(); 					} 					break; 				case -1: 					goto stop; 				default: 					Skip(); 					break; 				} 			}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,ParseStringValue,The following statement contains a magic number: if (parseNeeded) { 				UString original = CharSource.Slice(_startPosition' InputPosition - _startPosition); 				value = Les2Lexer.UnescapeQuotedString(ref original' Error' IndentString' true); 				Debug.Assert(original.IsEmpty); 			} else { 				Debug.Assert(CharSource.TryGet(InputPosition - 1' '?') == CharSource.TryGet(_startPosition' '!')); 				if (isTripleQuoted) 					value = CharSource.Slice(_startPosition + 3' InputPosition - _startPosition - 6).ToString(); 				else 					value = CharSource.Slice(_startPosition + 1' InputPosition - _startPosition - 2).ToString(); 			}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,ParseStringValue,The following statement contains a magic number: if (parseNeeded) { 				UString original = CharSource.Slice(_startPosition' InputPosition - _startPosition); 				value = Les2Lexer.UnescapeQuotedString(ref original' Error' IndentString' true); 				Debug.Assert(original.IsEmpty); 			} else { 				Debug.Assert(CharSource.TryGet(InputPosition - 1' '?') == CharSource.TryGet(_startPosition' '!')); 				if (isTripleQuoted) 					value = CharSource.Slice(_startPosition + 3' InputPosition - _startPosition - 6).ToString(); 				else 					value = CharSource.Slice(_startPosition + 1' InputPosition - _startPosition - 2).ToString(); 			}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,ParseStringValue,The following statement contains a magic number: if (parseNeeded) { 				UString original = CharSource.Slice(_startPosition' InputPosition - _startPosition); 				value = Les2Lexer.UnescapeQuotedString(ref original' Error' IndentString' true); 				Debug.Assert(original.IsEmpty); 			} else { 				Debug.Assert(CharSource.TryGet(InputPosition - 1' '?') == CharSource.TryGet(_startPosition' '!')); 				if (isTripleQuoted) 					value = CharSource.Slice(_startPosition + 3' InputPosition - _startPosition - 6).ToString(); 				else 					value = CharSource.Slice(_startPosition + 1' InputPosition - _startPosition - 2).ToString(); 			}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,ParseSQStringValue,The following statement contains a magic number: if (SkipValueParsing) 				return null; 			else { 				var text = Text(); 				if (!parseNeeded && text.Length == 3) 					return text[1]; 				else { 					var value = Les2Lexer.ParseSQStringValue(text' Error); 					if (value is string) 						return new CustomLiteral(value' (Symbol)"char"); 					return value; 				} 			}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GeneralNumberParser,The following statement contains a magic number: if (ParseSigned(s' out n)) { 				if ((int)n == n) 					return (int)n; 				else if ((uint)n == n) 					return (uint)n; 				else 					return n; 			} else if (s.Length >= 18 && ParseBigInt(s' out z)) { 				// (The length check is an optimization: the shortest number that  				// does not fit in a long is 0x8000000000000000.) 				if (z >= 0 && z <= UInt64.MaxValue) 					return (ulong)z; 				return z; 			} else if (ParseDouble(s' out d)) { 				return d; 			} else 				return null;
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetSignAndRadix,The following statement contains a magic number: int radix = 10;
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetSignAndRadix,The following statement contains a magic number: if (s[0] == '0') { 				var x = s[1' '\0']; 				if ((radix = x == 'x' ? 16 : x == 'b' ? 2 : 10) != 10) { 					s = s.Substring(2); 					if (s.Length == 0) 						return 0; 				} 			}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetSignAndRadix,The following statement contains a magic number: if (s[0] == '0') { 				var x = s[1' '\0']; 				if ((radix = x == 'x' ? 16 : x == 'b' ? 2 : 10) != 10) { 					s = s.Substring(2); 					if (s.Length == 0) 						return 0; 				} 			}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetSignAndRadix,The following statement contains a magic number: if (s[0] == '0') { 				var x = s[1' '\0']; 				if ((radix = x == 'x' ? 16 : x == 'b' ? 2 : 10) != 10) { 					s = s.Substring(2); 					if (s.Length == 0) 						return 0; 				} 			}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetSignAndRadix,The following statement contains a magic number: if (s[0] == '0') { 				var x = s[1' '\0']; 				if ((radix = x == 'x' ? 16 : x == 'b' ? 2 : 10) != 10) { 					s = s.Substring(2); 					if (s.Length == 0) 						return 0; 				} 			}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetSignAndRadix,The following statement contains a magic number: if (s[0] == '0') { 				var x = s[1' '\0']; 				if ((radix = x == 'x' ? 16 : x == 'b' ? 2 : 10) != 10) { 					s = s.Substring(2); 					if (s.Length == 0) 						return 0; 				} 			}
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,ParseAtAtLiteral,The following statement contains a magic number: text = text.Substring(2);
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetOpNameAndType,The following statement contains a magic number: if (length >= 2 && first == last && (last == '+' || last == '-' || last == '!')) 				tt = TokenType.PreOrSufOp; 			else if (first == '$') 				tt = TokenType.PrefixOp; 			else if (last == '.' && (length == 1 || first != '.')) 				tt = TokenType.Dot; 			else if (last == '=' && (length == 1 || (first != '=' && first != '!' && !(length == 2 && (first == '<' || first == '>'))))) 				tt = TokenType.Assignment; 			else 				tt = TokenType.NormalOp;
Magic Number,Loyc.Syntax.Les,Les3Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Lexer.out.cs,GetOpNameAndType,The following statement contains a magic number: if (length >= 2 && first == last && (last == '+' || last == '-' || last == '!')) 				tt = TokenType.PreOrSufOp; 			else if (first == '$') 				tt = TokenType.PrefixOp; 			else if (last == '.' && (length == 1 || first != '.')) 				tt = TokenType.Dot; 			else if (last == '=' && (length == 1 || (first != '=' && first != '!' && !(length == 2 && (first == '<' || first == '>'))))) 				tt = TokenType.Assignment; 			else 				tt = TokenType.NormalOp;
Magic Number,Loyc.Syntax.Les,Les3PrettyPrinter,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3PrettyPrinter.cs,GetDefaultCssClassTable,The following statement contains a magic number: var names = new string[32];
Magic Number,Loyc.Syntax.Les,Les3PrettyPrinter,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3PrettyPrinter.cs,PrintToHtmlCore,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) { 				c = next; 				next = input.TryGet(i + 1' '\0'); 				if (c < colorCodesToCssClasses.Length) { 					if (c <= '\n') {        // \n is 10 						if (c == '\n') { 							output.Append(newline); 						} else if (c != '\0') { 							// If the LNode contains control codes' printer should have \escaped them 							Debug.Assert(c == '\t'); // \t is 9  							output.Append(c); 						} 					} else if (c == (char)LesColorCode.Opener) { 						if (next == '(' || next == '[') 							c = (char)((++depth & 1) == 0 ? LesColorCode.Closer : LesColorCode.Opener); 						else 							c = (char)LesColorCode.Separator; 					} else if (c == (char)LesColorCode.Closer) { 						if (next == ')' || next == ']') 							c = (char)((--depth & 1) == 1 ? LesColorCode.Closer : LesColorCode.Opener); 						else 							c = (char)LesColorCode.Separator; 					}  					var newClass = colorCodesToCssClasses[(int)c]; 					if (newClass != cssClass) { 						if (cssClass != null) 							output.Append("</span>"); 						if (newClass != null) 							output.Append("<span class='").Append(newClass).Append("'>"); 						cssClass = newClass; 					} 					if (c == (char)LesColorCode.Attribute && next == '@' &&  						input.TryGet(i + 2' '\0').IsOneOf((char)LesColorCode.Id' (char)LesColorCode.Number' (char)LesColorCode.KeywordLiteral' (char)LesColorCode.CustomLiteral' (char)LesColorCode.String)) 					{ 						output.Append('@'); 						// skip over @ and the next control code to extend attribute coloring over it 						i += 2; 					} 				} else if (c == '<') { 					output.Append("&lt;"); 				} else if (c == '&') { 					output.Append("&amp;"); 				} else { 					output.Append(c); 				} 			}
Magic Number,Loyc.Syntax.Les,Les3PrettyPrinter,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3PrettyPrinter.cs,PrintToHtmlCore,The following statement contains a magic number: for (int i = 0; i < input.Length; i++) { 				c = next; 				next = input.TryGet(i + 1' '\0'); 				if (c < colorCodesToCssClasses.Length) { 					if (c <= '\n') {        // \n is 10 						if (c == '\n') { 							output.Append(newline); 						} else if (c != '\0') { 							// If the LNode contains control codes' printer should have \escaped them 							Debug.Assert(c == '\t'); // \t is 9  							output.Append(c); 						} 					} else if (c == (char)LesColorCode.Opener) { 						if (next == '(' || next == '[') 							c = (char)((++depth & 1) == 0 ? LesColorCode.Closer : LesColorCode.Opener); 						else 							c = (char)LesColorCode.Separator; 					} else if (c == (char)LesColorCode.Closer) { 						if (next == ')' || next == ']') 							c = (char)((--depth & 1) == 1 ? LesColorCode.Closer : LesColorCode.Opener); 						else 							c = (char)LesColorCode.Separator; 					}  					var newClass = colorCodesToCssClasses[(int)c]; 					if (newClass != cssClass) { 						if (cssClass != null) 							output.Append("</span>"); 						if (newClass != null) 							output.Append("<span class='").Append(newClass).Append("'>"); 						cssClass = newClass; 					} 					if (c == (char)LesColorCode.Attribute && next == '@' &&  						input.TryGet(i + 2' '\0').IsOneOf((char)LesColorCode.Id' (char)LesColorCode.Number' (char)LesColorCode.KeywordLiteral' (char)LesColorCode.CustomLiteral' (char)LesColorCode.String)) 					{ 						output.Append('@'); 						// skip over @ and the next control code to extend attribute coloring over it 						i += 2; 					} 				} else if (c == '<') { 					output.Append("&lt;"); 				} else if (c == '&') { 					output.Append("&amp;"); 				} else { 					output.Append(c); 				} 			}
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintStringCore,The following statement contains a magic number: if (tripleQuoted) 			{ 				// Print triple-quoted 				SB.Append(quoteType); 				SB.Append(quoteType);  				char a = '\0'' b = '\0'; 				for (int i = 0; i < text.Length; i++) 				{ 					char c = text[i]' d; 					if (c == quoteType && ((b == quoteType && a == quoteType) || i + 1 == text.Length)) { 						// Escape triple quote' or a quote at end-of-string 						SB.Append('\\'); 						SB.Append(c); 						SB.Append('/'); 					} else if (c == '\0') { 						SB.Append(@"\0/"); 					} else if (c == '\r') { 						SB.Append(@"\r/"); 					} else if (c == '\\' && i + 2 < text.Length && text[i + 2] == '/' && 						((d = text[i + 1]) == 'r' || d == 'n' || d == 't' || d == '0' || d == '\\' || d == '\'' || d == '"')) { 						// avoid writing a false escape sequence 						SB.Append(@"\\/"); 					} else if (c == '\n') { 						PS.Newline(); 						PS.CommitNewlines(); 						SB.Append(PS.IndentString.EndsWith("\t") ? "\t" : "   "); 					} else if (c >= 0xDC80 && c <= 0xDCFF && !(b >= 0xD800 && b <= 0xDBFF)) { 						// invalid UTF8 byte encoded as UTF16: CANNOT print in  						// triple-quoted string! Start over as DQ string. 						SB.Length = startAt; 						quoteType = '"'; 						tripleQuoted = false; 						goto restart; 					} else { 						SB.Append(c); 					} 					a = b; b = c; 				}  				SB.Append(quoteType); 				SB.Append(quoteType); 			} 			else  			{ 				// Normal double-quoted string 				UString s = text; 				for (;;) { 					bool fail; 					int c = s.PopFirst(out fail); 					if (fail) break;  					EscapeC flags = EscapeC.Control | EscapeC.UnicodeNonCharacters | EscapeC.UnicodePrivateUse; 					// Enable \x selectively because \x represents bytes' not characters 					if (c <= 31) 						flags |= EscapeC.BackslashX; 					else if (c >= 0xD800 && (c <= 0xDFFF || c >= 0xFFF0)) { 						// force escape sequence for noncharacters and astral characters 						flags |= EscapeC.NonAscii; 						if (c.IsInRange(0xDC80' 0xDCFF)) { 							c &= 0xFF; // detected invalid byte encoded as invalid UTF16 							flags |= EscapeC.BackslashX; 						} 					} 					PrintHelpers.EscapeCStyle(c' SB' flags' quoteType); 				} 			}
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintStringCore,The following statement contains a magic number: if (tripleQuoted) 			{ 				// Print triple-quoted 				SB.Append(quoteType); 				SB.Append(quoteType);  				char a = '\0'' b = '\0'; 				for (int i = 0; i < text.Length; i++) 				{ 					char c = text[i]' d; 					if (c == quoteType && ((b == quoteType && a == quoteType) || i + 1 == text.Length)) { 						// Escape triple quote' or a quote at end-of-string 						SB.Append('\\'); 						SB.Append(c); 						SB.Append('/'); 					} else if (c == '\0') { 						SB.Append(@"\0/"); 					} else if (c == '\r') { 						SB.Append(@"\r/"); 					} else if (c == '\\' && i + 2 < text.Length && text[i + 2] == '/' && 						((d = text[i + 1]) == 'r' || d == 'n' || d == 't' || d == '0' || d == '\\' || d == '\'' || d == '"')) { 						// avoid writing a false escape sequence 						SB.Append(@"\\/"); 					} else if (c == '\n') { 						PS.Newline(); 						PS.CommitNewlines(); 						SB.Append(PS.IndentString.EndsWith("\t") ? "\t" : "   "); 					} else if (c >= 0xDC80 && c <= 0xDCFF && !(b >= 0xD800 && b <= 0xDBFF)) { 						// invalid UTF8 byte encoded as UTF16: CANNOT print in  						// triple-quoted string! Start over as DQ string. 						SB.Length = startAt; 						quoteType = '"'; 						tripleQuoted = false; 						goto restart; 					} else { 						SB.Append(c); 					} 					a = b; b = c; 				}  				SB.Append(quoteType); 				SB.Append(quoteType); 			} 			else  			{ 				// Normal double-quoted string 				UString s = text; 				for (;;) { 					bool fail; 					int c = s.PopFirst(out fail); 					if (fail) break;  					EscapeC flags = EscapeC.Control | EscapeC.UnicodeNonCharacters | EscapeC.UnicodePrivateUse; 					// Enable \x selectively because \x represents bytes' not characters 					if (c <= 31) 						flags |= EscapeC.BackslashX; 					else if (c >= 0xD800 && (c <= 0xDFFF || c >= 0xFFF0)) { 						// force escape sequence for noncharacters and astral characters 						flags |= EscapeC.NonAscii; 						if (c.IsInRange(0xDC80' 0xDCFF)) { 							c &= 0xFF; // detected invalid byte encoded as invalid UTF16 							flags |= EscapeC.BackslashX; 						} 					} 					PrintHelpers.EscapeCStyle(c' SB' flags' quoteType); 				} 			}
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintStringCore,The following statement contains a magic number: if (tripleQuoted) 			{ 				// Print triple-quoted 				SB.Append(quoteType); 				SB.Append(quoteType);  				char a = '\0'' b = '\0'; 				for (int i = 0; i < text.Length; i++) 				{ 					char c = text[i]' d; 					if (c == quoteType && ((b == quoteType && a == quoteType) || i + 1 == text.Length)) { 						// Escape triple quote' or a quote at end-of-string 						SB.Append('\\'); 						SB.Append(c); 						SB.Append('/'); 					} else if (c == '\0') { 						SB.Append(@"\0/"); 					} else if (c == '\r') { 						SB.Append(@"\r/"); 					} else if (c == '\\' && i + 2 < text.Length && text[i + 2] == '/' && 						((d = text[i + 1]) == 'r' || d == 'n' || d == 't' || d == '0' || d == '\\' || d == '\'' || d == '"')) { 						// avoid writing a false escape sequence 						SB.Append(@"\\/"); 					} else if (c == '\n') { 						PS.Newline(); 						PS.CommitNewlines(); 						SB.Append(PS.IndentString.EndsWith("\t") ? "\t" : "   "); 					} else if (c >= 0xDC80 && c <= 0xDCFF && !(b >= 0xD800 && b <= 0xDBFF)) { 						// invalid UTF8 byte encoded as UTF16: CANNOT print in  						// triple-quoted string! Start over as DQ string. 						SB.Length = startAt; 						quoteType = '"'; 						tripleQuoted = false; 						goto restart; 					} else { 						SB.Append(c); 					} 					a = b; b = c; 				}  				SB.Append(quoteType); 				SB.Append(quoteType); 			} 			else  			{ 				// Normal double-quoted string 				UString s = text; 				for (;;) { 					bool fail; 					int c = s.PopFirst(out fail); 					if (fail) break;  					EscapeC flags = EscapeC.Control | EscapeC.UnicodeNonCharacters | EscapeC.UnicodePrivateUse; 					// Enable \x selectively because \x represents bytes' not characters 					if (c <= 31) 						flags |= EscapeC.BackslashX; 					else if (c >= 0xD800 && (c <= 0xDFFF || c >= 0xFFF0)) { 						// force escape sequence for noncharacters and astral characters 						flags |= EscapeC.NonAscii; 						if (c.IsInRange(0xDC80' 0xDCFF)) { 							c &= 0xFF; // detected invalid byte encoded as invalid UTF16 							flags |= EscapeC.BackslashX; 						} 					} 					PrintHelpers.EscapeCStyle(c' SB' flags' quoteType); 				} 			}
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintIntegerCore,The following statement contains a magic number: if ((style & NodeStyle.BaseStyleMask) == NodeStyle.HexLiteral) { 				PrintHelpers.AppendIntegerTo(SB' value' "0x"' 16' 4' '_'); 				forceQuote |= suffix0 >= 'a' && suffix0 <= 'f' || suffix0 >= 'A' && suffix0 <= 'F'; 			} else if ((style & NodeStyle.BaseStyleMask) == NodeStyle.BinaryLiteral) 				PrintHelpers.AppendIntegerTo(SB' value' "0b"' 2' 8' '_'); 			else 				PrintHelpers.AppendIntegerTo(SB' value' ""' 10' 3' '_');
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintIntegerCore,The following statement contains a magic number: if ((style & NodeStyle.BaseStyleMask) == NodeStyle.HexLiteral) { 				PrintHelpers.AppendIntegerTo(SB' value' "0x"' 16' 4' '_'); 				forceQuote |= suffix0 >= 'a' && suffix0 <= 'f' || suffix0 >= 'A' && suffix0 <= 'F'; 			} else if ((style & NodeStyle.BaseStyleMask) == NodeStyle.BinaryLiteral) 				PrintHelpers.AppendIntegerTo(SB' value' "0b"' 2' 8' '_'); 			else 				PrintHelpers.AppendIntegerTo(SB' value' ""' 10' 3' '_');
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintIntegerCore,The following statement contains a magic number: if ((style & NodeStyle.BaseStyleMask) == NodeStyle.HexLiteral) { 				PrintHelpers.AppendIntegerTo(SB' value' "0x"' 16' 4' '_'); 				forceQuote |= suffix0 >= 'a' && suffix0 <= 'f' || suffix0 >= 'A' && suffix0 <= 'F'; 			} else if ((style & NodeStyle.BaseStyleMask) == NodeStyle.BinaryLiteral) 				PrintHelpers.AppendIntegerTo(SB' value' "0b"' 2' 8' '_'); 			else 				PrintHelpers.AppendIntegerTo(SB' value' ""' 10' 3' '_');
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintIntegerCore,The following statement contains a magic number: if ((style & NodeStyle.BaseStyleMask) == NodeStyle.HexLiteral) { 				PrintHelpers.AppendIntegerTo(SB' value' "0x"' 16' 4' '_'); 				forceQuote |= suffix0 >= 'a' && suffix0 <= 'f' || suffix0 >= 'A' && suffix0 <= 'F'; 			} else if ((style & NodeStyle.BaseStyleMask) == NodeStyle.BinaryLiteral) 				PrintHelpers.AppendIntegerTo(SB' value' "0b"' 2' 8' '_'); 			else 				PrintHelpers.AppendIntegerTo(SB' value' ""' 10' 3' '_');
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintIntegerCore,The following statement contains a magic number: if ((style & NodeStyle.BaseStyleMask) == NodeStyle.HexLiteral) { 				PrintHelpers.AppendIntegerTo(SB' value' "0x"' 16' 4' '_'); 				forceQuote |= suffix0 >= 'a' && suffix0 <= 'f' || suffix0 >= 'A' && suffix0 <= 'F'; 			} else if ((style & NodeStyle.BaseStyleMask) == NodeStyle.BinaryLiteral) 				PrintHelpers.AppendIntegerTo(SB' value' "0b"' 2' 8' '_'); 			else 				PrintHelpers.AppendIntegerTo(SB' value' ""' 10' 3' '_');
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintIntegerCore,The following statement contains a magic number: if ((style & NodeStyle.BaseStyleMask) == NodeStyle.HexLiteral) { 				PrintHelpers.AppendIntegerTo(SB' value' "0x"' 16' 4' '_'); 				forceQuote |= suffix0 >= 'a' && suffix0 <= 'f' || suffix0 >= 'A' && suffix0 <= 'F'; 			} else if ((style & NodeStyle.BaseStyleMask) == NodeStyle.BinaryLiteral) 				PrintHelpers.AppendIntegerTo(SB' value' "0b"' 2' 8' '_'); 			else 				PrintHelpers.AppendIntegerTo(SB' value' ""' 10' 3' '_');
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintDouble,The following statement contains a magic number: if (double.IsNaN(value)) { 				WriteToken(NaNPrefix' LesColorCode.KeywordLiteral' Chars.At' Chars.IdAndPunc); 			} else if (double.IsPositiveInfinity(value)) { 				WriteToken(PositiveInfinityPrefix' LesColorCode.KeywordLiteral' Chars.At' Chars.IdAndPunc); 			} else if (double.IsNegativeInfinity(value)) { 				WriteToken(NegativeInfinityPrefix' LesColorCode.KeywordLiteral' Chars.At' Chars.IdAndPunc); 			} else { 				isNumber = true; 				StartToken(LesColorCode.Number' value < 0 ? Chars.Id : Chars.NumberStart' Chars.NumberEnd); 				string asStr; 				if ((style & NodeStyle.BaseStyleMask) == NodeStyle.HexLiteral) 					asStr = DoubleToString_HexOrBinary(new StringBuilder()' value' "0x"' 4' suffix == _F).ToString(); 				else if ((style & NodeStyle.BaseStyleMask) == NodeStyle.BinaryLiteral) 					asStr = DoubleToString_HexOrBinary(new StringBuilder()' value' "0b"' 1' suffix == _F).ToString(); 				else 					asStr = DoubleToString_Decimal(value);  				if (value < 0) { 					PrintIdCore(suffix ?? _D' startToken: false); 					SB.Append('\"'); 					SB.Append(asStr); 					SB.Append('\"'); 					return; 				} else { 					SB.Append(asStr); 					if (suffix == _D) { 						if (!asStr.Contains(".") && !asStr.Contains("e")) 							SB.Append(".0"); 						return; 					} 				} 			}
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,DoubleToString_HexOrBinary,The following statement contains a magic number: int precision = isFloat ? 23 : MantissaBits;
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,DoubleToString_HexOrBinary,The following statement contains a magic number: if (_o.DigitSeparator.HasValue) 				separatorInterval = bitsPerDigit == 1 ? 8 : 4;
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,DoubleToString_HexOrBinary,The following statement contains a magic number: if (_o.DigitSeparator.HasValue) 				separatorInterval = bitsPerDigit == 1 ? 8 : 4;
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,DoubleToString_HexOrBinary,The following statement contains a magic number: if (forcePNotation || scientificNotationShift != 0) 				PrintHelpers.AppendIntegerTo(result' scientificNotationShift' "p"' @base: 10' separatorInterval: 0);
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,DoubleToString_Decimal,The following statement contains a magic number: if (_o.DigitSeparator.HasValue && asStr.Length > 3) { 				int iDot = asStr.IndexOf('.'); 				if (iDot <= -1) iDot = asStr.IndexOf('E'); 				if (iDot <= -1) iDot = asStr.Length; 				// Add thousands separators 				if (iDot > 3) { 					StringBuilder sb = new StringBuilder(asStr); 					for (int i = iDot - 3; i > 0; i -= 3) 						sb.Insert(i' '_'); 					return sb.ToString(); 				} 			}
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,DoubleToString_Decimal,The following statement contains a magic number: if (_o.DigitSeparator.HasValue && asStr.Length > 3) { 				int iDot = asStr.IndexOf('.'); 				if (iDot <= -1) iDot = asStr.IndexOf('E'); 				if (iDot <= -1) iDot = asStr.Length; 				// Add thousands separators 				if (iDot > 3) { 					StringBuilder sb = new StringBuilder(asStr); 					for (int i = iDot - 3; i > 0; i -= 3) 						sb.Insert(i' '_'); 					return sb.ToString(); 				} 			}
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,DoubleToString_Decimal,The following statement contains a magic number: if (_o.DigitSeparator.HasValue && asStr.Length > 3) { 				int iDot = asStr.IndexOf('.'); 				if (iDot <= -1) iDot = asStr.IndexOf('E'); 				if (iDot <= -1) iDot = asStr.Length; 				// Add thousands separators 				if (iDot > 3) { 					StringBuilder sb = new StringBuilder(asStr); 					for (int i = iDot - 3; i > 0; i -= 3) 						sb.Insert(i' '_'); 					return sb.ToString(); 				} 			}
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,DoubleToString_Decimal,The following statement contains a magic number: if (_o.DigitSeparator.HasValue && asStr.Length > 3) { 				int iDot = asStr.IndexOf('.'); 				if (iDot <= -1) iDot = asStr.IndexOf('E'); 				if (iDot <= -1) iDot = asStr.Length; 				// Add thousands separators 				if (iDot > 3) { 					StringBuilder sb = new StringBuilder(asStr); 					for (int i = iDot - 3; i > 0; i -= 3) 						sb.Insert(i' '_'); 					return sb.ToString(); 				} 			}
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,VisitCall,The following statement contains a magic number: switch (_o.PrefixNotationOnly ? NodeStyle.PrefixNotation : node.BaseStyle()) 			{ 				case NodeStyle.Operator: 				case NodeStyle.Statement: 				case NodeStyle.Default: 					// Figure out if this node can be treated as an operator and if  					// so' whether it's a suffix operator. 					if (!HasTargetIdWithoutPAttrs(node)) 						goto default;  					Symbol opName = node.Name; 					if (!TryToPrintCallAsSpecialOperator(opName' node)) 					{ 						if (!node.ArgCount().IsInRange(1' 2)) 							goto default; 						var shape = (OperatorShape)node.ArgCount(); 						if (node.ArgCount() == 1 && Les3PrecedenceMap.IsSuffixOperatorName(opName' out opName)) 							shape = OperatorShape.Suffix;  						if (!PrintCallAsNormalOp(shape' opName' node' ref parens)) 							PrintPrefixNotation(node' ref parens); 					} 					break; 				case NodeStyle.Special: 					if (!TryToPrintCallAsKeywordExpression(node)) 						goto default; 					break; 				case NodeStyle.PrefixNotation: 					PrintPrefixNotation(node' ref parens); 					break; 				default: 					PrintPrefixNotation(node' ref parens); 					break; 			}
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,IsContinuator,The following statement contains a magic number: if ((argc == 1 || argc == 2) && ContinuatorOps.Contains(candidate.Name) && HasTargetIdWithoutPAttrs(candidate)) { 				if (argc == 2) 					return candidate[1].Calls(S.Braces) && HasTargetIdWithoutPAttrs(candidate[1]); 				return true; 			}
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,IsContinuator,The following statement contains a magic number: if ((argc == 1 || argc == 2) && ContinuatorOps.Contains(candidate.Name) && HasTargetIdWithoutPAttrs(candidate)) { 				if (argc == 2) 					return candidate[1].Calls(S.Braces) && HasTargetIdWithoutPAttrs(candidate[1]); 				return true; 			}
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,CanBePrefixOperator,The following statement contains a magic number: int i = name[1] == '$' ? 2 : 1;
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintCallAsNormalOp,The following statement contains a magic number: switch (shape) { 				case OperatorShape.Prefix: 					Debug.Assert(node.ArgCount() == 1); 					var inner = node[0]; 					PrintOpName(opName' node.Target' isBinaryOp: false); 					Space(prec.Lo < _o.SpaceAfterPrefixStopPrecedence); 					Print(inner' prec.RightContext(_context)); 					break; 				case OperatorShape.Suffix: 					Debug.Assert(node.ArgCount() == 1); 					Print(node[0]' prec.LeftContext(_context)); 					PrintOpName(opName' node.Target' isBinaryOp: false); 					break; 				default: 					Debug.Assert(node.ArgCount() == 2); 					Print(node[0]' prec.LeftContext(_context)); 					Space(prec.Lo < _o.SpaceAroundInfixStopPrecedence); 					bool newlineSafe = PrintOpName(opName' node.Target' isBinaryOp: true); 					if (SB.Last() != '\n') 						Space(prec.Lo < _o.SpaceAroundInfixStopPrecedence); 					var nlContext = NewlineContext.AutoDetect; 					if (newlineSafe) 						nlContext |= NewlineContext.NewlineSafeBefore; 					Print(node[1]' prec.RightContext(_context)' nlContext: nlContext); 					break; 			}
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,TryToPrintCallAsSpecialOperator,The following statement contains a magic number: if (opName == CodeSymbols.Braces) { // {...} 				PrintBracedBlock(node); 			} else if (opName == CodeSymbols.Array) { // [...] 				PrintArgListCore(node.Args()' '['' ']''  					ArgListStyle.Normal' _o.SpaceInsideListBrackets' leftBracket: node.Target); 			} else if (opName == CodeSymbols.Tuple) { // (;;) 				PrintArgListCore(node.Args()' '('' ')''  					ArgListStyle.Semicolons' _o.SpaceInsideTuples' leftBracket: node.Target); 			} else if (opName == CodeSymbols.IndexBracks && node.ArgCount() > 0) { // foo[...] 				Print(node[0]' LesPrecedence.Primary.LeftContext(_context)); 				PrintArgListCore(node.Args().Slice(1)' '['' ']'' (node.Style & NodeStyle.Alternate) != 0 					? ArgListStyle.Semicolons : ArgListStyle.Normal' _o.SpaceInsideArgLists' leftBracket: node.Target); 			} else if (opName == CodeSymbols.Of) { 				var args = node.Args(); 				Print(args[0]' LesPrecedence.Of.LeftContext(_context)); 				PrintOpName(S.Not' node.Target' true); 				if (args.Count == 2 && args[1].IsId() && args[1].AttrCount() == 0) 					VisitId(args[1]); 				else 					PrintArgListCore(args.Slice(1)' '('' ')'' ArgListStyle.Normal' _o.SpaceInsideArgLists); 			} else 				return false;
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintContinuator,The following statement contains a magic number: if (argc >= 2) { 				Space(); 				PrintBracedBlock(continuator[1]); 			}
Magic Number,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,IsKeywordExpression,The following statement contains a magic number: int i = block.Calls(S.Braces) ? 2 : 1;
Magic Number,Loyc.Syntax.Les,Les3PrinterOptions,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,Les3PrinterOptions,The following statement contains a magic number: ForcedLineBreakThreshold = 120;
Magic Number,Loyc.Syntax.Les,Les2LanguageService,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LanguageService.cs,Parse,The following statement contains a magic number: if (inputType == ParsingMode.Expressions || file.Text.TryGet(255' ref _)) { 				Les2Parser parser = _parser; 				if (parser == null) 					_parser = parser = new Les2Parser(input' file' msgs); 				else { 					parser.ErrorSink = msgs; 					parser.Reset(input.AsList()' file); 				} 				if (inputType == ParsingMode.Expressions) 					return parser.ExprList(); 				else 					return parser.Start(new Holder<TokenType>(TokenType.Semicolon)).Buffered(); 			} else { 				var parser = new Les2Parser(input' file' msgs); 				return parser.Start(new Holder<TokenType>(TokenType.Semicolon)).Buffered(); 			}
Magic Number,Loyc.Syntax.Les,Les2Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2Printer.cs,Print,The following statement contains a magic number: try { 				int parenCount = WriteAttrs(node' ref context);  				if (!node.IsCall() || node.BaseStyle() == NodeStyle.PrefixNotation) 					PrintPrefixNotation(node' context); 				else do { 					if (AutoPrintBracesOrBracks(node)) 						break; 					if (!LesPrecedence.Primary.CanAppearIn(context)) { 						_out.Write("(@[] "' true); 						parenCount++; 						context = StartStmt; 					} 					int args = node.ArgCount(); 					if (args == 1 && AutoPrintPrefixOrSuffixOp(node' context)) 						break; 					if (args == 2 && AutoPrintInfixOp(node' context)) 						break; 					PrintPrefixNotation(node' context); 				} while (false); 			 				PrintSuffixTrivia(node' parenCount' terminator); 			} finally { 				_isOneLiner = old_isOneLiner; 			}
Magic Number,Loyc.Syntax.Les,Les2PrecedenceMap,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\LesPrecedenceMap.cs,GetOpChars,The following statement contains a magic number: var map = new BitArray(128);
Magic Number,Loyc.Syntax.Les,Les2PrecedenceMap,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\LesPrecedenceMap.cs,IsOperator,The following statement contains a magic number: if (i >= name.Length || name.Length > 255) 				return false;
Magic Number,Loyc.Syntax.Les,Les2PrecedenceMap,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\LesPrecedenceMap.cs,IsSuffixOperatorName,The following statement contains a magic number: if (name.Name.EndsWith("suf")) { 				bareName = (Symbol)name.Name.Substring(0' name.Name.Length - 3); 				return IsNaturalOperator(bareName.Name); 			} else { 				bareName = name; 				return false; 			}
Magic Number,Loyc.Syntax.Lexing,BaseILexer<CharSrc;Token>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseILexer.cs,ScanIndent,The following statement contains a magic number: if (SupportDotIndents() && LA0 == '.') { 				for (;;) { 					if (LA(li) == '.') { 						var la1 = LA(li + 1); 						if (la1 == '\t' || la1 == ' ') { 							li += 2; 							indentLevel += SpacesPerTab; 							for (; LA(li) == ' '; li++) {} 						} else 							break; 					} else 						break; 				} 			}
Magic Number,Loyc.Syntax.Lexing,IndentTokenGenerator<Token>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\IndentTokenGenerator.cs,IndentChangedUnexpectedly,The following statement contains a magic number: if (deltaIndent > 0) { 				if (_errorBias >= 0) 					ErrorSink.Error(pos' "Unexpected indent"); 				_errorBias++; 			} else { 				if (_errorBias <= 0) { 					var sev = Severity.Error; 					if (_outerIndents.Count >= 2 && _outerIndents.Last == _outerIndents[_outerIndents.Count - 2]) 						sev = Severity.Warning; 					ErrorSink.Write(sev' pos' "Unindent does not match any outer indentation level"); 				} 				_errorBias--; 			}
Magic Number,Loyc.Syntax.Lexing,IndentTokenGenerator<Token>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\IndentTokenGenerator.cs,IndentChangedUnexpectedly,The following statement contains a magic number: if (deltaIndent > 0) { 				if (_errorBias >= 0) 					ErrorSink.Error(pos' "Unexpected indent"); 				_errorBias++; 			} else { 				if (_errorBias <= 0) { 					var sev = Severity.Error; 					if (_outerIndents.Count >= 2 && _outerIndents.Last == _outerIndents[_outerIndents.Count - 2]) 						sev = Severity.Warning; 					ErrorSink.Write(sev' pos' "Unindent does not match any outer indentation level"); 				} 				_errorBias--; 			}
Magic Number,Loyc.Syntax.Lexing,IndentTokenGenerator<Token>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\IndentTokenGenerator.cs,HandleNextToken,The following statement contains a magic number: if (_curIndent > -1) 			{ 				// Check for unexpected indent 				bool emitEol = true; 				if (nextIndent > _curIndent && _outerIndents.Last != _curIndent) 				{ 					int delta = nextIndent - _curIndent; 					emitEol = IndentChangedUnexpectedly(_lastNonWS' ref next' ref delta); 					AutoNext(ref next' ref nextCat' atEof); 					nextIndent = _curIndent + delta; 				}  				if (newline && !indentTriggered && emitEol) 				{ 					int? delta = nextIndent - _curIndent; 					if (nextIndent <= _outerIndents.Last) 						delta = null; 					var insert = MakeEndOfLineToken(_lastNonWS' ref next' delta); 					AutoNext(ref next' ref nextCat' atEof); 					if (insert.HasValue) 						_pending.PushLast(insert.Value); 				}  				if (newline) { 					// Add dedents 					int outerIndent = _outerIndents.Last; 					for (int oi = outerIndent; nextIndent <= oi; oi = _outerIndents.Last) 					{ 						// Unindent detected 						outerIndent = oi; 						_outerIndents.Pop(); 						AddPendingLast(MakeDedentToken(_lastNonWS' ref next)); 						AutoNext(ref next' ref nextCat' atEof); 						if (!next.HasValue && !atEof) return; // advance to next token 					}  					// Detect partial dedent 					if (nextIndent < _curIndent && nextIndent > outerIndent) 					{ 						int delta = nextIndent - _curIndent; 						bool _ = IndentChangedUnexpectedly(_lastNonWS' ref next' ref delta); 						AutoNext(ref next' ref nextCat' atEof); 						nextIndent = _curIndent + delta;  						if (_outerIndents.Count >= 2 && _outerIndents.Last == _outerIndents[_outerIndents.Count - 2]) 						{ 							// The situation is like this: 							// if c1: if c2: 							//         c1_and_c2(); 							//     c1_only(); 							// It's usually illegal' but it has a reasonable interpretation. 							// (Note: in Python you can't even write "if c1: if c2:") 							_outerIndents.Pop(); 							AddPendingLast(MakeDedentToken(_lastNonWS' ref next)); 							AutoNext(ref next' ref nextCat' atEof); 						} 					} 				} 			}
Magic Number,Loyc.Syntax.Lexing,IndentTokenGenerator<Token>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\IndentTokenGenerator.cs,HandleNextToken,The following statement contains a magic number: if (_curIndent > -1) 			{ 				// Check for unexpected indent 				bool emitEol = true; 				if (nextIndent > _curIndent && _outerIndents.Last != _curIndent) 				{ 					int delta = nextIndent - _curIndent; 					emitEol = IndentChangedUnexpectedly(_lastNonWS' ref next' ref delta); 					AutoNext(ref next' ref nextCat' atEof); 					nextIndent = _curIndent + delta; 				}  				if (newline && !indentTriggered && emitEol) 				{ 					int? delta = nextIndent - _curIndent; 					if (nextIndent <= _outerIndents.Last) 						delta = null; 					var insert = MakeEndOfLineToken(_lastNonWS' ref next' delta); 					AutoNext(ref next' ref nextCat' atEof); 					if (insert.HasValue) 						_pending.PushLast(insert.Value); 				}  				if (newline) { 					// Add dedents 					int outerIndent = _outerIndents.Last; 					for (int oi = outerIndent; nextIndent <= oi; oi = _outerIndents.Last) 					{ 						// Unindent detected 						outerIndent = oi; 						_outerIndents.Pop(); 						AddPendingLast(MakeDedentToken(_lastNonWS' ref next)); 						AutoNext(ref next' ref nextCat' atEof); 						if (!next.HasValue && !atEof) return; // advance to next token 					}  					// Detect partial dedent 					if (nextIndent < _curIndent && nextIndent > outerIndent) 					{ 						int delta = nextIndent - _curIndent; 						bool _ = IndentChangedUnexpectedly(_lastNonWS' ref next' ref delta); 						AutoNext(ref next' ref nextCat' atEof); 						nextIndent = _curIndent + delta;  						if (_outerIndents.Count >= 2 && _outerIndents.Last == _outerIndents[_outerIndents.Count - 2]) 						{ 							// The situation is like this: 							// if c1: if c2: 							//         c1_and_c2(); 							//     c1_only(); 							// It's usually illegal' but it has a reasonable interpretation. 							// (Note: in Python you can't even write "if c1: if c2:") 							_outerIndents.Pop(); 							AddPendingLast(MakeDedentToken(_lastNonWS' ref next)); 							AutoNext(ref next' ref nextCat' atEof); 						} 					} 				} 			}
Magic Number,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,NewSetOfRanges,The following statement contains a magic number: for (int r = 0; r < ranges.Length; r += 2) 				for (int i = ranges[r]; i <= ranges[r+1]; i++) 					set.Add(i);
Magic Number,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,MatchError,The following statement contains a magic number: if (InputPosition == _lastErrorPosition) 				InputPosition++; // avoid entering an infinite loop writing errors at same place 			else { 				string rangesDescr = RangesToString(ranges); 				var input = new StringBuilder(); 				PrintChar(LA0' input); 				if (inverted) 					Error(0' "{0}: expected a character other than {1}"' input' rangesDescr); 				else if (ranges.Count > 2) 					Error(0' "{0}: expected one of {1}"' input' rangesDescr); 				else 					Error(0' "{0}: expected {1}"' input' rangesDescr); 			}
Magic Number,Loyc.Syntax.Lexing,BaseLexer<CharSrc>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\BaseLexer.cs,RangesToString,The following statement contains a magic number: for (int i = 0; i < ranges.Count; i += 2) 			{ 				if (i != 0) 					sb.Append(' '); 				int lo = ranges[i]' hi = ranges[i + 1]; 				PrintChar(lo' sb); 				if (hi > lo) 				{ 					sb.Append(hi > lo + 1 ? ".." : " "); 					PrintChar(hi' sb); 				} 			}
Magic Number,Loyc.Syntax.Lexing,Token,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Lexing\Token.cs,KindAttrTable,The following statement contains a magic number: Debug.Assert(((int)TokenKind.KindMask & ((2 << TokenKindShift) - 1)) == (1 << TokenKindShift));
Magic Number,LeMP,MacroContext,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LeMP\IMacroContext.cs,GetOptions,The following statement contains a magic number: foreach (var option in optionList) { 				if ((option.Calls(CodeSymbols.NamedArg' 2) || option.Calls(CodeSymbols.Colon' 2)) && option.Args[0].IsId) 				{ 					LNode key = option.Args[0]; 					LNode value = option.Args.Last; 					yield return new KeyValuePair<LNode' LNode>(key' value); 				} 				else if (option.Args.Count == 1 && option.Target.IsId) 					yield return new KeyValuePair<LNode' LNode>(option.Target' option.Args[0]); 				else 					yield return new KeyValuePair<LNode' LNode>(option' null); 			}
Magic Number,LeMP,MacroContext,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LeMP\IMacroContext.cs,GetOptions,The following statement contains a magic number: foreach (var option in optionList) { 				if ((option.Calls(CodeSymbols.NamedArg' 2) || option.Calls(CodeSymbols.Colon' 2)) && option.Args[0].IsId) 				{ 					LNode key = option.Args[0]; 					LNode value = option.Args.Last; 					yield return new KeyValuePair<LNode' LNode>(key' value); 				} 				else if (option.Args.Count == 1 && option.Target.IsId) 					yield return new KeyValuePair<LNode' LNode>(option.Target' option.Args[0]); 				else 					yield return new KeyValuePair<LNode' LNode>(option' null); 			}
Magic Number,Loyc.Syntax,BaseParser<Token;MatchType>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\BaseParser.cs,LaIndexToCharIndex,The following statement contains a magic number: if (token.Type.Equals(EOF)) { 				if (SourceFile != null) 					charIdx = System.Math.Max(SourceFile.Text.Count' charIdx); 				else  					for (int li = lookaheadIndex; li > lookaheadIndex-100;  li--) { 						var token2 = LT(li) as ISimpleToken<MatchType>; 						if (!token2.Type.Equals(EOF)) { 							charIdx = System.Math.Max(charIdx' token2.StartIndex); 							break; 						} 					} 			}
Magic Number,Loyc.Syntax,BaseParser<Token;MatchType>,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\BaseParser.cs,ToString,The following statement contains a magic number: int plural = expected.Take(2).Count();
Magic Number,Loyc.Syntax,CodeSymbols,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\CodeSymbols.cs,CountArrayDimensions,The following statement contains a magic number: if (s.Name.Length >= 3 && s.Name.StartsWith("'[") && s.Name[s.Name.Length-1] == ']') { 				for (int i = 2; i < s.Name.Length-1; i++) 					if (s.Name[i] != ''') 						return 0; 				return s.Name.Length-2; 			}
Magic Number,Loyc.Syntax,CodeSymbols,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\CodeSymbols.cs,CountArrayDimensions,The following statement contains a magic number: if (s.Name.Length >= 3 && s.Name.StartsWith("'[") && s.Name[s.Name.Length-1] == ']') { 				for (int i = 2; i < s.Name.Length-1; i++) 					if (s.Name[i] != ''') 						return 0; 				return s.Name.Length-2; 			}
Magic Number,Loyc.Syntax,CodeSymbols,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\CodeSymbols.cs,CountArrayDimensions,The following statement contains a magic number: if (s.Name.Length >= 3 && s.Name.StartsWith("'[") && s.Name[s.Name.Length-1] == ']') { 				for (int i = 2; i < s.Name.Length-1; i++) 					if (s.Name[i] != ''') 						return 0; 				return s.Name.Length-2; 			}
Magic Number,Loyc.Syntax,CodeSymbols,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\CodeSymbols.cs,GetArrayKeyword,The following statement contains a magic number: if (dims == 2) return TwoDimensionalArray;
Magic Number,Loyc.Syntax,CallNode,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\AbstractNodes.cs,GetHashCode,The following statement contains a magic number: int hash = (args.Count << 3) + attrs.Count;
Magic Number,Loyc.Syntax,CallNode,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\AbstractNodes.cs,GetHashCode,The following statement contains a magic number: if (recurse > 0) { 				var target = Target; 				if (target != null) 					hash ^= target.GetHashCode(recurse - 1' styleMask); 				for (int i = 0' c = System.Math.Min(attrs.Count' recurse << 2); i < c; i++) 					hash = (hash * 4129) + attrs[i].GetHashCode(recurse - 1' styleMask); 				for (int i = 0' c = System.Math.Min(args.Count' recurse << 2); i < c; i++) 					hash = (hash * 1013) + args[i].GetHashCode(recurse - 1' styleMask); 			}
Magic Number,Loyc.Syntax,CallNode,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\AbstractNodes.cs,GetHashCode,The following statement contains a magic number: if (recurse > 0) { 				var target = Target; 				if (target != null) 					hash ^= target.GetHashCode(recurse - 1' styleMask); 				for (int i = 0' c = System.Math.Min(attrs.Count' recurse << 2); i < c; i++) 					hash = (hash * 4129) + attrs[i].GetHashCode(recurse - 1' styleMask); 				for (int i = 0' c = System.Math.Min(args.Count' recurse << 2); i < c; i++) 					hash = (hash * 1013) + args[i].GetHashCode(recurse - 1' styleMask); 			}
Magic Number,Loyc.Syntax,CallNode,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\AbstractNodes.cs,GetHashCode,The following statement contains a magic number: if (recurse > 0) { 				var target = Target; 				if (target != null) 					hash ^= target.GetHashCode(recurse - 1' styleMask); 				for (int i = 0' c = System.Math.Min(attrs.Count' recurse << 2); i < c; i++) 					hash = (hash * 4129) + attrs[i].GetHashCode(recurse - 1' styleMask); 				for (int i = 0' c = System.Math.Min(args.Count' recurse << 2); i < c; i++) 					hash = (hash * 1013) + args[i].GetHashCode(recurse - 1' styleMask); 			}
Magic Number,Loyc.Syntax,CallNode,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\AbstractNodes.cs,GetHashCode,The following statement contains a magic number: if (recurse > 0) { 				var target = Target; 				if (target != null) 					hash ^= target.GetHashCode(recurse - 1' styleMask); 				for (int i = 0' c = System.Math.Min(attrs.Count' recurse << 2); i < c; i++) 					hash = (hash * 4129) + attrs[i].GetHashCode(recurse - 1' styleMask); 				for (int i = 0' c = System.Math.Min(args.Count' recurse << 2); i < c; i++) 					hash = (hash * 1013) + args[i].GetHashCode(recurse - 1' styleMask); 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,MoveNext,The following statement contains a magic number: switch(_step) { 			case 0: // the node itself 				_step = 1; 				if ((_mode & NodeScanMode.YieldSelf) != 0) { 					current = _node; 					return 1; 				} 				goto case 1; 			case 1: // consider whether to return attributes 				if ((_mode & (NodeScanMode.ScanAttrs | NodeScanMode.YieldLocalAttrs)) == 0 || _node.AttrCount == 0) 					goto case 3; // skip attrs 				_children = _node.Attrs; 				Debug.Assert(_index == 0); 				_step = 2; 				goto case 2; 			case 2: // return attributes 				Debug.Assert(_step == 2); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalAttrs); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				goto case 3; 			case 3: // consider whether to return head 				if (_node.Target == null || (_mode & (NodeScanMode.ScanHeads | NodeScanMode.YieldLocalHead)) == 0) 					goto case 5; // skip attrs 				goto case 4; 			case 4: // return head 				subMode = SubMode(NodeScanMode.YieldLocalHead); 				frame = new DescendantsFrame(_node.Target' subMode); 				_step = 5; 				return -1; 			case 5: // consider whether to return args 				if ((_mode & (NodeScanMode.ScanArgsOnly | NodeScanMode.YieldLocalArgsOnly)) == 0 || _node.ArgCount == 0) { 					_step = -1; 					goto default; // skip args 				} 				_children = _node.Args; 				_index = 0; 				_step = 6; 				goto case 6; 			case 6: // return args 				Debug.Assert(_step == 6); 				if (_index < _children.Count) { 					subMode = SubMode(NodeScanMode.YieldLocalArgsOnly); 					frame = new DescendantsFrame(_children[_index]' subMode); 					_index++; 					return -1; 				} 				_step = -1; 				goto default; 			default: 				Debug.Assert(_step == -1); 				return 0; 			}
Magic Number,Loyc.Syntax,DescendantsFrame,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\DescendantsFrame.cs,SubMode,The following statement contains a magic number: var subMode = (_mode & ~(NodeScanMode.YieldLocal | NodeScanMode.YieldSelf)) 						| (NodeScanMode)((int)(_mode & NodeScanMode.YieldDeep) >> 3);
Magic Number,Loyc.Syntax,LNode,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNode.cs,GetHashCode,The following statement contains a magic number: return GetHashCode(3' 0);
Magic Number,Loyc.Syntax,LNodeFactory,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\LNodeFactory.cs,Dot,The following statement contains a magic number: for (int i = 2; i < parts.Length; i++) 				expr = Call(S.Dot' expr' parts[i]' start' parts[i].Range.EndIndex);
Magic Number,Loyc.Syntax,StdSimpleCallNode,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LNodes\StdNodes.cs,DetectTargetRange,The following statement contains a magic number: if (RAS.Length > 0) { 				int c = _args.Count; 				SourceRange r0' r1; 				_targetOffs = 0; 				if (c == 0) { 					// assume this node is a simple call: MethodName() 					_targetLen = (ushort)System.Math.Max(0' Range.Length - 2); 				} else if ((r0 = _args[0].Range).Source == RAS.Source && r0.StartIndex >= RAS.StartIndex) { 					int endIndex = RAS.EndIndex; 					if (RAS.StartIndex < r0.StartIndex || c > 1 && r0.EndIndex >= (r1 = _args[1].Range).StartIndex) { 						// assume this is a normal call' Target is at beginning 						_targetLen = ClipUShort(r0.StartIndex - RAS.StartIndex); 					} else { 						// assume this is an operator' e.g. for x + y' use _targetOffs=1' _targetLen=3 						_targetOffs = ClipUShort(r0.EndIndex); 						int endTarget = endIndex; 						if (c > 1 && (r1 = _args[1].Range).StartIndex > r0.EndIndex) 							endTarget = r1.StartIndex; 						_targetLen = ClipUShort(endTarget - r0.EndIndex); 					} 				} else 					_targetLen = 0; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseHex,The following statement contains a magic number: for(;; len++' s = s.Slice(1)) 			{ 				int digit = HexDigitValue(s[0' '\0']); 				if (digit == -1) 					return len; 				else 					value = (value << 4) + digit; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,HexDigitValue,The following statement contains a magic number: if (c >= 'A' && c <= 'F') 				return c - 'A' + 10;
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,HexDigitValue,The following statement contains a magic number: if (c >= 'a' && c <= 'f') 				return c - 'a' + 10; 			else 				return -1;
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,Base36DigitValue,The following statement contains a magic number: if (c >= 'A' && c <= 'Z') 				return c - 'A' + 10;
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,Base36DigitValue,The following statement contains a magic number: if (c >= 'a' && c <= 'z') 				return c - 'a' + 10; 			else 				return -1;
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following statement contains a magic number: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloatParts,The following statement contains a magic number: if (c == 'p' || c == 'P') 			{ 				source = source.Slice(1); 				success = TryParseInt(ref source' out exponentBase2' 10' flags) && success; 				c = source[0' '\0']; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloatParts,The following statement contains a magic number: if (c == 'e' || c == 'E') 			{ 				source = source.Slice(1); 				success = TryParseInt(ref source' out exponentBase10' 10' flags) && success; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloatParts,The following statement contains a magic number: if (radix != 10) { 				radixShift = G.Log2Floor(radix); 				if (radix > 32 || radix != 1 << radixShift) 					throw new ArgumentOutOfRangeException("radix"); 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloatParts,The following statement contains a magic number: if (radix != 10) { 				radixShift = G.Log2Floor(radix); 				if (radix > 32 || radix != 1 << radixShift) 					throw new ArgumentOutOfRangeException("radix"); 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloatParts,The following statement contains a magic number: try { 				checked { 					if (radix == 10) 						exponentBase10 += exponentBaseR; 					else 						exponentBase2 += exponentBaseR * radixShift; 				} 			} catch (OverflowException) { 				return false; 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseDouble,The following statement contains a magic number: if (!TryParseFloatParts(ref source' radix' out negative' out mantissa' out exponentBase2' out exponentBase10' out numDigits' flags)) 				return double.NaN; 			else { 				double num = G.ShiftLeft((double)mantissa' exponentBase2); 				if (negative) 					num = -num; 				if (exponentBase10 == 0) 					return num; 				return num * System.Math.Pow(10' exponentBase10); 			}
Magic Number,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,TryParseFloat,The following statement contains a magic number: if (!TryParseFloatParts(ref source' radix' out negative' out mantissa' out exponentBase2' out exponentBase10' out numDigits' flags)) 				return float.NaN; 			else { 				float num = (float)G.ShiftLeft(mantissa' exponentBase2); 				if (negative) 					num = -num; 				if (exponentBase10 == 0) 					return num; 				return num * (float)System.Math.Pow(10' exponentBase10); 			}
Magic Number,Loyc.Syntax,Precedence,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\Precedence.cs,GetHashCode,The following statement contains a magic number: return Lo ^ (Hi << 4);
Magic Number,Loyc.Syntax,LineAndCol,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\SourceFiles\SourcePos.cs,GetHashCode,The following statement contains a magic number: return (_line << 4) ^ _posInLine;
Magic Number,Loyc.Syntax,SourceRange,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\SourceFiles\SourceRange.cs,GetHashCode,The following statement contains a magic number: return hc ^ _startIndex ^ (_length << 4);
Magic Number,Loyc.Syntax,StreamCharSource,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\SourceFiles\StreamCharSource.cs,Slice,The following statement contains a magic number: StringBuilder sb = new StringBuilder(Math.Min(length' 1024));
Missing Default,Loyc.Syntax.Les,Les2Lexer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2LexerGrammar.out.cs,Number,The following switch statement is missing a default case: switch (LA0) { 			case 'F': case 'f': 				{ 					Skip(); 					// line 72 					_typeSuffix = _F; 					_isFloat = true; 				} 				break; 			case 'D': case 'd': 				{ 					Skip(); 					// line 73 					_typeSuffix = _D; 					_isFloat = true; 				} 				break; 			case 'M': case 'm': 				{ 					Skip(); 					// line 74 					_typeSuffix = _M; 					_isFloat = true; 				} 				break; 			case 'Z': case 'z': 				{ 					Skip(); 					// line 75 					_typeSuffix = _Z; 				} 				break; 			case 'L': case 'l': 				{ 					Skip(); 					// line 77 					_typeSuffix = _L; 					// Line 77: ([Uu])? 					la0 = LA0; 					if (la0 == 'U' || la0 == 'u') { 						Skip(); 						// line 77 						_typeSuffix = _UL; 					} 				} 				break; 			case 'U': case 'u': 				{ 					Skip(); 					// line 78 					_typeSuffix = _U; 					// Line 78: ([Ll])? 					la0 = LA0; 					if (la0 == 'L' || la0 == 'l') { 						Skip(); 						// line 78 						_typeSuffix = _UL; 					} 				} 				break; 			}
Missing Default,Loyc.Syntax.Les,Les2Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les2ParserGrammar.out.cs,ToString,The following switch statement is missing a default case: switch ((TokenType)type) { 				case TT.SpaceLParen: return "' ('"; 				case TT.LParen: return "'('"; 				case TT.RParen: return "')'"; 				case TT.LBrack: return "'['"; 				case TT.RBrack: return "']'"; 				case TT.LBrace: return "'{'"; 				case TT.RBrace: return "'}'"; 				case TT.Comma:  return "'''"; 				case TT.Semicolon: return "';'"; 			}
Missing Default,Loyc.Syntax.Les,Les3Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,ExprList,The following switch statement is missing a default case: switch ((TT) LA0) { 			case TT.Assignment: case TT.At: case TT.BQId: case TT.BQOperator: 			case TT.Id: case TT.Keyword: case TT.LBrace: case TT.LBrack: 			case TT.Literal: case TT.LParen: case TT.NormalOp: case TT.Not: 			case TT.PrefixOp: case TT.PreOrSufOp: case TT.SingleQuoteOp: 				e = TopExpr(); 				break; 			}
Missing Default,Loyc.Syntax.Les,Les3Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,ExprListLazy,The following switch statement is missing a default case: switch ((TT) LA0) { 			case TT.Assignment: case TT.At: case TT.BQId: case TT.BQOperator: 			case TT.Id: case TT.Keyword: case TT.LBrace: case TT.LBrack: 			case TT.Literal: case TT.LParen: case TT.NormalOp: case TT.Not: 			case TT.PrefixOp: case TT.PreOrSufOp: case TT.SingleQuoteOp: 				e = TopExpr(); 				break; 			}
Missing Default,Loyc.Syntax.Les,Les3Parser,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Parser.out.cs,ToString,The following switch statement is missing a default case: switch ((TokenType)type) { 				case TokenType.LParen: return "'('"; 				case TokenType.RParen: return "')'"; 				case TokenType.LBrack: return "'['"; 				case TokenType.RBrack: return "']'"; 				case TokenType.LBrace: return "'{'"; 				case TokenType.RBrace: return "'}'"; 				case TokenType.Comma:  return "'''"; 				case TokenType.Semicolon: return "';'"; 			}
Missing Default,Loyc.Syntax.Les,Les3Printer,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\LES\Les3Printer.cs,PrintCore,The following switch statement is missing a default case: switch (node.Kind) 			{ 				case LNodeKind.Id: VisitId(node); break; 				case LNodeKind.Literal: VisitLiteral(node); break; 				case LNodeKind.Call: 					VisitCall(node); 					if (_endIndexOfKeywordExpr == SB.Length && avoidKwExprBraceAmbiguity) {  					} 					break; 			}
Missing Default,Loyc.Syntax,ParseHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Syntax\Parsing\ParseHelpers.cs,UnescapeChar,The following switch statement is missing a default case: switch (s.PopFirst(out fail)) { 				case 'u': 					slice = s.Left(6); 					if (TryParseHex(ref slice' out code) >= 4) { 						if (code <= 0x10FFFF) { 							s = s.Substring(slice.InternalStart - s.InternalStart); 						} else { 							Debug.Assert(slice.Length == 0); 							// It appears to be 6 digits but only the first 5 can  							// be treated as part of the escape sequence. 							s = s.Substring(5); 							code >>= 4; 							encountered |= EscapeC.HasInvalid6DigitEscape; 						} 						if (slice.InternalStart > s.InternalStart + 4) 							encountered |= EscapeC.HasLongEscape; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						return code; 					} else 						break; 				case 'x': 					slice = s.Left(2); 					if (TryParseHex(slice' out code)) { 						encountered |= EscapeC.BackslashX; 						if (code < 32) 							encountered |= EscapeC.Control; 						else if (code > 127) 							encountered |= EscapeC.NonAscii; 						s = s.Substring(2); 						return code; 					} else 						break; 				case '\\': 					return '\\'; 				case 'n': 					return '\n'; 				case 'r': 					return '\r'; 				case '0': 					return '\0'; 				case '\"': 					encountered |= EscapeC.DoubleQuotes; 					return '\"'; 				case '\'': 					encountered |= EscapeC.SingleQuotes; 					return '\''; 				case '`': 					encountered |= EscapeC.Quotes; 					return '`'; 				case 't': 					encountered |= EscapeC.Control; 					return '\t'; 				case 'a': 					encountered |= EscapeC.ABFV; 					return '\a'; 				case 'b': 					encountered |= EscapeC.ABFV; 					return '\b'; 				case 'f': 					encountered |= EscapeC.ABFV; 					return '\f'; 				case 'v': 					encountered |= EscapeC.ABFV; 					return '\v'; 			}
