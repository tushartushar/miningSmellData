Implementation smell,Namespace,Class,File,Method,Description
Long Method,Loyc.Collections,VListBlock<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlock.cs,EnsureMutable,The method has 124 lines of code.
Long Method,Loyc.Collections,VListBlock<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlock.cs,Transform,The method has 168 lines of code.
Long Method,Loyc.Collections.Impl,BListLeaf<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListLeaf.cs,DoSingleOperation,The method has 114 lines of code.
Long Method,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The method has 114 lines of code.
Complex Method,Loyc.Collections,Enumerator,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListBase.cs,MoveNext,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Collections,Enumerator,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListBase.cs,MovePrevious,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Collections,VListBlock<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlock.cs,EnsureMutable,Cyclomatic complexity of the method is 11
Complex Method,Loyc.Collections,VListBlock<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlock.cs,SelectMany,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Collections,VListBlock<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlock.cs,SmartSelect,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Collections,VListBlock<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlock.cs,Transform,Cyclomatic complexity of the method is 14
Complex Method,Loyc.Collections.Impl,AListIndexer<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListIndexer.cs,VerifyCorrectness,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Collections.Impl,BListLeaf<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListLeaf.cs,DoSingleOperation,Cyclomatic complexity of the method is 11
Complex Method,Loyc.Collections.Impl,SparseAListLeaf<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\SparseAListLeaf.cs,DoInsert,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,Cyclomatic complexity of the method is 11
Complex Method,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,Cyclomatic complexity of the method is 8
Long Parameter List,Loyc.Collections,AListNode<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListNode.cs,InsertRange,The method has 5 parameters. Parameters: index' source' sourceIndex' splitRight' tob
Long Parameter List,Loyc.Collections,AListSparseOperation,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListNode.cs,AListSparseOperation,The method has 5 parameters. Parameters: index' isInsert' writeEmpty' count' tob
Long Parameter List,Loyc.Collections,VListBlock<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlock.cs,InsertRange,The method has 5 parameters. Parameters: self' localCount' items' distanceFromFront' isRVList
Long Parameter List,Loyc.Collections,VListBlock<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlock.cs,Transform,The method has 5 parameters. Parameters: _block' _localCount' x' isRList' forWList
Long Parameter List,Loyc.Collections.Impl,AListInner<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInner.cs,AListInner,The method has 5 parameters. Parameters: original' localIndex' localCount' baseIndex' maxNodeSize
Long Parameter List,Loyc.Collections.Impl,AListInner<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInner.cs,InsertRange,The method has 5 parameters. Parameters: index' source' sourceIndex' splitRight' tob
Long Parameter List,Loyc.Collections.Impl,AListInner<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInner.cs,Combine,The method has 6 parameters. Parameters: other' heightDifference' splitRight' tob' move' append
Long Parameter List,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,AListInnerBase,The method has 5 parameters. Parameters: original' localIndex' localCount' baseIndex' maxNodeSize
Long Parameter List,Loyc.Collections.Impl,AListLeaf<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListLeaf.cs,InsertRange,The method has 5 parameters. Parameters: index' source' sourceIndex' splitRight' tob
Long Parameter List,Loyc.Collections.Impl,AListNode<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListNode.cs,InsertRange,The method has 5 parameters. Parameters: index' source' sourceIndex' splitRight' tob
Long Parameter List,Loyc.Collections.Impl,AListSparseOperation,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListNode.cs,AListSparseOperation,The method has 5 parameters. Parameters: index' isInsert' writeEmpty' count' tob
Long Parameter List,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BListInner,The method has 5 parameters. Parameters: original' localIndex' localCount' baseIndex' maxNodeSize
Long Parameter List,Loyc.Collections.Impl,BListInner<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BListInner,The method has 5 parameters. Parameters: original' localIndex' localCount' baseIndex' maxNodeSize
Long Parameter List,Loyc.Collections.Impl,BDictionaryInner<K;V>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BDictionaryInner,The method has 5 parameters. Parameters: original' localIndex' localCount' baseIndex' maxNodeSize
Long Parameter List,Loyc.Collections.Impl,AListTreeObserverExt,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\IAListTreeObserver.cs,RemovingItems,The method has 6 parameters. Parameters: self' list' index' count' parent' isMoving
Long Parameter List,Loyc.Collections.Impl,AListTreeObserverExt,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\IAListTreeObserver.cs,HandleRootSplit,The method has 5 parameters. Parameters: self' oldRoot' newLeft' newRight' newRoot
Long Parameter List,Loyc.Collections.Impl,AListTreeObserverExt,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\IAListTreeObserver.cs,HandleChildReplaced,The method has 5 parameters. Parameters: self' oldNode' newLeft' newRight' parent
Long Parameter List,Loyc.Collections.Impl,SparseAListLeaf<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\SparseAListLeaf.cs,InsertRange,The method has 5 parameters. Parameters: index' source' sourceIndex' splitRight' tob
Long Parameter List,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The method has 5 parameters. Parameters: slots' item' hc' comparer' mode
Long Parameter List,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,OnFoundInOverflow,The method has 5 parameters. Parameters: slots' i' item' mode' existing
Long Parameter List,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,OpAtMaxDepth,The method has 6 parameters. Parameters: slots' item' hc' depth' comparer' mode
Long Statement,Loyc.Collections,AListBase<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AList.cs,Combine,The length of the statement  "					splitLeft = ((AListInner<T>)_root).Combine((AListInner<T>)other._root' heightDifference' out splitRight' _observer' move' append);" is 130.
Long Statement,Loyc.Collections,AListBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListBase.cs,ThrowFrozen,The length of the statement  "				throw new InvalidOperationException(Localize.Localized("Cannot insert or remove items in {0} during a ListChanging event."' name));" is 131.
Long Statement,Loyc.Collections,AListBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListBase.cs,ThrowFrozen,The length of the statement  "				throw new ConcurrentModificationException(Localize.Localized("{0} was accessed concurrently while being modified."' name));" is 123.
Long Statement,Loyc.Collections.Impl,AListIndexer<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListIndexer.cs,VerifyCorrectness,The length of the statement  "						AddError(ref e' "Outdated record: inner {0:X} no longer contains node {1:X}."' parent.GetHashCode() & 0xFFFF' child.GetHashCode() & 0xFFFF);" is 140.
Long Statement,Loyc.Collections.Impl,AListIndexer<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListIndexer.cs,VerifyCorrectness,The length of the statement  "					AddError(ref e' "Computed count {0}+{1} != indexed count {2}+{3}."' totalChildren' _root.LocalCount' _items.Count' _nodes.Count);" is 129.
Long Statement,Loyc.Collections.Impl,BListLeaf<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListLeaf.cs,DoSingleOperation,The length of the statement  "						CallListChanging(op.List' new ListChangeInfo<T>(NotifyCollectionChangedAction.Add' (int)op.BaseIndex' 1' ListExt.Single(searchItem)));" is 134.
Long Statement,Loyc.Collections.Impl,BListLeaf<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListLeaf.cs,DoSingleOperation,The length of the statement  "				CallListChanging(op.List' new ListChangeInfo<T>(NotifyCollectionChangedAction.Replace' (int)op.BaseIndex' 0' ListExt.Single(searchItem)));" is 138.
Complex Conditional,Loyc.Collections,AList<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AList.cs,TreeQuickSort,The conditional expression  "order < 0 || (order == 0 && (eOut.LastIndex - eOut._currentIndex) > (count >> 1) && (swapEqual = !swapEqual))"  is complex.
Complex Conditional,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The conditional expression  "(object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]"  is complex.
Complex Conditional,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The conditional expression  "(object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]"  is complex.
Magic Number,Loyc.Collections,AList<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AList.cs,TreeQuickSort,The following statement contains a magic number: {	// Start by choosing a pivot based the median of three  				// values. Two candidates are random' and one is the first element. 				uint offset0 = (uint)_r.Next((int)count - 2) + 1; 				uint offset2 = (uint)_r.Next((int)count - 1) + 1; 				T pivot0 = _root[start + offset0]; 				T pivot2 = _root[start + offset2]; 				if (comp(pivot0' pivot1) > 0) 				{ 					G.Swap(ref pivot0' ref pivot1); 					G.Swap(ref offset0' ref offset1); 				} 				if (comp(pivot1' pivot2) > 0) 				{ 					pivot1 = pivot2; 					offset1 = offset2; 					if (comp(pivot0' pivot1) > 0) 					{ 						pivot1 = pivot0; 						offset1 = offset0; 					} 				} 			}
Magic Number,Loyc.Collections,AListBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListBase.cs,AListBase,The following statement contains a magic number: if (maxLeafSize < 3) 				CheckParam.ThrowOutOfRange("maxLeafSize");
Magic Number,Loyc.Collections,AListBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListBase.cs,AListBase,The following statement contains a magic number: if (maxInnerSize < 3) 				CheckParam.ThrowOutOfRange("maxInnerSize");
Magic Number,Loyc.Collections,CG,C:\repos\qwertie_Loyc\Core\Loyc.Collections\CG.cs,Cache,The following statement contains a magic number: if (num >= -3 && num <= 9) 				return OneDigitInts[num + 3];
Magic Number,Loyc.Collections,CG,C:\repos\qwertie_Loyc\Core\Loyc.Collections\CG.cs,Cache,The following statement contains a magic number: if (num >= -3 && num <= 9) 				return OneDigitInts[num + 3];
Magic Number,Loyc.Collections,CG,C:\repos\qwertie_Loyc\Core\Loyc.Collections\CG.cs,Cache,The following statement contains a magic number: if (num >= -3 && num <= 9) 				return OneDigitInts[num + 3];
Magic Number,Loyc.Collections,ArrayOf4<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Other\ArrayOf4.cs,Insert,The following statement contains a magic number: if (index < 2) { 				t2 = t1; 				if (index == 0) 					t0 = item; 				else 					t1 = item; 				return popped; 			} else { 				if (index == 2) 					t2 = item; 				else 					t3 = item; 				return popped; 			}
Magic Number,Loyc.Collections,ArrayOf4<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Other\ArrayOf4.cs,Insert,The following statement contains a magic number: if (index < 2) { 				t2 = t1; 				if (index == 0) 					t0 = item; 				else 					t1 = item; 				return popped; 			} else { 				if (index == 2) 					t2 = item; 				else 					t3 = item; 				return popped; 			}
Magic Number,Loyc.Collections,ArrayOf4<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Other\ArrayOf4.cs,RemoveAt,The following statement contains a magic number: if (index < 2) 			{ 				if (index == 0) 					t0 = t1; 				t1 = t2; 			}
Magic Number,Loyc.Collections,ArrayOf4<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Other\ArrayOf4.cs,RemoveAt,The following statement contains a magic number: if (index == 2) 				t2 = t3;
Magic Number,Loyc.Collections,SimpleCache<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Other\SimpleCache.cs,Enlarge,The following statement contains a magic number: _table = new T[oldTable.Length * 2];
Magic Number,Loyc.Collections,SimpleCache<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Other\SimpleCache.cs,Clear,The following statement contains a magic number: _table = new T[_maxSize < 32 ? (_maxSize < 16 ? 8 : 16) : 32];
Magic Number,Loyc.Collections,SimpleCache<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Other\SimpleCache.cs,Clear,The following statement contains a magic number: _table = new T[_maxSize < 32 ? (_maxSize < 16 ? 8 : 16) : 32];
Magic Number,Loyc.Collections,SimpleCache<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Other\SimpleCache.cs,Clear,The following statement contains a magic number: _table = new T[_maxSize < 32 ? (_maxSize < 16 ? 8 : 16) : 32];
Magic Number,Loyc.Collections,SimpleCache<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Other\SimpleCache.cs,Clear,The following statement contains a magic number: _table = new T[_maxSize < 32 ? (_maxSize < 16 ? 8 : 16) : 32];
Magic Number,Loyc.Collections,SimpleCache<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Other\SimpleCache.cs,Clear,The following statement contains a magic number: _table = new T[_maxSize < 32 ? (_maxSize < 16 ? 8 : 16) : 32];
Magic Number,Loyc.Collections,SimpleCacheTests,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Other\SimpleCache.cs,TestRandom,The following statement contains a magic number: for (int i = 0; i < 1000; i++) 			{ 				for (int ci = 0; ci < 8; ci++) 					sb[ci] = (char)r.Next(0x7F); 				words.Add(sb.ToString());  				Try(words[r.Next(words.Count)]' c' ref cacheHits); 				Try(words[r.Next(words.Count)]' c' ref cacheHits); 				Try(words[r.Next(words.Count)]' c' ref cacheHits); 			}
Magic Number,Loyc.Collections,SimpleCacheTests,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Other\SimpleCache.cs,TestRandom,The following statement contains a magic number: for (int i = 0; i < 1000; i++) 			{ 				for (int ci = 0; ci < 8; ci++) 					sb[ci] = (char)r.Next(0x7F); 				words.Add(sb.ToString());  				Try(words[r.Next(words.Count)]' c' ref cacheHits); 				Try(words[r.Next(words.Count)]' c' ref cacheHits); 				Try(words[r.Next(words.Count)]' c' ref cacheHits); 			}
Magic Number,Loyc.Collections,SimpleCacheTests,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Other\SimpleCache.cs,TestRandom,The following statement contains a magic number: Assert.GreaterOrEqual(c.CacheHits' 500);
Magic Number,Loyc.Collections,SimpleCacheTests,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Other\SimpleCache.cs,TestRandom,The following statement contains a magic number: Assert.GreaterOrEqual(c.CacheMisses' 500);
Magic Number,Loyc.Collections,InvertibleSetTests,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InvertibleSet.cs,RegressionTests,The following statement contains a magic number: var a = new InvertibleSet<int>(new[] { 1' 2 }' false);
Magic Number,Loyc.Collections,InvertibleSetTests,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InvertibleSet.cs,RegressionTests,The following statement contains a magic number: var b = new InvertibleSet<int>(new[] { 1' 2' 3 }' true);
Magic Number,Loyc.Collections,InvertibleSetTests,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InvertibleSet.cs,RegressionTests,The following statement contains a magic number: var b = new InvertibleSet<int>(new[] { 1' 2' 3 }' true);
Magic Number,Loyc.Collections,InvertibleSetTests,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InvertibleSet.cs,RegressionTests,The following statement contains a magic number: var c = new InvertibleSet<int>(new[] { 3 }' true);
Magic Number,Loyc.Collections,MapOrMMap<K;V>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\Map.cs,CountMemory,The following statement contains a magic number: return IntPtr.Size * 4 + _set.CountMemory(sizeOfPair);
Magic Number,Loyc.Collections,MSet<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\MSet.cs,CountMemory,The following statement contains a magic number: return IntPtr.Size * 4 + _set.CountMemory(sizeOfT);
Magic Number,Loyc.Collections,Set,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\Set.cs,CountMemory,The following statement contains a magic number: return IntPtr.Size * 2 + _set.CountMemory(sizeOfT);
Magic Number,Loyc.Collections,FVList,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\FVList.cs,FVList,The following statement contains a magic number: _localCount = 2;
Magic Number,Loyc.Collections,FVList,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\FVList.cs,GetHashCode,The following statement contains a magic number: if (_block == null) 				return 2468;
Magic Number,Loyc.Collections,FWList<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\FWList.cs,FWList,The following statement contains a magic number: LocalCount = 2;
Magic Number,Loyc.Collections,VList,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VList.cs,VList,The following statement contains a magic number: _localCount = 2;
Magic Number,Loyc.Collections,VList,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VList.cs,GetHashCode,The following statement contains a magic number: if (_block == null) 				return 2357;
Magic Number,Loyc.Collections,WList<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\WList.cs,WList,The following statement contains a magic number: LocalCount = 2;
Magic Number,Loyc.Collections,VListBlock<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlock.cs,MuAllocBlock,The following statement contains a magic number: int capacity = Math.Min(newBlockSizeLimit' w.Count + 2);
Magic Number,Loyc.Collections,VListBlock<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlock.cs,MakeResult,The following statement contains a magic number: FVList<T> output = new FVList<T>(new VListBlockOfTwo<T>(_1' _2' forWList != null)' 2);
Magic Number,Loyc.Collections,VListBlock<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlock.cs,Transform,The following statement contains a magic number: if (two != null) 			{ 				// Optimization: handle numerous cases on short lists 				count = _localCount; 				if (!isRList) { 					i = count; 					inc = -1; 				} 				 				item = two._1; 				act = x(i += inc' ref item); 				bool moveNextOnlyOnce = false;  				if (act == XfAction.Keep) 				{ 					if (count == 1) 					{ 						if (two._immCount == MutableFlag) 							two._immCount = 1; // Ensure first item is immutable 						return MakeResult(_block' 1' forWList); 					} 					else 					{ 						item = two._2; 						act = x(i += inc' ref item); 						if (act == XfAction.Keep) 						{ 							two._immCount = 2; // Ensure both items are immutable 							return MakeResult(_block' 2' forWList); 						} 						else if (act == XfAction.Change) 						{ 							return MakeResult(two._1' item' forWList); 						} 						else if (act == XfAction.Drop) 						{ 							if (two._immCount == MutableFlag) 								two._immCount = 1; // Ensure first item is immutable 							return MakeResult(_block' 1' forWList); 						} 						else // assume XfAction.Repeat 						{ 							output = MakeResult(two._1' forWList); 						} 					} 				} 				else if (act == XfAction.Drop) 				{ 					if (count == 1) 						return FVList<T>.Empty; 					else 					{ 						item = two._2; 						act = x(i += inc' ref item); 						if (act == XfAction.Drop) 							return FVList<T>.Empty; 						else if (act == XfAction.Keep) 							return MakeResult(two._2' forWList); 						else if (act == XfAction.Change) 							return MakeResult(item' forWList); 					} 				} 				else if (act == XfAction.Change) 				{ 					T item1 = item; 					if (count == 1) 						return MakeResult(item' forWList); 					else 					{ 						item = two._2; 						act = x(i += inc' ref item); 						if (act == XfAction.Change) 							return MakeResult(item1' item' forWList); 						else if (act == XfAction.Keep) 							return MakeResult(item1' two._2' forWList); 						else { 							output = MakeResult(item1' forWList); 							if (act == XfAction.Drop) 								return output; 						} 					} 				} 				else 					moveNextOnlyOnce = true;  				// Use general approach. Skip the first item' unless moveNextOnlyOnce 				e = new VList<T>.Enumerator(new FVList<T>(_block' _localCount)); 				e.MoveNext(); 				if (!moveNextOnlyOnce) 					e.MoveNext(); 			} else { 				e = new VList<T>.Enumerator(new FVList<T>(_block' _localCount)); 				e.MoveNext(); // always true  				count = _localCount + _block.PriorCount; 				if (!isRList) { 					i = count; 					inc = -1; 				} 				item = e.Current; 				act = x(i += inc' ref item); 			}
Magic Number,Loyc.Collections,VListBlock<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlock.cs,Transform,The following statement contains a magic number: if (two != null) 			{ 				// Optimization: handle numerous cases on short lists 				count = _localCount; 				if (!isRList) { 					i = count; 					inc = -1; 				} 				 				item = two._1; 				act = x(i += inc' ref item); 				bool moveNextOnlyOnce = false;  				if (act == XfAction.Keep) 				{ 					if (count == 1) 					{ 						if (two._immCount == MutableFlag) 							two._immCount = 1; // Ensure first item is immutable 						return MakeResult(_block' 1' forWList); 					} 					else 					{ 						item = two._2; 						act = x(i += inc' ref item); 						if (act == XfAction.Keep) 						{ 							two._immCount = 2; // Ensure both items are immutable 							return MakeResult(_block' 2' forWList); 						} 						else if (act == XfAction.Change) 						{ 							return MakeResult(two._1' item' forWList); 						} 						else if (act == XfAction.Drop) 						{ 							if (two._immCount == MutableFlag) 								two._immCount = 1; // Ensure first item is immutable 							return MakeResult(_block' 1' forWList); 						} 						else // assume XfAction.Repeat 						{ 							output = MakeResult(two._1' forWList); 						} 					} 				} 				else if (act == XfAction.Drop) 				{ 					if (count == 1) 						return FVList<T>.Empty; 					else 					{ 						item = two._2; 						act = x(i += inc' ref item); 						if (act == XfAction.Drop) 							return FVList<T>.Empty; 						else if (act == XfAction.Keep) 							return MakeResult(two._2' forWList); 						else if (act == XfAction.Change) 							return MakeResult(item' forWList); 					} 				} 				else if (act == XfAction.Change) 				{ 					T item1 = item; 					if (count == 1) 						return MakeResult(item' forWList); 					else 					{ 						item = two._2; 						act = x(i += inc' ref item); 						if (act == XfAction.Change) 							return MakeResult(item1' item' forWList); 						else if (act == XfAction.Keep) 							return MakeResult(item1' two._2' forWList); 						else { 							output = MakeResult(item1' forWList); 							if (act == XfAction.Drop) 								return output; 						} 					} 				} 				else 					moveNextOnlyOnce = true;  				// Use general approach. Skip the first item' unless moveNextOnlyOnce 				e = new VList<T>.Enumerator(new FVList<T>(_block' _localCount)); 				e.MoveNext(); 				if (!moveNextOnlyOnce) 					e.MoveNext(); 			} else { 				e = new VList<T>.Enumerator(new FVList<T>(_block' _localCount)); 				e.MoveNext(); // always true  				count = _localCount + _block.PriorCount; 				if (!isRList) { 					i = count; 					inc = -1; 				} 				item = e.Current; 				act = x(i += inc' ref item); 			}
Magic Number,Loyc.Collections,VListBlockArray<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockArray.cs,VListBlockArray,The following statement contains a magic number: if (localCapacity <= 0) 				localCapacity = Math.Min(MAX_BLOCK_LEN' 				                Math.Max(prior._localCount * 2' prior._block.ImmCount));
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,VListBlockOfTwo,The following statement contains a magic number: _immCount = mutable ? MutableFlag : 2;
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,FGet,The following statement contains a magic number: Debug.Assert((uint)localCount <= 2);
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,FGet,The following statement contains a magic number: Debug.Assert((uint)localCount <= 2);
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,RGet,The following statement contains a magic number: Debug.Assert((uint)localCount <= 2);
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,RGet,The following statement contains a magic number: Debug.Assert((uint)localCount <= 2);
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,Front,The following statement contains a magic number: Debug.Assert(localCount == 1 || localCount == 2);
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,Add,The following statement contains a magic number: Debug.Assert(localIndex == 1 || localIndex == 2);
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,Add,The following statement contains a magic number: if (localIndex == 1 && _immCount == 1) { 				if (Interlocked.CompareExchange(ref _immCount' 2' 1) == 1) { 					_2 = item; 					return this; 				} 			}
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,SubList,The following statement contains a magic number: if (localIndex <= 0) 				return new FVList<T>(); // empty 			else { 				Debug.Assert(localIndex <= Math.Min(_immCount' 2) && ImmCount <= 2); 				return new FVList<T>(this' localIndex); 			}
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,SubList,The following statement contains a magic number: if (localIndex <= 0) 				return new FVList<T>(); // empty 			else { 				Debug.Assert(localIndex <= Math.Min(_immCount' 2) && ImmCount <= 2); 				return new FVList<T>(this' localIndex); 			}
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,MuClear,The following statement contains a magic number: Debug.Assert(ImmCount <= localCountWithMutables && localCountWithMutables <= 2);
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,BlockToArray,The following statement contains a magic number: if (localCount == 1) { 				array[arrayOffset] = _1; 			} else if (localCount == 2) { 				if (isRList) { 					array[arrayOffset] = _1; 					array[arrayOffset+1] = _2; 				} else { 					array[arrayOffset] = _2; 					array[arrayOffset+1] = _1; 				} 			} else 				Debug.Assert(localCount == 0);
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,Where,The following statement contains a magic number: if (keep(_1)) 			{ 				if (localCount == 2) { 					if (keep(_2)) { 						_immCount = 2; // Mark immutable if it isn't already 						return MakeResult(this' 2' forWList); 					} 				}  				if (_immCount == MutableFlag) 					_immCount = 1; // Ensure first item is immutable  				return MakeResult(this' 1' forWList); 			} 			else 			{ 				if (localCount == 2 && keep(_2)) 					return MakeResult(_2' forWList); 				else 					return new FVList<T>(); 			}
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,Where,The following statement contains a magic number: if (keep(_1)) 			{ 				if (localCount == 2) { 					if (keep(_2)) { 						_immCount = 2; // Mark immutable if it isn't already 						return MakeResult(this' 2' forWList); 					} 				}  				if (_immCount == MutableFlag) 					_immCount = 1; // Ensure first item is immutable  				return MakeResult(this' 1' forWList); 			} 			else 			{ 				if (localCount == 2 && keep(_2)) 					return MakeResult(_2' forWList); 				else 					return new FVList<T>(); 			}
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,Where,The following statement contains a magic number: if (keep(_1)) 			{ 				if (localCount == 2) { 					if (keep(_2)) { 						_immCount = 2; // Mark immutable if it isn't already 						return MakeResult(this' 2' forWList); 					} 				}  				if (_immCount == MutableFlag) 					_immCount = 1; // Ensure first item is immutable  				return MakeResult(this' 1' forWList); 			} 			else 			{ 				if (localCount == 2 && keep(_2)) 					return MakeResult(_2' forWList); 				else 					return new FVList<T>(); 			}
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,Where,The following statement contains a magic number: if (keep(_1)) 			{ 				if (localCount == 2) { 					if (keep(_2)) { 						_immCount = 2; // Mark immutable if it isn't already 						return MakeResult(this' 2' forWList); 					} 				}  				if (_immCount == MutableFlag) 					_immCount = 1; // Ensure first item is immutable  				return MakeResult(this' 1' forWList); 			} 			else 			{ 				if (localCount == 2 && keep(_2)) 					return MakeResult(_2' forWList); 				else 					return new FVList<T>(); 			}
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,SmartSelect,The following statement contains a magic number: if (EqualityComparer.Equals(item = map(_1)' _1)) 			{ 				if (_localCount == 2) { 					if (EqualityComparer.Equals(item2 = map(_2)' _2)) { 						_immCount = 2; // Mark immutable if it isn't already 						return MakeResult(this' 2' forWList); 					} else { 						return MakeResult(item' item2' forWList); 					} 				} else { 					if (_immCount == MutableFlag) 						_immCount = 1; // Ensure first item is immutable 					return MakeResult(this' 1' forWList); 				} 			} else { 				if (_localCount == 2) 					return MakeResult(item' map(_2)' forWList); 				else 					return MakeResult(item' forWList); 			}
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,SmartSelect,The following statement contains a magic number: if (EqualityComparer.Equals(item = map(_1)' _1)) 			{ 				if (_localCount == 2) { 					if (EqualityComparer.Equals(item2 = map(_2)' _2)) { 						_immCount = 2; // Mark immutable if it isn't already 						return MakeResult(this' 2' forWList); 					} else { 						return MakeResult(item' item2' forWList); 					} 				} else { 					if (_immCount == MutableFlag) 						_immCount = 1; // Ensure first item is immutable 					return MakeResult(this' 1' forWList); 				} 			} else { 				if (_localCount == 2) 					return MakeResult(item' map(_2)' forWList); 				else 					return MakeResult(item' forWList); 			}
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,SmartSelect,The following statement contains a magic number: if (EqualityComparer.Equals(item = map(_1)' _1)) 			{ 				if (_localCount == 2) { 					if (EqualityComparer.Equals(item2 = map(_2)' _2)) { 						_immCount = 2; // Mark immutable if it isn't already 						return MakeResult(this' 2' forWList); 					} else { 						return MakeResult(item' item2' forWList); 					} 				} else { 					if (_immCount == MutableFlag) 						_immCount = 1; // Ensure first item is immutable 					return MakeResult(this' 1' forWList); 				} 			} else { 				if (_localCount == 2) 					return MakeResult(item' map(_2)' forWList); 				else 					return MakeResult(item' forWList); 			}
Magic Number,Loyc.Collections,VListBlockOfTwo<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\VLists\VListBlockOfTwo.cs,SmartSelect,The following statement contains a magic number: if (EqualityComparer.Equals(item = map(_1)' _1)) 			{ 				if (_localCount == 2) { 					if (EqualityComparer.Equals(item2 = map(_2)' _2)) { 						_immCount = 2; // Mark immutable if it isn't already 						return MakeResult(this' 2' forWList); 					} else { 						return MakeResult(item' item2' forWList); 					} 				} else { 					if (_immCount == MutableFlag) 						_immCount = 1; // Ensure first item is immutable 					return MakeResult(this' 1' forWList); 				} 			} else { 				if (_localCount == 2) 					return MakeResult(item' map(_2)' forWList); 				else 					return MakeResult(item' forWList); 			}
Magic Number,Loyc.Collections.Impl,AListIndexer<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListIndexer.cs,AddError,The following statement contains a magic number: if (sb.Length < 1000) 			{ 				if (args == null) 					sb.Append(fmt); 				else 					sb.AppendFormat(fmt' args); 				 				if (sb.Length > 1000) 				{ 					sb.Remove(1000' sb.Length - 1000); 					sb.Append("..."); 				} 			}
Magic Number,Loyc.Collections.Impl,AListIndexer<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListIndexer.cs,AddError,The following statement contains a magic number: if (sb.Length < 1000) 			{ 				if (args == null) 					sb.Append(fmt); 				else 					sb.AppendFormat(fmt' args); 				 				if (sb.Length > 1000) 				{ 					sb.Remove(1000' sb.Length - 1000); 					sb.Append("..."); 				} 			}
Magic Number,Loyc.Collections.Impl,AListIndexer<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListIndexer.cs,AddError,The following statement contains a magic number: if (sb.Length < 1000) 			{ 				if (args == null) 					sb.Append(fmt); 				else 					sb.AppendFormat(fmt' args); 				 				if (sb.Length > 1000) 				{ 					sb.Remove(1000' sb.Length - 1000); 					sb.Append("..."); 				} 			}
Magic Number,Loyc.Collections.Impl,AListIndexer<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListIndexer.cs,AddError,The following statement contains a magic number: if (sb.Length < 1000) 			{ 				if (args == null) 					sb.Append(fmt); 				else 					sb.AppendFormat(fmt' args); 				 				if (sb.Length > 1000) 				{ 					sb.Remove(1000' sb.Length - 1000); 					sb.Append("..."); 				} 			}
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,AListInnerBase,The following statement contains a magic number: _children = new Entry[4];
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,AListInnerBase,The following statement contains a magic number: _childCount = 2;
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,AListInnerBase,The following statement contains a magic number: _children[2] = new Entry { Index = uint.MaxValue };
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,AListInnerBase,The following statement contains a magic number: _children[3] = new Entry { Index = uint.MaxValue };
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,AListInnerBase,The following statement contains a magic number: _children = new Entry[(localCount + 3) & ~3];
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,AListInnerBase,The following statement contains a magic number: _children = new Entry[(localCount + 3) & ~3];
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,AListInnerBase,The following statement contains a magic number: _children = new Entry[(localCount + 3) & ~3];
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,AListInnerBase,The following statement contains a magic number: _children = new Entry[(localCount + 3) & ~3];
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: Debug.Assert(children.Length < 256);
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: int i = 2;
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: if (children.Length > 4) 			{ 				i = 8; 				if (children.Length > 16) 				{ 					i = 32; 					if (children.Length > 64) 					{ 						i = 128; 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 64 : -64); 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 32 : -32); 					} 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 16 : -16); 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 8 : -8); 				} 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 4 : -4); 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: if (children.Length > 4) 			{ 				i = 8; 				if (children.Length > 16) 				{ 					i = 32; 					if (children.Length > 64) 					{ 						i = 128; 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 64 : -64); 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 32 : -32); 					} 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 16 : -16); 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 8 : -8); 				} 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 4 : -4); 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: if (children.Length > 4) 			{ 				i = 8; 				if (children.Length > 16) 				{ 					i = 32; 					if (children.Length > 64) 					{ 						i = 128; 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 64 : -64); 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 32 : -32); 					} 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 16 : -16); 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 8 : -8); 				} 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 4 : -4); 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: if (children.Length > 4) 			{ 				i = 8; 				if (children.Length > 16) 				{ 					i = 32; 					if (children.Length > 64) 					{ 						i = 128; 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 64 : -64); 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 32 : -32); 					} 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 16 : -16); 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 8 : -8); 				} 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 4 : -4); 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: if (children.Length > 4) 			{ 				i = 8; 				if (children.Length > 16) 				{ 					i = 32; 					if (children.Length > 64) 					{ 						i = 128; 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 64 : -64); 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 32 : -32); 					} 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 16 : -16); 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 8 : -8); 				} 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 4 : -4); 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: if (children.Length > 4) 			{ 				i = 8; 				if (children.Length > 16) 				{ 					i = 32; 					if (children.Length > 64) 					{ 						i = 128; 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 64 : -64); 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 32 : -32); 					} 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 16 : -16); 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 8 : -8); 				} 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 4 : -4); 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: if (children.Length > 4) 			{ 				i = 8; 				if (children.Length > 16) 				{ 					i = 32; 					if (children.Length > 64) 					{ 						i = 128; 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 64 : -64); 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 32 : -32); 					} 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 16 : -16); 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 8 : -8); 				} 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 4 : -4); 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: if (children.Length > 4) 			{ 				i = 8; 				if (children.Length > 16) 				{ 					i = 32; 					if (children.Length > 64) 					{ 						i = 128; 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 64 : -64); 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 32 : -32); 					} 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 16 : -16); 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 8 : -8); 				} 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 4 : -4); 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: if (children.Length > 4) 			{ 				i = 8; 				if (children.Length > 16) 				{ 					i = 32; 					if (children.Length > 64) 					{ 						i = 128; 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 64 : -64); 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 32 : -32); 					} 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 16 : -16); 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 8 : -8); 				} 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 4 : -4); 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: if (children.Length > 4) 			{ 				i = 8; 				if (children.Length > 16) 				{ 					i = 32; 					if (children.Length > 64) 					{ 						i = 128; 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 64 : -64); 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 32 : -32); 					} 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 16 : -16); 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 8 : -8); 				} 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 4 : -4); 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: if (children.Length > 4) 			{ 				i = 8; 				if (children.Length > 16) 				{ 					i = 32; 					if (children.Length > 64) 					{ 						i = 128; 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 64 : -64); 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 32 : -32); 					} 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 16 : -16); 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 8 : -8); 				} 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 4 : -4); 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: if (children.Length > 4) 			{ 				i = 8; 				if (children.Length > 16) 				{ 					i = 32; 					if (children.Length > 64) 					{ 						i = 128; 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 64 : -64); 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 32 : -32); 					} 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 16 : -16); 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 8 : -8); 				} 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 4 : -4); 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: if (children.Length > 4) 			{ 				i = 8; 				if (children.Length > 16) 				{ 					i = 32; 					if (children.Length > 64) 					{ 						i = 128; 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 64 : -64); 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 32 : -32); 					} 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 16 : -16); 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 8 : -8); 				} 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 4 : -4); 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: if (children.Length > 4) 			{ 				i = 8; 				if (children.Length > 16) 				{ 					i = 32; 					if (children.Length > 64) 					{ 						i = 128; 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 64 : -64); 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 32 : -32); 					} 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 16 : -16); 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 8 : -8); 				} 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 4 : -4); 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: if (children.Length > 4) 			{ 				i = 8; 				if (children.Length > 16) 				{ 					i = 32; 					if (children.Length > 64) 					{ 						i = 128; 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 64 : -64); 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 32 : -32); 					} 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 16 : -16); 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 8 : -8); 				} 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 4 : -4); 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: if (children.Length > 4) 			{ 				i = 8; 				if (children.Length > 16) 				{ 					i = 32; 					if (children.Length > 64) 					{ 						i = 128; 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 64 : -64); 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 32 : -32); 					} 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 16 : -16); 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 8 : -8); 				} 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 4 : -4); 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: if (children.Length > 4) 			{ 				i = 8; 				if (children.Length > 16) 				{ 					i = 32; 					if (children.Length > 64) 					{ 						i = 128; 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 64 : -64); 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 32 : -32); 					} 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 16 : -16); 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 8 : -8); 				} 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 4 : -4); 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,AListInnerBase<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListInnerBase.cs,BinarySearchI,The following statement contains a magic number: if (children.Length > 4) 			{ 				i = 8; 				if (children.Length > 16) 				{ 					i = 32; 					if (children.Length > 64) 					{ 						i = 128; 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 64 : -64); 						i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 32 : -32); 					} 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 16 : -16); 					i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 8 : -8); 				} 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 4 : -4); 				i += ((uint)i < (uint)children.Length && index >= children[i].Index ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,AListLeaf<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\AListLeaf.cs,AListLeaf,The following statement contains a magic number: Debug.Assert(maxNodeSize >= 3);
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BinarySearchK,The following statement contains a magic number: Debug.Assert(_highestKey.Length < 256);
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BinarySearchK,The following statement contains a magic number: if (keyCount >= 4) 			{ 				i = 7; 				if (keyCount >= 16) 				{ 					i = 31; 					if (keyCount >= 64) 					{ 						i = 127; 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 64 : -64); 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 32 : -32); 					} 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 16 : -16); 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 8 : -8); 				} 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 4 : -4); 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BinarySearchK,The following statement contains a magic number: if (keyCount >= 4) 			{ 				i = 7; 				if (keyCount >= 16) 				{ 					i = 31; 					if (keyCount >= 64) 					{ 						i = 127; 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 64 : -64); 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 32 : -32); 					} 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 16 : -16); 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 8 : -8); 				} 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 4 : -4); 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BinarySearchK,The following statement contains a magic number: if (keyCount >= 4) 			{ 				i = 7; 				if (keyCount >= 16) 				{ 					i = 31; 					if (keyCount >= 64) 					{ 						i = 127; 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 64 : -64); 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 32 : -32); 					} 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 16 : -16); 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 8 : -8); 				} 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 4 : -4); 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BinarySearchK,The following statement contains a magic number: if (keyCount >= 4) 			{ 				i = 7; 				if (keyCount >= 16) 				{ 					i = 31; 					if (keyCount >= 64) 					{ 						i = 127; 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 64 : -64); 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 32 : -32); 					} 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 16 : -16); 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 8 : -8); 				} 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 4 : -4); 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BinarySearchK,The following statement contains a magic number: if (keyCount >= 4) 			{ 				i = 7; 				if (keyCount >= 16) 				{ 					i = 31; 					if (keyCount >= 64) 					{ 						i = 127; 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 64 : -64); 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 32 : -32); 					} 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 16 : -16); 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 8 : -8); 				} 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 4 : -4); 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BinarySearchK,The following statement contains a magic number: if (keyCount >= 4) 			{ 				i = 7; 				if (keyCount >= 16) 				{ 					i = 31; 					if (keyCount >= 64) 					{ 						i = 127; 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 64 : -64); 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 32 : -32); 					} 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 16 : -16); 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 8 : -8); 				} 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 4 : -4); 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BinarySearchK,The following statement contains a magic number: if (keyCount >= 4) 			{ 				i = 7; 				if (keyCount >= 16) 				{ 					i = 31; 					if (keyCount >= 64) 					{ 						i = 127; 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 64 : -64); 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 32 : -32); 					} 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 16 : -16); 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 8 : -8); 				} 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 4 : -4); 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BinarySearchK,The following statement contains a magic number: if (keyCount >= 4) 			{ 				i = 7; 				if (keyCount >= 16) 				{ 					i = 31; 					if (keyCount >= 64) 					{ 						i = 127; 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 64 : -64); 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 32 : -32); 					} 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 16 : -16); 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 8 : -8); 				} 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 4 : -4); 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BinarySearchK,The following statement contains a magic number: if (keyCount >= 4) 			{ 				i = 7; 				if (keyCount >= 16) 				{ 					i = 31; 					if (keyCount >= 64) 					{ 						i = 127; 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 64 : -64); 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 32 : -32); 					} 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 16 : -16); 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 8 : -8); 				} 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 4 : -4); 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BinarySearchK,The following statement contains a magic number: if (keyCount >= 4) 			{ 				i = 7; 				if (keyCount >= 16) 				{ 					i = 31; 					if (keyCount >= 64) 					{ 						i = 127; 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 64 : -64); 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 32 : -32); 					} 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 16 : -16); 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 8 : -8); 				} 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 4 : -4); 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BinarySearchK,The following statement contains a magic number: if (keyCount >= 4) 			{ 				i = 7; 				if (keyCount >= 16) 				{ 					i = 31; 					if (keyCount >= 64) 					{ 						i = 127; 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 64 : -64); 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 32 : -32); 					} 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 16 : -16); 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 8 : -8); 				} 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 4 : -4); 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BinarySearchK,The following statement contains a magic number: if (keyCount >= 4) 			{ 				i = 7; 				if (keyCount >= 16) 				{ 					i = 31; 					if (keyCount >= 64) 					{ 						i = 127; 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 64 : -64); 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 32 : -32); 					} 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 16 : -16); 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 8 : -8); 				} 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 4 : -4); 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BinarySearchK,The following statement contains a magic number: if (keyCount >= 4) 			{ 				i = 7; 				if (keyCount >= 16) 				{ 					i = 31; 					if (keyCount >= 64) 					{ 						i = 127; 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 64 : -64); 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 32 : -32); 					} 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 16 : -16); 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 8 : -8); 				} 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 4 : -4); 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BinarySearchK,The following statement contains a magic number: if (keyCount >= 4) 			{ 				i = 7; 				if (keyCount >= 16) 				{ 					i = 31; 					if (keyCount >= 64) 					{ 						i = 127; 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 64 : -64); 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 32 : -32); 					} 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 16 : -16); 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 8 : -8); 				} 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 4 : -4); 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BinarySearchK,The following statement contains a magic number: if (keyCount >= 4) 			{ 				i = 7; 				if (keyCount >= 16) 				{ 					i = 31; 					if (keyCount >= 64) 					{ 						i = 127; 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 64 : -64); 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 32 : -32); 					} 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 16 : -16); 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 8 : -8); 				} 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 4 : -4); 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BinarySearchK,The following statement contains a magic number: if (keyCount >= 4) 			{ 				i = 7; 				if (keyCount >= 16) 				{ 					i = 31; 					if (keyCount >= 64) 					{ 						i = 127; 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 64 : -64); 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 32 : -32); 					} 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 16 : -16); 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 8 : -8); 				} 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 4 : -4); 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BinarySearchK,The following statement contains a magic number: if (keyCount >= 4) 			{ 				i = 7; 				if (keyCount >= 16) 				{ 					i = 31; 					if (keyCount >= 64) 					{ 						i = 127; 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 64 : -64); 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 32 : -32); 					} 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 16 : -16); 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 8 : -8); 				} 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 4 : -4); 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,BinarySearchK,The following statement contains a magic number: if (keyCount >= 4) 			{ 				i = 7; 				if (keyCount >= 16) 				{ 					i = 31; 					if (keyCount >= 64) 					{ 						i = 127; 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 64 : -64); 						i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 32 : -32); 					} 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 16 : -16); 					i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 8 : -8); 				} 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 4 : -4); 				i += (i < keyCount && compare(highestKey[i]' key) < 0 ? 2 : -2); 			}
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,HandleUndersized,The following statement contains a magic number: int jStop = Math.Min(_childCount - 1' i + 2);
Magic Number,Loyc.Collections.Impl,BListInner<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListInner.cs,LLDelete,The following statement contains a magic number: if (_childCount > 1) 				InternalList.RemoveAt(Math.Min(i' _childCount - 2)' _highestKey' _childCount - 1);
Magic Number,Loyc.Collections.Impl,BListLeaf<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListLeaf.cs,DoSingleOperation,The following statement contains a magic number: if (op.Mode >= AListOperation.Add) 			{ 				// Possible operations: Add' AddOrReplace' AddIfNotPresent' AddOrThrow 				if (_list.Count >= _maxNodeSize && (op.Mode == AListOperation.Add || !op.Found)) 				{ 					op.BaseIndex -= (uint)index; 					op.Item = searchItem; 					return SplitAndAdd(ref op' out splitLeft' out splitRight); 				}  				if (op.Found && op.Mode != AListOperation.Add) 				{ 					if (op.Mode == AListOperation.AddOrThrow) 						throw new KeyAlreadyExistsException(); 					else if (op.Mode == AListOperation.AddIfNotPresent) 						return 0; 				}  				else // add new item 				{ 					if (HasListChanging(op.List)) 						CallListChanging(op.List' new ListChangeInfo<T>(NotifyCollectionChangedAction.Add' (int)op.BaseIndex' 1' ListExt.Single(searchItem)));  					if (index == _list.Count) 					{	// Highest key may change 						splitLeft = this; 						op.AggregateChanged |= 1; 						op.AggregateKey = op.List.GetKey(searchItem); 					}  					_list.AutoRaiseCapacity(1' _maxNodeSize); 					_list.Insert(index' searchItem);  					if (GetObserver(op.List) != null) 					{ 						if ((op.AggregateChanged & 2) == 0) 							GetObserver(op.List).ItemAdded(searchItem' this); 					} 					return 1; 				} 				Debug.Assert(op.Mode == AListOperation.AddOrReplace); 			} 			else if (op.Found) 			{ 				// Possible operations: ReplaceIfPresent' Remove 				if (op.Mode == AListOperation.Remove) 				{ 					if (HasListChanging(op.List)) 						CallListChanging(op.List' new ListChangeInfo<T>(NotifyCollectionChangedAction.Remove' (int)op.BaseIndex' -1' null));  					_list.RemoveAt(index);  					if (index == _list.Count) 					{	// Highest key may change 						splitLeft = this; 						if (_list.Count != 0) { 							op.AggregateChanged |= 1; 							op.AggregateKey = op.List.GetKey(_list.Last); 						} 					} 					else if (IsUndersized) 						splitLeft = this;  					if (GetObserver(op.List) != null) 					{ 						Debug.Assert((op.AggregateChanged & 2) == 0); 						GetObserver(op.List).ItemRemoved(op.Item' this); 					}  					return -1; 				} 				Debug.Assert(op.Mode == AListOperation.ReplaceIfPresent); 			} 			else 			{ 				Debug.Assert(op.Mode == AListOperation.Remove || op.Mode == AListOperation.ReplaceIfPresent); 				return 0; // can't remove/replace because item was not found. 			}
Magic Number,Loyc.Collections.Impl,BListLeaf<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListLeaf.cs,DoSingleOperation,The following statement contains a magic number: if (op.Mode >= AListOperation.Add) 			{ 				// Possible operations: Add' AddOrReplace' AddIfNotPresent' AddOrThrow 				if (_list.Count >= _maxNodeSize && (op.Mode == AListOperation.Add || !op.Found)) 				{ 					op.BaseIndex -= (uint)index; 					op.Item = searchItem; 					return SplitAndAdd(ref op' out splitLeft' out splitRight); 				}  				if (op.Found && op.Mode != AListOperation.Add) 				{ 					if (op.Mode == AListOperation.AddOrThrow) 						throw new KeyAlreadyExistsException(); 					else if (op.Mode == AListOperation.AddIfNotPresent) 						return 0; 				}  				else // add new item 				{ 					if (HasListChanging(op.List)) 						CallListChanging(op.List' new ListChangeInfo<T>(NotifyCollectionChangedAction.Add' (int)op.BaseIndex' 1' ListExt.Single(searchItem)));  					if (index == _list.Count) 					{	// Highest key may change 						splitLeft = this; 						op.AggregateChanged |= 1; 						op.AggregateKey = op.List.GetKey(searchItem); 					}  					_list.AutoRaiseCapacity(1' _maxNodeSize); 					_list.Insert(index' searchItem);  					if (GetObserver(op.List) != null) 					{ 						if ((op.AggregateChanged & 2) == 0) 							GetObserver(op.List).ItemAdded(searchItem' this); 					} 					return 1; 				} 				Debug.Assert(op.Mode == AListOperation.AddOrReplace); 			} 			else if (op.Found) 			{ 				// Possible operations: ReplaceIfPresent' Remove 				if (op.Mode == AListOperation.Remove) 				{ 					if (HasListChanging(op.List)) 						CallListChanging(op.List' new ListChangeInfo<T>(NotifyCollectionChangedAction.Remove' (int)op.BaseIndex' -1' null));  					_list.RemoveAt(index);  					if (index == _list.Count) 					{	// Highest key may change 						splitLeft = this; 						if (_list.Count != 0) { 							op.AggregateChanged |= 1; 							op.AggregateKey = op.List.GetKey(_list.Last); 						} 					} 					else if (IsUndersized) 						splitLeft = this;  					if (GetObserver(op.List) != null) 					{ 						Debug.Assert((op.AggregateChanged & 2) == 0); 						GetObserver(op.List).ItemRemoved(op.Item' this); 					}  					return -1; 				} 				Debug.Assert(op.Mode == AListOperation.ReplaceIfPresent); 			} 			else 			{ 				Debug.Assert(op.Mode == AListOperation.Remove || op.Mode == AListOperation.ReplaceIfPresent); 				return 0; // can't remove/replace because item was not found. 			}
Magic Number,Loyc.Collections.Impl,BListLeaf<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListLeaf.cs,SplitAndAdd,The following statement contains a magic number: op.AggregateChanged |= 2;
Magic Number,Loyc.Collections.Impl,BListLeaf<K;T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\BListLeaf.cs,SplitAndAdd,The following statement contains a magic number: op.AggregateChanged &= unchecked((byte)~2);
Magic Number,Loyc.Collections.Impl,SparseAListLeaf<T>,C:\repos\qwertie_Loyc\Core\Loyc.Collections\ALists\SparseAListLeaf.cs,SparseAListLeaf,The following statement contains a magic number: Debug.Assert(maxNodeSize >= 3);
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TryRemoveChild,The following statement contains a magic number: Debug.Assert(G.CountOnes(child._used & FlagMask) <= 4);
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TryRemoveChild,The following statement contains a magic number: if (InternalSet_LUT.Zeros[slotsUsed] >= child.Counter) { 				// There's room! Clear child reference' and put each item from  				// the child into the parent' or just stop if child is empty. 				ReplaceChild(ref slots' iHome' null); 				if (child.Counter > 0) { 					int adj = 0; 					for (int iChild = 0; iChild < FanOut; iChild++) { 						if ((child._used & (1u << iChild)) != 0) { 							while ((slotsUsed & 1u) != 0) { 								slotsUsed >>= 1; 								adj++; 							} 							Debug.Assert(adj < 4); 							slots.Assign(child._items[iChild]' Adj(iHome' adj)); 							slotsUsed >>= 1; 							adj++; 						} 					} 				} 				return true; 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (slots._children != null && (child = slots._children[iHome]) != null) { 				var old = child; 				PropagateFrozenFlag(slots' child); 				Debug.Assert(child.Depth == slots.Depth + 1); 				added = AddOrRemove(ref child' ref item' hc >> BitsPerLevel' comparer' mode); 				if (child != old) 					ReplaceChild(ref slots' iHome' child); 				else if (child.Counter <= 2) 					TryRemoveChild(ref slots' iHome' child); 				return added; 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				// In this branch we'll compare with all four items to simplify the 				// code (this approach needs an extra lookup table' _targetTable.) 				// It would be foolish to use this approach for normal comparison' 				// since comparison may be expensive in general (and besides' we  				// should not call comparer.Equals() on slots that may be empty); 				// but we know that reference comparison is trivial. This  				// optimization cannot be used when item==default(T)' hence the  				// check for item!=null above. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return mode(ref slots' iAdj' item);  				deleted &= Mask; 				target = InternalSet_LUT.Value[usedOrDeleted | (deleted << BitsPerLevel)]; 			} else { 				switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following statement contains a magic number: if (target <= 3) { 				slots.Assign(item' Adj(iHome' target)); 				return true; 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,SelectBucketToSpill,The following statement contains a magic number: for (int adj = -1; adj < 5; adj++) 			{ 				int iAdj = Adj(i0' adj); 				T value = slots._items[iAdj]; 				if (slots.TAt(iAdj)) { 					int hc = (int)(GetHashCode(value' comparer) >> (depth * BitsPerLevel)) & Mask; 					if (++count[hc] > max) { 						max = count[hc]; 						max_i = hc; 					} 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Spill,The following statement contains a magic number: for (int adj = 0; adj < 4; adj++) 			{ 				int iAdj = Adj(i0' adj); 				if (parent.TAt(iAdj)) { 					T t = parent._items[iAdj]; 					uint hc = GetHashCode(t' comparer) >> (parentDepth * BitsPerLevel); 					if ((hc & Mask) == i0) { 						bool @true = AddOrRemove(ref child' ref t' hc >> BitsPerLevel' comparer' AddIfNotPresent); 						Debug.Assert(@true); 						parent.ClearTAt(iAdj); 					} 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following statement contains a magic number: if (comparer == null && (item != null || (comparer = EqualityComparer<T>.Default) == null)) { 				// Use reference equality (e.g. for T=Symbol); too bad .NET doesn't 				// support bitwise equality or we'd use this code for integers too. 				if ((object)item == (object)slots._items[iAdj = iHome] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 1)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 2)] || 					(object)item == (object)slots._items[iAdj = Adj(iHome' 3)]) 					return true; 			} else { 				uint used = slots._used; 				uint deleted = slots.DeletedFlags; 				uint usedOrDeleted = (used | deleted) & FlagMask; 				deleted |= deleted << FanOut; 				deleted >>= iHome; 				usedOrDeleted |= usedOrDeleted << FanOut; 				usedOrDeleted = (usedOrDeleted >> iHome) & Mask;  				switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,SetOperationEnumerator,The following statement contains a magic number: return _setOperationEnumerator = new Enumerator(8);
Magic Number,Loyc.Collections.Impl,Node,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,CheckCounter,The following statement contains a magic number: int used = (int)(_used & FlagMask)' deleted = (int)(_used >> 16);
Magic Number,Loyc.Collections.Impl,Node,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,CountMemory,The following statement contains a magic number: if (_children != null) { 					size += IntPtr.Size * (4 + FanOut); // add _children array 					for (int i = 0; i < _children.Length; i++) 						if (_children[i] != null) 							size += _children[i].CountMemory(sizeOfT' ref s); 				} else 					s.LeafCount++;
Magic Number,Loyc.Collections.Impl,MaxDepthNode,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,CountMemory,The following statement contains a magic number: size += IntPtr.Size * 2;
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,ZerosTable,The following statement contains a magic number: var table = new byte[16];
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,ZerosTable,The following statement contains a magic number: for (int i = 0; i < table.Length; i++) 				table[i] = (byte)(4 - G.CountOnes(i));
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: var table = new byte[256];
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following statement contains a magic number: for (int deleted = 0; deleted < 16; deleted++) { 				for (int used = 0; used < 16; used++) { 					int target = 0; 					switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					} 					table[used | deleted | (deleted << 4)] = (byte)target; 				} 			}
Magic Number,Loyc.Utilities,BloomFilterM64K2,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Other\BloomFilterM64K2.cs,Mask,The following statement contains a magic number: return ((ulong)1 << id) | ((ulong)1 << (id >> 6));
Missing Default,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,AddOrRemove,The following switch statement is missing a default case: switch (usedOrDeleted) { 					case 15: 						target++; 						if ((deleted & 8) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						target++; 						if ((deleted & 4) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						target++; 						if ((deleted & 2) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						target++; 						if ((deleted & 1) != 0) target = 0; 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				}
Missing Default,Loyc.Collections.Impl,InternalSet,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,Find,The following switch statement is missing a default case: switch (usedOrDeleted) { 					case 15: 						if ((deleted & 8) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 3)]' item)) goto found; 						goto case 7; 					case 7: 						if ((deleted & 4) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 2)]' item)) goto found; 						goto case 3; 					case 3: case 11: 						if ((deleted & 2) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = Adj(iHome' 1)]' item)) goto found; 						goto case 1; 					case 1: case 5: case 9: case 13: 						if ((deleted & 1) != 0) {} 						else if (comparer.Equals(existing = slots._items[iAdj = iHome]' item)) goto found; 						goto case 0; 					case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 						break; 				}
Missing Default,Loyc.Collections.Impl,InternalSet_LUT,C:\repos\qwertie_Loyc\Core\Loyc.Collections\Sets\InternalSet.cs,TargetTable,The following switch statement is missing a default case: switch(used | deleted) { 						case 15: 							target++; 							if ((deleted & 8) != 0) target = 0; 							goto case 7; 						case 7: 							target++; 							if ((deleted & 4) != 0) target = 0; 							goto case 3; 						case 3: case 11: 							target++; 							if ((deleted & 2) != 0) target = 0; 							goto case 1; 						case 1: case 5: case 9: case 13: 							target++; 							if ((deleted & 1) != 0) target = 0; 							goto case 0; 						case 0:	case 2: case 4: case 6: case 8: case 10: case 12: case 14: 							break; 					}
