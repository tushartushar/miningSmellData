Implementation smell,Namespace,Class,File,Method,Description
Long Method,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The method has 126 lines of code.
Complex Method,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,SimplifyPolyline,Cyclomatic complexity of the method is 9
Complex Method,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ProjectOnto,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,GetFractionAlong,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ComputeIntersection,Cyclomatic complexity of the method is 16
Complex Method,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ProjectOnto,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,GetFractionAlong,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ComputeIntersection,Cyclomatic complexity of the method is 16
Complex Method,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ProjectOnto,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,GetFractionAlong,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ComputeIntersection,Cyclomatic complexity of the method is 16
Complex Method,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ProjectOnto,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,GetFractionAlong,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ComputeIntersection,Cyclomatic complexity of the method is 16
Complex Method,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ProjectOnto,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,GetFractionAlong,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ComputeIntersection,Cyclomatic complexity of the method is 16
Complex Method,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ProjectOnto,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,GetFractionAlong,Cyclomatic complexity of the method is 8
Complex Method,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ComputeIntersection,Cyclomatic complexity of the method is 16
Long Parameter List,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,SimplifyPolyline,The method has 5 parameters. Parameters: points' output' tolerance' distanceToLine' inRecursion
Long Parameter List,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ComputeIntersection,The method has 6 parameters. Parameters: P' pType' pFrac' Q' qType' qFrac
Long Parameter List,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,GetOverlapRegion,The method has 8 parameters. Parameters: pa' pb' pType' qa' qb' qType' from' to
Long Parameter List,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ComputeIntersection,The method has 6 parameters. Parameters: P' pType' pFrac' Q' qType' qFrac
Long Parameter List,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,GetOverlapRegion,The method has 8 parameters. Parameters: pa' pb' pType' qa' qb' qType' from' to
Long Parameter List,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ComputeIntersection,The method has 6 parameters. Parameters: P' pType' pFrac' Q' qType' qFrac
Long Parameter List,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,GetOverlapRegion,The method has 8 parameters. Parameters: pa' pb' pType' qa' qb' qType' from' to
Long Parameter List,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ComputeIntersection,The method has 6 parameters. Parameters: P' pType' pFrac' Q' qType' qFrac
Long Parameter List,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,GetOverlapRegion,The method has 8 parameters. Parameters: pa' pb' pType' qa' qb' qType' from' to
Long Parameter List,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ComputeIntersection,The method has 6 parameters. Parameters: P' pType' pFrac' Q' qType' qFrac
Long Parameter List,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,GetOverlapRegion,The method has 8 parameters. Parameters: pa' pb' pType' qa' qb' qType' from' to
Long Parameter List,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ComputeIntersection,The method has 6 parameters. Parameters: P' pType' pFrac' Q' qType' qFrac
Long Parameter List,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,GetOverlapRegion,The method has 8 parameters. Parameters: pa' pb' pType' qa' qb' qType' from' to
Long Parameter List,Loyc.Geometry,Rectangle3Ext,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\Rectangle3Ext.cs,SetRect,The method has 7 parameters. Parameters: r' x' y' z' width' height' depth
Long Parameter List,Loyc.Geometry,Rectangle3Ext,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\Rectangle3Ext.cs,SetRange,The method has 7 parameters. Parameters: r' x1' y1' z1' x2' y2' z2
Long Parameter List,Loyc.Geometry,RectangleExt,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\RectangleExt.cs,SetRect,The method has 5 parameters. Parameters: r' x' y' width' height
Long Parameter List,Loyc.Geometry,RectangleExt,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\RectangleExt.cs,SetRange,The method has 5 parameters. Parameters: r' x1' y1' x2' y2
Long Parameter List,Loyc.Geometry,LineSegment3,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineSegment.cs,LineSegment3,The method has 6 parameters. Parameters: ax' ay' az' bx' by' bz
Long Parameter List,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The method has 5 parameters. Parameters: aH' aL' b' remainder' roundDown
Long Parameter List,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The method has 6 parameters. Parameters: aH' aL' b' resultHi' remainder' roundDown
Long Parameter List,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The method has 5 parameters. Parameters: aH' aL' b' resultHi' remainder
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountX < 0 && -amountX * 2 >= self.Width()) 				self.SetXAndWidth(MathEx.Average(self.X1' self.X2)' 0); 			else 				self.SetXRange(self.X1 - amountX' self.X2 + amountX);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountY < 0 && -amountY * 2 >= self.Height()) 				self.SetYAndHeight(MathEx.Average(self.Y1' self.Y2)' 0); 			else 				self.SetYRange(self.Y1 - amountY' self.Y2 + amountY);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountX < 0 && -amountX * 2 >= self.Width()) 				self.SetXAndWidth(MathEx.Average(self.X1' self.X2)' 0); 			else 				self.SetXRange(self.X1 - amountX' self.X2 + amountX);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountY < 0 && -amountY * 2 >= self.Height()) 				self.SetYAndHeight(MathEx.Average(self.Y1' self.Y2)' 0); 			else 				self.SetYRange(self.Y1 - amountY' self.Y2 + amountY);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountX < 0 && -amountX * 2 >= self.Width()) 				self.SetXAndWidth(MathEx.Average(self.X1' self.X2)' 0); 			else 				self.SetXRange(self.X1 - amountX' self.X2 + amountX);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountY < 0 && -amountY * 2 >= self.Height()) 				self.SetYAndHeight(MathEx.Average(self.Y1' self.Y2)' 0); 			else 				self.SetYRange(self.Y1 - amountY' self.Y2 + amountY);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountX < 0 && -amountX * 2 >= self.Width()) 				self.SetXAndWidth(MathEx.Average(self.X1' self.X2)' 0); 			else 				self.SetXRange(self.X1 - amountX' self.X2 + amountX);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountY < 0 && -amountY * 2 >= self.Height()) 				self.SetYAndHeight(MathEx.Average(self.Y1' self.Y2)' 0); 			else 				self.SetYRange(self.Y1 - amountY' self.Y2 + amountY);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountX < 0 && -amountX * 2 >= self.Width()) 				self.SetXAndWidth(MathEx.Average(self.X1' self.X2)' 0); 			else 				self.SetXRange(self.X1 - amountX' self.X2 + amountX);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountY < 0 && -amountY * 2 >= self.Height()) 				self.SetYAndHeight(MathEx.Average(self.Y1' self.Y2)' 0); 			else 				self.SetYRange(self.Y1 - amountY' self.Y2 + amountY);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountX < 0 && -amountX * 2 >= self.Width()) 				self.SetXAndWidth(MathEx.Average(self.X1' self.X2)' 0); 			else 				self.SetXRange(self.X1 - amountX' self.X2 + amountX);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountY < 0 && -amountY * 2 >= self.Height()) 				self.SetYAndHeight(MathEx.Average(self.Y1' self.Y2)' 0); 			else 				self.SetYRange(self.Y1 - amountY' self.Y2 + amountY);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountX < 0 && -amountX * 2 >= self.Width()) 				self.SetXAndWidth(MathEx.Average(self.X1' self.X2)' 0); 			else 				self.SetXRange(self.X1 - amountX' self.X2 + amountX);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountY < 0 && -amountY * 2 >= self.Height()) 				self.SetYAndHeight(MathEx.Average(self.Y1' self.Y2)' 0); 			else 				self.SetYRange(self.Y1 - amountY' self.Y2 + amountY);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountX < 0 && -amountX * 2 >= self.Width()) 				self.SetXAndWidth(MathEx.Average(self.X1' self.X2)' 0); 			else 				self.SetXRange(self.X1 - amountX' self.X2 + amountX);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountY < 0 && -amountY * 2 >= self.Height()) 				self.SetYAndHeight(MathEx.Average(self.Y1' self.Y2)' 0); 			else 				self.SetYRange(self.Y1 - amountY' self.Y2 + amountY);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountX < 0 && -amountX * 2 >= self.Width()) 				self.SetXAndWidth(MathEx.Average(self.X1' self.X2)' 0); 			else 				self.SetXRange(self.X1 - amountX' self.X2 + amountX);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountY < 0 && -amountY * 2 >= self.Height()) 				self.SetYAndHeight(MathEx.Average(self.Y1' self.Y2)' 0); 			else 				self.SetYRange(self.Y1 - amountY' self.Y2 + amountY);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountX < 0 && -amountX * 2 >= self.Width()) 				self.SetXAndWidth(MathEx.Average(self.X1' self.X2)' 0); 			else 				self.SetXRange(self.X1 - amountX' self.X2 + amountX);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountY < 0 && -amountY * 2 >= self.Height()) 				self.SetYAndHeight(MathEx.Average(self.Y1' self.Y2)' 0); 			else 				self.SetYRange(self.Y1 - amountY' self.Y2 + amountY);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountX < 0 && -amountX * 2 >= self.Width()) 				self.SetXAndWidth(MathEx.Average(self.X1' self.X2)' 0); 			else 				self.SetXRange(self.X1 - amountX' self.X2 + amountX);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountY < 0 && -amountY * 2 >= self.Height()) 				self.SetYAndHeight(MathEx.Average(self.Y1' self.Y2)' 0); 			else 				self.SetYRange(self.Y1 - amountY' self.Y2 + amountY);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountX < 0 && -amountX * 2 >= self.Width()) 				self.SetXAndWidth(MathEx.Average(self.X1' self.X2)' 0); 			else 				self.SetXRange(self.X1 - amountX' self.X2 + amountX);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountY < 0 && -amountY * 2 >= self.Height()) 				self.SetYAndHeight(MathEx.Average(self.Y1' self.Y2)' 0); 			else 				self.SetYRange(self.Y1 - amountY' self.Y2 + amountY);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountX < 0 && -amountX * 2 >= self.Width()) 				self.SetXAndWidth(MathEx.Average(self.X1' self.X2)' 0); 			else 				self.SetXRange(self.X1 - amountX' self.X2 + amountX);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountY < 0 && -amountY * 2 >= self.Height()) 				self.SetYAndHeight(MathEx.Average(self.Y1' self.Y2)' 0); 			else 				self.SetYRange(self.Y1 - amountY' self.Y2 + amountY);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountX < 0 && -amountX * 2 >= self.Width()) 				self.SetXAndWidth(MathEx.Average(self.X1' self.X2)' 0); 			else 				self.SetXRange(self.X1 - amountX' self.X2 + amountX);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountY < 0 && -amountY * 2 >= self.Height()) 				self.SetYAndHeight(MathEx.Average(self.Y1' self.Y2)' 0); 			else 				self.SetYRange(self.Y1 - amountY' self.Y2 + amountY);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountX < 0 && -amountX * 2 >= self.Width()) 				self.SetXAndWidth(MathEx.Average(self.X1' self.X2)' 0); 			else 				self.SetXRange(self.X1 - amountX' self.X2 + amountX);
Magic Number,Loyc.Geometry,BoundingBoxMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\BoundingBoxMathTT.cs,Inflate,The following statement contains a magic number: if (amountY < 0 && -amountY * 2 >= self.Height()) 				self.SetYAndHeight(MathEx.Average(self.Y1' self.Y2)' 0); 			else 				self.SetYRange(self.Y1 - amountY' self.Y2 + amountY);
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,SimplifyPolyline,The following statement contains a magic number: if (c <= 2) { 				// This block is mainly an optimization; it should not affect the  				// output' EXCEPT that this code also handles the case that the 				// input array contains 0 or 1 input points. 				if (inRecursion) 					c--; 				if (c > 0) { 					output.Add(points[0]); 					if (c > 1) 						output.Add(points[1]); 				} 				return c; 			}
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,SimplifyPolyline,The following statement contains a magic number: if (iFarthest == -1) { 				output.Add(from); 				if (inRecursion) 					return 1; 				output.Add(to); 				return 2; 			} else { 				int count = SimplifyPolyline(points.Slice(0' iFarthest + 1)' output' tolerance' distanceToLine' true); 				count    += SimplifyPolyline(points.Slice(iFarthest)' output' tolerance' distanceToLine' inRecursion); 				return count; 			}
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,Sides,The following statement contains a magic number: if (p.X > bbox.X2) sides |= 2;
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,Sides,The following statement contains a magic number: if (p.Y < bbox.Y1) sides |= 4;
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,Sides,The following statement contains a magic number: if (p.Y > bbox.Y2) sides |= 8;
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ClipTo,The following statement contains a magic number: if (sidesA == sidesB) { 				return sidesA == 0 ? (LineSegment<T>?)seg : null; 			} else if ((sidesA & sidesB) != 0) { 				return null; 			} else { 				int sides = sidesA | sidesB; 				if ((sides & 1) != 0) 					if (seg.A.X < seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X1); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X1); 				if ((sides & 2) != 0) 					if (seg.A.X > seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X2); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X2);  				if ((Sides(seg.A' bbox) & Sides(seg.B' bbox)) != 0) 					return null;  				if ((sides & 4) != 0) 					if (seg.A.Y < seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y1); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y1); 				if ((sides & 8) != 0) 					if (seg.A.Y > seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y2); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y2);  				return seg; 			}
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ClipTo,The following statement contains a magic number: if (sidesA == sidesB) { 				return sidesA == 0 ? (LineSegment<T>?)seg : null; 			} else if ((sidesA & sidesB) != 0) { 				return null; 			} else { 				int sides = sidesA | sidesB; 				if ((sides & 1) != 0) 					if (seg.A.X < seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X1); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X1); 				if ((sides & 2) != 0) 					if (seg.A.X > seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X2); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X2);  				if ((Sides(seg.A' bbox) & Sides(seg.B' bbox)) != 0) 					return null;  				if ((sides & 4) != 0) 					if (seg.A.Y < seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y1); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y1); 				if ((sides & 8) != 0) 					if (seg.A.Y > seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y2); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y2);  				return seg; 			}
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ClipTo,The following statement contains a magic number: if (sidesA == sidesB) { 				return sidesA == 0 ? (LineSegment<T>?)seg : null; 			} else if ((sidesA & sidesB) != 0) { 				return null; 			} else { 				int sides = sidesA | sidesB; 				if ((sides & 1) != 0) 					if (seg.A.X < seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X1); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X1); 				if ((sides & 2) != 0) 					if (seg.A.X > seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X2); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X2);  				if ((Sides(seg.A' bbox) & Sides(seg.B' bbox)) != 0) 					return null;  				if ((sides & 4) != 0) 					if (seg.A.Y < seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y1); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y1); 				if ((sides & 8) != 0) 					if (seg.A.Y > seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y2); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y2);  				return seg; 			}
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,Sides,The following statement contains a magic number: if (p.X > bbox.X2) sides |= 2;
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,Sides,The following statement contains a magic number: if (p.Y < bbox.Y1) sides |= 4;
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,Sides,The following statement contains a magic number: if (p.Y > bbox.Y2) sides |= 8;
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ClipTo,The following statement contains a magic number: if (sidesA == sidesB) { 				return sidesA == 0 ? (LineSegment<T>?)seg : null; 			} else if ((sidesA & sidesB) != 0) { 				return null; 			} else { 				int sides = sidesA | sidesB; 				if ((sides & 1) != 0) 					if (seg.A.X < seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X1); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X1); 				if ((sides & 2) != 0) 					if (seg.A.X > seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X2); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X2);  				if ((Sides(seg.A' bbox) & Sides(seg.B' bbox)) != 0) 					return null;  				if ((sides & 4) != 0) 					if (seg.A.Y < seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y1); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y1); 				if ((sides & 8) != 0) 					if (seg.A.Y > seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y2); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y2);  				return seg; 			}
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ClipTo,The following statement contains a magic number: if (sidesA == sidesB) { 				return sidesA == 0 ? (LineSegment<T>?)seg : null; 			} else if ((sidesA & sidesB) != 0) { 				return null; 			} else { 				int sides = sidesA | sidesB; 				if ((sides & 1) != 0) 					if (seg.A.X < seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X1); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X1); 				if ((sides & 2) != 0) 					if (seg.A.X > seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X2); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X2);  				if ((Sides(seg.A' bbox) & Sides(seg.B' bbox)) != 0) 					return null;  				if ((sides & 4) != 0) 					if (seg.A.Y < seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y1); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y1); 				if ((sides & 8) != 0) 					if (seg.A.Y > seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y2); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y2);  				return seg; 			}
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ClipTo,The following statement contains a magic number: if (sidesA == sidesB) { 				return sidesA == 0 ? (LineSegment<T>?)seg : null; 			} else if ((sidesA & sidesB) != 0) { 				return null; 			} else { 				int sides = sidesA | sidesB; 				if ((sides & 1) != 0) 					if (seg.A.X < seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X1); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X1); 				if ((sides & 2) != 0) 					if (seg.A.X > seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X2); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X2);  				if ((Sides(seg.A' bbox) & Sides(seg.B' bbox)) != 0) 					return null;  				if ((sides & 4) != 0) 					if (seg.A.Y < seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y1); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y1); 				if ((sides & 8) != 0) 					if (seg.A.Y > seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y2); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y2);  				return seg; 			}
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,Sides,The following statement contains a magic number: if (p.X > bbox.X2) sides |= 2;
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,Sides,The following statement contains a magic number: if (p.Y < bbox.Y1) sides |= 4;
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,Sides,The following statement contains a magic number: if (p.Y > bbox.Y2) sides |= 8;
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ClipTo,The following statement contains a magic number: if (sidesA == sidesB) { 				return sidesA == 0 ? (LineSegment<T>?)seg : null; 			} else if ((sidesA & sidesB) != 0) { 				return null; 			} else { 				int sides = sidesA | sidesB; 				if ((sides & 1) != 0) 					if (seg.A.X < seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X1); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X1); 				if ((sides & 2) != 0) 					if (seg.A.X > seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X2); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X2);  				if ((Sides(seg.A' bbox) & Sides(seg.B' bbox)) != 0) 					return null;  				if ((sides & 4) != 0) 					if (seg.A.Y < seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y1); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y1); 				if ((sides & 8) != 0) 					if (seg.A.Y > seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y2); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y2);  				return seg; 			}
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ClipTo,The following statement contains a magic number: if (sidesA == sidesB) { 				return sidesA == 0 ? (LineSegment<T>?)seg : null; 			} else if ((sidesA & sidesB) != 0) { 				return null; 			} else { 				int sides = sidesA | sidesB; 				if ((sides & 1) != 0) 					if (seg.A.X < seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X1); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X1); 				if ((sides & 2) != 0) 					if (seg.A.X > seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X2); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X2);  				if ((Sides(seg.A' bbox) & Sides(seg.B' bbox)) != 0) 					return null;  				if ((sides & 4) != 0) 					if (seg.A.Y < seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y1); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y1); 				if ((sides & 8) != 0) 					if (seg.A.Y > seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y2); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y2);  				return seg; 			}
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ClipTo,The following statement contains a magic number: if (sidesA == sidesB) { 				return sidesA == 0 ? (LineSegment<T>?)seg : null; 			} else if ((sidesA & sidesB) != 0) { 				return null; 			} else { 				int sides = sidesA | sidesB; 				if ((sides & 1) != 0) 					if (seg.A.X < seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X1); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X1); 				if ((sides & 2) != 0) 					if (seg.A.X > seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X2); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X2);  				if ((Sides(seg.A' bbox) & Sides(seg.B' bbox)) != 0) 					return null;  				if ((sides & 4) != 0) 					if (seg.A.Y < seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y1); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y1); 				if ((sides & 8) != 0) 					if (seg.A.Y > seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y2); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y2);  				return seg; 			}
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,Sides,The following statement contains a magic number: if (p.X > bbox.X2) sides |= 2;
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,Sides,The following statement contains a magic number: if (p.Y < bbox.Y1) sides |= 4;
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,Sides,The following statement contains a magic number: if (p.Y > bbox.Y2) sides |= 8;
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ClipTo,The following statement contains a magic number: if (sidesA == sidesB) { 				return sidesA == 0 ? (LineSegment<T>?)seg : null; 			} else if ((sidesA & sidesB) != 0) { 				return null; 			} else { 				int sides = sidesA | sidesB; 				if ((sides & 1) != 0) 					if (seg.A.X < seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X1); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X1); 				if ((sides & 2) != 0) 					if (seg.A.X > seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X2); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X2);  				if ((Sides(seg.A' bbox) & Sides(seg.B' bbox)) != 0) 					return null;  				if ((sides & 4) != 0) 					if (seg.A.Y < seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y1); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y1); 				if ((sides & 8) != 0) 					if (seg.A.Y > seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y2); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y2);  				return seg; 			}
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ClipTo,The following statement contains a magic number: if (sidesA == sidesB) { 				return sidesA == 0 ? (LineSegment<T>?)seg : null; 			} else if ((sidesA & sidesB) != 0) { 				return null; 			} else { 				int sides = sidesA | sidesB; 				if ((sides & 1) != 0) 					if (seg.A.X < seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X1); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X1); 				if ((sides & 2) != 0) 					if (seg.A.X > seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X2); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X2);  				if ((Sides(seg.A' bbox) & Sides(seg.B' bbox)) != 0) 					return null;  				if ((sides & 4) != 0) 					if (seg.A.Y < seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y1); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y1); 				if ((sides & 8) != 0) 					if (seg.A.Y > seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y2); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y2);  				return seg; 			}
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ClipTo,The following statement contains a magic number: if (sidesA == sidesB) { 				return sidesA == 0 ? (LineSegment<T>?)seg : null; 			} else if ((sidesA & sidesB) != 0) { 				return null; 			} else { 				int sides = sidesA | sidesB; 				if ((sides & 1) != 0) 					if (seg.A.X < seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X1); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X1); 				if ((sides & 2) != 0) 					if (seg.A.X > seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X2); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X2);  				if ((Sides(seg.A' bbox) & Sides(seg.B' bbox)) != 0) 					return null;  				if ((sides & 4) != 0) 					if (seg.A.Y < seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y1); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y1); 				if ((sides & 8) != 0) 					if (seg.A.Y > seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y2); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y2);  				return seg; 			}
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,Sides,The following statement contains a magic number: if (p.X > bbox.X2) sides |= 2;
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,Sides,The following statement contains a magic number: if (p.Y < bbox.Y1) sides |= 4;
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,Sides,The following statement contains a magic number: if (p.Y > bbox.Y2) sides |= 8;
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ClipTo,The following statement contains a magic number: if (sidesA == sidesB) { 				return sidesA == 0 ? (LineSegment<T>?)seg : null; 			} else if ((sidesA & sidesB) != 0) { 				return null; 			} else { 				int sides = sidesA | sidesB; 				if ((sides & 1) != 0) 					if (seg.A.X < seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X1); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X1); 				if ((sides & 2) != 0) 					if (seg.A.X > seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X2); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X2);  				if ((Sides(seg.A' bbox) & Sides(seg.B' bbox)) != 0) 					return null;  				if ((sides & 4) != 0) 					if (seg.A.Y < seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y1); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y1); 				if ((sides & 8) != 0) 					if (seg.A.Y > seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y2); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y2);  				return seg; 			}
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ClipTo,The following statement contains a magic number: if (sidesA == sidesB) { 				return sidesA == 0 ? (LineSegment<T>?)seg : null; 			} else if ((sidesA & sidesB) != 0) { 				return null; 			} else { 				int sides = sidesA | sidesB; 				if ((sides & 1) != 0) 					if (seg.A.X < seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X1); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X1); 				if ((sides & 2) != 0) 					if (seg.A.X > seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X2); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X2);  				if ((Sides(seg.A' bbox) & Sides(seg.B' bbox)) != 0) 					return null;  				if ((sides & 4) != 0) 					if (seg.A.Y < seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y1); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y1); 				if ((sides & 8) != 0) 					if (seg.A.Y > seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y2); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y2);  				return seg; 			}
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ClipTo,The following statement contains a magic number: if (sidesA == sidesB) { 				return sidesA == 0 ? (LineSegment<T>?)seg : null; 			} else if ((sidesA & sidesB) != 0) { 				return null; 			} else { 				int sides = sidesA | sidesB; 				if ((sides & 1) != 0) 					if (seg.A.X < seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X1); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X1); 				if ((sides & 2) != 0) 					if (seg.A.X > seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X2); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X2);  				if ((Sides(seg.A' bbox) & Sides(seg.B' bbox)) != 0) 					return null;  				if ((sides & 4) != 0) 					if (seg.A.Y < seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y1); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y1); 				if ((sides & 8) != 0) 					if (seg.A.Y > seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y2); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y2);  				return seg; 			}
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,Sides,The following statement contains a magic number: if (p.X > bbox.X2) sides |= 2;
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,Sides,The following statement contains a magic number: if (p.Y < bbox.Y1) sides |= 4;
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,Sides,The following statement contains a magic number: if (p.Y > bbox.Y2) sides |= 8;
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ClipTo,The following statement contains a magic number: if (sidesA == sidesB) { 				return sidesA == 0 ? (LineSegment<T>?)seg : null; 			} else if ((sidesA & sidesB) != 0) { 				return null; 			} else { 				int sides = sidesA | sidesB; 				if ((sides & 1) != 0) 					if (seg.A.X < seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X1); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X1); 				if ((sides & 2) != 0) 					if (seg.A.X > seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X2); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X2);  				if ((Sides(seg.A' bbox) & Sides(seg.B' bbox)) != 0) 					return null;  				if ((sides & 4) != 0) 					if (seg.A.Y < seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y1); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y1); 				if ((sides & 8) != 0) 					if (seg.A.Y > seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y2); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y2);  				return seg; 			}
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ClipTo,The following statement contains a magic number: if (sidesA == sidesB) { 				return sidesA == 0 ? (LineSegment<T>?)seg : null; 			} else if ((sidesA & sidesB) != 0) { 				return null; 			} else { 				int sides = sidesA | sidesB; 				if ((sides & 1) != 0) 					if (seg.A.X < seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X1); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X1); 				if ((sides & 2) != 0) 					if (seg.A.X > seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X2); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X2);  				if ((Sides(seg.A' bbox) & Sides(seg.B' bbox)) != 0) 					return null;  				if ((sides & 4) != 0) 					if (seg.A.Y < seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y1); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y1); 				if ((sides & 8) != 0) 					if (seg.A.Y > seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y2); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y2);  				return seg; 			}
Magic Number,Loyc.Geometry,LineMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\LineMath.cs,ClipTo,The following statement contains a magic number: if (sidesA == sidesB) { 				return sidesA == 0 ? (LineSegment<T>?)seg : null; 			} else if ((sidesA & sidesB) != 0) { 				return null; 			} else { 				int sides = sidesA | sidesB; 				if ((sides & 1) != 0) 					if (seg.A.X < seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X1); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X1); 				if ((sides & 2) != 0) 					if (seg.A.X > seg.B.X) 						seg.A = IntersectWithXEquals(ref seg' bbox.X2); 					else 						seg.B = IntersectWithXEquals(ref seg' bbox.X2);  				if ((Sides(seg.A' bbox) & Sides(seg.B' bbox)) != 0) 					return null;  				if ((sides & 4) != 0) 					if (seg.A.Y < seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y1); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y1); 				if ((sides & 8) != 0) 					if (seg.A.Y > seg.B.Y) 						seg.A = IntersectWithYEquals(ref seg' bbox.Y2); 					else 						seg.B = IntersectWithYEquals(ref seg' bbox.Y2);  				return seg; 			}
Magic Number,Loyc.Geometry,PointExt,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointExt.cs,Angle,The following statement contains a magic number: if (m.IsLess(angle' m.Zero)) 				return m.Add(angle' m.From(2*Math.PI));
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,Angle,The following statement contains a magic number: if (angle < 0) 				return angle + 2*Math.PI;
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,Angle,The following statement contains a magic number: if (angle < 0) 				return angle + 2*Math.PI;
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,AngleDeg,The following statement contains a magic number: return Angle(v) * (180 / Math.PI);
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,Angle,The following statement contains a magic number: if (angle < 0) 				return angle + 2*Math.PI;
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,AngleDeg,The following statement contains a magic number: return Angle(v) * (180 / Math.PI);
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,Angle,The following statement contains a magic number: if (angle < 0) 				return angle + 2*Math.PI;
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,AngleDeg,The following statement contains a magic number: return Angle(v) * (180 / Math.PI);
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,Angle,The following statement contains a magic number: if (angle < 0) 				return angle + 2*Math.PI;
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,AngleDeg,The following statement contains a magic number: return Angle(v) * (180 / Math.PI);
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,Angle,The following statement contains a magic number: if (angle < 0) 				return angle + 2*Math.PI;
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,AngleDeg,The following statement contains a magic number: return Angle(v) * (180 / Math.PI);
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,Angle,The following statement contains a magic number: if (angle < 0) 				return angle + 2*Math.PI;
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,AngleDeg,The following statement contains a magic number: return Angle(v) * (180 / Math.PI);
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,Angle,The following statement contains a magic number: if (angle < 0) 				return angle + 2*Math.PI;
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,AngleDeg,The following statement contains a magic number: return Angle(v) * (180 / Math.PI);
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,Angle,The following statement contains a magic number: if (angle < 0) 				return angle + 2*Math.PI;
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,AngleDeg,The following statement contains a magic number: return Angle(v) * (180 / Math.PI);
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,Angle,The following statement contains a magic number: if (angle < 0) 				return angle + 2*Math.PI;
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,AngleDeg,The following statement contains a magic number: return Angle(v) * (180 / Math.PI);
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PointMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PointMath.cs,ComputeConvexHull,The following statement contains a magic number: for (int i = points.Count - 1; i >= 0 ; i--) 			{ 				// right turn (clockwise) => negative cross product (for Y-up coords) 				Point p = points[i]' p1;  				// build lower hull (at end of output list) 				while (L >= 2 && (p1 = hull.Last).Sub(hull[hull.Count-2]).Cross(p.Sub(p1)) >= 0) { 					hull.RemoveAt(hull.Count-1); 					L--; 				} 				hull.PushLast(p); 				L++;  				// build upper hull (at beginning of output list) 				while (U >= 2 && (p1 = hull.First).Sub(hull[1]).Cross(p.Sub(p1)) <= 0) { 					hull.RemoveAt(0); 					U--; 				} 				if (U != 0) // when U == 0' share the point added above 					hull.PushFirst(p); 				U++; 				Debug.Assert(U + L == hull.Count + 1); 			}
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (long)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (float)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (double)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (FPL16)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (FPL32)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (long)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (float)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (double)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (FPL16)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (FPL32)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (long)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (float)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (double)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (FPL16)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (FPL32)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (long)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (float)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (double)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (FPL16)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (FPL32)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (long)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (float)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (double)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (FPL16)2;
Magic Number,Loyc.Geometry,PolygonMath,C:\repos\qwertie_Loyc\Core\Loyc.Math\Geometry\PolygonMathTT.cs,PolygonArea,The following statement contains a magic number: return area / (FPL32)2;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Sign,The following statement contains a magic number: return (num >> 31) | (num != 0 ? 1 : 0);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Sign,The following statement contains a magic number: return (int)(num >> 63) | (num != 0 ? 1 : 0);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Mod,The following statement contains a magic number: return m + ((m >> 31) & y);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,RoL,The following statement contains a magic number: return (value << amt) | (value >> (32 - amt));
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,RoL,The following statement contains a magic number: return (int)(((uint)value << amt) | ((uint)value >> (32 - amt)));
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,RoL,The following statement contains a magic number: return (value << amt) | (value >> (64 - amt));
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,RoL,The following statement contains a magic number: return (long)(((ulong)value << amt) | ((ulong)value >> (64 - amt)));
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,RoL,The following statement contains a magic number: return (ushort)((value << amt) | (value >> (16 - amt)));
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,RoL,The following statement contains a magic number: return (byte)((value << amt) | (value >> (8 - amt)));
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,RoR,The following statement contains a magic number: return (value >> amt) | (value << (32 - amt));
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,RoR,The following statement contains a magic number: return (int)(((uint)value >> amt) | ((uint)value << (32 - amt)));
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,RoR,The following statement contains a magic number: return (value >> amt) | (value << (64 - amt));
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,RoR,The following statement contains a magic number: return (long)(((ulong)value >> amt) | ((ulong)value << (32 - amt)));
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,RoR,The following statement contains a magic number: return (ushort)((value >> amt) | (value << (16 - amt)));
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,RoR,The following statement contains a magic number: return (byte)((value >> amt) | (value << (8 - amt)));
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,get_ones,The following statement contains a magic number: var ones = new byte[256];
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,CountOnes,The following statement contains a magic number: return (_ones[(byte)x] + _ones[(byte)(x >> 8)])  		         + (_ones[(byte)(x >> 16)] + _ones[x >> 24]);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,CountOnes,The following statement contains a magic number: return (_ones[(byte)x] + _ones[(byte)(x >> 8)])  		         + (_ones[(byte)(x >> 16)] + _ones[x >> 24]);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,CountOnes,The following statement contains a magic number: return (_ones[(byte)x] + _ones[(byte)(x >> 8)])  		         + (_ones[(byte)(x >> 16)] + _ones[x >> 24]);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,CountOnes,The following statement contains a magic number: return _ones[(byte)x] + _ones[x >> 8];
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,CountOnes,The following statement contains a magic number: x = (((x >> 2) & 0x3333333333333333u) + (x & 0x3333333333333333u));
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,CountOnes,The following statement contains a magic number: x = (((x >> 4) + x) & 0x0f0f0f0f0f0f0f0fu);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,CountOnes,The following statement contains a magic number: x += (x >> 8);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,CountOnes,The following statement contains a magic number: x += (x >> 16);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,CountOnes,The following statement contains a magic number: int x32 = (int)x + (int)(x >> 32);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Log2Floor,The following statement contains a magic number: x |= (x >> 2);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Log2Floor,The following statement contains a magic number: x |= (x >> 4);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Log2Floor,The following statement contains a magic number: x |= (x >> 8);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Log2Floor,The following statement contains a magic number: x |= (x >> 16);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Log2Floor,The following statement contains a magic number: uint xHi = (uint)(x >> 32);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Log2Floor,The following statement contains a magic number: if (xHi != 0) 				return 32 + Log2Floor(xHi);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,NextPowerOf2,The following statement contains a magic number: x |= (x >> 2);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,NextPowerOf2,The following statement contains a magic number: x |= (x >> 4);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,NextPowerOf2,The following statement contains a magic number: x |= (x >> 8);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,NextPowerOf2,The following statement contains a magic number: x |= (x >> 16);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,NextPowerOf2,The following statement contains a magic number: x |= (x >> 2);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,NextPowerOf2,The following statement contains a magic number: x |= (x >> 4);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,NextPowerOf2,The following statement contains a magic number: x |= (x >> 8);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,NextPowerOf2,The following statement contains a magic number: x |= (x >> 16);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,NextPowerOf2,The following statement contains a magic number: x |= (x >> 32);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindFirstOne,The following statement contains a magic number: if ((ushort)i == 0) 			{ 				i >>= 16; 				result += 16; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindFirstOne,The following statement contains a magic number: if ((ushort)i == 0) 			{ 				i >>= 16; 				result += 16; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindFirstOne,The following statement contains a magic number: if ((byte)i == 0) 			{ 				i >>= 8; 				result += 8; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindFirstOne,The following statement contains a magic number: if ((byte)i == 0) 			{ 				i >>= 8; 				result += 8; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindFirstOne,The following statement contains a magic number: if ((i & 0xF) == 0) 			{ 				i >>= 4; 				result += 4; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindFirstOne,The following statement contains a magic number: if ((i & 0xF) == 0) 			{ 				i >>= 4; 				result += 4; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindFirstOne,The following statement contains a magic number: if ((i & 3) == 0) 			{ 				i >>= 2; 				result += 2; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindFirstOne,The following statement contains a magic number: if ((i & 3) == 0) 			{ 				i >>= 2; 				result += 2; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindFirstOne,The following statement contains a magic number: if ((i & 3) == 0) 			{ 				i >>= 2; 				result += 2; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindFirstOne,The following statement contains a magic number: if ((i & 1) == 0) 			{ 				result += 1; 				if ((i & 2) == 0) 				{ 					Debug.Assert(result == 31); 					return -1; 				} 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindFirstOne,The following statement contains a magic number: if ((i & 1) == 0) 			{ 				result += 1; 				if ((i & 2) == 0) 				{ 					Debug.Assert(result == 31); 					return -1; 				} 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindLastOne,The following statement contains a magic number: int result = 31;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindLastOne,The following statement contains a magic number: if (i >> 16 == 0) 			{ 				i <<= 16; 				result -= 16; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindLastOne,The following statement contains a magic number: if (i >> 16 == 0) 			{ 				i <<= 16; 				result -= 16; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindLastOne,The following statement contains a magic number: if (i >> 16 == 0) 			{ 				i <<= 16; 				result -= 16; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindLastOne,The following statement contains a magic number: if (i >> 24 == 0) 			{ 				i <<= 8; 				result -= 8; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindLastOne,The following statement contains a magic number: if (i >> 24 == 0) 			{ 				i <<= 8; 				result -= 8; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindLastOne,The following statement contains a magic number: if (i >> 24 == 0) 			{ 				i <<= 8; 				result -= 8; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindLastOne,The following statement contains a magic number: if (i >> 28 == 0) 			{ 				i <<= 4; 				result -= 4; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindLastOne,The following statement contains a magic number: if (i >> 28 == 0) 			{ 				i <<= 4; 				result -= 4; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindLastOne,The following statement contains a magic number: if (i >> 28 == 0) 			{ 				i <<= 4; 				result -= 4; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindLastOne,The following statement contains a magic number: if (i >> 30 == 0) 			{ 				i <<= 2; 				result -= 2; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindLastOne,The following statement contains a magic number: if (i >> 30 == 0) 			{ 				i <<= 2; 				result -= 2; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindLastOne,The following statement contains a magic number: if (i >> 30 == 0) 			{ 				i <<= 2; 				result -= 2; 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,FindLastOne,The following statement contains a magic number: if (i >> 31 == 0) 			{ 				result -= 1; 				if (i == 0) 				{ 					Debug.Assert(result == 0); 					return -1; 				} 			}
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Int32BitsToSingle,The following statement contains a magic number: byte[] buf = new byte[4];
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Int32BitsToSingle,The following statement contains a magic number: buf[1] = (byte)(bits >> 8);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Int32BitsToSingle,The following statement contains a magic number: buf[2] = (byte)(bits >> 16);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Int32BitsToSingle,The following statement contains a magic number: buf[2] = (byte)(bits >> 16);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Int32BitsToSingle,The following statement contains a magic number: buf[3] = (byte)(bits >> 24);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Int32BitsToSingle,The following statement contains a magic number: buf[3] = (byte)(bits >> 24);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Export,The following statement contains a magic number: buf[1] = (byte)(bits >> 8);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Export,The following statement contains a magic number: buf[2] = (byte)(bits >> 16);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Export,The following statement contains a magic number: buf[2] = (byte)(bits >> 16);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Export,The following statement contains a magic number: buf[3] = (byte)(bits >> 24);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Export,The following statement contains a magic number: buf[3] = (byte)(bits >> 24);
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,ShiftLeft,The following statement contains a magic number: if (amount >= 0) 				return amount > 31 ? num << 31 : num << amount; 			else 				return amount < -31 ? num >> 31 : num >> -amount;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,ShiftLeft,The following statement contains a magic number: if (amount >= 0) 				return amount > 31 ? num << 31 : num << amount; 			else 				return amount < -31 ? num >> 31 : num >> -amount;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,ShiftLeft,The following statement contains a magic number: if (amount >= 0) 				return amount > 31 ? num << 31 : num << amount; 			else 				return amount < -31 ? num >> 31 : num >> -amount;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,ShiftLeft,The following statement contains a magic number: if (amount >= 0) 				return amount > 31 ? num << 31 : num << amount; 			else 				return amount < -31 ? num >> 31 : num >> -amount;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,ShiftRight,The following statement contains a magic number: if (amount >= 0) 				return amount > 31 ? num >> 31 : num >> amount; 			else 				return -amount > 31 ? num << 31 : num << -amount;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,ShiftRight,The following statement contains a magic number: if (amount >= 0) 				return amount > 31 ? num >> 31 : num >> amount; 			else 				return -amount > 31 ? num << 31 : num << -amount;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,ShiftRight,The following statement contains a magic number: if (amount >= 0) 				return amount > 31 ? num >> 31 : num >> amount; 			else 				return -amount > 31 ? num << 31 : num << -amount;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,ShiftRight,The following statement contains a magic number: if (amount >= 0) 				return amount > 31 ? num >> 31 : num >> amount; 			else 				return -amount > 31 ? num << 31 : num << -amount;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,ShiftLeft,The following statement contains a magic number: if (amount >= 0) 				return amount > 63 ? num << 63 : num << amount; 			else 				return -amount > 63 ? num >> 63 : num >> -amount;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,ShiftLeft,The following statement contains a magic number: if (amount >= 0) 				return amount > 63 ? num << 63 : num << amount; 			else 				return -amount > 63 ? num >> 63 : num >> -amount;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,ShiftLeft,The following statement contains a magic number: if (amount >= 0) 				return amount > 63 ? num << 63 : num << amount; 			else 				return -amount > 63 ? num >> 63 : num >> -amount;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,ShiftLeft,The following statement contains a magic number: if (amount >= 0) 				return amount > 63 ? num << 63 : num << amount; 			else 				return -amount > 63 ? num >> 63 : num >> -amount;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,ShiftRight,The following statement contains a magic number: if (amount >= 0) 				return amount > 63 ? num >> 63 : num >> amount; 			else 				return -amount > 63 ? num << 63 : num << -amount;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,ShiftRight,The following statement contains a magic number: if (amount >= 0) 				return amount > 63 ? num >> 63 : num >> amount; 			else 				return -amount > 63 ? num << 63 : num << -amount;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,ShiftRight,The following statement contains a magic number: if (amount >= 0) 				return amount > 63 ? num >> 63 : num >> amount; 			else 				return -amount > 63 ? num << 63 : num << -amount;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,ShiftRight,The following statement contains a magic number: if (amount >= 0) 				return amount > 63 ? num >> 63 : num >> amount; 			else 				return -amount > 63 ? num << 63 : num << -amount;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Average,The following statement contains a magic number: return x * 0.5 + y * 0.5;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,Average,The following statement contains a magic number: return x * 0.5 + y * 0.5;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,IsPrime,The following statement contains a magic number: if (num <= 3) 				return num >= 2;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,IsPrime,The following statement contains a magic number: if (num <= 3) 				return num >= 2;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,IsPrime,The following statement contains a magic number: if (num % 3 == 0) // avoid the work of Sqrt in many cases 				return false;
Magic Number,Loyc.Math,MathEx,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\MathEx.cs,IsPrime,The following statement contains a magic number: for (int candidate = 4; candidate <= root; candidate++) 				if (num % candidate == 0) 					return false;
Magic Number,Loyc.Math,FPI8,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\FixedPoint.cs,Sqrt,The following statement contains a magic number: if ((uint)N <= (uint)MaxInt) 				return Prescaled((Int32)MathEx.Sqrt((uint)N << Frac)); 			else 				// Compute lower-precision answer (this path is also taken if N is negative) 				return Prescaled(MathEx.Sqrt(N) << Frac/2);
Magic Number,Loyc.Math,FPI16,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\FixedPoint.cs,Sqrt,The following statement contains a magic number: if ((uint)N <= (uint)MaxInt) 				return Prescaled((Int32)MathEx.Sqrt((uint)N << Frac)); 			else 				// Compute lower-precision answer (this path is also taken if N is negative) 				return Prescaled(MathEx.Sqrt(N) << Frac/2);
Magic Number,Loyc.Math,FPI23,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\FixedPoint.cs,Sqrt,The following statement contains a magic number: if ((uint)N <= (uint)MaxInt) 				return Prescaled((Int32)MathEx.Sqrt((uint)N << Frac)); 			else 				// Compute lower-precision answer (this path is also taken if N is negative) 				return Prescaled(MathEx.Sqrt(N << 1) << Frac/2);
Magic Number,Loyc.Math,FPL16,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\FixedPoint.cs,Sqrt,The following statement contains a magic number: if ((ulong)N <= (ulong)MaxInt) 				return Prescaled((Int64)MathEx.Sqrt((ulong)N << Frac)); 			else 				// Compute lower-precision answer (this path is also taken if N is negative) 				return Prescaled(MathEx.Sqrt(N) << Frac/2);
Magic Number,Loyc.Math,FPL32,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\FixedPoint.cs,Sqrt,The following statement contains a magic number: if ((ulong)N <= (ulong)MaxInt) 				return Prescaled((Int64)MathEx.Sqrt((ulong)N << Frac)); 			else 				// Compute lower-precision answer (this path is also taken if N is negative) 				return Prescaled(MathEx.Sqrt(N) << Frac/2);
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Multiply,The following statement contains a magic number: uint aH = (uint)(a >> 32)' aL = (uint)a;
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Multiply,The following statement contains a magic number: uint bH = (uint)(b >> 32)' bL = (uint)b;
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Multiply,The following statement contains a magic number: resultHi = (ulong)aH * bH + (mid >> 32);
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Multiply,The following statement contains a magic number: ulong lo = lo1 + (mid << 32);
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Multiply,The following statement contains a magic number: if (mid < mid1) 				resultHi += (1 << 32);
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,Divide,The following statement contains a magic number: if ((b >> 32) == 0) 			{ 				// 128/32-bit division 				uint bL = (uint)b;  				// Optimize for b=1 and b=2 				if (bL <= 2) 				{ 					if (bL == 2) { 						remainder = aL & 1; 						resultHi = ShiftRightFast(aH' ref aL' 1); 						return aL; 					} 					if (bL == 1) { 						remainder = 0; 						resultHi = aH; 						return aL; 					} 					throw new DivideByZeroException(); 				}  				uint a4; 				ulong a3' a2' a1; 				uint result4' result3' result2' result1; 				uint r;  				// There are obvious machine-language optimizations here... 				// I hope the JIT is smart enough to see them. 				a4 = (uint)(aH >> 32); 				if (a4 == 0) 					r = result4 = 0; 				else { 					result4 = a4 / bL; 					r = a4 % bL; 				}  				a3 = ((ulong)r << 32) + (uint)aH; 				result3 = (uint)(a3 / bL); 				r = (uint)(a3 % bL);  				a2 = ((ulong)r << 32) + (uint)(aL >> 32); 				result2 = (uint)(a2 / bL); 				r = (uint)(a2 % bL);  				a1 = ((ulong)r << 32) + (uint)aL; 				result1 = (uint)(a1 / bL); 				r = (uint)(a1 % bL);  				resultHi = (ulong)(result4 << 32) + result3; 				remainder = r; 				return (ulong)(result2 << 32) + result1; 			} 			else 			{ 				Debug.Assert(aH != 0); 				int iterations = 128;  				// Optimization 1: skip loop iterations that have no effect 				if ((aH >> 32) == 0) { 					aH = ShiftLeftFast(aH' ref aL' 32); 					iterations -= 32; 				} 				if (aH < (1 << (64-16))) { 					aH = ShiftLeftFast(aH' ref aL' 16); 					iterations -= 16; 				} 				if (aH < (1 << (64-8))) { 					aH = ShiftLeftFast(aH' ref aL' 8); 					iterations -= 8; 				} 				if (aH < (1 << (64-4))) { 					aH = ShiftLeftFast(aH' ref aL' 4); 					iterations -= 4; 				} 				if (aH < (1 << (64-2))) { 					aH = ShiftLeftFast(aH' ref aL' 2); 					iterations -= 2; 				}  				// Optimization 2: get a head start by shifting some bits into  				// 'remainder'' but not enough to change the outcome. 				Debug.Assert(b > uint.MaxValue); 				int skip = MathEx.Log2Floor((uint)(b >> 32)) + 32; 				iterations -= skip; 				remainder = ShiftLeftEx(ref aH' ref aL' skip);  				// The core division algorithm is based on the assembly code in  				// http://www.codeproject.com/KB/recipes/MulDiv64.aspx 				// Unoptimized' it required an iteration for every bit of the input  				// (a). The way it works is slightly subtle. The dividend 'a'  				// slowly becomes the output as the loop progresses. The original  				// bits of 'a' are shifted left one-by-one into 'remainder'' and 'a' 				// is shifted 128 times so it eventually disappears. Meanwhile' the  				// bits of the result are determined one-at-a-time and are shifted  				// in as the new low bits of 'a'. In general' this is more efficient  				// than using separate variables for the dividend and the result. 				Debug.Assert(remainder < b); 				for (; iterations != 0; iterations--) { 					ulong oldH = aH' oldL = aL' oldR = remainder; 					remainder <<= 1; 					aH <<= 1; 					if (aH < oldH) // aH overflowed? 						++remainder; 					aL <<= 1; 					if (aL < oldL) // aL overflowed? 						++aH; 					if (remainder < oldR || remainder >= b) 					{ 						remainder -= b; 						if (++aL == 0) // aL overflowed? 							++aH; 					} 				}  				resultHi = aH; 				return aL; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftLeft,The following statement contains a magic number: if (amount < 64) 				return ShiftLeftFast(aH' ref aL' amount); 			else { 				if (amount >= 128) 					aH = 0; 				else 					aH = aL << (amount - 64); 				aL = 0; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftLeft,The following statement contains a magic number: if (amount < 64) 				return ShiftLeftFast(aH' ref aL' amount); 			else { 				if (amount >= 128) 					aH = 0; 				else 					aH = aL << (amount - 64); 				aL = 0; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftLeft,The following statement contains a magic number: if (amount < 64) 				return ShiftLeftFast(aH' ref aL' amount); 			else { 				if (amount >= 128) 					aH = 0; 				else 					aH = aL << (amount - 64); 				aL = 0; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftLeftFast,The following statement contains a magic number: aH = (aH << amount) + (aL >> (64-amount));
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftLeftEx,The following statement contains a magic number: if (amount < 64) { 				ulong newL = (aL << amount); 				ulong newH = (aH << amount) + (aL >> (64-amount)); 				overflow =                    (aH >> (64-amount)); 				aL = newL; 				aH = newH; 			} else if (amount < 128) { 				overflow = aL >> (128-amount); 				aH = aL << (amount-64); 				aL = 0; 			} else if (amount < 192) { 				overflow = (aL << (amount-128)); 				aH = aL = 0; 			} else { 				aH = aL = 0; 				return 0; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftLeftEx,The following statement contains a magic number: if (amount < 64) { 				ulong newL = (aL << amount); 				ulong newH = (aH << amount) + (aL >> (64-amount)); 				overflow =                    (aH >> (64-amount)); 				aL = newL; 				aH = newH; 			} else if (amount < 128) { 				overflow = aL >> (128-amount); 				aH = aL << (amount-64); 				aL = 0; 			} else if (amount < 192) { 				overflow = (aL << (amount-128)); 				aH = aL = 0; 			} else { 				aH = aL = 0; 				return 0; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftLeftEx,The following statement contains a magic number: if (amount < 64) { 				ulong newL = (aL << amount); 				ulong newH = (aH << amount) + (aL >> (64-amount)); 				overflow =                    (aH >> (64-amount)); 				aL = newL; 				aH = newH; 			} else if (amount < 128) { 				overflow = aL >> (128-amount); 				aH = aL << (amount-64); 				aL = 0; 			} else if (amount < 192) { 				overflow = (aL << (amount-128)); 				aH = aL = 0; 			} else { 				aH = aL = 0; 				return 0; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftLeftEx,The following statement contains a magic number: if (amount < 64) { 				ulong newL = (aL << amount); 				ulong newH = (aH << amount) + (aL >> (64-amount)); 				overflow =                    (aH >> (64-amount)); 				aL = newL; 				aH = newH; 			} else if (amount < 128) { 				overflow = aL >> (128-amount); 				aH = aL << (amount-64); 				aL = 0; 			} else if (amount < 192) { 				overflow = (aL << (amount-128)); 				aH = aL = 0; 			} else { 				aH = aL = 0; 				return 0; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftLeftEx,The following statement contains a magic number: if (amount < 64) { 				ulong newL = (aL << amount); 				ulong newH = (aH << amount) + (aL >> (64-amount)); 				overflow =                    (aH >> (64-amount)); 				aL = newL; 				aH = newH; 			} else if (amount < 128) { 				overflow = aL >> (128-amount); 				aH = aL << (amount-64); 				aL = 0; 			} else if (amount < 192) { 				overflow = (aL << (amount-128)); 				aH = aL = 0; 			} else { 				aH = aL = 0; 				return 0; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftLeftEx,The following statement contains a magic number: if (amount < 64) { 				ulong newL = (aL << amount); 				ulong newH = (aH << amount) + (aL >> (64-amount)); 				overflow =                    (aH >> (64-amount)); 				aL = newL; 				aH = newH; 			} else if (amount < 128) { 				overflow = aL >> (128-amount); 				aH = aL << (amount-64); 				aL = 0; 			} else if (amount < 192) { 				overflow = (aL << (amount-128)); 				aH = aL = 0; 			} else { 				aH = aL = 0; 				return 0; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftLeftEx,The following statement contains a magic number: if (amount < 64) { 				ulong newL = (aL << amount); 				ulong newH = (aH << amount) + (aL >> (64-amount)); 				overflow =                    (aH >> (64-amount)); 				aL = newL; 				aH = newH; 			} else if (amount < 128) { 				overflow = aL >> (128-amount); 				aH = aL << (amount-64); 				aL = 0; 			} else if (amount < 192) { 				overflow = (aL << (amount-128)); 				aH = aL = 0; 			} else { 				aH = aL = 0; 				return 0; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftLeftEx,The following statement contains a magic number: if (amount < 64) { 				ulong newL = (aL << amount); 				ulong newH = (aH << amount) + (aL >> (64-amount)); 				overflow =                    (aH >> (64-amount)); 				aL = newL; 				aH = newH; 			} else if (amount < 128) { 				overflow = aL >> (128-amount); 				aH = aL << (amount-64); 				aL = 0; 			} else if (amount < 192) { 				overflow = (aL << (amount-128)); 				aH = aL = 0; 			} else { 				aH = aL = 0; 				return 0; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftRight,The following statement contains a magic number: if (amount < 64) 				return ShiftRightFast(aH' ref aL' amount); 			else { 				if (amount >= 128) 					aL = 0; 				else 					aL = aH >> (amount - 64); 				aH = 0; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftRight,The following statement contains a magic number: if (amount < 64) 				return ShiftRightFast(aH' ref aL' amount); 			else { 				if (amount >= 128) 					aL = 0; 				else 					aL = aH >> (amount - 64); 				aH = 0; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftRight,The following statement contains a magic number: if (amount < 64) 				return ShiftRightFast(aH' ref aL' amount); 			else { 				if (amount >= 128) 					aL = 0; 				else 					aL = aH >> (amount - 64); 				aH = 0; 			}
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftRightFast,The following statement contains a magic number: aL = (aL >> amount) + (aH << (64-amount));
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftRight,The following statement contains a magic number: if (amount < 64) 				return ShiftRightFast(aH' ref aL' amount); 			else if (amount < 127) { 				aL = (ulong)(aH >> (amount - 64)); 				aH >>= 63; // keep only the sign 			} else 				aL = (ulong)(aH >>= 63);
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftRight,The following statement contains a magic number: if (amount < 64) 				return ShiftRightFast(aH' ref aL' amount); 			else if (amount < 127) { 				aL = (ulong)(aH >> (amount - 64)); 				aH >>= 63; // keep only the sign 			} else 				aL = (ulong)(aH >>= 63);
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftRight,The following statement contains a magic number: if (amount < 64) 				return ShiftRightFast(aH' ref aL' amount); 			else if (amount < 127) { 				aL = (ulong)(aH >> (amount - 64)); 				aH >>= 63; // keep only the sign 			} else 				aL = (ulong)(aH >>= 63);
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftRight,The following statement contains a magic number: if (amount < 64) 				return ShiftRightFast(aH' ref aL' amount); 			else if (amount < 127) { 				aL = (ulong)(aH >> (amount - 64)); 				aH >>= 63; // keep only the sign 			} else 				aL = (ulong)(aH >>= 63);
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftRight,The following statement contains a magic number: if (amount < 64) 				return ShiftRightFast(aH' ref aL' amount); 			else if (amount < 127) { 				aL = (ulong)(aH >> (amount - 64)); 				aH >>= 63; // keep only the sign 			} else 				aL = (ulong)(aH >>= 63);
Magic Number,Loyc.Math,Math128,C:\repos\qwertie_Loyc\Core\Loyc.Math\Math\Math128.cs,ShiftRightFast,The following statement contains a magic number: aL = (aL >> amount) + ((ulong)aH << (64-amount));
