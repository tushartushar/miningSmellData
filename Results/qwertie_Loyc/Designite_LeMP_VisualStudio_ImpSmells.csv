Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Loyc.VisualStudio,SyntaxAnalyzerForVS<ParseResults>,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\SyntaxAnalyzerForVS.cs,GetTags,Cyclomatic complexity of the method is 8
Complex Method,Loyc.VisualStudio,SyntaxClassifierForVS,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\SyntaxClassifierForVS.cs,RunLexerUntil,Cyclomatic complexity of the method is 8
Complex Method,VS.Common,BraceMatchingTagger,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\BraceMatchingTagger.cs,FindMatchingOpenChar,Cyclomatic complexity of the method is 8
Long Parameter List,Loyc,CustomToolBase,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SFG\CustomToolBase.cs,Generate,The method has 6 parameters. Parameters: inputFilePath' inputFileContents' defaultNamespace' outputFileContents' outputSize' progressCallback
Long Parameter List,Loyc.VisualStudio,LeMPCustomTool,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SFG\LoycCustomTools.cs,ReportErrorToVS,The method has 5 parameters. Parameters: generatorProgress' severity' context' message' args
Long Parameter List,VS.Common,BraceMatchingTagger,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\BraceMatchingTagger.cs,FindMatchingCloseChar,The method has 6 parameters. Parameters: start' classifier' open' close' maxLines' pairSpan
Long Parameter List,VS.Common,BraceMatchingTagger,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\BraceMatchingTagger.cs,FindMatchingOpenChar,The method has 6 parameters. Parameters: start' aggregator' open' close' maxLines' pairSpan
Long Statement,Loyc.VisualStudio,Les2SyntaxForVSProvider,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\Les2SyntaxForVs.cs,Get,The length of the statement  "			return buffer.Properties.GetOrCreateSingletonProperty<Les2SyntaxForVS>(() => new Les2SyntaxForVS(new VSBuffer(vs' buffer)));" is 124.
Long Statement,Loyc.VisualStudio,Les3SyntaxForVSProvider,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\Les3SyntaxForVS.cs,Get,The length of the statement  "			return buffer.Properties.GetOrCreateSingletonProperty<Les3SyntaxForVS>(() => new Les3SyntaxForVS(new VSBuffer(vs' buffer)));" is 124.
Long Statement,Loyc.VisualStudio,SampleLanguageForVS,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\SampleLanguage.cs,OnRunSucceeded,The length of the statement  "				TagsChanged(this' new SnapshotSpanEventArgs(new SnapshotSpan(_buffer.CurrentSnapshot' new Span(0' _buffer.CurrentSnapshot.Length))));" is 133.
Long Statement,Loyc.VisualStudio,SyntaxAnalyzerForVS<ParseResults>,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\SyntaxAnalyzerForVS.cs,GetTags,The length of the statement  "			//return new ITagSpan<ErrorTag>[] { new TagSpan<ErrorTag>(sspan' new ErrorTag("compiler warning"' "Example warning tag")) };" is 124.
Long Statement,VS.Common,BraceMatchingTagger,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\BraceMatchingTagger.cs,FindMatchingCloseChar,The length of the statement  "					if (currentChar == close && !IsInCommentOrLiteral(classifier' new SnapshotPoint(start.Snapshot' offset + line.Start.Position)' PositionAffinity.Successor))" is 155.
Long Statement,VS.Common,BraceMatchingTagger,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\BraceMatchingTagger.cs,FindMatchingCloseChar,The length of the statement  "					else if (currentChar == open && !IsInCommentOrLiteral(classifier' new SnapshotPoint(start.Snapshot' offset + line.Start.Position)' PositionAffinity.Successor))" is 159.
Long Statement,VS.Common,BraceMatchingTagger,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\BraceMatchingTagger.cs,FindMatchingOpenChar,The length of the statement  "					if (currentChar == open && !IsInCommentOrLiteral(aggregator' new SnapshotPoint(start.Snapshot' offset + line.Start.Position)' PositionAffinity.Successor))" is 154.
Long Statement,VS.Common,BraceMatchingTagger,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\BraceMatchingTagger.cs,FindMatchingOpenChar,The length of the statement  "					else if (currentChar == close && !IsInCommentOrLiteral(aggregator' new SnapshotPoint(start.Snapshot' offset + line.Start.Position)' PositionAffinity.Successor))" is 160.
Long Statement,VS.Common,BraceMatchingTagger,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\BraceMatchingTagger.cs,GetTags,The length of the statement  "				if (BraceMatchingTagger.FindMatchingCloseChar(currentChar' Classifier' currentText' closeChar' 10 * TextView.TextViewLines.Count' out pairSpan))" is 144.
Long Statement,VS.Common,BraceMatchingTagger,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\BraceMatchingTagger.cs,GetTags,The length of the statement  "				if (BraceMatchingTagger.FindMatchingOpenChar(lastChar' Classifier' open' lastText' 10 * TextView.TextViewLines.Count' out pairSpan))" is 132.
Long Statement,VS.Common,BraceMatchingTagger,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\BraceMatchingTagger.cs,UpdateAtCaretPosition,The length of the statement  "				t(this' new SnapshotSpanEventArgs(new SnapshotSpan(SourceBuffer.CurrentSnapshot' 0' SourceBuffer.CurrentSnapshot.Length)));" is 123.
Complex Conditional,Loyc.VisualStudio,SampleLanguageForVS,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\SampleLanguage.cs,GetLineClassification,The conditional expression  "i < line.Snapshot.Length &&  				(line.Snapshot[i] == '#' || 				 line.Snapshot[i] == '/' && i + 1 < line.Snapshot.Length && line.Snapshot[i+1] == '/')"  is complex.
Complex Conditional,Loyc.VisualStudio,SyntaxClassifierForVS,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\SyntaxClassifierForVS.cs,TokenToVSClassification,The conditional expression  "t.Value is int || t.Value is uint || t.Value is sbyte || t.Value is byte 						|| t.Value is short || t.Value is ushort || t.Value is long || t.Value is ulong 						|| t.Value is float || t.Value is double || t.Value is decimal"  is complex.
Magic Number,Loyc.VisualStudio,LeMPCustomTool,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SFG\LoycCustomTools.cs,Generate,The following statement contains a magic number: try { 				string inputFolder = Path.GetDirectoryName(inputFilePath);  				Environment.CurrentDirectory = inputFolder; // --macros should be relative to file being processed  				// Originally I wrote a conversion from IVsGeneratorProgress to  				// IMessageSink so that errors could be reported immediately and 				// directly to Visual Studio. This broke in a bizarre way when I 				// added processing on a separate thread (in order to be able to 				// abort the thread if it runs too long); I got the following 				// InvalidCastException: "Unable to cast COM object of type 'System.__ComObject'  				// to interface type 'Microsoft.VisualStudio.Shell.Interop.IVsGeneratorProgress'. 				// This operation failed because the QueryInterface call on the COM component for  				// the interface with IID '{BED89B98-6EC9-43CB-B0A8-41D6E2D6669D}' failed due to  				// the following error: No such interface supported (Exception from HRESULT:  				// 0x80004002 (E_NOINTERFACE))." 				//  				// A simple solution is to store the messages rather than reporting 				// them immediately. I'll report the errors at the very end. 				MessageHolder sink = new MessageHolder(); 				 				var sourceFile = new InputOutput((UString)inputFileContents' inputFilePath);  				Compiler.KnownOptions["no-out-header"] = Pair.Create(""' "Remove explanatory comment from output file"); 				Compiler.KnownOptions.Remove("parallel");   // not applicable to single file 				Compiler.KnownOptions.Remove("noparallel"); // not applicable to single file  				var c = new Compiler(sink' sourceFile) {  					AbortTimeout = TimeSpan.FromSeconds(10)' 					Parallel = false // only one file' parallel doesn't help 				};  				var argList = G.SplitCommandLineArguments(defaultNamespace); 				var options = c.ProcessArguments(argList' true' false); 				// Note: if default namespace is left blank' VS uses the namespace  				// from project settings. Don't show an error in that case. 				if (argList.Count > 1 || (argList.Count == 1 && options.Count > 0)) 					sink.Write(Severity.Error' "Command line"' "'{0}': expected options only (try --help)."' argList[0]);  				string _; 				if (options.TryGetValue("help"' out _) || options.TryGetValue("?"' out _)) 				{ 					var ms = new MemoryStream(); 					LeMP.Compiler.ShowHelp(LeMP.Compiler.KnownOptions' new StreamWriter(ms)' false); 					return ms.GetBuffer(); 				}  				LeMP.Compiler.WarnAboutUnknownOptions(options' sink' LeMP.Compiler.KnownOptions); 				 				if (options.ContainsKey("no-out-header")) 					c.NoOutHeader = true; 				 				if (c.InLang == LesLanguageService.Value || inputFilePath.EndsWith(".les"' StringComparison.OrdinalIgnoreCase)) 					c.MacroProcessor.PreOpenedNamespaces.Add(GSymbol.Get("LeMP.Prelude.Les")); 						 				Configure(c); 				_requestedExtension = c.OutExt; 				c.Run();  				// Report errors 				foreach (var msg in sink.List) 					ReportErrorToVS(progressCallback' msg.Severity' msg.Context' msg.Format' msg.Args);  				return Encoding.UTF8.GetBytes(c.Output.ToString()); 			} finally { 				Environment.CurrentDirectory = oldCurDir; 			}
Magic Number,Loyc.VisualStudio,LeMPCustomTool,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SFG\LoycCustomTools.cs,ReportErrorToVS,The following statement contains a magic number: int n = subwarning ? 2 : severity == Severity.Warning ? 1 : 0;
Magic Number,Loyc.VisualStudio,PreSufOpDef,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\Les2SyntaxForVs.cs,PreSufOpDef,The following statement contains a magic number: this.ForegroundColor = Color.FromRgb(50' 100' 0);
Magic Number,Loyc.VisualStudio,PreSufOpDef,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\Les2SyntaxForVs.cs,PreSufOpDef,The following statement contains a magic number: this.ForegroundColor = Color.FromRgb(50' 100' 0);
Magic Number,Loyc.VisualStudio,CallTargetDef,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\Les2SyntaxForVs.cs,CallTargetDef,The following statement contains a magic number: this.ForegroundColor = Color.FromRgb(80' 40' 0);
Magic Number,Loyc.VisualStudio,CallTargetDef,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\Les2SyntaxForVs.cs,CallTargetDef,The following statement contains a magic number: this.ForegroundColor = Color.FromRgb(80' 40' 0);
Magic Number,Loyc.VisualStudio,CallTargetDef,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\Les2SyntaxForVs.cs,CallTargetDef,The following statement contains a magic number: this.BackgroundColor = Color.FromRgb(255' 248' 240);
Magic Number,Loyc.VisualStudio,CallTargetDef,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\Les2SyntaxForVs.cs,CallTargetDef,The following statement contains a magic number: this.BackgroundColor = Color.FromRgb(255' 248' 240);
Magic Number,Loyc.VisualStudio,CallTargetDef,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\Les2SyntaxForVs.cs,CallTargetDef,The following statement contains a magic number: this.BackgroundColor = Color.FromRgb(255' 248' 240);
Magic Number,Loyc.VisualStudio,SampleLanguageForVS,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\SampleLanguage.cs,RunAnalysis,The following statement contains a magic number: for (int i = 0; i < snapshot.Length; i++) 			{ 				char c = snapshot[i]; 				if (c == '\\') 					results.Add(new TagSpan<ErrorTag>( 						new SnapshotSpan(snapshot' new Span(i' 1))' 						new ErrorTag("compiler warning"' "Caution: that's not really a slash' it's a backslash!!"))); 				bool open = (c == '[' || c == '('); 				bool close = (c == ']' || c == ')'); 				if (close) { 					if (parenLevel > 0) 						parenLevel--; 					else { 						results.Add(new TagSpan<ErrorTag>( 							new SnapshotSpan(snapshot' new Span(i' Math.Min(2' snapshot.Length-i)))' 							new ErrorTag("syntax error"' "Caution: closing parenthesis without matching opener"))); 					} 				} 				if ((open || close) && parenLevel == 0) 					results.Add(new TagSpan<ClassificationTag>( 						new SnapshotSpan(snapshot' new Span(i' 1))'  						_outerParenTag)); 				if (open) 					parenLevel++; 			}
Magic Number,Loyc.VisualStudio,EditorToken,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\SyntaxClassifierForVS.cs,EditorToken,The following statement contains a magic number: TypeAndLength = (type & 0x3FFF) | (Math.Min(length' 0x3FFFF) << 14);
Magic Number,Loyc.VisualStudio,AttributeKeywordsDef,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\SyntaxClassifierForVS.cs,AttributeKeywordsDef,The following statement contains a magic number: this.ForegroundColor = Color.FromRgb(0' 0' 255);
Magic Number,Loyc.VisualStudio,BuiltinTypeNameDef,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\SyntaxClassifierForVS.cs,BuiltinTypeNameDef,The following statement contains a magic number: this.ForegroundColor = Color.FromRgb(0' 128' 255);
Magic Number,Loyc.VisualStudio,BuiltinTypeNameDef,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\SyntaxClassifierForVS.cs,BuiltinTypeNameDef,The following statement contains a magic number: this.ForegroundColor = Color.FromRgb(0' 128' 255);
Magic Number,Loyc.VisualStudio,SpecialNameDef,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\SyntaxClassifierForVS.cs,SpecialNameDef,The following statement contains a magic number: this.ForegroundColor = Color.FromRgb(0' 0' 96);
Magic Number,Loyc.VisualStudio,BracketDef,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\SyntaxClassifierForVS.cs,BracketDef,The following statement contains a magic number: this.ForegroundColor = Color.FromRgb(40' 80' 120);
Magic Number,Loyc.VisualStudio,BracketDef,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\SyntaxClassifierForVS.cs,BracketDef,The following statement contains a magic number: this.ForegroundColor = Color.FromRgb(40' 80' 120);
Magic Number,Loyc.VisualStudio,BracketDef,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\SyntaxClassifierForVS.cs,BracketDef,The following statement contains a magic number: this.ForegroundColor = Color.FromRgb(40' 80' 120);
Magic Number,Loyc.VisualStudio,OtherLiteralDef,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\SyntaxClassifierForVS.cs,OtherLiteralDef,The following statement contains a magic number: this.ForegroundColor = Color.FromRgb(96' 0' 192);
Magic Number,Loyc.VisualStudio,OtherLiteralDef,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\SyntaxClassifierForVS.cs,OtherLiteralDef,The following statement contains a magic number: this.ForegroundColor = Color.FromRgb(96' 0' 192);
Magic Number,VS.Common,BraceMatchingTagger,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\BraceMatchingTagger.cs,GetTags,The following statement contains a magic number: if (IsMatchStartCharacter(currentText)) 			{ 				char closeChar = GetMatchCloseCharacter(currentText); 				/* TODO: Need to improve handling of larger blocks. this won't highlight if the matching brace is more 				 *       than 1 screen's worth of lines away. Changing this to 10 * TextView.TextViewLines.Count seemed 				 *       to improve the situation. 				 */ 				if (BraceMatchingTagger.FindMatchingCloseChar(currentChar' Classifier' currentText' closeChar' 10 * TextView.TextViewLines.Count' out pairSpan)) 				{ 					yield return new TagSpan<TextMarkerTag>(new SnapshotSpan(currentChar' 1)' BraceHighlightTag); 					yield return new TagSpan<TextMarkerTag>(pairSpan' BraceHighlightTag); 				} 			} 			else if (IsMatchCloseCharacter(lastText)) 			{ 				var open = GetMatchOpenCharacter(lastText); 				if (BraceMatchingTagger.FindMatchingOpenChar(lastChar' Classifier' open' lastText' 10 * TextView.TextViewLines.Count' out pairSpan)) 				{ 					yield return new TagSpan<TextMarkerTag>(new SnapshotSpan(lastChar' 1)' BraceHighlightTag); 					yield return new TagSpan<TextMarkerTag>(pairSpan' BraceHighlightTag); 				} 			}
Magic Number,VS.Common,BraceMatchingTagger,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\BraceMatchingTagger.cs,GetTags,The following statement contains a magic number: if (IsMatchStartCharacter(currentText)) 			{ 				char closeChar = GetMatchCloseCharacter(currentText); 				/* TODO: Need to improve handling of larger blocks. this won't highlight if the matching brace is more 				 *       than 1 screen's worth of lines away. Changing this to 10 * TextView.TextViewLines.Count seemed 				 *       to improve the situation. 				 */ 				if (BraceMatchingTagger.FindMatchingCloseChar(currentChar' Classifier' currentText' closeChar' 10 * TextView.TextViewLines.Count' out pairSpan)) 				{ 					yield return new TagSpan<TextMarkerTag>(new SnapshotSpan(currentChar' 1)' BraceHighlightTag); 					yield return new TagSpan<TextMarkerTag>(pairSpan' BraceHighlightTag); 				} 			} 			else if (IsMatchCloseCharacter(lastText)) 			{ 				var open = GetMatchOpenCharacter(lastText); 				if (BraceMatchingTagger.FindMatchingOpenChar(lastChar' Classifier' open' lastText' 10 * TextView.TextViewLines.Count' out pairSpan)) 				{ 					yield return new TagSpan<TextMarkerTag>(new SnapshotSpan(lastChar' 1)' BraceHighlightTag); 					yield return new TagSpan<TextMarkerTag>(pairSpan' BraceHighlightTag); 				} 			}
Missing Default,Loyc.VisualStudio,SyntaxClassifierForVS,C:\repos\qwertie_Loyc\Visual Studio Integration\LoycForVS2017\SyntaxHighlights\SyntaxClassifierForVS.cs,TokenToVSClassification,The following switch statement is missing a default case: switch (t.Kind) 			{ 				case TokenKind.Comment: return _commentType; 				case TokenKind.Id: return IsSpecialIdentifier(t.Value) ? _specialNameType : _identifierType; 				case TokenKind.Literal:  					if (t.Value is string) 						return _stringType; 					if (t.Value is int || t.Value is uint || t.Value is sbyte || t.Value is byte 						|| t.Value is short || t.Value is ushort || t.Value is long || t.Value is ulong 						|| t.Value is float || t.Value is double || t.Value is decimal) 						return _numberType; 					return _literalType; 				case TokenKind.Dot: 				case TokenKind.Assignment: 				case TokenKind.Operator: return _operatorType; 				case TokenKind.Separator: return _operatorType; 				case TokenKind.AttrKeyword: return _attributeKeywordType; 				case TokenKind.TypeKeyword: return _typeKeywordType; 				case TokenKind.OtherKeyword: return _keywordType; 				case TokenKind.LParen: 				case TokenKind.RParen: 				case TokenKind.LBrack: 				case TokenKind.RBrack: 				case TokenKind.LBrace: 				case TokenKind.RBrace: return _bracketType; 			}
