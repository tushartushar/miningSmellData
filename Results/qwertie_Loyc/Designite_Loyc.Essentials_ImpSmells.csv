Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Loyc.Collections,ListExt,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\ExtensionMethods\ListExt.cs,SortCore,Cyclomatic complexity of the method is 12
Complex Method,Loyc,G,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,ShiftLeft,Cyclomatic complexity of the method is 9
Complex Method,Loyc,StringExt,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Strings\StringExt.cs,EliminateNamedArgs,Cyclomatic complexity of the method is 12
Complex Method,Loyc.MiniTest,Assert,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\MiniTest.cs,StringifyObject,Cyclomatic complexity of the method is 10
Long Parameter List,Loyc.Collections,ListExt,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\ExtensionMethods\ListExt.cs,ZipLonger,The method has 5 parameters. Parameters: a' b' defaultA' defaultB' resultSelector
Long Parameter List,Loyc.Collections,ListExt,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\ExtensionMethods\ListExt.cs,SortLowestK,The method has 5 parameters. Parameters: list' index' count' k' comp
Long Parameter List,Loyc.Collections,ListExt,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\ExtensionMethods\ListExt.cs,Sort,The method has 6 parameters. Parameters: list' index' count' comp' indexes' quickSelectElems
Long Parameter List,Loyc.Collections,ListExt,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\ExtensionMethods\ListExt.cs,SortCore,The method has 6 parameters. Parameters: list' index' count' comp' indexes' quickSelectElems
Long Parameter List,Loyc,MessageHolder,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\MessageSinks\MessageHolder.cs,Write,The method has 5 parameters. Parameters: level' context' format' arg0' arg1
Long Parameter List,Loyc,LogMessage,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\MessageSinks\MessageHolder.cs,LogMessage,The method has 5 parameters. Parameters: type' context' format' arg0' arg1
Long Parameter List,Loyc,SeverityMessageFilter<TContext>,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\MessageSinks\WrapperSinks.cs,Write,The method has 5 parameters. Parameters: level' context' format' arg0' arg1
Long Parameter List,Loyc,MessageFilter,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\MessageSinks\WrapperSinks.cs,Write,The method has 5 parameters. Parameters: level' context' format' arg0' arg1
Long Parameter List,Loyc,MessageMulticaster<TContext>,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\MessageSinks\WrapperSinks.cs,Write,The method has 5 parameters. Parameters: level' context' format' arg0' arg1
Long Parameter List,Loyc,MessageSinkWithContext<TContext>,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\MessageSinks\WrapperSinks.cs,Write,The method has 5 parameters. Parameters: level' context' format' arg0' arg1
Long Parameter List,Loyc,G,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,IsOneOf,The method has 5 parameters. Parameters: value' item1' item2' item3' item4
Long Parameter List,Loyc,G,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,IsOneOf,The method has 6 parameters. Parameters: value' item1' item2' item3' item4' item5
Long Parameter List,Loyc,ExceptionExt,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\Extensions.cs,AppendDataList,The method has 5 parameters. Parameters: dict' sb' linePrefix' keyValueSeparator' newLine
Long Parameter List,Loyc,IMessageSink,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\MessageSinks\IMessageSink.cs,Write,The method has 5 parameters. Parameters: level' context' format' arg0' arg1
Long Parameter List,Loyc,MessageSink,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\MessageSinks\MessageSink.out.cs,Fatal,The method has 5 parameters. Parameters: sink' context' format' arg0' arg1
Long Parameter List,Loyc,MessageSink,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\MessageSinks\MessageSink.out.cs,Error,The method has 5 parameters. Parameters: sink' context' format' arg0' arg1
Long Parameter List,Loyc,MessageSink,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\MessageSinks\MessageSink.out.cs,Warning,The method has 5 parameters. Parameters: sink' context' format' arg0' arg1
Long Parameter List,Loyc,MessageSink,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\MessageSinks\MessageSink.out.cs,Info,The method has 5 parameters. Parameters: sink' context' format' arg0' arg1
Long Parameter List,Loyc,MessageSink,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\MessageSinks\MessageSink.out.cs,Debug,The method has 5 parameters. Parameters: sink' context' format' arg0' arg1
Long Parameter List,Loyc,ConsoleMessageSink,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\MessageSinks\BasicSinks.cs,Write,The method has 5 parameters. Parameters: level' context' format' arg0' arg1
Long Parameter List,Loyc,NullMessageSink,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\MessageSinks\BasicSinks.cs,Write,The method has 5 parameters. Parameters: level' context' format' arg0' arg1
Long Parameter List,Loyc,TraceMessageSink,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\MessageSinks\BasicSinks.cs,Write,The method has 5 parameters. Parameters: type' context' format' arg0' arg1
Long Parameter List,Loyc,MessageSinkFromDelegate,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\MessageSinks\BasicSinks.cs,Write,The method has 5 parameters. Parameters: level' context' format' arg0' arg1
Long Parameter List,Loyc.Collections.Impl,InternalList,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\InternalList.cs,BinarySearch,The method has 5 parameters. Parameters: array' count' k' comp' lowerBound
Long Parameter List,Loyc.Collections.Impl,InternalList,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\InternalList.cs,BinarySearch,The method has 5 parameters. Parameters: _array' _count' k' compare' lowerBound
Long Parameter List,Loyc.Geometry,INewRectangle3,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Geometry\IRectangle3.cs,NewRect,The method has 6 parameters. Parameters: x' y' z' width' height' depth
Long Parameter List,Loyc.Geometry,INewRectangle3,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Geometry\IRectangle3.cs,NewRange,The method has 6 parameters. Parameters: x1' y1' z1' x2' y2' z2
Long Parameter List,Loyc.MiniTest,Assert,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\MiniTest.cs,AreEqual,The method has 5 parameters. Parameters: expected' actual' delta' message' args
Long Parameter List,Loyc.MiniTest,Assert,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\MiniTest.cs,AreNotEqual,The method has 5 parameters. Parameters: expected' actual' delta' message' args
Long Parameter List,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,IntegerToString,The method has 5 parameters. Parameters: value' prefix' base' separatorInterval' separatorChar
Long Parameter List,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,IntegerToString,The method has 5 parameters. Parameters: value' prefix' base' separatorInterval' separatorChar
Long Parameter List,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,AppendIntegerTo,The method has 6 parameters. Parameters: target' value' prefix' base' separatorInterval' separatorChar
Long Parameter List,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,AppendIntegerTo,The method has 6 parameters. Parameters: target' value' prefix' base' separatorInterval' separatorChar
Long Statement,Loyc.Collections,DList<T>,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\DList.cs,CheckPopCount,The length of the statement  "	 			throw new InvalidOperationException("Can't pop more elements than DList<{0}> contains ({1}>{2})".Localized(typeof(T).Name' amount' Count));" is 139.
Long Statement,Loyc.Collections,DList<T>,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\DList.cs,CheckInsertIndex,The length of the statement  "				throw new IndexOutOfRangeException(Localize.Localized("Invalid index in DList<{0}> ({1}∉[0'{2}])"' typeof(T).Name' index' Count));" is 130.
Long Statement,Loyc.Collections,DList<T>,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\DList.cs,CheckRemoveIndex,The length of the statement  "				throw new IndexOutOfRangeException(Localize.Localized("Invalid removal range in Deque<{0}> ([{1}'{2})⊈[0'{3}))"' typeof(T).Name' index' index + amount' Count));" is 160.
Long Statement,Loyc.Collections,DList<T>,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\DList.cs,ThrowOutOfRange,The length of the statement  "			throw new ArgumentOutOfRangeException(Localize.Localized("Invalid index in Deque<{0}> ({1}∉[0'{2}))"' typeof(T).Name' index' Count));" is 133.
Long Statement,Loyc.Collections,CheckParam,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\Exceptions.cs,IsNotNegative,The length of the statement  "				throw new ArgumentOutOfRangeException(argName' @"Argument ""{0}"" value '{1}' should not be negative.".Localized(argName' value));" is 130.
Long Statement,Loyc.Collections,CheckParam,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\Exceptions.cs,ThrowOutOfRange,The length of the statement  "			throw new ArgumentOutOfRangeException(argName' @"Argument ""{0}"" value '{1}' is not within the expected range ({2}...{3})".Localized(argName' value' min' max)); " is 161.
Long Statement,Loyc,CheckParam,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\Exceptions.cs,IsNotNegative,The length of the statement  "				throw new ArgumentOutOfRangeException(argName' @"Argument ""{0}"" value '{1}' should not be negative.".Localized(argName' value));" is 130.
Long Statement,Loyc,CheckParam,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\Exceptions.cs,ThrowOutOfRange,The length of the statement  "			throw new ArgumentOutOfRangeException(argName' @"Argument ""{0}"" value '{1}' is not within the expected range ({2}...{3})".Localized(argName' value' min' max)); " is 161.
Long Statement,Loyc,ComparisonFrom<T>,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,GetC,The length of the statement  "				return (Comparison<T>)Delegate.CreateDelegate(typeof(Comparison<T>)' null' typeof(IComparable<T>).GetMethod("CompareTo"));" is 122.
Long Statement,Loyc,ComparisonFrom<T>,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,GetF,The length of the statement  "				return (Func<T' T' int>)Delegate.CreateDelegate(typeof(Func<T' T' int>)' null' typeof(IComparable<T>).GetMethod("CompareTo"));" is 126.
Complex Conditional,Loyc.Collections,ListExt,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\ExtensionMethods\ListExt.cs,SortCore,The conditional expression  "c > 0 || (c == 0 && indexes != null && indexes[index] > indexes[index+1])"  is complex.
Complex Conditional,Loyc,UString,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Strings\UString.cs,Find,The conditional expression  "fail || what == f || f <= 0xFFFF && what == char.ToUpperInvariant((char)f)"  is complex.
Complex Conditional,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,EscapeCStyle,The conditional expression  "(flags & EscapeC.UnicodeNonCharacters) != 0 && ( 							c >= 0xFDD0 && c <= 0xFDEF || // 0xFDD0...0xFDEF  							(c & 0xFFFE) == 0xFFFE) || // 0xFFFE' 0xFFFF' 0x1FFFE' 0x1FFFF' etc. 							(c & 0xFC00) == 0xDC00"  is complex.
Complex Conditional,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,EscapeCStyle,The conditional expression  "(flags & EscapeC.UnicodePrivateUse) != 0 && ( 							c >= 0xE000 && c <= 0xF8FF || 							c >= 0xF0000 && c <= 0xFFFFD || 							c >= 0x100000 && c <= 0x10FFFD)"  is complex.
Empty Catch Block,Loyc,LogException,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\MessageSinks\Misc.cs,LogException,The method has an empty catch block.
Empty Catch Block,Loyc,ExceptionExt,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\Extensions.cs,ToDetailedString,The method has an empty catch block.
Empty Catch Block,Loyc,ExceptionExt,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\Extensions.cs,PreserveStackTrace,The method has an empty catch block.
Magic Number,Loyc.Collections,EnumerableExt,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\ExtensionMethods\EnumerableExt.cs,SequenceHashCode,The following statement contains a magic number: int hc = 517617279;
Magic Number,Loyc.Collections,EnumerableExt,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\ExtensionMethods\EnumerableExt.cs,SequenceHashCode,The following statement contains a magic number: foreach (T item in list) 				hc = hc * 257 ^ comp.GetHashCode(item);
Magic Number,Loyc.Collections,ListExt,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\ExtensionMethods\ListExt.cs,StableSort,The following statement contains a magic number: if (list.Count <= 18) 				InsertionSort(list' 0' list.Count' comp); 			else 				Sort(list' 0' list.Count' comp' RangeArray(list.Count));
Magic Number,Loyc.Collections,ListExt,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\ExtensionMethods\ListExt.cs,SortCore,The following statement contains a magic number: for (;;) { 				if (count < InternalList.QuickSortThreshold) 				{ 					if (count <= 2) { 						if (count == 2) { 							int c = comp(list[index]' list[index+1]); 							if (c > 0 || (c == 0 && indexes != null && indexes[index] > indexes[index+1])) 								Swap(list' index' index+1); 						} 						return; 					} else if (indexes == null) { 						InsertionSort(list' index' count' comp); 						return; 					} 				}  				// TODO: fix slug: PickPivot does not use 'indexes'. Makes stable sort slower if many duplicate items. 				int iPivot = InternalList.PickPivot(list' index' count' comp);  				int iBegin = index; 				// Swap the pivot to the beginning of the range 				T pivot = list[iPivot]; 				if (iBegin != iPivot) { 					Swap(list' iBegin' iPivot); 					if (indexes != null) 						G.Swap(ref indexes[iPivot]' ref indexes[iBegin]); 				}  				int i = iBegin + 1; 				int iOut = iBegin; 				int iStop = index + count; 				int leftSize = 0; // size of left partition  				// Quick sort pass 				do { 					int order = comp(list[i]' pivot); 					if (order > 0) 						continue; 					if (order == 0) { 						if (indexes != null) { 							if (indexes[i] > indexes[iBegin]) 								continue; 						} else if (leftSize < (count >> 1)) 							continue; 					} 					 					++iOut; 					++leftSize; 					if (i != iOut) { 						Swap(list' i' iOut); 						if (indexes != null) 							G.Swap(ref indexes[i]' ref indexes[iOut]); 					} 				} while (++i != iStop);  				// Finally' put the pivot element in the middle (at iOut) 				Swap(list' iBegin' iOut); 				if (indexes != null) 					G.Swap(ref indexes[iBegin]' ref indexes[iOut]);  				// Now we need to sort the left and right sub-partitions. Use a  				// recursive call only to sort the smaller partition' in order to  				// guarantee O(log N) stack space usage. 				int rightSize = count - 1 - leftSize; 				if (leftSize < rightSize) 				{ 					// Recursively sort the left partition; iteratively sort the right 					SortCore(list' index' leftSize' comp' indexes' quickSelectElems); 					index += leftSize + 1; 					count = rightSize; 					if ((quickSelectElems -= leftSize + 1) <= 0) 						break; 				} 				else 				{	// Iteratively sort the left partition; recursively sort the right 					count = leftSize; 					SortCore(list' index + leftSize + 1' rightSize' comp' indexes' quickSelectElems - (leftSize + 1)); 				} 			}
Magic Number,Loyc.Collections,ListExt,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\ExtensionMethods\ListExt.cs,SortCore,The following statement contains a magic number: for (;;) { 				if (count < InternalList.QuickSortThreshold) 				{ 					if (count <= 2) { 						if (count == 2) { 							int c = comp(list[index]' list[index+1]); 							if (c > 0 || (c == 0 && indexes != null && indexes[index] > indexes[index+1])) 								Swap(list' index' index+1); 						} 						return; 					} else if (indexes == null) { 						InsertionSort(list' index' count' comp); 						return; 					} 				}  				// TODO: fix slug: PickPivot does not use 'indexes'. Makes stable sort slower if many duplicate items. 				int iPivot = InternalList.PickPivot(list' index' count' comp);  				int iBegin = index; 				// Swap the pivot to the beginning of the range 				T pivot = list[iPivot]; 				if (iBegin != iPivot) { 					Swap(list' iBegin' iPivot); 					if (indexes != null) 						G.Swap(ref indexes[iPivot]' ref indexes[iBegin]); 				}  				int i = iBegin + 1; 				int iOut = iBegin; 				int iStop = index + count; 				int leftSize = 0; // size of left partition  				// Quick sort pass 				do { 					int order = comp(list[i]' pivot); 					if (order > 0) 						continue; 					if (order == 0) { 						if (indexes != null) { 							if (indexes[i] > indexes[iBegin]) 								continue; 						} else if (leftSize < (count >> 1)) 							continue; 					} 					 					++iOut; 					++leftSize; 					if (i != iOut) { 						Swap(list' i' iOut); 						if (indexes != null) 							G.Swap(ref indexes[i]' ref indexes[iOut]); 					} 				} while (++i != iStop);  				// Finally' put the pivot element in the middle (at iOut) 				Swap(list' iBegin' iOut); 				if (indexes != null) 					G.Swap(ref indexes[iBegin]' ref indexes[iOut]);  				// Now we need to sort the left and right sub-partitions. Use a  				// recursive call only to sort the smaller partition' in order to  				// guarantee O(log N) stack space usage. 				int rightSize = count - 1 - leftSize; 				if (leftSize < rightSize) 				{ 					// Recursively sort the left partition; iteratively sort the right 					SortCore(list' index' leftSize' comp' indexes' quickSelectElems); 					index += leftSize + 1; 					count = rightSize; 					if ((quickSelectElems -= leftSize + 1) <= 0) 						break; 				} 				else 				{	// Iteratively sort the left partition; recursively sort the right 					count = leftSize; 					SortCore(list' index + leftSize + 1' rightSize' comp' indexes' quickSelectElems - (leftSize + 1)); 				} 			}
Magic Number,Loyc.Collections,WeakValueDictionary<K;V>,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\WeakValueDictionary.cs,AutoCleanup,The following statement contains a magic number: if (_accessCounter++ > (Count << 2)) { 				Cleanup(); 				return true; 			}
Magic Number,Loyc.Collections,WeakValueDictionary<K;V>,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\WeakValueDictionary.cs,Add,The following statement contains a magic number: _accessCounter += 4;
Magic Number,Loyc.Collections,WeakValueDictionary<K;V>,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\WeakValueDictionary.cs,SetValue,The following statement contains a magic number: _accessCounter += 3;
Magic Number,Loyc,StringBuilderExt,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Strings\StringBuilderExt.cs,AppendCodePoint,The following statement contains a magic number: if ((uint)c <= 0xFFFF) 				s.Append((char)c); 			else if ((uint)c <= 0x10FFFF) 			{ 				c -= 0x10000; 				s.Append((char)((c >> 10) | 0xD800)); 				s.Append((char)((c & 0x3FF) | 0xDC00)); 			} 			else 				throw new ArgumentOutOfRangeException("Invalid unicode character: {0}".Localized(c));
Magic Number,Loyc,UString,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Strings\UString.cs,PopFirst,The following statement contains a magic number: if (_count != 0) { 				fail = false; 				var c = First; 				int inc = c >= 0x10000 ? 2 : 1; 				_count -= inc; 				_start += inc; 				return c; 			}
Magic Number,Loyc,UString,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Strings\UString.cs,PopLast,The following statement contains a magic number: if (_count != 0) { 				fail = false; 				var c = Last; 				_count -= (c >= 0x10000 ? 2 : 1); 				return c; 			}
Magic Number,Loyc,UString,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Strings\UString.cs,TryDecodeAt,The following statement contains a magic number: if ((uint)index < (uint)_count) { 				int c = _str[_start + index]; 				if (c < 0xD800 || c > 0xDBFF || (uint)(index + 1) >= (uint)_count) 					return c; 				int c1 = _str[_start + index + 1]; 				if (c1 >= 0xDC00 && c1 <= 0xDFFF) 					return 0x10000 + ((c & 0x3FF) << 10) + (c1 & 0x3FF); 			}
Magic Number,Loyc,UString,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Strings\UString.cs,GetHashCode,The following statement contains a magic number: int hc1 = 352654597' hc2 = hc1;
Magic Number,Loyc,UString,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Strings\UString.cs,GetHashCode,The following statement contains a magic number: for (int i = _start' e = _start + _count; i < e; i++) { 				hc1 = ((hc1 << 5) + hc1 + (hc1 >> 27)) ^ _str[i]; 				if (++i == e) break; 				hc2 = ((hc2 << 5) + hc2 + (hc2 >> 27)) ^ _str[i]; 			}
Magic Number,Loyc,UString,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Strings\UString.cs,GetHashCode,The following statement contains a magic number: for (int i = _start' e = _start + _count; i < e; i++) { 				hc1 = ((hc1 << 5) + hc1 + (hc1 >> 27)) ^ _str[i]; 				if (++i == e) break; 				hc2 = ((hc2 << 5) + hc2 + (hc2 >> 27)) ^ _str[i]; 			}
Magic Number,Loyc,UString,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Strings\UString.cs,GetHashCode,The following statement contains a magic number: for (int i = _start' e = _start + _count; i < e; i++) { 				hc1 = ((hc1 << 5) + hc1 + (hc1 >> 27)) ^ _str[i]; 				if (++i == e) break; 				hc2 = ((hc2 << 5) + hc2 + (hc2 >> 27)) ^ _str[i]; 			}
Magic Number,Loyc,UString,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Strings\UString.cs,GetHashCode,The following statement contains a magic number: for (int i = _start' e = _start + _count; i < e; i++) { 				hc1 = ((hc1 << 5) + hc1 + (hc1 >> 27)) ^ _str[i]; 				if (++i == e) break; 				hc2 = ((hc2 << 5) + hc2 + (hc2 >> 27)) ^ _str[i]; 			}
Magic Number,Loyc,UString,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Strings\UString.cs,GetHashCode,The following statement contains a magic number: return hc1 + hc2 * 1566083941;
Magic Number,Loyc,G,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,SplitCommandLineArguments,The following statement contains a magic number: for (; m.Success; m = m.NextMatch()) { 				string s = m.ToString(); 				if (s.StartsWith("\"") && s.EndsWith("\"")) 					s = s.Substring(1' s.Length - 2); 				list.Add(s); 			}
Magic Number,Loyc,G,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,CountOnes,The following statement contains a magic number: X = (((X >> 2) & 0x33) + (X & 0x33));
Magic Number,Loyc,G,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,CountOnes,The following statement contains a magic number: return (X & 0x0F) + (X >> 4);
Magic Number,Loyc,G,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,CountOnes,The following statement contains a magic number: x = (((x >> 2) & 0x33333333) + (x & 0x33333333));
Magic Number,Loyc,G,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,CountOnes,The following statement contains a magic number: x = (((x >> 4) + x) & 0x0f0f0f0f);
Magic Number,Loyc,G,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,CountOnes,The following statement contains a magic number: x += (x >> 8);
Magic Number,Loyc,G,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,CountOnes,The following statement contains a magic number: x += (x >> 16);
Magic Number,Loyc,G,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,Log2Floor,The following statement contains a magic number: x |= (x >> 2);
Magic Number,Loyc,G,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,Log2Floor,The following statement contains a magic number: x |= (x >> 4);
Magic Number,Loyc,G,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,Log2Floor,The following statement contains a magic number: x |= (x >> 8);
Magic Number,Loyc,G,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,Log2Floor,The following statement contains a magic number: x |= (x >> 16);
Magic Number,Loyc,G,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,ShiftLeft,The following statement contains a magic number: uint exp = (uint)(bits >> 52) & 0x7FF;
Magic Number,Loyc,G,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,ShiftLeft,The following statement contains a magic number: if ((exp += (uint)amount) < 0x7FFu) 				return Int64BitsToDouble((long)(bits & 0x800FFFFFFFFFFFFFu) | ((long)exp << 52));
Magic Number,Loyc,G,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,ShiftRight,The following statement contains a magic number: uint exp = (uint)(bits >> 52) & 0x7FF;
Magic Number,Loyc,G,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,ShiftRight,The following statement contains a magic number: if (newExp - 1 < 0x7FF) 				return Int64BitsToDouble((long)(bits & 0x800FFFFFFFFFFFFFu) | ((long)newExp << 52));
Magic Number,Loyc,G,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\G.cs,ShiftRight,The following statement contains a magic number: if (amount > 53) 				return 0;
Magic Number,Loyc,ExceptionExt,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\Extensions.cs,ToDetailedString,The following statement contains a magic number: return ToDetailedString(ex' 3);
Magic Number,Loyc,StringExt,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Strings\StringExt.cs,EliminateNamedArgs,The following statement contains a magic number: for (int i = 0; i < sb.Length - 1; i++) 			{ 				if (sb[i] == '{' && sb[i + 1] != '{') 				{ 					int placeholderStart = ++i; // Placeholder name starts here. 					for (; (c = sb[i]) != '}' && c != ':' && c != '''; i++) { } 					int placeholderLen = i - placeholderStart;  					// StringBuilder lacks Substring()! Instead' get the name  					// from the original string and keep track of a correction  					// factor so that in subsequent iterations' we get the  					// substring from the right position in the original string. 					UString name = format.Slice(placeholderStart + correction' placeholderLen);  					for (int arg = highestIndex + 1; arg < args.Length; arg += 2) 						if (args[arg] != null && name.Equals(args[arg] as string' ignoreCase: true)) 						{ 							// Matching argument found. Replace name with index: 							string idxStr = (arg + 1).ToString(); 							sb.Remove(placeholderStart' placeholderLen); 							sb.Insert(placeholderStart' idxStr); 							int dif = placeholderLen - idxStr.Length; 							correction += dif; 							i -= dif; 							break; 						} 				} 				Debug.Assert(sb[i] == format[i + correction]); 			}
Magic Number,Loyc,Symbol,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\Symbol.cs,GetHashCode,The following statement contains a magic number: return 5432 + _id ^ (_pool.PoolId << 16);
Magic Number,Loyc,Symbol,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\Symbol.cs,GetHashCode,The following statement contains a magic number: return 5432 + _id ^ (_pool.PoolId << 16);
Magic Number,Loyc.Collections.Impl,InternalDList,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\InternalDList.cs,AutoShrink,The following statement contains a magic number: if ((_count << 1) + 2 < _array.Length) 				Capacity = _count + 2;
Magic Number,Loyc.Collections.Impl,InternalDList,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\InternalDList.cs,AutoShrink,The following statement contains a magic number: if ((_count << 1) + 2 < _array.Length) 				Capacity = _count + 2;
Magic Number,Loyc.Collections.Impl,InternalDList,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\InternalDList.cs,CopyFwd,The following statement contains a magic number: if (amount < 16) { 				int stop = to + amount; 				while (to < stop) 					array[to++] = array[from++]; 			} else 				// Benchmarks show that Array.Copy is faster for large copies. 				// Benchmarks have not been done for small copies but Array.Copy 				// is not likely to be faster in that case due to a larger decision tree 				// (e.g. detecting if the arrays are the same and the regions overlap) 				Array.Copy(array' from' array' to' amount);
Magic Number,Loyc.Collections.Impl,InternalDList,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\InternalDList.cs,CopyBwd,The following statement contains a magic number: if (amount < 16) { 				int to = toPlusAmount - amount; 				while (toPlusAmount > to) 					array[--toPlusAmount] = array[--fromPlusAmount]; 			} else 				Array.Copy(array' fromPlusAmount-amount' array' toPlusAmount-amount' amount);
Magic Number,Loyc.Collections.Impl,InternalDList,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\InternalDList.cs,Min,The following statement contains a magic number: return x + (((y - x) >> 31) & (y - x));
Magic Number,Loyc.Collections.Impl,InternalList,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\InternalList.cs,Resize,The following statement contains a magic number: if (newSize > _count) 			{ 				if (newSize > _array.Length) 				{ 					if (newSize <= _array.Length + (_array.Length >> 2)) { 						IncreaseCapacity(); 						Debug.Assert(Capacity > newSize); 					} else 						Capacity = newSize; 				} 				_count = newSize; 			} 			else if (newSize < _count) 			{ 				if (allowReduceCapacity && newSize < (_array.Length >> 2)) { 					_count = newSize; 					Capacity = newSize; 				} else { 					for (int i = newSize; i < _count; i++) 						_array[i] = default(T); 					_count = newSize; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalList,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\InternalList.cs,Resize,The following statement contains a magic number: if (newSize > _count) 			{ 				if (newSize > _array.Length) 				{ 					if (newSize <= _array.Length + (_array.Length >> 2)) { 						IncreaseCapacity(); 						Debug.Assert(Capacity > newSize); 					} else 						Capacity = newSize; 				} 				_count = newSize; 			} 			else if (newSize < _count) 			{ 				if (allowReduceCapacity && newSize < (_array.Length >> 2)) { 					_count = newSize; 					Capacity = newSize; 				} else { 					for (int i = newSize; i < _count; i++) 						_array[i] = default(T); 					_count = newSize; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalList,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\InternalList.cs,Fill,The following statement contains a magic number: if (count > 0) 			{ 				// Just for fun' let's unroll the loop 				start--; 				if ((count & 1) != 0) 					array[++start] = value; 				while ((count -= 2) >= 0) 				{ 					array[++start] = value; 					array[++start] = value; 				} 			}
Magic Number,Loyc.Collections.Impl,InternalList,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\InternalList.cs,NextLargerSize,The following statement contains a magic number: return ((than << 1) - (than >> 2) + 2) & ~1;
Magic Number,Loyc.Collections.Impl,InternalList,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\InternalList.cs,NextLargerSize,The following statement contains a magic number: return ((than << 1) - (than >> 2) + 2) & ~1;
Magic Number,Loyc.Collections.Impl,InternalList,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\InternalList.cs,NextLargerSize,The following statement contains a magic number: if (larger + (larger >> 2) > capacityLimit && than < capacityLimit) 				return capacityLimit;
Magic Number,Loyc.Collections.Impl,InternalList,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\InternalList.cs,Sort,The following statement contains a magic number: for (;;) { 				if (count < QuickSortThreshold) 				{ 					if (count <= 2) { 						if (count == 2) 							G.SortPair(ref array[index]' ref array[index+1]' comp); 					} else { 						InsertionSort(array' index' count' comp); 					} 					return; 				}  				int iPivot = PickPivot(array' index' count' comp);  				int iBegin = index; 				// Swap the pivot to the beginning of the range 				T pivot = array[iPivot]; 				if (iBegin != iPivot) 					G.Swap(ref array[iBegin]' ref array[iPivot]);  				int i = iBegin + 1; 				int iOut = iBegin; 				int iStop = index + count; 				int leftSize = 0; // size of left partition  				// Quick sort pass 				do { 					int order = comp(array[i]' pivot); 					if (order < 0 || (order == 0 && leftSize < (count >> 1))) 					{ 						++iOut; 						++leftSize; 						if (i != iOut) 							G.Swap(ref array[i]' ref array[iOut]); 					} 				} while (++i != iStop);  				// Finally' put the pivot element in the middle (at iOut) 				G.Swap(ref array[iBegin]' ref array[iOut]);  				// Now we need to sort the left and right sub-partitions. Use a  				// recursive call only to sort the smaller partition' in order to  				// guarantee O(log N) stack space usage. 				int rightSize = count - 1 - leftSize; 				if (leftSize < rightSize) 				{ 					// Recursively sort the left partition; iteratively sort the right 					Sort(array' index' leftSize' comp); 					index += leftSize + 1; 					count = rightSize; 				} 				else 				{	// Iteratively sort the left partition; recursively sort the right 					count = leftSize; 					Sort(array' index + leftSize + 1' rightSize' comp); 				} 			}
Magic Number,Loyc.Collections.Impl,InternalList,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Collections\Implementations\InternalList.cs,Sort,The following statement contains a magic number: for (;;) { 				if (count < QuickSortThreshold) 				{ 					if (count <= 2) { 						if (count == 2) 							G.SortPair(ref array[index]' ref array[index+1]' comp); 					} else { 						InsertionSort(array' index' count' comp); 					} 					return; 				}  				int iPivot = PickPivot(array' index' count' comp);  				int iBegin = index; 				// Swap the pivot to the beginning of the range 				T pivot = array[iPivot]; 				if (iBegin != iPivot) 					G.Swap(ref array[iBegin]' ref array[iPivot]);  				int i = iBegin + 1; 				int iOut = iBegin; 				int iStop = index + count; 				int leftSize = 0; // size of left partition  				// Quick sort pass 				do { 					int order = comp(array[i]' pivot); 					if (order < 0 || (order == 0 && leftSize < (count >> 1))) 					{ 						++iOut; 						++leftSize; 						if (i != iOut) 							G.Swap(ref array[i]' ref array[iOut]); 					} 				} while (++i != iStop);  				// Finally' put the pivot element in the middle (at iOut) 				G.Swap(ref array[iBegin]' ref array[iOut]);  				// Now we need to sort the left and right sub-partitions. Use a  				// recursive call only to sort the smaller partition' in order to  				// guarantee O(log N) stack space usage. 				int rightSize = count - 1 - leftSize; 				if (leftSize < rightSize) 				{ 					// Recursively sort the left partition; iteratively sort the right 					Sort(array' index' leftSize' comp); 					index += leftSize + 1; 					count = rightSize; 				} 				else 				{	// Iteratively sort the left partition; recursively sort the right 					count = leftSize; 					Sort(array' index + leftSize + 1' rightSize' comp); 				} 			}
Magic Number,Loyc.MiniTest,Assert,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\MiniTest.cs,GetStringsNotEqualMessage,The following statement contains a magic number: if (a == null || b == null) 				return GetObjectMismatchMessage(a' b); 			else { 				int i' c = System.Math.Min((a ?? "").Length' (b ?? "").Length); 				for (i = 0; i < c; i++) 					if (a[i] != b[i]) 						break; 				StringBuilder msg = new StringBuilder(); 				if (a.Length == b.Length) 					msg.AppendFormat("  String lengths are both {0}. Strings differ at index {1}.\n"' c' i); 				else 					msg.AppendFormat("  Expected string length {0} but was {1}. Strings differ at index {2}.\n"' a.Length' b.Length' i); 				int a_i = i' b_i = i' maxlen = System.Math.Max(a.Length' b.Length); 				msg.AppendFormat("  Expected: {0}\n"' GetQuotedString(ref a' ref a_i' maxlen)); 				msg.AppendFormat("  But was:  {0}\n"' GetQuotedString(ref b' ref b_i' maxlen)); 				 				int TailLength = "-----------".Length; 				var prefix = b.Left(b_i); 				int i_adjusted = PrintHelpers.EscapeCStyle(prefix' EscapeC.Default' '"').Length; 				msg.Append(' '' 2); 				msg.Append('-'' TailLength + i_adjusted); 				msg.Append("^\n"); 				return msg.ToString(); 			}
Magic Number,Loyc.MiniTest,Assert,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\MiniTest.cs,GetQuotedString,The following statement contains a magic number: if (len > maxw) { 				if (dif_i < maxw/2) { 					s = s.Left(maxw - 3) + "..."; // "beginning..." 				} else if (len - dif_i < maxw/2) { 					s = "..." + s.SafeSubstring(len - (maxw - 3)); // "...ending" 					dif_i -= len - maxw; 				} else { 					s = "..." + s.SafeSubstring(dif_i - maxw / 2 + 3' maxw - 6) + "..."; 					dif_i = maxw / 2; // "...middle..." 				} 			}
Magic Number,Loyc.MiniTest,Assert,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\MiniTest.cs,GetQuotedString,The following statement contains a magic number: if (len > maxw) { 				if (dif_i < maxw/2) { 					s = s.Left(maxw - 3) + "..."; // "beginning..." 				} else if (len - dif_i < maxw/2) { 					s = "..." + s.SafeSubstring(len - (maxw - 3)); // "...ending" 					dif_i -= len - maxw; 				} else { 					s = "..." + s.SafeSubstring(dif_i - maxw / 2 + 3' maxw - 6) + "..."; 					dif_i = maxw / 2; // "...middle..." 				} 			}
Magic Number,Loyc.MiniTest,Assert,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\MiniTest.cs,GetQuotedString,The following statement contains a magic number: if (len > maxw) { 				if (dif_i < maxw/2) { 					s = s.Left(maxw - 3) + "..."; // "beginning..." 				} else if (len - dif_i < maxw/2) { 					s = "..." + s.SafeSubstring(len - (maxw - 3)); // "...ending" 					dif_i -= len - maxw; 				} else { 					s = "..." + s.SafeSubstring(dif_i - maxw / 2 + 3' maxw - 6) + "..."; 					dif_i = maxw / 2; // "...middle..." 				} 			}
Magic Number,Loyc.MiniTest,Assert,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\MiniTest.cs,GetQuotedString,The following statement contains a magic number: if (len > maxw) { 				if (dif_i < maxw/2) { 					s = s.Left(maxw - 3) + "..."; // "beginning..." 				} else if (len - dif_i < maxw/2) { 					s = "..." + s.SafeSubstring(len - (maxw - 3)); // "...ending" 					dif_i -= len - maxw; 				} else { 					s = "..." + s.SafeSubstring(dif_i - maxw / 2 + 3' maxw - 6) + "..."; 					dif_i = maxw / 2; // "...middle..." 				} 			}
Magic Number,Loyc.MiniTest,Assert,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\MiniTest.cs,GetQuotedString,The following statement contains a magic number: if (len > maxw) { 				if (dif_i < maxw/2) { 					s = s.Left(maxw - 3) + "..."; // "beginning..." 				} else if (len - dif_i < maxw/2) { 					s = "..." + s.SafeSubstring(len - (maxw - 3)); // "...ending" 					dif_i -= len - maxw; 				} else { 					s = "..." + s.SafeSubstring(dif_i - maxw / 2 + 3' maxw - 6) + "..."; 					dif_i = maxw / 2; // "...middle..." 				} 			}
Magic Number,Loyc.MiniTest,Assert,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\MiniTest.cs,GetQuotedString,The following statement contains a magic number: if (len > maxw) { 				if (dif_i < maxw/2) { 					s = s.Left(maxw - 3) + "..."; // "beginning..." 				} else if (len - dif_i < maxw/2) { 					s = "..." + s.SafeSubstring(len - (maxw - 3)); // "...ending" 					dif_i -= len - maxw; 				} else { 					s = "..." + s.SafeSubstring(dif_i - maxw / 2 + 3' maxw - 6) + "..."; 					dif_i = maxw / 2; // "...middle..." 				} 			}
Magic Number,Loyc.MiniTest,Assert,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\MiniTest.cs,GetQuotedString,The following statement contains a magic number: if (len > maxw) { 				if (dif_i < maxw/2) { 					s = s.Left(maxw - 3) + "..."; // "beginning..." 				} else if (len - dif_i < maxw/2) { 					s = "..." + s.SafeSubstring(len - (maxw - 3)); // "...ending" 					dif_i -= len - maxw; 				} else { 					s = "..." + s.SafeSubstring(dif_i - maxw / 2 + 3' maxw - 6) + "..."; 					dif_i = maxw / 2; // "...middle..." 				} 			}
Magic Number,Loyc.MiniTest,Assert,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\MiniTest.cs,GetQuotedString,The following statement contains a magic number: if (len > maxw) { 				if (dif_i < maxw/2) { 					s = s.Left(maxw - 3) + "..."; // "beginning..." 				} else if (len - dif_i < maxw/2) { 					s = "..." + s.SafeSubstring(len - (maxw - 3)); // "...ending" 					dif_i -= len - maxw; 				} else { 					s = "..." + s.SafeSubstring(dif_i - maxw / 2 + 3' maxw - 6) + "..."; 					dif_i = maxw / 2; // "...middle..." 				} 			}
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,HexDigitChar,The following statement contains a magic number: if ((uint)value < 10) 				return (char)('0' + value); 			else if ((uint)value < 16) 				return (char)('A' - 10 + value); 			else 				return '?';
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,HexDigitChar,The following statement contains a magic number: if ((uint)value < 10) 				return (char)('0' + value); 			else if ((uint)value < 16) 				return (char)('A' - 10 + value); 			else 				return '?';
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,HexDigitChar,The following statement contains a magic number: if ((uint)value < 10) 				return (char)('0' + value); 			else if ((uint)value < 16) 				return (char)('A' - 10 + value); 			else 				return '?';
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,EscapeU,The following statement contains a magic number: if (c <= 255 && (flags & EscapeC.BackslashX) != 0) 				@out.Append(@"\x"); 			else { 				@out.Append(@"\u"); 				if (c > 0xFFFF || (flags & EscapeC.HasLongEscape) != 0) { 					Debug.Assert(c <= 0x10FFFF); 					@out.Append(HexDigitChar((c >> 20) & 0xF)); 					@out.Append(HexDigitChar((c >> 16) & 0xF)); 				} 				@out.Append(HexDigitChar((c >> 12) & 0xF)); 				@out.Append(HexDigitChar((c >> 8) & 0xF)); 			}
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,EscapeU,The following statement contains a magic number: if (c <= 255 && (flags & EscapeC.BackslashX) != 0) 				@out.Append(@"\x"); 			else { 				@out.Append(@"\u"); 				if (c > 0xFFFF || (flags & EscapeC.HasLongEscape) != 0) { 					Debug.Assert(c <= 0x10FFFF); 					@out.Append(HexDigitChar((c >> 20) & 0xF)); 					@out.Append(HexDigitChar((c >> 16) & 0xF)); 				} 				@out.Append(HexDigitChar((c >> 12) & 0xF)); 				@out.Append(HexDigitChar((c >> 8) & 0xF)); 			}
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,EscapeU,The following statement contains a magic number: if (c <= 255 && (flags & EscapeC.BackslashX) != 0) 				@out.Append(@"\x"); 			else { 				@out.Append(@"\u"); 				if (c > 0xFFFF || (flags & EscapeC.HasLongEscape) != 0) { 					Debug.Assert(c <= 0x10FFFF); 					@out.Append(HexDigitChar((c >> 20) & 0xF)); 					@out.Append(HexDigitChar((c >> 16) & 0xF)); 				} 				@out.Append(HexDigitChar((c >> 12) & 0xF)); 				@out.Append(HexDigitChar((c >> 8) & 0xF)); 			}
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,EscapeU,The following statement contains a magic number: if (c <= 255 && (flags & EscapeC.BackslashX) != 0) 				@out.Append(@"\x"); 			else { 				@out.Append(@"\u"); 				if (c > 0xFFFF || (flags & EscapeC.HasLongEscape) != 0) { 					Debug.Assert(c <= 0x10FFFF); 					@out.Append(HexDigitChar((c >> 20) & 0xF)); 					@out.Append(HexDigitChar((c >> 16) & 0xF)); 				} 				@out.Append(HexDigitChar((c >> 12) & 0xF)); 				@out.Append(HexDigitChar((c >> 8) & 0xF)); 			}
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,EscapeU,The following statement contains a magic number: if (c <= 255 && (flags & EscapeC.BackslashX) != 0) 				@out.Append(@"\x"); 			else { 				@out.Append(@"\u"); 				if (c > 0xFFFF || (flags & EscapeC.HasLongEscape) != 0) { 					Debug.Assert(c <= 0x10FFFF); 					@out.Append(HexDigitChar((c >> 20) & 0xF)); 					@out.Append(HexDigitChar((c >> 16) & 0xF)); 				} 				@out.Append(HexDigitChar((c >> 12) & 0xF)); 				@out.Append(HexDigitChar((c >> 8) & 0xF)); 			}
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,EscapeU,The following statement contains a magic number: @out.Append(HexDigitChar((c >> 4) & 0xF));
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,EscapeCStyle,The following statement contains a magic number: for(;;) { 				if (c >= 128) { 					if ((flags & EscapeC.NonAscii) != 0) { 						EscapeU(c' @out' flags); 					} else if (c >= 0xDC00) { 						if ((flags & EscapeC.UnicodeNonCharacters) != 0 && ( 							c >= 0xFDD0 && c <= 0xFDEF || // 0xFDD0...0xFDEF  							(c & 0xFFFE) == 0xFFFE) || // 0xFFFE' 0xFFFF' 0x1FFFE' 0x1FFFF' etc. 							(c & 0xFC00) == 0xDC00) { // 0xDC00...0xDCFF  							EscapeU(c' @out' flags); 						} else if ((flags & EscapeC.UnicodePrivateUse) != 0 && ( 							c >= 0xE000 && c <= 0xF8FF || 							c >= 0xF0000 && c <= 0xFFFFD || 							c >= 0x100000 && c <= 0x10FFFD)) { 							EscapeU(c' @out' flags); 						} else 							break; 					} else 						break; 				} else if (c < 32) { 					if (c == '\n') 						@out.Append(@"\n"); 					else if (c == '\r') 						@out.Append(@"\r"); 					else if (c == '\0') 						@out.Append(@"\0"); 					else { 						if ((flags & EscapeC.ABFV) != 0) { 							if (c == '\a') { // 7 (alert) 								@out.Append(@"\a"); 								return true; 							} 							if (c == '\b') { // 8 (backspace) 								@out.Append(@"\b"); 								return true; 							} 							if (c == '\f') { // 12 (form feed) 								@out.Append(@"\f"); 								return true; 							} 							if (c == '\v') { // 11 (vertical tab) 								@out.Append(@"\v"); 								return true; 							} 						} 						if ((flags & EscapeC.Control) != 0) { 							if (c == '\t') 								@out.Append(@"\t"); 							else 								EscapeU(c' @out' flags); 						} else 							@out.Append(c); 					} 				} else if (c == '\"' && (flags & EscapeC.DoubleQuotes) != 0) { 					@out.Append("\\\""); 				} else if (c == '\'' && (flags & EscapeC.SingleQuotes) != 0) { 					@out.Append("\\'"); 				} else if (c == '\\') 					@out.Append(@"\\"); 				else 					break; 				return true; 			}
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,EscapeCStyle,The following statement contains a magic number: for(;;) { 				if (c >= 128) { 					if ((flags & EscapeC.NonAscii) != 0) { 						EscapeU(c' @out' flags); 					} else if (c >= 0xDC00) { 						if ((flags & EscapeC.UnicodeNonCharacters) != 0 && ( 							c >= 0xFDD0 && c <= 0xFDEF || // 0xFDD0...0xFDEF  							(c & 0xFFFE) == 0xFFFE) || // 0xFFFE' 0xFFFF' 0x1FFFE' 0x1FFFF' etc. 							(c & 0xFC00) == 0xDC00) { // 0xDC00...0xDCFF  							EscapeU(c' @out' flags); 						} else if ((flags & EscapeC.UnicodePrivateUse) != 0 && ( 							c >= 0xE000 && c <= 0xF8FF || 							c >= 0xF0000 && c <= 0xFFFFD || 							c >= 0x100000 && c <= 0x10FFFD)) { 							EscapeU(c' @out' flags); 						} else 							break; 					} else 						break; 				} else if (c < 32) { 					if (c == '\n') 						@out.Append(@"\n"); 					else if (c == '\r') 						@out.Append(@"\r"); 					else if (c == '\0') 						@out.Append(@"\0"); 					else { 						if ((flags & EscapeC.ABFV) != 0) { 							if (c == '\a') { // 7 (alert) 								@out.Append(@"\a"); 								return true; 							} 							if (c == '\b') { // 8 (backspace) 								@out.Append(@"\b"); 								return true; 							} 							if (c == '\f') { // 12 (form feed) 								@out.Append(@"\f"); 								return true; 							} 							if (c == '\v') { // 11 (vertical tab) 								@out.Append(@"\v"); 								return true; 							} 						} 						if ((flags & EscapeC.Control) != 0) { 							if (c == '\t') 								@out.Append(@"\t"); 							else 								EscapeU(c' @out' flags); 						} else 							@out.Append(c); 					} 				} else if (c == '\"' && (flags & EscapeC.DoubleQuotes) != 0) { 					@out.Append("\\\""); 				} else if (c == '\'' && (flags & EscapeC.SingleQuotes) != 0) { 					@out.Append("\\'"); 				} else if (c == '\\') 					@out.Append(@"\\"); 				else 					break; 				return true; 			}
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,AppendIntegerTo,The following statement contains a magic number: if (value < 0) { 				CheckParam.IsInRange("base"' @base' 2' 36); 				target.Append('-'); 				target.Append(prefix); 				return AppendIntegerTo(target' (ulong)-value' ""' @base' separatorInterval' separatorChar); 			} else  				return AppendIntegerTo(target' (ulong)value' prefix' @base' separatorInterval' separatorChar);
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,AppendIntegerTo,The following statement contains a magic number: if (value < 0) { 				CheckParam.IsInRange("base"' @base' 2' 36); 				target.Append('-'); 				target.Append(prefix); 				return AppendIntegerTo(target' (ulong)-value' ""' @base' separatorInterval' separatorChar); 			} else  				return AppendIntegerTo(target' (ulong)value' prefix' @base' separatorInterval' separatorChar);
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,AppendIntegerTo,The following statement contains a magic number: CheckParam.IsInRange("base"' @base' 2' 36);
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,AppendIntegerTo,The following statement contains a magic number: CheckParam.IsInRange("base"' @base' 2' 36);
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,AppendIntegerTo,The following statement contains a magic number: int shift = @base > 8 ? (@base <= 16 ? 4 : 5) 				  : (@base <= 2 ? 1 : @base <= 4 ? 2 : 3);
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,AppendIntegerTo,The following statement contains a magic number: int shift = @base > 8 ? (@base <= 16 ? 4 : 5) 				  : (@base <= 2 ? 1 : @base <= 4 ? 2 : 3);
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,AppendIntegerTo,The following statement contains a magic number: int shift = @base > 8 ? (@base <= 16 ? 4 : 5) 				  : (@base <= 2 ? 1 : @base <= 4 ? 2 : 3);
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,AppendIntegerTo,The following statement contains a magic number: int shift = @base > 8 ? (@base <= 16 ? 4 : 5) 				  : (@base <= 2 ? 1 : @base <= 4 ? 2 : 3);
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,AppendIntegerTo,The following statement contains a magic number: int shift = @base > 8 ? (@base <= 16 ? 4 : 5) 				  : (@base <= 2 ? 1 : @base <= 4 ? 2 : 3);
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,AppendIntegerTo,The following statement contains a magic number: int shift = @base > 8 ? (@base <= 16 ? 4 : 5) 				  : (@base <= 2 ? 1 : @base <= 4 ? 2 : 3);
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,AppendIntegerTo,The following statement contains a magic number: int shift = @base > 8 ? (@base <= 16 ? 4 : 5) 				  : (@base <= 2 ? 1 : @base <= 4 ? 2 : 3);
Magic Number,Loyc.Syntax,PrintHelpers,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\PrintHelpers.cs,AppendIntegerTo,The following statement contains a magic number: int shift = @base > 8 ? (@base <= 16 ? 4 : 5) 				  : (@base <= 2 ? 1 : @base <= 4 ? 2 : 3);
Magic Number,Loyc.Threading,ThreadEx,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\ThreadEx.cs,ThreadStart,The following statement contains a magic number: try { 				// Inherit thread-local variables from parent 				InheritThreadLocalVars(_parent.ManagedThreadId);  				// Note that Start() is still running in the parent thread 				if (ThreadStarting != null) 					ThreadStarting(this' new ThreadStartEventArgs(_parent' this));  				_startState = 2; // allow parent thread to continue  				if (_ts2 != null) 					_ts2(parameter); 				else 					_ts1(); 			} finally { 				_startState = 3; // ensure parent thread continues  				if (ThreadStopping != null) 					ThreadStopping(this' new ThreadStartEventArgs(_parent' this));  				DeinitThreadLocalVars(); 			}
Magic Number,Loyc.Threading,ThreadEx,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\ThreadEx.cs,ThreadStart,The following statement contains a magic number: try { 				// Inherit thread-local variables from parent 				InheritThreadLocalVars(_parent.ManagedThreadId);  				// Note that Start() is still running in the parent thread 				if (ThreadStarting != null) 					ThreadStarting(this' new ThreadStartEventArgs(_parent' this));  				_startState = 2; // allow parent thread to continue  				if (_ts2 != null) 					_ts2(parameter); 				else 					_ts1(); 			} finally { 				_startState = 3; // ensure parent thread continues  				if (ThreadStopping != null) 					ThreadStopping(this' new ThreadStartEventArgs(_parent' this));  				DeinitThreadLocalVars(); 			}
Missing Default,Loyc.MiniTest,Assert,C:\repos\qwertie_Loyc\Core\Loyc.Essentials\Utilities\MiniTest.cs,ThrowException,The following switch statement is missing a default case: switch (reason) 			{ 				case StopReason.Fail:   throw new AssertionException(msg); 				case StopReason.Ignore: throw new IgnoreException(msg); 				case StopReason.Inconclusive: throw new InconclusiveException(msg); 				case StopReason.Success: throw new SuccessException(msg); 			}
