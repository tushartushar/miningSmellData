Implementation smell,Namespace,Class,File,Method,Description
Long Method,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The method has 405 lines of code.
Long Method,Loyc,GoInterfaceBenchmark,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\GoInterfaceBenchmark.cs,DoBenchmark,The method has 104 lines of code.
Complex Method,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ThreadLocalStorage,Cyclomatic complexity of the method is 9
Complex Method,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,Cyclomatic complexity of the method is 56
Complex Method,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,LinqVsForLoop,Cyclomatic complexity of the method is 9
Complex Method,Benchmark,Benchmarker,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmarker.cs,RunPublicBenchmarks,Cyclomatic complexity of the method is 15
Complex Method,Benchmark,Benchmarker,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmarker.cs,PrintResults,Cyclomatic complexity of the method is 8
Complex Method,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,UpdateGraph,Cyclomatic complexity of the method is 8
Long Parameter List,Benchmark,Benchmarker,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmarker.cs,RunCore,The method has 5 parameters. Parameters: minMillisec' code' loopTimes' noGC' totalTime
Long Parameter List,Benchmark,Benchmarker,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmarker.cs,RunPublicBenchmarks,The method has 5 parameters. Parameters: subject' randomOrder' postprocess' prefix' clearOldResults
Long Parameter List,Benchmark,Benchmarker,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmarker.cs,PrintResults,The method has 7 parameters. Parameters: writer' results' separator' addPadding' userDataFormatter' userDataColumnName' numberFormat
Long Parameter List,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,TrialMembershipTests,The method has 5 parameters. Parameters: data' start' stop' time' set
Long Parameter List,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,TrialMembershipTests,The method has 5 parameters. Parameters: data' start' stop' time' set
Long Statement,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,EnumeratorVsIterator,The length of the statement  "			Console.WriteLine("However' Iterator.MoveNext needs {0:0.0}% as much time as Iterator used directly."' total2b * 100.0 / total2);" is 129.
Long Statement,Benchmark,Benchmarker,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmarker.cs,RunPublicBenchmarks,The length of the statement  "						var methodDelegate = (Func<Benchmarker' object>)Delegate.CreateDelegate(typeof(Func<Benchmarker' object>)' subject' method' false);" is 131.
Long Statement,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,CountMemory,The length of the statement  "				HashSet_buckets = set.GetType().GetField("m_buckets"' BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.IgnoreCase);" is 128.
Long Statement,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,CountMemory,The length of the statement  "			// size of Dictionary<T'T> itself (buckets' entries' KeyCollection' ValueCollection' SyncRoot' SerializationInfo' Comparer' count' version' freeList' freeCount)" is 160.
Long Statement,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,CountMemory,The length of the statement  "				Dict_buckets = set.GetType().GetField("buckets"' BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.IgnoreCase);" is 123.
Long Statement,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,InitializeComponent,The length of the statement  "			this._tabs.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) " is 141.
Long Statement,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,InitializeComponent,The length of the statement  "			this.btnSaveAll.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));" is 149.
Long Statement,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,InitializeComponent,The length of the statement  "			this.btnSaveCurrent.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));" is 153.
Long Statement,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,Run,The length of the statement  "				model.PlotMargins = new OxyThickness(double.NaN' double.NaN' 12' double.NaN); // avoid cutting off "1000000" (NaN=autodetect)" is 125.
Complex Conditional,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The conditional expression  "total1 != total2 || total2 != total3 || total2 != total2b || total3 != total5"  is complex.
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ThreadLocalStorage,The following statement contains a magic number: const int Iterations = 10000000;
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ThreadLocalStorage,The following statement contains a magic number: for (int i = 0; i < Iterations/5; i++) 				Thread.SetData(_tlSlot' (int)Thread.GetData(_tlSlot) + i);
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ThreadLocalStorage,The following statement contains a magic number: time = t.Restart() * 5;
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: byte[] array1 = new byte[256];
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: byte[] array2 = new byte[256];
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: const int Iterations = 2000000;
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 				for (int B = 0; B < 256; B++) 					array1[B] = (byte)B;
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				fixed (byte* p = array1) 				{ 					// Do effectively the same thing as the first two loops (on a  					// little-endian machine)' but 32 bits at once 					uint* p2 = (uint*)p; 					int length2 = array1.Length >> 2; 					for (int dw = 0; dw < length2; dw++) 					{ 						uint B = (uint)dw << 2; 						p2[dw] = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				fixed (byte* p = array1) 				{ 					// Do effectively the same thing as the first two loops (on a  					// little-endian machine)' but 32 bits at once 					uint* p2 = (uint*)p; 					int length2 = array1.Length >> 2; 					for (int dw = 0; dw < length2; dw++) 					{ 						uint B = (uint)dw << 2; 						p2[dw] = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				fixed (byte* p = array1) 				{ 					// Do effectively the same thing as the first two loops (on a  					// little-endian machine)' but 32 bits at once 					uint* p2 = (uint*)p; 					int length2 = array1.Length >> 2; 					for (int dw = 0; dw < length2; dw++) 					{ 						uint B = (uint)dw << 2; 						p2[dw] = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				fixed (byte* p = array1) 				{ 					// Do effectively the same thing as the first two loops (on a  					// little-endian machine)' but 32 bits at once 					uint* p2 = (uint*)p; 					int length2 = array1.Length >> 2; 					for (int dw = 0; dw < length2; dw++) 					{ 						uint B = (uint)dw << 2; 						p2[dw] = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				fixed (byte* p = array1) 				{ 					// Do effectively the same thing as the first two loops (on a  					// little-endian machine)' but 32 bits at once 					uint* p2 = (uint*)p; 					int length2 = array1.Length >> 2; 					for (int dw = 0; dw < length2; dw++) 					{ 						uint B = (uint)dw << 2; 						p2[dw] = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				fixed (byte* p = array1) 				{ 					// Do effectively the same thing as the first two loops (on a  					// little-endian machine)' but 32 bits at once 					uint* p2 = (uint*)p; 					int length2 = array1.Length >> 2; 					for (int dw = 0; dw < length2; dw++) 					{ 						uint B = (uint)dw << 2; 						p2[dw] = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				fixed (byte* p = array1) 				{ 					// Do effectively the same thing as the first two loops (on a  					// little-endian machine)' but 32 bits at once 					uint* p2 = (uint*)p; 					int length2 = array1.Length >> 2; 					for (int dw = 0; dw < length2; dw++) 					{ 						uint B = (uint)dw << 2; 						p2[dw] = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				fixed (byte* p = array1) 				{ 					// same as the last test' but with an advancing pointer 					uint* p2 = (uint*)p; 					for (uint B = 0; B < array1.Length; B += 4) 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				fixed (byte* p = array1) 				{ 					// same as the last test' but with an advancing pointer 					uint* p2 = (uint*)p; 					for (uint B = 0; B < array1.Length; B += 4) 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				fixed (byte* p = array1) 				{ 					// same as the last test' but with an advancing pointer 					uint* p2 = (uint*)p; 					for (uint B = 0; B < array1.Length; B += 4) 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				fixed (byte* p = array1) 				{ 					// same as the last test' but with an advancing pointer 					uint* p2 = (uint*)p; 					for (uint B = 0; B < array1.Length; B += 4) 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				fixed (byte* p = array1) 				{ 					// same as the last test' but with an advancing pointer 					uint* p2 = (uint*)p; 					for (uint B = 0; B < array1.Length; B += 4) 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				fixed (byte* p = array1) 				{ 					// same as the last test' but with an advancing pointer 					uint* p2 = (uint*)p; 					for (uint B = 0; B < array1.Length; B += 4) 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				int left2 = array1.Length >> 2; 				fixed (byte* p = array1) { 					// Fast fill: fill with zeros 					uint* p2 = (uint*)p; 					while (left2-- > 0) 						*p2++ = 0; 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				fixed (byte* p = array1) { 					// same as test #3' but unrolled 					uint* p2 = (uint*)p; 					for (uint B = 0; B < array1.Length; B += 4) { 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 						B += 4; 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				fixed (byte* p = array1) { 					// same as test #3' but unrolled 					uint* p2 = (uint*)p; 					for (uint B = 0; B < array1.Length; B += 4) { 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 						B += 4; 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				fixed (byte* p = array1) { 					// same as test #3' but unrolled 					uint* p2 = (uint*)p; 					for (uint B = 0; B < array1.Length; B += 4) { 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 						B += 4; 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				fixed (byte* p = array1) { 					// same as test #3' but unrolled 					uint* p2 = (uint*)p; 					for (uint B = 0; B < array1.Length; B += 4) { 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 						B += 4; 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				fixed (byte* p = array1) { 					// same as test #3' but unrolled 					uint* p2 = (uint*)p; 					for (uint B = 0; B < array1.Length; B += 4) { 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 						B += 4; 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				fixed (byte* p = array1) { 					// same as test #3' but unrolled 					uint* p2 = (uint*)p; 					for (uint B = 0; B < array1.Length; B += 4) { 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 						B += 4; 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				fixed (byte* p = array1) { 					// same as test #3' but unrolled 					uint* p2 = (uint*)p; 					for (uint B = 0; B < array1.Length; B += 4) { 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 						B += 4; 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				fixed (byte* p = array1) { 					// same as test #3' but unrolled 					uint* p2 = (uint*)p; 					for (uint B = 0; B < array1.Length; B += 4) { 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 						B += 4; 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				fixed (byte* p = array1) { 					// same as test #3' but unrolled 					uint* p2 = (uint*)p; 					for (uint B = 0; B < array1.Length; B += 4) { 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 						B += 4; 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				fixed (byte* p = array1) { 					// same as test #3' but unrolled 					uint* p2 = (uint*)p; 					for (uint B = 0; B < array1.Length; B += 4) { 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 						B += 4; 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				fixed (byte* p = array1) { 					// same as test #3' but unrolled 					uint* p2 = (uint*)p; 					for (uint B = 0; B < array1.Length; B += 4) { 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 						B += 4; 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				fixed (byte* p = array1) { 					// same as test #3' but unrolled 					uint* p2 = (uint*)p; 					for (uint B = 0; B < array1.Length; B += 4) { 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 						B += 4; 						*p2++ = B | ((B + 1) << 8) | ((B + 2) << 16) | ((B + 3) << 24); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				int left2 = array1.Length >> 2; 				fixed (byte* p = array2) 				{ 					uint* p2 = (uint*)p; 					while (left2-- > 0) 					{ 						uint v = *p2++; 						total3 += (int)((v >> 24) + (byte)(v >> 16) + (byte)(v >> 8) + (byte)v); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				int left2 = array1.Length >> 2; 				fixed (byte* p = array2) 				{ 					uint* p2 = (uint*)p; 					while (left2-- > 0) 					{ 						uint v = *p2++; 						total3 += (int)((v >> 24) + (byte)(v >> 16) + (byte)(v >> 8) + (byte)v); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				int left2 = array1.Length >> 2; 				fixed (byte* p = array2) 				{ 					uint* p2 = (uint*)p; 					while (left2-- > 0) 					{ 						uint v = *p2++; 						total3 += (int)((v >> 24) + (byte)(v >> 16) + (byte)(v >> 8) + (byte)v); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				int left2 = array1.Length >> 2; 				fixed (byte* p = array2) 				{ 					uint* p2 = (uint*)p; 					while (left2-- > 0) 					{ 						uint v = *p2++; 						total3 += (int)((v >> 24) + (byte)(v >> 16) + (byte)(v >> 8) + (byte)v); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				int left2 = array1.Length >> 2; 				fixed (byte* p = array2) 				{ 					uint* p2 = (uint*)p; 					while (left2-- > 0) 						dummy += (int)(*p2++); 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				int lengthDW = array1.Length >> 2; 				fixed (byte* p = array2) { 					// same as test #3' but unrolled 					uint* p2 = (uint*)p; 					for (int dw = 0; dw < lengthDW;) { 						uint v = p2[dw++]; 						total5 += (int)((v >> 24) + (byte)(v >> 16) + (byte)(v >> 8) + (byte)v); 						v = p2[dw++]; 						total5 += (int)((v >> 24) + (byte)(v >> 16) + (byte)(v >> 8) + (byte)v); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				int lengthDW = array1.Length >> 2; 				fixed (byte* p = array2) { 					// same as test #3' but unrolled 					uint* p2 = (uint*)p; 					for (int dw = 0; dw < lengthDW;) { 						uint v = p2[dw++]; 						total5 += (int)((v >> 24) + (byte)(v >> 16) + (byte)(v >> 8) + (byte)v); 						v = p2[dw++]; 						total5 += (int)((v >> 24) + (byte)(v >> 16) + (byte)(v >> 8) + (byte)v); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				int lengthDW = array1.Length >> 2; 				fixed (byte* p = array2) { 					// same as test #3' but unrolled 					uint* p2 = (uint*)p; 					for (int dw = 0; dw < lengthDW;) { 						uint v = p2[dw++]; 						total5 += (int)((v >> 24) + (byte)(v >> 16) + (byte)(v >> 8) + (byte)v); 						v = p2[dw++]; 						total5 += (int)((v >> 24) + (byte)(v >> 16) + (byte)(v >> 8) + (byte)v); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				int lengthDW = array1.Length >> 2; 				fixed (byte* p = array2) { 					// same as test #3' but unrolled 					uint* p2 = (uint*)p; 					for (int dw = 0; dw < lengthDW;) { 						uint v = p2[dw++]; 						total5 += (int)((v >> 24) + (byte)(v >> 16) + (byte)(v >> 8) + (byte)v); 						v = p2[dw++]; 						total5 += (int)((v >> 24) + (byte)(v >> 16) + (byte)(v >> 8) + (byte)v); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				int lengthDW = array1.Length >> 2; 				fixed (byte* p = array2) { 					// same as test #3' but unrolled 					uint* p2 = (uint*)p; 					for (int dw = 0; dw < lengthDW;) { 						uint v = p2[dw++]; 						total5 += (int)((v >> 24) + (byte)(v >> 16) + (byte)(v >> 8) + (byte)v); 						v = p2[dw++]; 						total5 += (int)((v >> 24) + (byte)(v >> 16) + (byte)(v >> 8) + (byte)v); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				int lengthDW = array1.Length >> 2; 				fixed (byte* p = array2) { 					// same as test #3' but unrolled 					uint* p2 = (uint*)p; 					for (int dw = 0; dw < lengthDW;) { 						uint v = p2[dw++]; 						total5 += (int)((v >> 24) + (byte)(v >> 16) + (byte)(v >> 8) + (byte)v); 						v = p2[dw++]; 						total5 += (int)((v >> 24) + (byte)(v >> 16) + (byte)(v >> 8) + (byte)v); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) { 				int lengthDW = array1.Length >> 2; 				fixed (byte* p = array2) { 					// same as test #3' but unrolled 					uint* p2 = (uint*)p; 					for (int dw = 0; dw < lengthDW;) { 						uint v = p2[dw++]; 						total5 += (int)((v >> 24) + (byte)(v >> 16) + (byte)(v >> 8) + (byte)v); 						v = p2[dw++]; 						total5 += (int)((v >> 24) + (byte)(v >> 16) + (byte)(v >> 8) + (byte)v); 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				int left2 = array1.Length >> 2; 				fixed (byte* p1 = array1) 				fixed (byte* p2 = array2) 				{ 					uint* dw1 = (uint*)p1; 					uint* dw2 = (uint*)p2; 					while (left2-- > 0) 						*dw1++ = *dw2++; 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				for (int dw = 0; dw < (array1.Length >> 2); dw++) 				{ 					fixed (byte* p1 = &array1[dw << 2]) 					fixed (byte* p2 = &array2[dw << 2]) 					{ 						uint* dw1 = (uint*)p1; 						uint* dw2 = (uint*)p2; 						*dw1 = *dw2; 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				for (int dw = 0; dw < (array1.Length >> 2); dw++) 				{ 					fixed (byte* p1 = &array1[dw << 2]) 					fixed (byte* p2 = &array2[dw << 2]) 					{ 						uint* dw1 = (uint*)p1; 						uint* dw2 = (uint*)p2; 						*dw1 = *dw2; 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 			{ 				for (int dw = 0; dw < (array1.Length >> 2); dw++) 				{ 					fixed (byte* p1 = &array1[dw << 2]) 					fixed (byte* p2 = &array2[dw << 2]) 					{ 						uint* dw1 = (uint*)p1; 						uint* dw2 = (uint*)p2; 						*dw1 = *dw2; 					} 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 				for (int B = 0; B < array1.Length; B += 16) 					Array.Copy(array1' B' array2' B' 16);
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 				for (int B = 0; B < array1.Length; B += 16) 					Array.Copy(array1' B' array2' B' 16);
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: Cell[] cells = new Cell[64];
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: for (int i = 0; i < Iterations; i++) 				for (int c = 0; c < 64; c++) 				{ 					cells[c].a = (byte)c; 					cells[c].b = (byte)c; 					cells[c].c = (byte)c; 					cells[c].d = (byte)c; 				}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ByteArrayAccess,The following statement contains a magic number: Cell[] cells2 = new Cell[64];
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,EnumeratorVsIterator,The following statement contains a magic number: const int Limit = 333333333;
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,EnumeratorVsIterator,The following statement contains a magic number: for (int i = 0; i < 3; i++) 			{ 				Console.Write("IEnumerator<int>...  "); 				t.Restart(); 				var b1 = Counter1(Limit); 				int current; 				while (b1.MoveNext()) 					current = b1.Current; 				total1 += t.Millisec; 				Console.WriteLine("{0} seconds"' t.Millisec * 0.001);  				Console.Write("Iterator<int>...     "); 				t.Restart(); 				var b2 = Counter2(Limit); 				bool ended = false; 				do 					current = b2(ref ended); 				while (!ended); 				total2 += t.Millisec; 				Console.WriteLine("{0} seconds"' t.Millisec * 0.001);  				Console.Write("Iterator.MoveNext... "); 				t.Restart(); 				b2 = Counter2(Limit); 				while (b2.MoveNext(out current)) { } 				total2b += t.Millisec; 				Console.WriteLine("{0} seconds"' t.Millisec * 0.001); 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,EnumeratorVsIterator,The following statement contains a magic number: for (int i = 0; i < 3; i++) 			{ 				Console.Write("IEnumerator<int>...  "); 				t.Restart(); 				var b1 = Counter1(Limit); 				int current; 				while (b1.MoveNext()) 					current = b1.Current; 				total1 += t.Millisec; 				Console.WriteLine("{0} seconds"' t.Millisec * 0.001);  				Console.Write("Iterator<int>...     "); 				t.Restart(); 				var b2 = Counter2(Limit); 				bool ended = false; 				do 					current = b2(ref ended); 				while (!ended); 				total2 += t.Millisec; 				Console.WriteLine("{0} seconds"' t.Millisec * 0.001);  				Console.Write("Iterator.MoveNext... "); 				t.Restart(); 				b2 = Counter2(Limit); 				while (b2.MoveNext(out current)) { } 				total2b += t.Millisec; 				Console.WriteLine("{0} seconds"' t.Millisec * 0.001); 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,EnumeratorVsIterator,The following statement contains a magic number: for (int i = 0; i < 3; i++) 			{ 				Console.Write("IEnumerator<int>...  "); 				t.Restart(); 				var b1 = Counter1(Limit); 				int current; 				while (b1.MoveNext()) 					current = b1.Current; 				total1 += t.Millisec; 				Console.WriteLine("{0} seconds"' t.Millisec * 0.001);  				Console.Write("Iterator<int>...     "); 				t.Restart(); 				var b2 = Counter2(Limit); 				bool ended = false; 				do 					current = b2(ref ended); 				while (!ended); 				total2 += t.Millisec; 				Console.WriteLine("{0} seconds"' t.Millisec * 0.001);  				Console.Write("Iterator.MoveNext... "); 				t.Restart(); 				b2 = Counter2(Limit); 				while (b2.MoveNext(out current)) { } 				total2b += t.Millisec; 				Console.WriteLine("{0} seconds"' t.Millisec * 0.001); 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,EnumeratorVsIterator,The following statement contains a magic number: for (int i = 0; i < 3; i++) 			{ 				Console.Write("IEnumerator<int>...  "); 				t.Restart(); 				var b1 = Counter1(Limit); 				int current; 				while (b1.MoveNext()) 					current = b1.Current; 				total1 += t.Millisec; 				Console.WriteLine("{0} seconds"' t.Millisec * 0.001);  				Console.Write("Iterator<int>...     "); 				t.Restart(); 				var b2 = Counter2(Limit); 				bool ended = false; 				do 					current = b2(ref ended); 				while (!ended); 				total2 += t.Millisec; 				Console.WriteLine("{0} seconds"' t.Millisec * 0.001);  				Console.Write("Iterator.MoveNext... "); 				t.Restart(); 				b2 = Counter2(Limit); 				while (b2.MoveNext(out current)) { } 				total2b += t.Millisec; 				Console.WriteLine("{0} seconds"' t.Millisec * 0.001); 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,EnumeratorVsIterator,The following statement contains a magic number: Console.WriteLine("On average' IEnumerator consumes {0:0.0}% as much time as Iterator."' total1 * 100.0 / total2);
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,EnumeratorVsIterator,The following statement contains a magic number: Console.WriteLine("However' Iterator.MoveNext needs {0:0.0}% as much time as Iterator used directly."' total2b * 100.0 / total2);
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,BenchmarkSets,The following statement contains a magic number: Debug.Assert(words.Length * words.Length >= 250000);
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,BenchmarkSets,The following statement contains a magic number: for (int i = 0; words2.Count < 200000; i++) 				words2.Add(string.Format("{0} {1} {2}"' words[_r.Next(words.Length)]' words[_r.Next(words.Length)]' i));
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,LinqVsForLoop,The following statement contains a magic number: for (int i = 0; i < 1000000; i++) 				numbers.Add(r.Next(1000000));
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,LinqVsForLoop,The following statement contains a magic number: for (int i = 0; i < 1000000; i++) 				numbers.Add(r.Next(1000000));
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,LinqVsForLoop,The following statement contains a magic number: for (int trial = 0; trial < 200; trial++) 			{ 				numbers2 = (from n in numbers where n < 100000 select n + 1).ToList(); 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,LinqVsForLoop,The following statement contains a magic number: for (int trial = 0; trial < 200; trial++) 			{ 				numbers2 = (from n in numbers where n < 100000 select n + 1).ToList(); 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,LinqVsForLoop,The following statement contains a magic number: for (int trial = 0; trial < 200; trial++) 			{ 				numbers2 = new List<int>(); 				for (int i = 0; i < numbers.Count; i++) { 					int n = numbers[i]; 					if (n < 100000) 						numbers2.Add(n + 1); 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,LinqVsForLoop,The following statement contains a magic number: for (int trial = 0; trial < 200; trial++) 			{ 				numbers2 = new List<int>(); 				for (int i = 0; i < numbers.Count; i++) { 					int n = numbers[i]; 					if (n < 100000) 						numbers2.Add(n + 1); 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,LinqVsForLoop,The following statement contains a magic number: for (int trial = 0; trial < 200; trial++) 			{ 				numbers2 = new List<int>(); 				foreach (int n in numbers) { 					if (n < 100000) 						numbers2.Add(n + 1); 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,LinqVsForLoop,The following statement contains a magic number: for (int trial = 0; trial < 200; trial++) 			{ 				numbers2 = new List<int>(); 				foreach (int n in numbers) { 					if (n < 100000) 						numbers2.Add(n + 1); 				} 			}
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ConvexHull,The following statement contains a magic number: int[] testSizes = new int[] { 12345' 100' 316' 1000' 3160' 10000' 31600' 100000' 316000' 1000000' 3160000' 10000000 };
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ConvexHull,The following statement contains a magic number: int[] testSizes = new int[] { 12345' 100' 316' 1000' 3160' 10000' 31600' 100000' 316000' 1000000' 3160000' 10000000 };
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ConvexHull,The following statement contains a magic number: int[] testSizes = new int[] { 12345' 100' 316' 1000' 3160' 10000' 31600' 100000' 316000' 1000000' 3160000' 10000000 };
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ConvexHull,The following statement contains a magic number: int[] testSizes = new int[] { 12345' 100' 316' 1000' 3160' 10000' 31600' 100000' 316000' 1000000' 3160000' 10000000 };
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ConvexHull,The following statement contains a magic number: int[] testSizes = new int[] { 12345' 100' 316' 1000' 3160' 10000' 31600' 100000' 316000' 1000000' 3160000' 10000000 };
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ConvexHull,The following statement contains a magic number: int[] testSizes = new int[] { 12345' 100' 316' 1000' 3160' 10000' 31600' 100000' 316000' 1000000' 3160000' 10000000 };
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ConvexHull,The following statement contains a magic number: int[] testSizes = new int[] { 12345' 100' 316' 1000' 3160' 10000' 31600' 100000' 316000' 1000000' 3160000' 10000000 };
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ConvexHull,The following statement contains a magic number: int[] testSizes = new int[] { 12345' 100' 316' 1000' 3160' 10000' 31600' 100000' 316000' 1000000' 3160000' 10000000 };
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ConvexHull,The following statement contains a magic number: int[] testSizes = new int[] { 12345' 100' 316' 1000' 3160' 10000' 31600' 100000' 316000' 1000000' 3160000' 10000000 };
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ConvexHull,The following statement contains a magic number: int[] testSizes = new int[] { 12345' 100' 316' 1000' 3160' 10000' 31600' 100000' 316000' 1000000' 3160000' 10000000 };
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ConvexHull,The following statement contains a magic number: int[] testSizes = new int[] { 12345' 100' 316' 1000' 3160' 10000' 31600' 100000' 316000' 1000000' 3160000' 10000000 };
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ConvexHull,The following statement contains a magic number: int[] testSizes = new int[] { 12345' 100' 316' 1000' 3160' 10000' 31600' 100000' 316000' 1000000' 3160000' 10000000 };
Magic Number,Benchmark,Benchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmark.cs,ConvexHull,The following statement contains a magic number: for (int iter = 0; iter < testSizes.Length; iter++) { 				Random r = new Random(); 				 				List<PointD> points = new List<PointD>(testSizes[iter]); 				for (int i = 0; i < points.Capacity; i++) { 					double size = r.NextDouble(); 					double ang = r.NextDouble() * (Math.PI * 2); 					points.Add(new PointD(size * Math.Cos(ang)' size * Math.Sin(ang))); 				} 				// Plus: test sorting time to learn how much of the time is spent sorting 				var points2 = new List<PointD>(points); 				EzStopwatch timer = new EzStopwatch(true); 				points2.Sort((a' b) => a.X == b.X ? a.Y.CompareTo(b.Y) : (a.X < b.X ? -1 : 1)); 				Stopwatch timer2 = new Stopwatch(); timer2.Start(); 				int sortTime = timer.Restart(); 				IListSource<Point<double>> output = PointMath.ComputeConvexHull(points' true); 				int hullTime = timer.Millisec; 				Console.WriteLine("{0:c}   (ticks:{1'10} freq:{2})"' timer2.Elapsed' timer2.ElapsedTicks' Stopwatch.Frequency);  				if (iter == 0) continue; // first iteration primes the JIT/caches 				Console.WriteLine("Convex hull of {0'8} points took {1} ms ({2} ms for sorting step). Output has {3} points."'  					testSizes[iter]' hullTime' sortTime' output.Count); 			}
Magic Number,Benchmark,Benchmarker,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmarker.cs,PrintResults,The following statement contains a magic number: if (results.Any(p => p.Value.Count >= 2)) 				columns.Add(new ColInfo("Average"' p => p.Value.Avg().ToString(numberFormat)));
Magic Number,Benchmark,Benchmarker,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\Benchmarker.cs,PrintResults,The following statement contains a magic number: if (results.Any(p => p.Value.Count >= 3)) 			{ 				columns.Add(new ColInfo("Max"' p => p.Value.Max.ToString(numberFormat))); 				columns.Add(new ColInfo("Min"' p => p.Value.Min.ToString(numberFormat))); 				columns.Add(new ColInfo("Std.Dev"' p => p.Value.StdDeviation().ToString(numberFormat))); 			}
Magic Number,Benchmark,BenchmarkSetsBase<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,DoForVariousSizes,The following statement contains a magic number: for (int size = 5; size <= maxSize; size *= 2) { 				DoForSize(description' testCode' size); 				iterations++; 				//DoForSize(description' testCode' size); 				//iterations++; 			}
Magic Number,Benchmark,BenchmarkSetsBase<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,DoForVariousSizes,The following statement contains a magic number: for (int size = 5; size <= maxSize; size *= 2) { 				DoForSize(description' testCode' size); 				iterations++; 				//DoForSize(description' testCode' size); 				//iterations++; 			}
Magic Number,Benchmark,Result,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,ToString,The following statement contains a magic number: if (HSetMemory != 0 && MSetMemory != 0) { 					msg += string.Format("'{0}%"' Math.Round((double)MSetMemory / (double)HSetMemory * 100.0)); 					Trace.WriteLine(msg); 					Trace.WriteLine(string.Format("HSetMemory={0}' MSetMemory={1}"' HSetMemory' MSetMemory)); 				}
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,Run,The following statement contains a magic number: int size50 = _data.Length * 2 / 3;
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,Run,The following statement contains a magic number: int size50 = _data.Length * 2 / 3;
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,Run,The following statement contains a magic number: int size0 = _data.Length / 2;
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,Run,The following statement contains a magic number: DoForVariousSizes("Add items' half new"'         size50'  size => DoAddTests(size' size/2));
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,Run,The following statement contains a magic number: DoForVariousSizes("Remove items' half found"'    size50'  size => DoRemoveTests(size' size/2));
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,Run,The following statement contains a magic number: DoForVariousSizes("Union' half overlap"'         size50'  size => DoSetOperationTests(size' size/2' Op.Or));
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,Run,The following statement contains a magic number: DoForVariousSizes("Intersect' half overlap"'     size50'  size => DoSetOperationTests(size' size/2' Op.And));
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,Run,The following statement contains a magic number: DoForVariousSizes("Subtract' half overlap"'      size50'  size => DoSetOperationTests(size' size/2' Op.Sub));
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,Run,The following statement contains a magic number: DoForVariousSizes("Xor' half overlap"'           size50'  size => DoSetOperationTests(size' size/2' Op.Xor));
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,Run,The following statement contains a magic number: DoForVariousSizes("Membership' half found"'      size50'  size => DoMembershipTests(size' size/2));
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,DoEnumeratorTests,The following statement contains a magic number: for (int counter = 0; counter < ItemQuota; counter += 10*size) { 				i = (i + 2) % (_data.Length - size); 				SetData(_data.Slice(i' size)); 				DoTimes(10' TrialEnumerateSets); 			}
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,DoEnumeratorTests,The following statement contains a magic number: for (int counter = 0; counter < ItemQuota; counter += 10*size) { 				i = (i + 2) % (_data.Length - size); 				SetData(_data.Slice(i' size)); 				DoTimes(10' TrialEnumerateSets); 			}
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,DoEnumeratorTests,The following statement contains a magic number: for (int counter = 0; counter < ItemQuota; counter += 10*size) { 				i = (i + 2) % (_data.Length - size); 				SetData(_data.Slice(i' size)); 				DoTimes(10' TrialEnumerateSets); 			}
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,TrialEnumerateSets,The following statement contains a magic number: Debug.Assert(count == _hSet.Count * 3);
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,CountMemory,The following statement contains a magic number: int bytes = IntPtr.Size * 6 + 4 * 4;
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,CountMemory,The following statement contains a magic number: int bytes = IntPtr.Size * 6 + 4 * 4;
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,CountMemory,The following statement contains a magic number: int bytes = IntPtr.Size * 6 + 4 * 4;
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,CountMemory,The following statement contains a magic number: if (arrayLength != 0) { 				bytes += IntPtr.Size * 6; // overhead of the two arrays in HashSet 				bytes += arrayLength * (sizeOfT + 12); // size of the buckets' cached hashcodes' "next" indexes and T data 			}
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,CountMemory,The following statement contains a magic number: if (arrayLength != 0) { 				bytes += IntPtr.Size * 6; // overhead of the two arrays in HashSet 				bytes += arrayLength * (sizeOfT + 12); // size of the buckets' cached hashcodes' "next" indexes and T data 			}
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,DoMembershipTests,The following statement contains a magic number: for (int counter = 0; counter < ItemQuota; counter += 10 * size) { 				i0 = (i0 + 2) % (_data.Length - (size + phase)); 				i1 = i0 + phase; 				SetData(_data.Slice(i0' size)); 				DoTimes(10' () => TrialMembershipTests(_data' i1' i1 + size)); 			}
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,DoMembershipTests,The following statement contains a magic number: for (int counter = 0; counter < ItemQuota; counter += 10 * size) { 				i0 = (i0 + 2) % (_data.Length - (size + phase)); 				i1 = i0 + phase; 				SetData(_data.Slice(i0' size)); 				DoTimes(10' () => TrialMembershipTests(_data' i1' i1 + size)); 			}
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,DoMembershipTests,The following statement contains a magic number: for (int counter = 0; counter < ItemQuota; counter += 10 * size) { 				i0 = (i0 + 2) % (_data.Length - (size + phase)); 				i1 = i0 + phase; 				SetData(_data.Slice(i0' size)); 				DoTimes(10' () => TrialMembershipTests(_data' i1' i1 + size)); 			}
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,DoAddTests,The following statement contains a magic number: for (int counter = 0; counter < ItemQuota; counter += size) { 				i = (i + 2) % (_data.Length - size); 				SetData(_data.Slice(i' prepopulation)); 				TrialAdds(_data' i' i + size' true); 			}
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,DoRemoveTests,The following statement contains a magic number: for (int counter = 0; counter < ItemQuota; counter += size) { 				i0 = (i0 + 2) % (_data.Length - (size + phase)); 				i1 = i0 + phase; 				SetData(_data.Slice(i0' size)); 				TrialRemoves(_data' i1' i1 + size' true); 			}
Magic Number,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,DoSetOperationTests,The following statement contains a magic number: for (int counter = 0; counter < ItemQuota; counter += size) { 				i0 = (i0 + 2) % (_data.Length - (size + phase)); 				i1 = i0 + phase; 				TrialSetOperation(_data.Slice(i0' size)' _data.Slice(i1' size)' op); 			}
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,Run,The following statement contains a magic number: int size50 = _data.Length * 2 / 3;
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,Run,The following statement contains a magic number: int size50 = _data.Length * 2 / 3;
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,Run,The following statement contains a magic number: int size0 = _data.Length / 2;
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,Run,The following statement contains a magic number: DoForVariousSizes("Add items' half new"'         size50'  size => DoAddTests(size' size/2));
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,Run,The following statement contains a magic number: DoForVariousSizes("Remove items' half found"'    size50'  size => DoRemoveTests(size' size/2));
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,Run,The following statement contains a magic number: DoForVariousSizes("Membership' half found"'      size50'  size => DoMembershipTests(size' size/2));
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,DoEnumeratorTests,The following statement contains a magic number: for (int counter = 0; counter < ItemQuota; counter += 10*size) { 				i = (i + 2) % (_data.Length - size); 				SetData(_data.Slice(i' size)); 				DoTimes(10' TrialEnumerateSets); 			}
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,DoEnumeratorTests,The following statement contains a magic number: for (int counter = 0; counter < ItemQuota; counter += 10*size) { 				i = (i + 2) % (_data.Length - size); 				SetData(_data.Slice(i' size)); 				DoTimes(10' TrialEnumerateSets); 			}
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,DoEnumeratorTests,The following statement contains a magic number: for (int counter = 0; counter < ItemQuota; counter += 10*size) { 				i = (i + 2) % (_data.Length - size); 				SetData(_data.Slice(i' size)); 				DoTimes(10' TrialEnumerateSets); 			}
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,TrialEnumerateSets,The following statement contains a magic number: Debug.Assert(count == _hSet.Count * 3);
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,CountMemory,The following statement contains a magic number: int bytes = IntPtr.Size * 7 + 4 * 4;
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,CountMemory,The following statement contains a magic number: int bytes = IntPtr.Size * 7 + 4 * 4;
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,CountMemory,The following statement contains a magic number: int bytes = IntPtr.Size * 7 + 4 * 4;
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,CountMemory,The following statement contains a magic number: if (arrayLength != 0) { 				bytes += IntPtr.Size * 6; // overhead of the two arrays in Dictionary 				bytes += arrayLength * (sizeOfPair + 12); // size of the buckets' cached hashcodes' "next" indexes and pairs 			}
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,CountMemory,The following statement contains a magic number: if (arrayLength != 0) { 				bytes += IntPtr.Size * 6; // overhead of the two arrays in Dictionary 				bytes += arrayLength * (sizeOfPair + 12); // size of the buckets' cached hashcodes' "next" indexes and pairs 			}
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,DoMembershipTests,The following statement contains a magic number: for (int counter = 0; counter < ItemQuota; counter += 10 * size) { 				i0 = (i0 + 2) % (_data.Length - (size + phase)); 				i1 = i0 + phase; 				SetData(_data.Slice(i0' size)); 				DoTimes(10' () => TrialMembershipTests(_data' i1' i1 + size)); 			}
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,DoMembershipTests,The following statement contains a magic number: for (int counter = 0; counter < ItemQuota; counter += 10 * size) { 				i0 = (i0 + 2) % (_data.Length - (size + phase)); 				i1 = i0 + phase; 				SetData(_data.Slice(i0' size)); 				DoTimes(10' () => TrialMembershipTests(_data' i1' i1 + size)); 			}
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,DoMembershipTests,The following statement contains a magic number: for (int counter = 0; counter < ItemQuota; counter += 10 * size) { 				i0 = (i0 + 2) % (_data.Length - (size + phase)); 				i1 = i0 + phase; 				SetData(_data.Slice(i0' size)); 				DoTimes(10' () => TrialMembershipTests(_data' i1' i1 + size)); 			}
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,DoAddTests,The following statement contains a magic number: for (int counter = 0; counter < ItemQuota; counter += size) { 				i = (i + 2) % (_data.Length - size); 				SetData(_data.Slice(i' prepopulation)); 				TrialAdds(_data' i' i + size' true); 			}
Magic Number,Benchmark,BenchmarkMaps<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,DoRemoveTests,The following statement contains a magic number: for (int counter = 0; counter < ItemQuota; counter += size) { 				i0 = (i0 + 2) % (_data.Length - (size + phase)); 				i1 = i0 + phase; 				SetData(_data.Slice(i0' size)); 				TrialRemoves(_data' i1' i1 + size' true); 			}
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,EzChartForm,The following statement contains a magic number: for (int i = 0; i <= 11; i++) 			{ 				AddGraph("Example"' new PlotModel() { 					Title = "Example!"' 					LegendPosition = LegendPosition.TopLeft' 					LegendPlacement = LegendPlacement.Inside' 				}); 				Add("Example"' "Series A"' ((char)('A' + i)).ToString()' i); 				Add("Example"' "Series B"' i' i * i / 10.0); 				InitDefaultModel = (id' model) => { 					model.LegendPosition = LegendPosition.TopLeft; 				}; 			}
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,EzChartForm,The following statement contains a magic number: for (int i = 0; i <= 11; i++) 			{ 				AddGraph("Example"' new PlotModel() { 					Title = "Example!"' 					LegendPosition = LegendPosition.TopLeft' 					LegendPlacement = LegendPlacement.Inside' 				}); 				Add("Example"' "Series A"' ((char)('A' + i)).ToString()' i); 				Add("Example"' "Series B"' i' i * i / 10.0); 				InitDefaultModel = (id' model) => { 					model.LegendPosition = LegendPosition.TopLeft; 				}; 			}
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,UpdateGraphs,The following statement contains a magic number: foreach (var pair in Graphs) { 				var page = _tabs.TabPages.Cast<ChartPage>().FirstOrDefault(p => object.Equals(p.GraphId' pair.Key)); 				if (page == null) { 					page = new ChartPage(pair.Key' pair.Value' pair.Value.Title.Left(25)); 					_tabs.TabPages.Add(page); 				} 				page.Model = pair.Value; 			}
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,UpdateGraph,The following statement contains a magic number: foreach (var series in allSeries.Values) { 				if (series.Any(p => p.Parameter is string)) { 					var plotSeries = new ColumnSeries { Title = series.First().Series }; 					plotSeries.XAxisKey = cAxis.Key; 					foreach (var dp in series) 						plotSeries.Items.Add(new ColumnItem(dp.Value' cAxis.Labels.IndexOf(dp.Parameter.ToString()))); 					model.Series.Add(plotSeries); 				} else { 					var plotSeries = new LineSeries { Title = series.First().Series }; 					if (cAxis != null) plotSeries.XAxisKey = cAxis.Key; 					// There are 7 marker types starting at 1' excluding None (0) 					plotSeries.MarkerType = (MarkerType)((iSeries % 7) + 1); 					plotSeries.MarkerSize = 4; 					plotSeries.MarkerFill = plotSeries.Color;  					foreach (var dp in series) 						plotSeries.Points.Add(new OxyPlot.DataPoint(Convert.ToDouble(dp.Parameter)' dp.Value)); 					model.Series.Add(plotSeries); 				} 				iSeries++; 			}
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,UpdateGraph,The following statement contains a magic number: foreach (var series in allSeries.Values) { 				if (series.Any(p => p.Parameter is string)) { 					var plotSeries = new ColumnSeries { Title = series.First().Series }; 					plotSeries.XAxisKey = cAxis.Key; 					foreach (var dp in series) 						plotSeries.Items.Add(new ColumnItem(dp.Value' cAxis.Labels.IndexOf(dp.Parameter.ToString()))); 					model.Series.Add(plotSeries); 				} else { 					var plotSeries = new LineSeries { Title = series.First().Series }; 					if (cAxis != null) plotSeries.XAxisKey = cAxis.Key; 					// There are 7 marker types starting at 1' excluding None (0) 					plotSeries.MarkerType = (MarkerType)((iSeries % 7) + 1); 					plotSeries.MarkerSize = 4; 					plotSeries.MarkerFill = plotSeries.Color;  					foreach (var dp in series) 						plotSeries.Points.Add(new OxyPlot.DataPoint(Convert.ToDouble(dp.Parameter)' dp.Value)); 					model.Series.Add(plotSeries); 				} 				iSeries++; 			}
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,InitializeComponent,The following statement contains a magic number: this._tabs.Location = new System.Drawing.Point(4' 3);
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,InitializeComponent,The following statement contains a magic number: this._tabs.Location = new System.Drawing.Point(4' 3);
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,InitializeComponent,The following statement contains a magic number: this._tabs.Size = new System.Drawing.Size(577' 429);
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,InitializeComponent,The following statement contains a magic number: this._tabs.Size = new System.Drawing.Size(577' 429);
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSaveAll.Location = new System.Drawing.Point(485' 434);
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSaveAll.Location = new System.Drawing.Point(485' 434);
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSaveAll.Size = new System.Drawing.Size(96' 23);
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSaveAll.Size = new System.Drawing.Size(96' 23);
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSaveAll.TabIndex = 2;
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSaveCurrent.Location = new System.Drawing.Point(345' 434);
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSaveCurrent.Location = new System.Drawing.Point(345' 434);
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSaveCurrent.Size = new System.Drawing.Size(134' 23);
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSaveCurrent.Size = new System.Drawing.Size(134' 23);
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,InitializeComponent,The following statement contains a magic number: this.btnSaveCurrent.TabIndex = 2;
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(584' 462);
Magic Number,Benchmark,EzChartForm,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\EzChartForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(584' 462);
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,Run,The following statement contains a magic number: graph.InitDefaultModel = (id' model) => 			{ 				model.LegendPosition = LegendPosition.TopLeft; 				model.PlotMargins = new OxyThickness(double.NaN' double.NaN' 12' double.NaN); // avoid cutting off "1000000" (NaN=autodetect) 				model.Axes.Add(new LogarithmicAxis { 					Position = AxisPosition.Bottom' 					Title = "List size"' 					MajorGridlineStyle = LineStyle.Solid' 					MinorGridlineStyle = LineStyle.Dot 				}); 				int X = id.ToString().StartsWith("Scan by") ? StdIterations * 100 : StdIterations; 				model.Axes.Add(new LinearAxis {  					Position = AxisPosition.Left'  					Title = string.Format("Milliseconds to perform {0:n0} iterations"' X)' 					MajorGridlineStyle = LineStyle.Solid' 					MinorGridlineStyle = LineStyle.Dot' 					Minimum = -1' 				}); 			};
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,Run,The following statement contains a magic number: graph.InitDefaultModel = (id' model) => 			{ 				model.LegendPosition = LegendPosition.TopLeft; 				model.PlotMargins = new OxyThickness(double.NaN' double.NaN' 12' double.NaN); // avoid cutting off "1000000" (NaN=autodetect) 				model.Axes.Add(new LogarithmicAxis { 					Position = AxisPosition.Bottom' 					Title = "List size"' 					MajorGridlineStyle = LineStyle.Solid' 					MinorGridlineStyle = LineStyle.Dot 				}); 				int X = id.ToString().StartsWith("Scan by") ? StdIterations * 100 : StdIterations; 				model.Axes.Add(new LinearAxis {  					Position = AxisPosition.Left'  					Title = string.Format("Milliseconds to perform {0:n0} iterations"' X)' 					MajorGridlineStyle = LineStyle.Solid' 					MinorGridlineStyle = LineStyle.Dot' 					Minimum = -1' 				}); 			};
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,Run,The following statement contains a magic number: Run(b' 30);
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,Run,The following statement contains a magic number: Run(b' 100);
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,Run,The following statement contains a magic number: Run(b' 300);
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,Run,The following statement contains a magic number: Run(b' 1000);
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,Run,The following statement contains a magic number: Run(b' 3000);
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,Run,The following statement contains a magic number: Run(b' 10000);
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,Run,The following statement contains a magic number: Run(b' 30000);
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,Run,The following statement contains a magic number: Run(b' 100000);
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,Run,The following statement contains a magic number: Run(b' 300000);
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,Run,The following statement contains a magic number: Run(b' 1000000);
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,Run,The following statement contains a magic number: b.RunPublicBenchmarks(this' false' () => 			{ 				int start = Console.CursorTop; 				b.PrintResults(Console.Out); 				end = Console.CursorTop; 				Console.CursorTop = start;  				// Send results to _graph 				if (_graph != null) { 					foreach (var row in b.Results) { 						string rowName = row.Key; 						var result = row.Value; 						var pair1 = rowName.SplitAt(": "); 						var pair2 = pair1.B.SplitAt(": "); 						var graphName = pair2.A.ToString(); 						if (graphName.StartsWith("Scan by") && graphName.EndsWith("x")) 							// avoid creating separate graphs for "Scan by ... 1000x" and "Scan by ... 333x" 							graphName = graphName.Left(graphName.LastIndexOf(' '));  						var dp = new EzDataPoint { 							Parameter = double.Parse(pair1.A.ToString())' 							GraphId = graphName' 							Series = pair2.B.ToString()' 							Value = result.Avg() 						}; 						Add(dp);  						// Make a second version of the dictionary graph without SortedList 						if (dp.GraphId.ToString().StartsWith("Dictionary") && dp.Series != "SortedList") { 							dp = dp.Clone(); 							dp.GraphId = dp.GraphId.ToString() + " (no SortedList)"; 							Add(dp); 						} 						 						// Make a second version of the "@ random indexes" graphs for small lists 						if (dp.GraphId.ToString().Contains("random index") && (double)dp.Parameter < 10000) { 							dp = dp.Clone(); 							dp.GraphId = dp.GraphId.ToString() + " "; // extra space just to change the graph ID 							Add(dp); 						} 					} 				} 			}' 			string.Format("{0'8}: "' listCount)' true);
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,InsertRandom,The following statement contains a magic number: b.Run("List"' () => 			{ 				var list = MakeList(new List<long>()' b); 				for (int i = 0; i < StdIterations; i++) { 					int c = list.Count; 					list.Insert(_r.Next(c + 1)' i); 					if (c >= _count + 5) list.RemoveRange(list.Count - 10' 10); 				} 			});
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,InsertRandom,The following statement contains a magic number: b.Run("List"' () => 			{ 				var list = MakeList(new List<long>()' b); 				for (int i = 0; i < StdIterations; i++) { 					int c = list.Count; 					list.Insert(_r.Next(c + 1)' i); 					if (c >= _count + 5) list.RemoveRange(list.Count - 10' 10); 				} 			});
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,InsertRandom,The following statement contains a magic number: b.Run("List"' () => 			{ 				var list = MakeList(new List<long>()' b); 				for (int i = 0; i < StdIterations; i++) { 					int c = list.Count; 					list.Insert(_r.Next(c + 1)' i); 					if (c >= _count + 5) list.RemoveRange(list.Count - 10' 10); 				} 			});
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,InsertRandom,The following statement contains a magic number: b.Run("InternalList"' () => 			{ 				var list = MakeList(InternalList<long>.Empty' b); 				for (int i = 0; i < StdIterations; i++) { 					int c = list.Count; 					list.Insert(_r.Next(c + 1)' i); 					if (c >= _count + 5) list.RemoveRange(list.Count - 10' 10); 				} 			});
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,InsertRandom,The following statement contains a magic number: b.Run("InternalList"' () => 			{ 				var list = MakeList(InternalList<long>.Empty' b); 				for (int i = 0; i < StdIterations; i++) { 					int c = list.Count; 					list.Insert(_r.Next(c + 1)' i); 					if (c >= _count + 5) list.RemoveRange(list.Count - 10' 10); 				} 			});
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,InsertRandom,The following statement contains a magic number: b.Run("InternalList"' () => 			{ 				var list = MakeList(InternalList<long>.Empty' b); 				for (int i = 0; i < StdIterations; i++) { 					int c = list.Count; 					list.Insert(_r.Next(c + 1)' i); 					if (c >= _count + 5) list.RemoveRange(list.Count - 10' 10); 				} 			});
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,InsertRandom,The following statement contains a magic number: b.Run("DList"' () => 			{ 				var list = MakeList(new DList<long>()' b); 				for (int i = 0; i < StdIterations; i++) { 					int c = list.Count; 					list.Insert(_r.Next(c + 1)' i); 					if (c >= _count + 5) list.RemoveRange(list.Count - 10' 10); 				} 			});
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,InsertRandom,The following statement contains a magic number: b.Run("DList"' () => 			{ 				var list = MakeList(new DList<long>()' b); 				for (int i = 0; i < StdIterations; i++) { 					int c = list.Count; 					list.Insert(_r.Next(c + 1)' i); 					if (c >= _count + 5) list.RemoveRange(list.Count - 10' 10); 				} 			});
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,InsertRandom,The following statement contains a magic number: b.Run("DList"' () => 			{ 				var list = MakeList(new DList<long>()' b); 				for (int i = 0; i < StdIterations; i++) { 					int c = list.Count; 					list.Insert(_r.Next(c + 1)' i); 					if (c >= _count + 5) list.RemoveRange(list.Count - 10' 10); 				} 			});
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,InsertRandom,The following statement contains a magic number: b.Run("AList"' () => 			{ 				var list = MakeList(new AList<long>()' b); 				for (int i = 0; i < StdIterations; i++) { 					int c = list.Count; 					list.Insert(_r.Next(c + 1)' i); 					if (c >= _count + 5) list.RemoveRange(list.Count - 10' 10); 				} 			});
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,InsertRandom,The following statement contains a magic number: b.Run("AList"' () => 			{ 				var list = MakeList(new AList<long>()' b); 				for (int i = 0; i < StdIterations; i++) { 					int c = list.Count; 					list.Insert(_r.Next(c + 1)' i); 					if (c >= _count + 5) list.RemoveRange(list.Count - 10' 10); 				} 			});
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,InsertRandom,The following statement contains a magic number: b.Run("AList"' () => 			{ 				var list = MakeList(new AList<long>()' b); 				for (int i = 0; i < StdIterations; i++) { 					int c = list.Count; 					list.Insert(_r.Next(c + 1)' i); 					if (c >= _count + 5) list.RemoveRange(list.Count - 10' 10); 				} 			});
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,RemoveRandom,The following statement contains a magic number: var more = new long[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' };
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,RemoveRandom,The following statement contains a magic number: var more = new long[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' };
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,RemoveRandom,The following statement contains a magic number: var more = new long[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' };
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,RemoveRandom,The following statement contains a magic number: var more = new long[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' };
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,RemoveRandom,The following statement contains a magic number: var more = new long[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' };
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,RemoveRandom,The following statement contains a magic number: var more = new long[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' };
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,RemoveRandom,The following statement contains a magic number: var more = new long[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' };
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,RemoveRandom,The following statement contains a magic number: var more = new long[] { 0' 1' 2' 3' 4' 5' 6' 7' 8' 9' };
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,RemoveRandom,The following statement contains a magic number: b.Run("List"' () => 			{ 				var list = MakeList(new List<long>()' b); 				for (int i = 0; i < StdIterations; i++) { 					int c = list.Count; 					list.RemoveAt(_r.Next(c)); 					if (c <= _count - 5) list.AddRange(more); 				} 			});
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,RemoveRandom,The following statement contains a magic number: b.Run("InternalList"' () => 			{ 				var list = MakeList(InternalList<long>.Empty' b); 				for (int i = 0; i < StdIterations; i++) { 					int c = list.Count; 					list.RemoveAt(_r.Next(c)); 					if (c <= _count - 5) list.AddRange((IList<long>)more); 				} 			});
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,RemoveRandom,The following statement contains a magic number: b.Run("DList"' () => 			{ 				var list = MakeList(new DList<long>()' b); 				for (int i = 0; i < StdIterations; i++) { 					int c = list.Count; 					list.RemoveAt(_r.Next(c)); 					if (c <= _count - 5) list.AddRange((ICollection<long>)more); 				} 			});
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,RemoveRandom,The following statement contains a magic number: b.Run("AList"' () => 			{ 				var list = MakeList(new AList<long>()' b); 				for (int i = 0; i < StdIterations; i++) { 					int c = list.Count; 					list.RemoveAt(_r.Next(c)); 					if (c <= _count - 5) list.AddRange(more); 				} 			});
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,ScanIndexer,The following statement contains a magic number: int Cycles = Math.Max(MathEx.MulDiv(StdIterations' 100' _count)' 1);
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,ScanIEnumerator,The following statement contains a magic number: int Cycles = Math.Max(MathEx.MulDiv(StdIterations' 100' _count)' 1);
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,DictionaryBenchmarks,The following statement contains a magic number: if (_count < 10000 || b.CurrentTrialNumber == 1) 				b.Run("SortedList"' () => 				{ 					var list = MakeDict(new SortedList<long' int>()' b' out max); 					for (int i = 0; i < StdIterations; i++) { 						int k = _r.Next(max); 						list[k] = i; 						if (list.Count > _count) 							list.Remove(k); 					} 				});
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,MakeDict,The following statement contains a magic number: for (int i = 0; i < _count; i++) { 				list.Add(k' i); 				k += _r.Next(50' 150); 			}
Magic Number,Benchmark,ListBenchmarks,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\ListBenchmarks.cs,MakeDict,The following statement contains a magic number: for (int i = 0; i < _count; i++) { 				list.Add(k' i); 				k += _r.Next(50' 150); 			}
Magic Number,Loyc,GoInterfaceBenchmark,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\GoInterfaceBenchmark.cs,DoBenchmark,The following statement contains a magic number: const int Iterations = 10000000;
Magic Number,Loyc,GoInterfaceBenchmark,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\GoInterfaceBenchmark.cs,DoBenchmark,The following statement contains a magic number: list.Add(2);
Magic Number,Loyc,GoInterfaceBenchmark,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\GoInterfaceBenchmark.cs,DoBenchmark,The following statement contains a magic number: list.Add(3);
Magic Number,Loyc,GoInterfaceBenchmark,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\GoInterfaceBenchmark.cs,DoBenchmark,The following statement contains a magic number: for (i = 0; i < Iterations; i++) 			{ 				total0 += list[i & 3]; 			}
Magic Number,Loyc,GoInterfaceBenchmark,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\GoInterfaceBenchmark.cs,DoBenchmark,The following statement contains a magic number: for (i = 0; i < Iterations; i++) 			{ 				total1 += ilist[i & 3]; 			}
Magic Number,Loyc,GoInterfaceBenchmark,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\GoInterfaceBenchmark.cs,DoBenchmark,The following statement contains a magic number: for (i = 0; i < Iterations; i++) 			{ 				total2 += rolist[i & 3]; 			}
Missing Default,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,TrialSetOperation,The following switch statement is missing a default case: switch(op) { 				case Op.Or:  hSet.UnionWith(hSet2); break; 				case Op.And: hSet.IntersectWith(hSet2); break; 				case Op.Sub: hSet.ExceptWith(hSet2); break; 				case Op.Xor: hSet.SymmetricExceptWith(hSet2); break; 			}
Missing Default,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,TrialSetOperation,The following switch statement is missing a default case: switch(op) { 				case Op.Or:  oSet = oSet1 | oSet2; break; 				case Op.And: oSet = oSet1 & oSet2; break; 				case Op.Sub: oSet = oSet1 - oSet2; break; 				case Op.Xor: oSet = oSet1 ^ oSet2; break; 			}
Missing Default,Benchmark,BenchmarkSets<T>,C:\repos\qwertie_Loyc\Core\LoycCore.Benchmarks\Benchmarks\BenchmarkSets.cs,TrialSetOperation,The following switch statement is missing a default case: switch(op) { 				case Op.Or:  iSet = iSet1 | iSet2; break; 				case Op.And: iSet = iSet1 & iSet2; break; 				case Op.Sub: iSet = iSet1 - iSet2; break; 				case Op.Xor: iSet = iSet1 ^ iSet2; break; 			}
