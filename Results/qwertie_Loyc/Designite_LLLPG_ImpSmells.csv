Implementation smell,Namespace,Class,File,Method,Description
Long Method,Loyc.LLParserGenerator,GenerateCodeVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\GenerateCodeVisitor.cs,GenerateCodeForAlts,The method has 114 lines of code.
Long Method,Loyc.LLParserGenerator,AntlrStyleParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\AntlrStyleParserGrammar.out.cs,Rule,The method has 154 lines of code.
Long Method,Loyc.LLParserGenerator,StageOneParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\StageOneParser.cs,SeqExpr,The method has 105 lines of code.
Long Method,Loyc.LLParserGenerator,StageTwoParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\StageTwoParser.cs,NodeToPredCore,The method has 102 lines of code.
Long Method,Loyc.LLParserGenerator,LlpgBugsAndSlugs,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgBugsAndSlugs.cs,Bug_2017_01_ErrorBranchCausesIncorrectRecognizer,The method has 113 lines of code.
Long Method,Loyc.LLParserGenerator,LlpgGeneralTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgGeneralTests.cs,HexFloatsWithSynPred,The method has 238 lines of code.
Long Method,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,DifferentDefault,The method has 144 lines of code.
Long Method,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SynPred2,The method has 101 lines of code.
Long Method,Loyc.LLParserGenerator,LlpgTestLargerExamples,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgTestLargerExamples.cs,ParseEmails,The method has 127 lines of code.
Long Method,Loyc.LLParserGenerator,LlpgTestLargerExamples,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgTestLargerExamples.cs,CalculatorLexerLes,The method has 238 lines of code.
Long Method,Loyc.LLParserGenerator,LlpgTestLargerExamples,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgTestLargerExamples.cs,CalculatorRunnerLes,The method has 227 lines of code.
Long Method,Loyc.LLParserGenerator,LlpgTestLargerExamples,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgTestLargerExamples.cs,ScannerlessExpressionParser,The method has 332 lines of code.
Complex Method,Loyc.LLParserGenerator,LLParserGenerator,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\AnalysisVisitors.cs,Run,Cyclomatic complexity of the method is 11
Complex Method,Loyc.LLParserGenerator,PredictionAnalysisVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\AnalysisVisitors.cs,Visit,Cyclomatic complexity of the method is 9
Complex Method,Loyc.LLParserGenerator,PredictionAnalysisVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\AnalysisVisitors.cs,ComputeSetForNextBranch,Cyclomatic complexity of the method is 8
Complex Method,Loyc.LLParserGenerator,GenerateCodeVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\GenerateCodeVisitor.cs,GenerateCodeForAlts,Cyclomatic complexity of the method is 17
Complex Method,Loyc.LLParserGenerator,GenerateCodeVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\GenerateCodeVisitor.cs,GeneratePredictionTreeCode,Cyclomatic complexity of the method is 10
Complex Method,Loyc.LLParserGenerator,AntlrStyleParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\AntlrStyleParserGrammar.out.cs,Rule,Cyclomatic complexity of the method is 20
Complex Method,Loyc.LLParserGenerator,StageTwoParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\StageTwoParser.cs,NodeToPredCore,Cyclomatic complexity of the method is 8
Complex Method,Loyc.LLParserGenerator,Alts,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Predicates.cs,ToString,Cyclomatic complexity of the method is 10
Complex Method,Loyc.LLPG,Macros,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\Macros.cs,run_LLLPG,Cyclomatic complexity of the method is 11
Long Parameter List,Loyc.LLParserGenerator,CodeGenHelperBase,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\CodeGenHelperBase.cs,GenerateSwitch,The method has 5 parameters. Parameters: branchSets' branchCode' casesToInclude' defaultBranch' laVar
Long Parameter List,Loyc.LLParserGenerator,IPGCodeGenHelper,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\IPGCodeGenHelper.cs,GenerateSwitch,The method has 5 parameters. Parameters: branchSets' branchCode' casesToInclude' defaultBranch' laVar
Long Parameter List,Loyc.LLParserGenerator,PredictionAnalysisVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\AnalysisVisitors.cs,AutoAddBranchForAndPred,The method has 5 parameters. Parameters: children' andPred' alts' matched' falsified
Long Parameter List,Loyc.LLParserGenerator,Pred,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Predicates.cs,Or,The method has 7 parameters. Parameters: a' b' slashJoined' basis' aMode' bMode' sink
Long Parameter List,Loyc.LLParserGenerator,Pred,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Predicates.cs,Rule,The method has 5 parameters. Parameters: name' pred' isStartingRule' isToken' maximumK
Long Parameter List,Loyc.LLParserGenerator,Alts,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Predicates.cs,Merge,The method has 7 parameters. Parameters: basis' a' b' slashJoined' aMode' bMode' warnings
Long Parameter List,Loyc.LLParserGenerator,Alts,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Predicates.cs,TwoArms,The method has 7 parameters. Parameters: basis' a' b' slashJoined' aMode' bMode' warnings
Long Parameter List,Loyc.LLParserGenerator,Alts,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Predicates.cs,Insert,The method has 6 parameters. Parameters: newBasis' slashJoined' append' b' bMode' warnings
Long Parameter List,Loyc.LLPG,Macros,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\Macros.cs,LllpgMacro,The method has 5 parameters. Parameters: node' context' expectedCodeGenMode' makeCodeGenHelper' isDefault
Long Statement,Loyc.LLParserGenerator,LLParserGenerator,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\AnalysisVisitors.cs,PrintVerboseStats,The length of the statement  "			Output(Verbose' null' Localize.Localized("{0} rule(s) are using Token mode. This mode assumes the follow set could be anything."' tokens));" is 139.
Long Statement,Loyc.LLParserGenerator,LLParserGenerator,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\AnalysisVisitors.cs,PrintVerboseStats,The length of the statement  "			Output(Verbose' null' Localize.Localized("{0} rule(s) are private. Private rules should only be called from other rules."' privates));" is 134.
Long Statement,Loyc.LLParserGenerator,LLParserGenerator,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\AnalysisVisitors.cs,ShouldReportAmbiguity,The length of the statement  "				if (ks != null && ks.Cases.All(transition => transition.Position.Pred == EndOfToken && transition.PrevPosition == EndOfToken))" is 126.
Long Statement,Loyc.LLParserGenerator,PredictionAnalysisVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\AnalysisVisitors.cs,Visit,The length of the statement  "							"It's poor style to put a code block {..} before an and-predicate &{..} because the and-predicate normally runs first.");" is 121.
Long Statement,Loyc.LLParserGenerator,GenerateCodeVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\GenerateCodeVisitor.cs,GenerateCodeForAlts,The length of the statement  "					LLPG.Output(Warning' alts' "The error branch will not be used because the other alternatives are exhaustive (cover all cases)");" is 128.
Long Statement,Loyc.LLParserGenerator,GenerateCodeVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\GenerateCodeVisitor.cs,GenerateCodeForAlts,The length of the statement  "				bool userDefinedError = needError && !_recognizerMode && alts.ErrorBranch != null && alts.ErrorBranch != DefaultErrorBranch.Value;" is 130.
Long Statement,Loyc.LLParserGenerator,GenerateCodeVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\GenerateCodeVisitor.cs,GenerateCodeForAlts,The length of the statement  "					LLPG.Output(Warning' alts' string.Format("Branches {{{0}}} are unreachable."' unreachable.Select(i => alts.AltName(i)).Join("' ")));" is 132.
Long Statement,Loyc.LLParserGenerator,DetermineLocalFollowSets,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\LLParserGenerator.cs,Visit,The length of the statement  "							alts.Arms.Count == 1 ? "The contents of this loop are nullable; the parser could loop forever without consuming any input."" is 123.
Long Statement,Loyc.LLParserGenerator,DetermineLocalFollowSets,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\LLParserGenerator.cs,Visit,The length of the statement  "							: string.Format("Arm #{0} of this loop is nullable; the parser could loop forever without consuming any input."' badArm + 1));" is 126.
Long Statement,Loyc.LLParserGenerator,AntlrStyleParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\AntlrStyleParserGrammar.out.cs,Rule,The length of the statement  "				Error(-1' isAntlrThing ? "LLLPG does not support ANTLR rule directives ('scope'' 'throws'' 'options'' etc.)." : "Syntax error (expected ':' to begin the rule)");" is 161.
Long Statement,Loyc.LLParserGenerator,AntlrStyleParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\AntlrStyleParserGrammar.out.cs,Rule,The length of the statement  "			// Line 126: (((TT.Colon|TT.StartColon)) GrammarExpr TT.Semicolon | TT.At TT.LBrace GrammarExpr TT.RBrace (TT.Semicolon)?)" is 122.
Long Statement,Loyc.LLParserGenerator,AntlrStyleParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\AntlrStyleParserGrammar.out.cs,Rule,The length of the statement  "			return LNode.Call((Symbol) "#noLexicalMacros"' LNode.List(LNode.Call(LNode.List(attrs)' rule' LNode.List(retType ?? F.Void' F.Id(ruleName)' LNode.Call(CodeSymbols.AltList' LNode.List(args))' gExpr))));" is 201.
Long Statement,Loyc.LLParserGenerator,AutoValueSaverVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\AutoValueSaverVisitor.cs,MaybeCreateVariableFor,The length of the statement  "				_sink.Error(pred' Localize.Localized("The type of this expression is unknown (did you set LLLPG's 'terminalType'  option?)"));" is 126.
Long Statement,Loyc.LLParserGenerator,StageOneParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\StageOneParser.cs,PrimaryExpr,The length of the statement  "			// Line 125: ( TT.Minus PrimaryExpr | TT.Any TT.Id (TT.In GateExpr / ) | Atom greedy(TT.Dot Atom | &{a.Range.EndIndex == LT($LI).StartIndex} (TT.LParen TT.RParen | TT.LBrack TT.RBrack))* )" is 188.
Long Statement,Loyc.LLParserGenerator,StageOneParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\StageOneParser.cs,PrimaryExpr,The length of the statement  "				// Line 135: greedy(TT.Dot Atom | &{a.Range.EndIndex == LT($LI).StartIndex} (TT.LParen TT.RParen | TT.LBrack TT.RBrack))*" is 121.
Long Statement,Loyc.LLParserGenerator,StageOneParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\StageOneParser.cs,Atom,The length of the statement  "			// Line 148: ( (TT.Id|TT.In) | TT.Literal | TT.LParen TT.RParen | TT.LBrace TT.RBrace | TT.LBrack TT.RBrack &((TT.QMark|TT.Star)) )" is 131.
Long Statement,Loyc.LLParserGenerator,StageTwoParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\StageTwoParser.cs,NodeToPredCore,The length of the statement  "					if (expr.ArgCount > args.ArgCount) // don't complain about too few args' in case there are default args (I'm too lazy to check)" is 127.
Long Statement,Loyc.LLParserGenerator,Alts,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Predicates.cs,Insert,The length of the statement  "						this.InsertSingle(ref insertAt' bAlts.ErrorBranch' bAlts.ExitOnError ? BranchMode.ErrorExit : BranchMode.ErrorContinue' warnings);" is 130.
Long Statement,Loyc.LLParserGenerator,Alts,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Predicates.cs,Warning_ErrorBranchNotLast,The length of the statement  "			warnings.Warning(b' "The error branch should come last to avoid confusion. It is not numbered like the others' e.g. 'c' is considered the second arm in (a | error b | c).");" is 173.
Long Statement,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,MatchComplexSet,The length of the statement  "				static readonly HashSet<int> Odd_set0 = NewSetOfRanges('-'' '.'' '1'' '1'' '3'' '3'' '5'' '5'' '7'' '7'' '9'' '9'' 'a'' 'z');" is 125.
Long Statement,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SymbolTest,The length of the statement  "			Rule Stmt = Rule("Stmt"' Sym("Number") + (Sym("print") + Sym("DQString") | Sym("goto") + Sym("Number")) + Sym("Newline"));" is 122.
Long Statement,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SymbolTestEx,The length of the statement  "			Rule BlockStmt2 = Rule("BlockStmt2"' Sym("fixed"' "lock"' "switch"' "using"' "while"' "for"' "if") + Sym("(") + Expr + Sym(")") + Stmt);" is 136.
Long Statement,Loyc.LLParserGenerator,LlpgParserTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgParserTests.cs,Stage1Les_MoreTests,The length of the statement  "			TestStage1("~(a..b) | (-a)..b.c"' F.Call(S.OrBits' F.Call(S.NotBits' F.Call(S.DotDot' a' b))' F.Call(S.DotDot' F.Call(S.Sub' a)' F.Dot(b' c))));" is 144.
Long Statement,Loyc.LLParserGenerator,LlpgParserTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgParserTests.cs,Stage1Les_MoreTests,The length of the statement  "			TestStage1("~ a..b  |  -a ..b.c"' F.Call(S.OrBits' F.Call(S.NotBits' F.Call(S.DotDot' a' b))' F.Call(S.DotDot' F.Call(S.Sub' a)' F.Dot(b' c))));" is 144.
Long Statement,Loyc.LLParserGenerator,LlpgTestLargerExamples,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgTestLargerExamples.cs,ParseEmails,The length of the statement  "					static readonly HashSet<int> UsernameChars_set0 = LexerSource.NewSetOfRanges('!'' '!'' '#'' '\''' '*'' '+'' '-'' '-'' '/'' '9'' '='' '='' '?'' '?'' 'A'' 'Z'' '^'' '~');" is 168.
Long Statement,Loyc.LLParserGenerator,LlpgTestLargerExamples,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgTestLargerExamples.cs,ScannerlessExpressionParser,The length of the statement  "					public ExprParser(IList<StringToken> tokens' ISourceFile file = null) : base(tokens' default(StringToken)' file ?? EmptySourceFile.Unknown)" is 139.
Long Statement,Loyc.LLParserGenerator,LlpgTestLargerExamples,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgTestLargerExamples.cs,ScannerlessExpressionParser,The length of the statement  "						// Line 42: greedy( &{prec <= 10} @""="" Expr | &{prec < 20} (@""&&""|@""||"") Expr | &{prec < 30} (@""!=""|@""<""|@""<=""|@""==""|@"">""|@"">="") Expr | &{prec < 40} (@""-""|@""+"") Expr | &{prec < 50} (@""*""|@""/""|@""<<""|@"">>"") Expr | @""("" Expr @"")"" | @""."" Atom )*" is 277.
Long Statement,Loyc.LLPG,Macros,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\Macros.cs,ApplyOptions,The length of the statement  "								"FullLLk(bool)' Verbosity(0..3)' NoDefaultArm(bool)' DefaultK(1..9)' AddComments(bool)' AddCsLineDirectives(bool)' and PrematchByDefault(bool)");" is 145.
Complex Conditional,Loyc.LLParserGenerator,Pred,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Predicates.cs,Or,The conditional expression  "a_ != null && b_ != null && aMode == BranchMode.None && bMode == BranchMode.None"  is complex.
Complex Conditional,Loyc.LLParserGenerator,Alts,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Predicates.cs,ShouldSuppressWarning,The conditional expression  "div.Slash && 					armA.IsInRange(div.Left' div.Right - 1) && 					armB.IsInRange(div.Left' div.Right - 1) && 					(armA < div.Mid) != (armB < div.Mid)"  is complex.
Complex Conditional,Loyc.LLParserGenerator,Alts,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Predicates.cs,ToString,The conditional expression  "!(prev.Right == d.Mid && prev.Left <= d.Left && (prev.Slash || !d.Slash))"  is complex.
Complex Conditional,Loyc.LLPG,Macros,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\Macros.cs,LllpgMacro,The conditional expression  "(args.Count == 1 && (codeGenOptions = args[0]).Name == expectedCodeGenMode) 				|| (args.Count == 0 && isDefault)"  is complex.
Virtual Method Call from Constructor,Loyc.LLParserGenerator,Rule,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Rule.cs,Rule,The constructor "Rule" calls a virtual method "Calls".
Magic Number,Loyc.LLParserGenerator,CodeGenHelperBase,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\CodeGenHelperBase.cs,VisitInput,The following statement contains a magic number: if ((stmt.Calls(_alias' 1) || stmt.CallsMin(S.Alias' 1)) && 				(aliasSet = stmt.Args[0]).Calls(S.Assign' 2)) 			{ 				IEnumerable<KeyValuePair<LNode' LNode>> q;  				LNode alias = aliasSet.Args[0]' replacement = aliasSet.Args[1]' old; 				if (_definedAliases.TryGetValue(alias' out old)) { 					if (stmt.AttrNamed(S.Partial) == null || !old.Equals(replacement)) 						sink.Warning(alias' "Redefinition of alias '{0}'"' alias); 				} else if ((q = _definedAliases.Where(pair => replacement.Equals(pair.Value))).Any()) 					sink.Warning(replacement' "Aliases '{0}' and '{1}' have the same replacement value"' q.First().Key' alias); 				_definedAliases[alias] = replacement; 				return LNode.Call(S.Splice' VList<LNode>.Empty); // erase alias from output 			}
Magic Number,Loyc.LLParserGenerator,CodeGenHelperBase,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\CodeGenHelperBase.cs,ErrorBranch,The following statement contains a magic number: if (coveredS.Length > 45) 				coveredS = coveredS.Substring(0' 40) + "...";
Magic Number,Loyc.LLParserGenerator,CodeGenHelperBase,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\CodeGenHelperBase.cs,ErrorBranch,The following statement contains a magic number: if (coveredS.Length > 45) 				coveredS = coveredS.Substring(0' 40) + "...";
Magic Number,Loyc.LLParserGenerator,CodeGenHelperBase,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\CodeGenHelperBase.cs,GetRelativeCostForSwitch,The following statement contains a magic number: return -1000000;
Magic Number,Loyc.LLParserGenerator,CodeGenHelperBase,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\CodeGenHelperBase.cs,ShouldGenerateSwitch,The following statement contains a magic number: for (; ; ) 			{ 				int maxIndex = score.IndexOfMax()' maxScore = score[maxIndex]; 				switchScore += maxScore; 				if (switchScore > 0) 					should = true; 				else if (maxScore < 0) 					break; 				casesToInclude.Add(maxIndex); 				score[maxIndex] = -1000000; 			}
Magic Number,Loyc.LLParserGenerator,CodeGenHelperBase,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\CodeGenHelperBase.cs,GenerateSwitch,The following statement contains a magic number: for (int i = 0; i < branchCode.Length; i++) 			{ 				if (casesToInclude.Contains(i)) 				{ 					int index = -1; 					foreach (LNode value in GetCases(branchSets[i])) 					{ 						var label = F.Call(S.Case' value); 						if (++index > 0 && (index % 4) != 0) // write 4 cases per line 							label = label.PlusAttr(F.Id(S.TriviaAppendStatement)); 						stmts.Add(label); 						if (stmts.Count > 65535) // sanity check 							throw new InvalidOperationException("switch is too large to generate"); 					} 					AddSwitchHandler(branchCode[i]' stmts); 				} 			}
Magic Number,Loyc.LLParserGenerator,CodeGenHelperBase,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\CodeGenHelperBase.cs,GenerateSwitch,The following statement contains a magic number: for (int i = 0; i < branchCode.Length; i++) 			{ 				if (casesToInclude.Contains(i)) 				{ 					int index = -1; 					foreach (LNode value in GetCases(branchSets[i])) 					{ 						var label = F.Call(S.Case' value); 						if (++index > 0 && (index % 4) != 0) // write 4 cases per line 							label = label.PlusAttr(F.Id(S.TriviaAppendStatement)); 						stmts.Add(label); 						if (stmts.Count > 65535) // sanity check 							throw new InvalidOperationException("switch is too large to generate"); 					} 					AddSwitchHandler(branchCode[i]' stmts); 				} 			}
Magic Number,Loyc.LLParserGenerator,CodeGenHelperBase,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\CodeGenHelperBase.cs,CreateTryWrapperForRecognizer,The following statement contains a magic number: LNode retType = method.Args[0]' name = method.Args[1]' args = method.Args[2];
Magic Number,Loyc.LLParserGenerator,CodeGenHelperBase,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\CodeGenHelperBase.cs,VarName,The following statement contains a magic number: if (varStmt.Calls(S.Var' 2)) { 				var nameAndInit = varStmt.Args[1]; 				if (nameAndInit.Calls(S.Assign' 2)) 					return nameAndInit.Args[0]; 				else 					return nameAndInit; 			}
Magic Number,Loyc.LLParserGenerator,CodeGenHelperBase,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\CodeGenHelperBase.cs,VarName,The following statement contains a magic number: if (varStmt.Calls(S.Var' 2)) { 				var nameAndInit = varStmt.Args[1]; 				if (nameAndInit.Calls(S.Assign' 2)) 					return nameAndInit.Args[0]; 				else 					return nameAndInit; 			}
Magic Number,Loyc.LLParserGenerator,CodeGenHelperBase,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\CodeGenHelperBase.cs,CallRule,The following statement contains a magic number: if (recognizerMode) 			{ 				target = target.MakeRecognizerVersion();  				// Allow recognizers to take fewer arguments than the normal rule  				// by truncating argument(s) at the call site. 				int maxArgCount = target.Basis.CallsMin(S.Fn' 3) ? target.Basis.Args[2].ArgCount : 0; 				if (@params.Count > maxArgCount) 					@params = @params.First(maxArgCount); 			}
Magic Number,Loyc.LLParserGenerator,CodeGenHelperBase,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\CodeGenHelperBase.cs,CallRule,The following statement contains a magic number: if (recognizerMode) 			{ 				target = target.MakeRecognizerVersion();  				// Allow recognizers to take fewer arguments than the normal rule  				// by truncating argument(s) at the call site. 				int maxArgCount = target.Basis.CallsMin(S.Fn' 3) ? target.Basis.Args[2].ArgCount : 0; 				if (@params.Count > maxArgCount) 					@params = @params.First(maxArgCount); 			}
Magic Number,Loyc.LLParserGenerator,GeneralCodeGenHelper,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\GeneralCodeGenHelper.cs,GenerateTest,The following statement contains a magic number: if (setName != null) { 				// setName.Contains($subject) 				if (MatchCast != null) 					subject = F.Call(S.Cast' subject' MatchCast); 				var test = F.Call(F.Dot(setName' _Contains)' subject); 				return set.IsInverted ? F.Call(S.Not' test) : test; 			} else { 				if (set.BaseSet.Count > 5) 					return null; // complex  				LNode test' result = null; 				// Note: sort the set so that the unit tests are deterministic 				foreach (LNode item in set.BaseSet.OrderBy(s => s.ToString())) { 					var item2 = item; 					if (item == PGNodeSet.EOF_node) { 						if (InputClass != null) 							item2 = F.Dot(InputClass' item); 						if (LaType != null) 							item2 = F.Call(S.Cast' item2' LaType); 					} 					test = F.Call(S.Eq' subject' item2); 					if (result == null) 						result = test; 					else 						result = F.Call(S.Or' result' test); 				} 				if (set.IsInverted) { 					if (result == null) 						return F.@true; 					if (result.Calls(S.Eq)) 						result = result.WithTarget(S.Neq); 					else 						result = F.Call(S.Not' F.InParens(result)); 				} 				return result ?? F.@false; 			}
Magic Number,Loyc.LLParserGenerator,GeneralCodeGenHelper,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\GeneralCodeGenHelper.cs,GenerateMatchExpr,The following statement contains a magic number: if (baseCount <= 4) { 				call = ApiCall(recognizerMode  					? (set.IsInverted ? _TryMatchExcept : _TryMatch) 					: (set.IsInverted ? _MatchExcept : _Match)' 					MatchArgs(symbols)); 			} else { 				var setName = GenerateSetDecl(set); 				if (set.IsInverted) 					call = ApiCall(recognizerMode ? _TryMatchExcept : _MatchExcept' F.Id(setName)); 				else 					call = ApiCall(recognizerMode ? _TryMatch : _Match' F.Id(setName)); 			}
Magic Number,Loyc.LLParserGenerator,GeneralCodeGenHelper,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\GeneralCodeGenHelper.cs,GetRelativeCostForSwitch,The following statement contains a magic number: if (!AllowSwitch || set.IsInverted) 				return -1000000;
Magic Number,Loyc.LLParserGenerator,GeneralCodeGenHelper,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\GeneralCodeGenHelper.cs,GetRelativeCostForSwitch,The following statement contains a magic number: int ifCost = System.Math.Min(set.BaseSet.Count * 4' 32);
Magic Number,Loyc.LLParserGenerator,GeneralCodeGenHelper,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\GeneralCodeGenHelper.cs,GetRelativeCostForSwitch,The following statement contains a magic number: int ifCost = System.Math.Min(set.BaseSet.Count * 4' 32);
Magic Number,Loyc.LLParserGenerator,PGNodeSet,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\GeneralCodeGenHelper.cs,ToString,The following statement contains a magic number: var sb = new StringBuilder(40);
Magic Number,Loyc.LLParserGenerator,IntStreamCodeGenHelper,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\IntStreamCodeGenHelper.cs,CodeToTerminalPred,The following statement contains a magic number: if (expr.IsIdNamed(_underscore)) { 				set = PGIntSet.AllExceptEOF; 			} else if (expr.IsIdNamed(_EOF)) { 				set = PGIntSet.EOF; 			} else if (expr.Calls(S.DotDot' 2) || expr.Calls(S.DotDotDot' 2)) { 				int? from = ConstValue(expr.Args[0]' ref isInt); 				int? to   = ConstValue(expr.Args[1]' ref isInt); 				if (from == null || to == null) { 					errorMsg = "Expected int32 or character literal on each side of «..»"; 					return null; 				} 				set = PGIntSet.WithRanges(from.Value' to.Value); 			} else if (expr.Value is string) { 				return Pred.Seq((string)expr.Value); 			} else { 				int? num = ConstValue(expr' ref isInt); 				if (num == null) { 					errorMsg = "Unrecognized expression. Expected int32 or character literal instead of: " + expr.ToString(); // warning 					return null; 				} 				set = PGIntSet.With(num.Value); 			}
Magic Number,Loyc.LLParserGenerator,IntStreamCodeGenHelper,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\IntStreamCodeGenHelper.cs,CodeToTerminalPred,The following statement contains a magic number: if (expr.IsIdNamed(_underscore)) { 				set = PGIntSet.AllExceptEOF; 			} else if (expr.IsIdNamed(_EOF)) { 				set = PGIntSet.EOF; 			} else if (expr.Calls(S.DotDot' 2) || expr.Calls(S.DotDotDot' 2)) { 				int? from = ConstValue(expr.Args[0]' ref isInt); 				int? to   = ConstValue(expr.Args[1]' ref isInt); 				if (from == null || to == null) { 					errorMsg = "Expected int32 or character literal on each side of «..»"; 					return null; 				} 				set = PGIntSet.WithRanges(from.Value' to.Value); 			} else if (expr.Value is string) { 				return Pred.Seq((string)expr.Value); 			} else { 				int? num = ConstValue(expr' ref isInt); 				if (num == null) { 					errorMsg = "Unrecognized expression. Expected int32 or character literal instead of: " + expr.ToString(); // warning 					return null; 				} 				set = PGIntSet.With(num.Value); 			}
Magic Number,Loyc.LLParserGenerator,IntStreamCodeGenHelper,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\IntStreamCodeGenHelper.cs,ExampleInt,The following statement contains a magic number: int min = set.IsCharSet ? 32 : 0;
Magic Number,Loyc.LLParserGenerator,IntStreamCodeGenHelper,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\IntStreamCodeGenHelper.cs,GenerateSetDecl,The following statement contains a magic number: if (ranges.Count * 2 < set.SizeIgnoringInversion) { // use ranges 				method = _NewSetOfRanges; 				args = ranges.SelectMany(r => { 					if (r.Lo >= 32 && r.Hi < 0xFFFC) 						return new object[] { (char)r.Lo' (char)r.Hi }; 					else 						return new object[] { r.Lo' r.Hi }; 				}); 			} else { 				method = _NewSet; 				args = set.IntegerSequence(false).Select(n =>  					set.IsCharSet && n >= 32 && n < 0xFFFC ? (object)(char)n : (object)(int)n); 			}
Magic Number,Loyc.LLParserGenerator,IntStreamCodeGenHelper,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\IntStreamCodeGenHelper.cs,GenerateSetDecl,The following statement contains a magic number: if (ranges.Count * 2 < set.SizeIgnoringInversion) { // use ranges 				method = _NewSetOfRanges; 				args = ranges.SelectMany(r => { 					if (r.Lo >= 32 && r.Hi < 0xFFFC) 						return new object[] { (char)r.Lo' (char)r.Hi }; 					else 						return new object[] { r.Lo' r.Hi }; 				}); 			} else { 				method = _NewSet; 				args = set.IntegerSequence(false).Select(n =>  					set.IsCharSet && n >= 32 && n < 0xFFFC ? (object)(char)n : (object)(int)n); 			}
Magic Number,Loyc.LLParserGenerator,IntStreamCodeGenHelper,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\IntStreamCodeGenHelper.cs,GenerateSetDecl,The following statement contains a magic number: if (ranges.Count * 2 < set.SizeIgnoringInversion) { // use ranges 				method = _NewSetOfRanges; 				args = ranges.SelectMany(r => { 					if (r.Lo >= 32 && r.Hi < 0xFFFC) 						return new object[] { (char)r.Lo' (char)r.Hi }; 					else 						return new object[] { r.Lo' r.Hi }; 				}); 			} else { 				method = _NewSet; 				args = set.IntegerSequence(false).Select(n =>  					set.IsCharSet && n >= 32 && n < 0xFFFC ? (object)(char)n : (object)(int)n); 			}
Magic Number,Loyc.LLParserGenerator,IntStreamCodeGenHelper,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\IntStreamCodeGenHelper.cs,GenerateMatchExpr,The following statement contains a magic number: var type = set.ChooseMatchType(2' 4);
Magic Number,Loyc.LLParserGenerator,IntStreamCodeGenHelper,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\IntStreamCodeGenHelper.cs,GenerateMatchExpr,The following statement contains a magic number: var type = set.ChooseMatchType(2' 4);
Magic Number,Loyc.LLParserGenerator,IntStreamCodeGenHelper,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\IntStreamCodeGenHelper.cs,GetRelativeCostForSwitch,The following statement contains a magic number: int switchCost = (int)System.Math.Min(1 + intset.Size' 1000000);
Magic Number,Loyc.LLParserGenerator,IntStreamCodeGenHelper,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\IntStreamCodeGenHelper.cs,GetRelativeCostForSwitch,The following statement contains a magic number: int ifCost = System.Math.Min(intset.ExprComplexity() * 4' 32);
Magic Number,Loyc.LLParserGenerator,IntStreamCodeGenHelper,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\IntStreamCodeGenHelper.cs,GetRelativeCostForSwitch,The following statement contains a magic number: int ifCost = System.Math.Min(intset.ExprComplexity() * 4' 32);
Magic Number,Loyc.LLParserGenerator,PGIntSet,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\PGIntSet.cs,ExprComplexity,The following statement contains a magic number: return _ranges.Select(r => r.Hi != r.Lo ? 2 : 1).Sum();
Magic Number,Loyc.LLParserGenerator,PGIntSet,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\PGIntSet.cs,ChooseMatchType,The following statement contains a magic number: if (singles <= maxSingles) 				return ranges * 2 < singles && ranges < maxRanges ? Match.Ranges : Match.Singles;
Magic Number,Loyc.LLParserGenerator,PGIntSet,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\PGIntSet.cs,GenerateTest,The following statement contains a magic number: if (setName != null) { 				// $setName.Contains($subject) 				LNode test = F.Call(F.Dot(setName' _Contains)' subject); 				return IsInverted ? F.Call(S.Not' test) : test; 			} else { 				if (_ranges.Count >= 3 && ExprComplexity() > 5) 					return null; // complex  				LNode test' result = null; 				for (int i = 0; i < _ranges.Count; i++) { 					var r = _ranges[i]; 					if (r.Lo == r.Hi) 						test = F.Call(S.Eq' subject' MakeLiteral(r.Lo)); 					else 						test = F.Call(S.And' F.Call(S.GE' subject' MakeLiteral(r.Lo))' 						                     F.Call(S.LE' subject' MakeLiteral(r.Hi))); 					AddTest(ref result' test); 				} 				if (IsInverted) { 					if (result == null) 						return F.@true; 					if (result.Calls(S.Eq)) 						result = result.WithTarget(S.Neq); 					else 						result = F.Call(S.Not' F.InParens(result)); 				} 				return result ?? F.@false; 			}
Magic Number,Loyc.LLParserGenerator,PGIntSet,C:\repos\qwertie_Loyc\Main\LLLPG\CodeGenHelpers\PGIntSet.cs,GenerateTest,The following statement contains a magic number: if (setName != null) { 				// $setName.Contains($subject) 				LNode test = F.Call(F.Dot(setName' _Contains)' subject); 				return IsInverted ? F.Call(S.Not' test) : test; 			} else { 				if (_ranges.Count >= 3 && ExprComplexity() > 5) 					return null; // complex  				LNode test' result = null; 				for (int i = 0; i < _ranges.Count; i++) { 					var r = _ranges[i]; 					if (r.Lo == r.Hi) 						test = F.Call(S.Eq' subject' MakeLiteral(r.Lo)); 					else 						test = F.Call(S.And' F.Call(S.GE' subject' MakeLiteral(r.Lo))' 						                     F.Call(S.LE' subject' MakeLiteral(r.Hi))); 					AddTest(ref result' test); 				} 				if (IsInverted) { 					if (result == null) 						return F.@true; 					if (result.Calls(S.Eq)) 						result = result.WithTarget(S.Neq); 					else 						result = F.Call(S.Not' F.InParens(result)); 				} 				return result ?? F.@false; 			}
Magic Number,Loyc.LLParserGenerator,LLParserGenerator,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\AnalysisVisitors.cs,PrintVerboseStats,The following statement contains a magic number: foreach (var rule in rules) { 				if (rule.IsPrivate ?? this.PrematchByDefault) 					privates++; 				if (rule.IsToken) 					tokens++; 				else { 					Output(Verbose' rule.Pred' Localize.Localized("Follow set of '{0}': {1}"' 						rule.Name' rule.EndOfRule.FollowSet.Select(p => p.ToStringWithPosition()).Join("' "))); 					if (Verbosity >= 2) { 						var end = new KthSet(rule.EndOfRule' ExitAlt' _helper.EmptySet); 						var followSet = ComputeNextSet(end' false);  						string casesStr; 						IList<Transition> cases = followSet.Cases; 						string message = "Follow set of '{0}': {1} from {2} cases: {4}"; 						if (Verbosity <= 2) { 							message = "Follow set of '{0}': {1} from {2} cases ({3} abridged): {4}"; 							var coverage = CodeGenHelper.EmptySet; 							cases = cases.Where(c => { 								bool subset = c.Set.IsSubsetOf(coverage); 								if (!subset) coverage = coverage.Union(c.Set); 								return !subset; 							}).ToList(); 						} 						casesStr = string.Concat(cases.Select(c => "\n  " + c.ToString()));  						Output(Verbose' rule.Pred' Localize.Localized(message' 							rule.Name' followSet.Set' followSet.Cases.Count' cases.Count' casesStr)); 					} 				} 			}
Magic Number,Loyc.LLParserGenerator,LLParserGenerator,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\AnalysisVisitors.cs,PrintVerboseStats,The following statement contains a magic number: foreach (var rule in rules) { 				if (rule.IsPrivate ?? this.PrematchByDefault) 					privates++; 				if (rule.IsToken) 					tokens++; 				else { 					Output(Verbose' rule.Pred' Localize.Localized("Follow set of '{0}': {1}"' 						rule.Name' rule.EndOfRule.FollowSet.Select(p => p.ToStringWithPosition()).Join("' "))); 					if (Verbosity >= 2) { 						var end = new KthSet(rule.EndOfRule' ExitAlt' _helper.EmptySet); 						var followSet = ComputeNextSet(end' false);  						string casesStr; 						IList<Transition> cases = followSet.Cases; 						string message = "Follow set of '{0}': {1} from {2} cases: {4}"; 						if (Verbosity <= 2) { 							message = "Follow set of '{0}': {1} from {2} cases ({3} abridged): {4}"; 							var coverage = CodeGenHelper.EmptySet; 							cases = cases.Where(c => { 								bool subset = c.Set.IsSubsetOf(coverage); 								if (!subset) coverage = coverage.Union(c.Set); 								return !subset; 							}).ToList(); 						} 						casesStr = string.Concat(cases.Select(c => "\n  " + c.ToString()));  						Output(Verbose' rule.Pred' Localize.Localized(message' 							rule.Name' followSet.Set' followSet.Cases.Count' cases.Count' casesStr)); 					} 				} 			}
Magic Number,Loyc.LLParserGenerator,PredictionAnalysisVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\AnalysisVisitors.cs,Visit,The following statement contains a magic number: if (LLPG.Verbosity > 0) { 					var sb = new StringBuilder(); 					for (int i = 0; i < firstSets.Length; i++) { 						if (firstSets[i].Alt == -1 || LLPG.Verbosity > 2) { 							if (sb.Length != 0) sb.Append('\n'); 							sb.AppendFormat("First set for {0}: {1}"' 								firstSets[i].Alt == -1 ? "exit" : "alt #" + (firstSets[i].Alt + 1)' firstSets[i]); 						} 					} 					if (sb.Length != 0) 						LLPG.Output(Verbose' alts' sb.ToString()); 				}
Magic Number,Loyc.LLParserGenerator,PredictionAnalysisVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\AnalysisVisitors.cs,Visit,The following statement contains a magic number: try { 					EzStopwatch TEMP = new EzStopwatch(true); 					alts.PredictionTree = ComputePredictionTree(firstSets); 					if (TEMP.Millisec > 500) 						LLPG.Output(Warning' alts' "Slug? This took a long time to analyze: " + TEMP.Millisec + "ms"); 				} catch (System.Threading.ThreadAbortException) { 					LLPG.Output(Error' alts' "ThreadAbortException in rule '" + _currentRule.Name + "'"); // user diagnostic 					throw; 				}
Magic Number,Loyc.LLParserGenerator,PredictionAnalysisVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\AnalysisVisitors.cs,Visit,The following statement contains a magic number: if ((LLPG.Verbosity & 2) != 0) 					LLPG.Output(Verbose' alts' "(unsimplified) " + alts.PredictionTree.ToString());
Magic Number,Loyc.LLParserGenerator,ApplyPrematchVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\AnalysisVisitors.cs,Visit,The following statement contains a magic number: if (rule.IsPrivate ?? LLPG.PrematchByDefault) { 						if (++_ruleDepth < 10) { 							rule.Pred.Call(this); 							--_ruleDepth; 						} 					}
Magic Number,Loyc.LLParserGenerator,GenerateCodeVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\GenerateCodeVisitor.cs,DeduplicateLabels,The following statement contains a magic number: for (int i = 0; i < matchingCode.Length; i++) { 					string label = matchingCode[i].B; 					if (label != null) { 						while (_labelsInUse.Contains(label)) { 							if (label.Length > 2 && label[label.Length-2] == '_' && label[label.Length-1].IsInRange('a'''y')) 								label = label.Left(label.Length-1) + (char)(label[label.Length-1] + 1); 							else 								label += "_a"; 						} 						_labelsInUse.Add(label); 						matchingCode[i].B = label; 					} 				}
Magic Number,Loyc.LLParserGenerator,GenerateCodeVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\GenerateCodeVisitor.cs,DeduplicateLabels,The following statement contains a magic number: for (int i = 0; i < matchingCode.Length; i++) { 					string label = matchingCode[i].B; 					if (label != null) { 						while (_labelsInUse.Contains(label)) { 							if (label.Length > 2 && label[label.Length-2] == '_' && label[label.Length-1].IsInRange('a'''y')) 								label = label.Left(label.Length-1) + (char)(label[label.Length-1] + 1); 							else 								label += "_a"; 						} 						_labelsInUse.Add(label); 						matchingCode[i].B = label; 					} 				}
Magic Number,Loyc.LLParserGenerator,GrammarPos,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\KthSet.cs,GetHashCode,The following statement contains a magic number: if (Return != null) 					hc ^= Return.GetHashCode() * 13;
Magic Number,Loyc.LLParserGenerator,ComputeNext,C:\repos\qwertie_Loyc\Main\LLLPG\CoreEngine\LLParserGenerator.cs,Visit,The following statement contains a magic number: if (_stackDepth > 250) { 					// Detect infinite loops and escape by throwing. One known  					// cause of an infinite loop is a nullable item inside a loop'  					// e.g. ('a'? 'b'?)*' so note that infinite recursion in  					// ComputeNext can occur without ever calling another rule. 					throw new StackOverflowException("The grammar is left-recursive' contains an infinite loop' or is too recursive."); 				}
Magic Number,Loyc.LLParserGenerator,AntlrStyleParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\AntlrStyleParserGrammar.out.cs,ParseHostReturnType,The following statement contains a magic number: if (result.Calls(S.Var' 2)) { 				if (!result[1].IsIdNamed("result")) 					ErrorSink.Error(result[1]' "LLLPG requires that the result of a rule be called 'result'"); 				return result[0]; 			} else 				return result;
Magic Number,Loyc.LLParserGenerator,AntlrStyleParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\AntlrStyleParserGrammar.out.cs,RulesAndStuff,The following statement contains a magic number: switch ((TT) LA0) { 			case TT.At: case TT.AttrKeyword: case TT.LBrack: 				result.Add(Rule()); 				break; 			case TT.Id: 				{ 					switch ((TT) LA(1)) { 					case TT.Id: case TT.LBrack: 						result.Add(Rule()); 						break; 					case TT.LParen: 						{ 							switch ((TT) LA(3)) { 							case TT.At: case TT.Colon: case TT.Id: case TT.Returns: 							case TT.StartColon: 								result.Add(Rule()); 								break; 							default: 								result.Add(HostCall()); 								break; 							} 						} 						break; 					case TT.At: case TT.Colon: case TT.Returns: case TT.StartColon: 						result.Add(Rule()); 						break; 					default: 						result.Add(HostBlock()); 						break; 					} 				} 				break; 			case TT.LParen: 				result.Add(HostCall()); 				break; 			default: 				result.Add(HostBlock()); 				break; 			}
Magic Number,Loyc.LLParserGenerator,AntlrStyleParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\AntlrStyleParserGrammar.out.cs,RulesAndStuff,The following statement contains a magic number: for (;;) { 				switch ((TT) LA0) { 				case TT.At: case TT.AttrKeyword: case TT.LBrack: 					result.Add(Rule()); 					break; 				case TT.Id: 					{ 						switch ((TT) LA(1)) { 						case TT.Id: case TT.LBrack: 							result.Add(Rule()); 							break; 						case TT.LParen: 							{ 								switch ((TT) LA(3)) { 								case TT.At: case TT.Colon: case TT.Id: case TT.Returns: 								case TT.StartColon: 									result.Add(Rule()); 									break; 								default: 									result.Add(HostCall()); 									break; 								} 							} 							break; 						case TT.At: case TT.Colon: case TT.Returns: case TT.StartColon: 							result.Add(Rule()); 							break; 						default: 							result.Add(HostBlock()); 							break; 						} 					} 					break; 				case TT.LParen: 					result.Add(HostCall()); 					break; 				case TT.LBrace: 					result.Add(HostBlock()); 					break; 				default: 					goto stop; 				} 			}
Magic Number,Loyc.LLParserGenerator,AutoValueSaverVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\AutoValueSaverVisitor.cs,PickVarNameForLNode,The following statement contains a magic number: if (label.IsId) { 				// Ignore the predefined special substitutions $LA and $LI 				//if (label.Name.Name == "LA" || label.Name.Name == "LI") 				//	return null; 				return GSymbol.Get("tok_" + label.Name); 			} else if (label.IsLiteral) { 				return LiteralToVarName(label.Value); 			} else if (label.Calls(S.Dot' 2)) 				return GSymbol.Get("tok__" + label.Args[1].Name); 			else if (label.Calls(S.DotDot' 2) || label.Calls(S.DotDotDot' 2)) 				return GSymbol.Get(PickVarNameForLNode(label[0]).Name + "_" + PickVarNameForLNode(label[1]).Name); 			else // can't return null 				return GSymbol.Get(label.GetHashCode().ToString());
Magic Number,Loyc.LLParserGenerator,AutoValueSaverVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\AutoValueSaverVisitor.cs,PickVarNameForLNode,The following statement contains a magic number: if (label.IsId) { 				// Ignore the predefined special substitutions $LA and $LI 				//if (label.Name.Name == "LA" || label.Name.Name == "LI") 				//	return null; 				return GSymbol.Get("tok_" + label.Name); 			} else if (label.IsLiteral) { 				return LiteralToVarName(label.Value); 			} else if (label.Calls(S.Dot' 2)) 				return GSymbol.Get("tok__" + label.Args[1].Name); 			else if (label.Calls(S.DotDot' 2) || label.Calls(S.DotDotDot' 2)) 				return GSymbol.Get(PickVarNameForLNode(label[0]).Name + "_" + PickVarNameForLNode(label[1]).Name); 			else // can't return null 				return GSymbol.Get(label.GetHashCode().ToString());
Magic Number,Loyc.LLParserGenerator,AutoValueSaverVisitor,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\AutoValueSaverVisitor.cs,PickVarNameForLNode,The following statement contains a magic number: if (label.IsId) { 				// Ignore the predefined special substitutions $LA and $LI 				//if (label.Name.Name == "LA" || label.Name.Name == "LI") 				//	return null; 				return GSymbol.Get("tok_" + label.Name); 			} else if (label.IsLiteral) { 				return LiteralToVarName(label.Value); 			} else if (label.Calls(S.Dot' 2)) 				return GSymbol.Get("tok__" + label.Args[1].Name); 			else if (label.Calls(S.DotDot' 2) || label.Calls(S.DotDotDot' 2)) 				return GSymbol.Get(PickVarNameForLNode(label[0]).Name + "_" + PickVarNameForLNode(label[1]).Name); 			else // can't return null 				return GSymbol.Get(label.GetHashCode().ToString());
Magic Number,Loyc.LLParserGenerator,StageTwoParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\StageTwoParser.cs,NodeToPredCore,The following statement contains a magic number: if (expr.IsCall) 			{ 				bool slash = false' not; 				var name = expr.Name; 				if (name == S.Tuple) 				{ 					// sequence: (a' b' c) 					if (expr.Calls(S.Tuple' 1)) 						return NodeToPred(expr.Args[0]' ctx); 					return TranslateToSeq(expr' ctx); 				} 				else if (name == S.Braces) 				{ 					// User action {block} 					if (ctx == Context.And || ctx == Context.GateLeft) { 						_sink.Error(expr' ctx == Context.And ? 							"Cannot use an action block inside an '&' or '&!' predicate; these predicates are for prediction only." : 							"Cannot use an action block on the left side of a '=>' gate; the left side is for prediction only."); 					} 					return new ActionPred(expr' expr.Args); 				} 				else if (expr.Calls(S.OrBits' 2) || (slash = expr.Calls(S.Div' 2))) 				{ 					// alternatives: a | b' a || b' a / b 					LNode lhs = expr.Args[0]' rhs = expr.Args[1]; 					BranchMode lhsMode' rhsMode; 					Pred left = BranchToPred(lhs' out lhsMode' ctx); 					Pred right = BranchToPred(rhs' out rhsMode' ctx); 					return Pred.Or(left' right' slash' expr' lhsMode' rhsMode' _sink); 				} 				else if (expr.Calls(_Star' 1) || expr.Calls(_Plus' 1) || expr.Calls(_Opt' 1)) 				{ 					// loop (a+' a*) or optional (a?) 					return TranslateLoopExpr(expr' ctx); 				} 				else if (expr.Calls(_Gate' 1) || expr.Calls(_EqGate' 1)) 				{ 					// => foo (LES-based parser artifact) 					return new Gate(expr' new Seq(F.Missing)' 					                      NodeToPred(expr.Args[0]' Context.GateRight)) 					                      { IsEquivalency = expr.Calls(_EqGate) }; 				} 				else if (expr.Calls(_Gate' 2) || expr.Calls(_EqGate' 2)) 				{ 					if (ctx == Context.GateLeft) 						_sink.Error(expr' "Cannot use a gate in the left-hand side of another gate");  					return new Gate(expr' NodeToPred(expr.Args[0]' Context.GateLeft)' 					                      NodeToPred(expr.Args[1]' Context.GateRight))  					                      { IsEquivalency = expr.Calls(_EqGate) }; 				} 				else if ((not = expr.Calls(_AndNot' 1)) || expr.Calls(_And' 1)) 				{ 					return TranslateAndPred(expr' not); 				} 				else if (expr.Calls(S.NotBits' 1)) 				{ 					var subpred = NodeToPred(expr.Args[0]' ctx); 					if (subpred is TerminalPred) { 						var term = (TerminalPred)subpred; 						term.Set = term.Set.Inverted().WithoutEOF(); 						return term; 					} else { 						_sink.Error(expr'  							"The set-inversion operator ~ can only be applied to a single terminal' not a '{0}'"' subpred.GetType().Name); 						return subpred; 					} 				} 				else if ((name.Name.EndsWith(":") || name.Name.EndsWith("=")) && expr.ArgCount == 2) 				{ 					return TranslateLabeledExpr(expr' ctx); 				} 				else if (expr.Calls(_Any' 2) && expr.Args[0].IsId)  				{ 					return Translate_any_in_Expr(expr' ctx); 				} 			}
Magic Number,Loyc.LLParserGenerator,StageTwoParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\StageTwoParser.cs,NodeToPredCore,The following statement contains a magic number: if (expr.IsCall) 			{ 				bool slash = false' not; 				var name = expr.Name; 				if (name == S.Tuple) 				{ 					// sequence: (a' b' c) 					if (expr.Calls(S.Tuple' 1)) 						return NodeToPred(expr.Args[0]' ctx); 					return TranslateToSeq(expr' ctx); 				} 				else if (name == S.Braces) 				{ 					// User action {block} 					if (ctx == Context.And || ctx == Context.GateLeft) { 						_sink.Error(expr' ctx == Context.And ? 							"Cannot use an action block inside an '&' or '&!' predicate; these predicates are for prediction only." : 							"Cannot use an action block on the left side of a '=>' gate; the left side is for prediction only."); 					} 					return new ActionPred(expr' expr.Args); 				} 				else if (expr.Calls(S.OrBits' 2) || (slash = expr.Calls(S.Div' 2))) 				{ 					// alternatives: a | b' a || b' a / b 					LNode lhs = expr.Args[0]' rhs = expr.Args[1]; 					BranchMode lhsMode' rhsMode; 					Pred left = BranchToPred(lhs' out lhsMode' ctx); 					Pred right = BranchToPred(rhs' out rhsMode' ctx); 					return Pred.Or(left' right' slash' expr' lhsMode' rhsMode' _sink); 				} 				else if (expr.Calls(_Star' 1) || expr.Calls(_Plus' 1) || expr.Calls(_Opt' 1)) 				{ 					// loop (a+' a*) or optional (a?) 					return TranslateLoopExpr(expr' ctx); 				} 				else if (expr.Calls(_Gate' 1) || expr.Calls(_EqGate' 1)) 				{ 					// => foo (LES-based parser artifact) 					return new Gate(expr' new Seq(F.Missing)' 					                      NodeToPred(expr.Args[0]' Context.GateRight)) 					                      { IsEquivalency = expr.Calls(_EqGate) }; 				} 				else if (expr.Calls(_Gate' 2) || expr.Calls(_EqGate' 2)) 				{ 					if (ctx == Context.GateLeft) 						_sink.Error(expr' "Cannot use a gate in the left-hand side of another gate");  					return new Gate(expr' NodeToPred(expr.Args[0]' Context.GateLeft)' 					                      NodeToPred(expr.Args[1]' Context.GateRight))  					                      { IsEquivalency = expr.Calls(_EqGate) }; 				} 				else if ((not = expr.Calls(_AndNot' 1)) || expr.Calls(_And' 1)) 				{ 					return TranslateAndPred(expr' not); 				} 				else if (expr.Calls(S.NotBits' 1)) 				{ 					var subpred = NodeToPred(expr.Args[0]' ctx); 					if (subpred is TerminalPred) { 						var term = (TerminalPred)subpred; 						term.Set = term.Set.Inverted().WithoutEOF(); 						return term; 					} else { 						_sink.Error(expr'  							"The set-inversion operator ~ can only be applied to a single terminal' not a '{0}'"' subpred.GetType().Name); 						return subpred; 					} 				} 				else if ((name.Name.EndsWith(":") || name.Name.EndsWith("=")) && expr.ArgCount == 2) 				{ 					return TranslateLabeledExpr(expr' ctx); 				} 				else if (expr.Calls(_Any' 2) && expr.Args[0].IsId)  				{ 					return Translate_any_in_Expr(expr' ctx); 				} 			}
Magic Number,Loyc.LLParserGenerator,StageTwoParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\StageTwoParser.cs,NodeToPredCore,The following statement contains a magic number: if (expr.IsCall) 			{ 				bool slash = false' not; 				var name = expr.Name; 				if (name == S.Tuple) 				{ 					// sequence: (a' b' c) 					if (expr.Calls(S.Tuple' 1)) 						return NodeToPred(expr.Args[0]' ctx); 					return TranslateToSeq(expr' ctx); 				} 				else if (name == S.Braces) 				{ 					// User action {block} 					if (ctx == Context.And || ctx == Context.GateLeft) { 						_sink.Error(expr' ctx == Context.And ? 							"Cannot use an action block inside an '&' or '&!' predicate; these predicates are for prediction only." : 							"Cannot use an action block on the left side of a '=>' gate; the left side is for prediction only."); 					} 					return new ActionPred(expr' expr.Args); 				} 				else if (expr.Calls(S.OrBits' 2) || (slash = expr.Calls(S.Div' 2))) 				{ 					// alternatives: a | b' a || b' a / b 					LNode lhs = expr.Args[0]' rhs = expr.Args[1]; 					BranchMode lhsMode' rhsMode; 					Pred left = BranchToPred(lhs' out lhsMode' ctx); 					Pred right = BranchToPred(rhs' out rhsMode' ctx); 					return Pred.Or(left' right' slash' expr' lhsMode' rhsMode' _sink); 				} 				else if (expr.Calls(_Star' 1) || expr.Calls(_Plus' 1) || expr.Calls(_Opt' 1)) 				{ 					// loop (a+' a*) or optional (a?) 					return TranslateLoopExpr(expr' ctx); 				} 				else if (expr.Calls(_Gate' 1) || expr.Calls(_EqGate' 1)) 				{ 					// => foo (LES-based parser artifact) 					return new Gate(expr' new Seq(F.Missing)' 					                      NodeToPred(expr.Args[0]' Context.GateRight)) 					                      { IsEquivalency = expr.Calls(_EqGate) }; 				} 				else if (expr.Calls(_Gate' 2) || expr.Calls(_EqGate' 2)) 				{ 					if (ctx == Context.GateLeft) 						_sink.Error(expr' "Cannot use a gate in the left-hand side of another gate");  					return new Gate(expr' NodeToPred(expr.Args[0]' Context.GateLeft)' 					                      NodeToPred(expr.Args[1]' Context.GateRight))  					                      { IsEquivalency = expr.Calls(_EqGate) }; 				} 				else if ((not = expr.Calls(_AndNot' 1)) || expr.Calls(_And' 1)) 				{ 					return TranslateAndPred(expr' not); 				} 				else if (expr.Calls(S.NotBits' 1)) 				{ 					var subpred = NodeToPred(expr.Args[0]' ctx); 					if (subpred is TerminalPred) { 						var term = (TerminalPred)subpred; 						term.Set = term.Set.Inverted().WithoutEOF(); 						return term; 					} else { 						_sink.Error(expr'  							"The set-inversion operator ~ can only be applied to a single terminal' not a '{0}'"' subpred.GetType().Name); 						return subpred; 					} 				} 				else if ((name.Name.EndsWith(":") || name.Name.EndsWith("=")) && expr.ArgCount == 2) 				{ 					return TranslateLabeledExpr(expr' ctx); 				} 				else if (expr.Calls(_Any' 2) && expr.Args[0].IsId)  				{ 					return Translate_any_in_Expr(expr' ctx); 				} 			}
Magic Number,Loyc.LLParserGenerator,StageTwoParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\StageTwoParser.cs,NodeToPredCore,The following statement contains a magic number: if (expr.IsCall) 			{ 				bool slash = false' not; 				var name = expr.Name; 				if (name == S.Tuple) 				{ 					// sequence: (a' b' c) 					if (expr.Calls(S.Tuple' 1)) 						return NodeToPred(expr.Args[0]' ctx); 					return TranslateToSeq(expr' ctx); 				} 				else if (name == S.Braces) 				{ 					// User action {block} 					if (ctx == Context.And || ctx == Context.GateLeft) { 						_sink.Error(expr' ctx == Context.And ? 							"Cannot use an action block inside an '&' or '&!' predicate; these predicates are for prediction only." : 							"Cannot use an action block on the left side of a '=>' gate; the left side is for prediction only."); 					} 					return new ActionPred(expr' expr.Args); 				} 				else if (expr.Calls(S.OrBits' 2) || (slash = expr.Calls(S.Div' 2))) 				{ 					// alternatives: a | b' a || b' a / b 					LNode lhs = expr.Args[0]' rhs = expr.Args[1]; 					BranchMode lhsMode' rhsMode; 					Pred left = BranchToPred(lhs' out lhsMode' ctx); 					Pred right = BranchToPred(rhs' out rhsMode' ctx); 					return Pred.Or(left' right' slash' expr' lhsMode' rhsMode' _sink); 				} 				else if (expr.Calls(_Star' 1) || expr.Calls(_Plus' 1) || expr.Calls(_Opt' 1)) 				{ 					// loop (a+' a*) or optional (a?) 					return TranslateLoopExpr(expr' ctx); 				} 				else if (expr.Calls(_Gate' 1) || expr.Calls(_EqGate' 1)) 				{ 					// => foo (LES-based parser artifact) 					return new Gate(expr' new Seq(F.Missing)' 					                      NodeToPred(expr.Args[0]' Context.GateRight)) 					                      { IsEquivalency = expr.Calls(_EqGate) }; 				} 				else if (expr.Calls(_Gate' 2) || expr.Calls(_EqGate' 2)) 				{ 					if (ctx == Context.GateLeft) 						_sink.Error(expr' "Cannot use a gate in the left-hand side of another gate");  					return new Gate(expr' NodeToPred(expr.Args[0]' Context.GateLeft)' 					                      NodeToPred(expr.Args[1]' Context.GateRight))  					                      { IsEquivalency = expr.Calls(_EqGate) }; 				} 				else if ((not = expr.Calls(_AndNot' 1)) || expr.Calls(_And' 1)) 				{ 					return TranslateAndPred(expr' not); 				} 				else if (expr.Calls(S.NotBits' 1)) 				{ 					var subpred = NodeToPred(expr.Args[0]' ctx); 					if (subpred is TerminalPred) { 						var term = (TerminalPred)subpred; 						term.Set = term.Set.Inverted().WithoutEOF(); 						return term; 					} else { 						_sink.Error(expr'  							"The set-inversion operator ~ can only be applied to a single terminal' not a '{0}'"' subpred.GetType().Name); 						return subpred; 					} 				} 				else if ((name.Name.EndsWith(":") || name.Name.EndsWith("=")) && expr.ArgCount == 2) 				{ 					return TranslateLabeledExpr(expr' ctx); 				} 				else if (expr.Calls(_Any' 2) && expr.Args[0].IsId)  				{ 					return Translate_any_in_Expr(expr' ctx); 				} 			}
Magic Number,Loyc.LLParserGenerator,StageTwoParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\StageTwoParser.cs,NodeToPredCore,The following statement contains a magic number: if (expr.IsCall) 			{ 				bool slash = false' not; 				var name = expr.Name; 				if (name == S.Tuple) 				{ 					// sequence: (a' b' c) 					if (expr.Calls(S.Tuple' 1)) 						return NodeToPred(expr.Args[0]' ctx); 					return TranslateToSeq(expr' ctx); 				} 				else if (name == S.Braces) 				{ 					// User action {block} 					if (ctx == Context.And || ctx == Context.GateLeft) { 						_sink.Error(expr' ctx == Context.And ? 							"Cannot use an action block inside an '&' or '&!' predicate; these predicates are for prediction only." : 							"Cannot use an action block on the left side of a '=>' gate; the left side is for prediction only."); 					} 					return new ActionPred(expr' expr.Args); 				} 				else if (expr.Calls(S.OrBits' 2) || (slash = expr.Calls(S.Div' 2))) 				{ 					// alternatives: a | b' a || b' a / b 					LNode lhs = expr.Args[0]' rhs = expr.Args[1]; 					BranchMode lhsMode' rhsMode; 					Pred left = BranchToPred(lhs' out lhsMode' ctx); 					Pred right = BranchToPred(rhs' out rhsMode' ctx); 					return Pred.Or(left' right' slash' expr' lhsMode' rhsMode' _sink); 				} 				else if (expr.Calls(_Star' 1) || expr.Calls(_Plus' 1) || expr.Calls(_Opt' 1)) 				{ 					// loop (a+' a*) or optional (a?) 					return TranslateLoopExpr(expr' ctx); 				} 				else if (expr.Calls(_Gate' 1) || expr.Calls(_EqGate' 1)) 				{ 					// => foo (LES-based parser artifact) 					return new Gate(expr' new Seq(F.Missing)' 					                      NodeToPred(expr.Args[0]' Context.GateRight)) 					                      { IsEquivalency = expr.Calls(_EqGate) }; 				} 				else if (expr.Calls(_Gate' 2) || expr.Calls(_EqGate' 2)) 				{ 					if (ctx == Context.GateLeft) 						_sink.Error(expr' "Cannot use a gate in the left-hand side of another gate");  					return new Gate(expr' NodeToPred(expr.Args[0]' Context.GateLeft)' 					                      NodeToPred(expr.Args[1]' Context.GateRight))  					                      { IsEquivalency = expr.Calls(_EqGate) }; 				} 				else if ((not = expr.Calls(_AndNot' 1)) || expr.Calls(_And' 1)) 				{ 					return TranslateAndPred(expr' not); 				} 				else if (expr.Calls(S.NotBits' 1)) 				{ 					var subpred = NodeToPred(expr.Args[0]' ctx); 					if (subpred is TerminalPred) { 						var term = (TerminalPred)subpred; 						term.Set = term.Set.Inverted().WithoutEOF(); 						return term; 					} else { 						_sink.Error(expr'  							"The set-inversion operator ~ can only be applied to a single terminal' not a '{0}'"' subpred.GetType().Name); 						return subpred; 					} 				} 				else if ((name.Name.EndsWith(":") || name.Name.EndsWith("=")) && expr.ArgCount == 2) 				{ 					return TranslateLabeledExpr(expr' ctx); 				} 				else if (expr.Calls(_Any' 2) && expr.Args[0].IsId)  				{ 					return Translate_any_in_Expr(expr' ctx); 				} 			}
Magic Number,Loyc.LLParserGenerator,StageTwoParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\StageTwoParser.cs,NodeToPredCore,The following statement contains a magic number: if (expr.IsCall) 			{ 				bool slash = false' not; 				var name = expr.Name; 				if (name == S.Tuple) 				{ 					// sequence: (a' b' c) 					if (expr.Calls(S.Tuple' 1)) 						return NodeToPred(expr.Args[0]' ctx); 					return TranslateToSeq(expr' ctx); 				} 				else if (name == S.Braces) 				{ 					// User action {block} 					if (ctx == Context.And || ctx == Context.GateLeft) { 						_sink.Error(expr' ctx == Context.And ? 							"Cannot use an action block inside an '&' or '&!' predicate; these predicates are for prediction only." : 							"Cannot use an action block on the left side of a '=>' gate; the left side is for prediction only."); 					} 					return new ActionPred(expr' expr.Args); 				} 				else if (expr.Calls(S.OrBits' 2) || (slash = expr.Calls(S.Div' 2))) 				{ 					// alternatives: a | b' a || b' a / b 					LNode lhs = expr.Args[0]' rhs = expr.Args[1]; 					BranchMode lhsMode' rhsMode; 					Pred left = BranchToPred(lhs' out lhsMode' ctx); 					Pred right = BranchToPred(rhs' out rhsMode' ctx); 					return Pred.Or(left' right' slash' expr' lhsMode' rhsMode' _sink); 				} 				else if (expr.Calls(_Star' 1) || expr.Calls(_Plus' 1) || expr.Calls(_Opt' 1)) 				{ 					// loop (a+' a*) or optional (a?) 					return TranslateLoopExpr(expr' ctx); 				} 				else if (expr.Calls(_Gate' 1) || expr.Calls(_EqGate' 1)) 				{ 					// => foo (LES-based parser artifact) 					return new Gate(expr' new Seq(F.Missing)' 					                      NodeToPred(expr.Args[0]' Context.GateRight)) 					                      { IsEquivalency = expr.Calls(_EqGate) }; 				} 				else if (expr.Calls(_Gate' 2) || expr.Calls(_EqGate' 2)) 				{ 					if (ctx == Context.GateLeft) 						_sink.Error(expr' "Cannot use a gate in the left-hand side of another gate");  					return new Gate(expr' NodeToPred(expr.Args[0]' Context.GateLeft)' 					                      NodeToPred(expr.Args[1]' Context.GateRight))  					                      { IsEquivalency = expr.Calls(_EqGate) }; 				} 				else if ((not = expr.Calls(_AndNot' 1)) || expr.Calls(_And' 1)) 				{ 					return TranslateAndPred(expr' not); 				} 				else if (expr.Calls(S.NotBits' 1)) 				{ 					var subpred = NodeToPred(expr.Args[0]' ctx); 					if (subpred is TerminalPred) { 						var term = (TerminalPred)subpred; 						term.Set = term.Set.Inverted().WithoutEOF(); 						return term; 					} else { 						_sink.Error(expr'  							"The set-inversion operator ~ can only be applied to a single terminal' not a '{0}'"' subpred.GetType().Name); 						return subpred; 					} 				} 				else if ((name.Name.EndsWith(":") || name.Name.EndsWith("=")) && expr.ArgCount == 2) 				{ 					return TranslateLabeledExpr(expr' ctx); 				} 				else if (expr.Calls(_Any' 2) && expr.Args[0].IsId)  				{ 					return Translate_any_in_Expr(expr' ctx); 				} 			}
Magic Number,Loyc.LLParserGenerator,Alts,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Predicates.cs,ToString,The following statement contains a magic number: if (Arms.Count >= 3) { 				prefix = "( "; suffix = " )"; // make output easier to read 			} else { 				prefix = "("; suffix = ")"; 			}
Magic Number,Loyc.LLParserGenerator,Alts,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Predicates.cs,AltName,The following statement contains a magic number: if ((uint)altNum < (uint)Arms.Count) 				if ((descr = Arms[altNum].ToString()).Length <= 9 + altNum) 					return (altNum + 1).ToString() + ":" + descr;
Magic Number,Loyc.LLParserGenerator,Rule,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Rule.cs,Rule,The following statement contains a magic number: if (basis != null && basis.Calls(S.Fn) && basis.ArgCount >= 3) 				ReturnType = basis.Args[0];
Magic Number,Loyc.LLParserGenerator,Rule,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Rule.cs,GetMethodSignature,The following statement contains a magic number: if (Basis != null && Basis.Calls(S.Fn) && Basis.ArgCount.IsInRange(3' 4)) { 				var parts = Basis.Args; 				if (parts.Count == 4) 					parts.RemoveAt(3); 				if (IsRecognizer) 					parts[0] = F.Bool; 				parts[1] = F.Id(Name); 				// remove OneLiner style to avoid suppresing newlines in output for one-line rules 				return Basis.WithArgs(parts).SetStyle(Basis.Style & ~NodeStyle.OneLiner); 			} else { 				var method = F.Fn(IsRecognizer ? F.Bool : F.Void' F.Id(Name)' F.List()); 				if (IsPrivate == true) 					method = F.Attr(F.Id(S.Private)' method); 				else if (IsStartingRule | IsToken) 					method = F.Attr(F.Id(S.Public)' method); 				return method; 			}
Magic Number,Loyc.LLParserGenerator,Rule,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Rule.cs,GetMethodSignature,The following statement contains a magic number: if (Basis != null && Basis.Calls(S.Fn) && Basis.ArgCount.IsInRange(3' 4)) { 				var parts = Basis.Args; 				if (parts.Count == 4) 					parts.RemoveAt(3); 				if (IsRecognizer) 					parts[0] = F.Bool; 				parts[1] = F.Id(Name); 				// remove OneLiner style to avoid suppresing newlines in output for one-line rules 				return Basis.WithArgs(parts).SetStyle(Basis.Style & ~NodeStyle.OneLiner); 			} else { 				var method = F.Fn(IsRecognizer ? F.Bool : F.Void' F.Id(Name)' F.List()); 				if (IsPrivate == true) 					method = F.Attr(F.Id(S.Private)' method); 				else if (IsStartingRule | IsToken) 					method = F.Attr(F.Id(S.Public)' method); 				return method; 			}
Magic Number,Loyc.LLParserGenerator,Rule,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Rule.cs,GetMethodSignature,The following statement contains a magic number: if (Basis != null && Basis.Calls(S.Fn) && Basis.ArgCount.IsInRange(3' 4)) { 				var parts = Basis.Args; 				if (parts.Count == 4) 					parts.RemoveAt(3); 				if (IsRecognizer) 					parts[0] = F.Bool; 				parts[1] = F.Id(Name); 				// remove OneLiner style to avoid suppresing newlines in output for one-line rules 				return Basis.WithArgs(parts).SetStyle(Basis.Style & ~NodeStyle.OneLiner); 			} else { 				var method = F.Fn(IsRecognizer ? F.Bool : F.Void' F.Id(Name)' F.List()); 				if (IsPrivate == true) 					method = F.Attr(F.Id(S.Private)' method); 				else if (IsStartingRule | IsToken) 					method = F.Attr(F.Id(S.Public)' method); 				return method; 			}
Magic Number,Loyc.LLParserGenerator,Rule,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Rule.cs,GetMethodSignature,The following statement contains a magic number: if (Basis != null && Basis.Calls(S.Fn) && Basis.ArgCount.IsInRange(3' 4)) { 				var parts = Basis.Args; 				if (parts.Count == 4) 					parts.RemoveAt(3); 				if (IsRecognizer) 					parts[0] = F.Bool; 				parts[1] = F.Id(Name); 				// remove OneLiner style to avoid suppresing newlines in output for one-line rules 				return Basis.WithArgs(parts).SetStyle(Basis.Style & ~NodeStyle.OneLiner); 			} else { 				var method = F.Fn(IsRecognizer ? F.Bool : F.Void' F.Id(Name)' F.List()); 				if (IsPrivate == true) 					method = F.Attr(F.Id(S.Private)' method); 				else if (IsStartingRule | IsToken) 					method = F.Attr(F.Id(S.Public)' method); 				return method; 			}
Magic Number,Loyc.LLParserGenerator,Rule,C:\repos\qwertie_Loyc\Main\LLLPG\RuleAndPreds\Rule.cs,CreateMethod,The following statement contains a magic number: Debug.Assert(parts.Count == 3);
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,AddNumbers,The following statement contains a magic number: var stmt = F.Assign(n' F.Call(S.Checked'  					F.Call(S.Add' F.Call(S.Mul' n' F.Literal(10))' 					   F.InParens(F.Call(S.Sub' F.Id("c")' F.Literal('0'))))));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,MLComment,The following statement contains a magic number: Rule MLComment = Rule("MLComment"' C('/') + '*' + Star(AnyCh'false) + '*' + '/'' Token' 2);
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,OneAmbiguityExpected,The following statement contains a magic number: var AmbigLL2 = Rule("AmbigLL2"' Opt(Seq("ab")) + 'a' + Opt(C('b'))' Token' 2);
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,OneAmbiguityExpected,The following statement contains a magic number: var UnambigLL3 = Rule("UnambigLL3"' Opt(Seq("ab")) + 'a' + Opt(C('b'))' Token' 3);
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,LeftRecursive1,The following statement contains a magic number: A.K = 3;
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,DifferentDefault,The following statement contains a magic number: star2.DefaultArm = 2;
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Rule slashes = Rule("Slashes"' all' Token' 4);
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsTrue(all.ShouldSuppressWarning(0' 2));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsTrue(all.ShouldSuppressWarning(2' 0));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsFalse(all.ShouldSuppressWarning(4' 5));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsFalse(all.ShouldSuppressWarning(4' 5));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsFalse(all.ShouldSuppressWarning(3' 4));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsFalse(all.ShouldSuppressWarning(3' 4));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsFalse(all.ShouldSuppressWarning(3' 5));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsFalse(all.ShouldSuppressWarning(3' 5));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsFalse(all.ShouldSuppressWarning(3' 6));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsFalse(all.ShouldSuppressWarning(3' 6));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsTrue(all.ShouldSuppressWarning(4' 6));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsTrue(all.ShouldSuppressWarning(4' 6));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsTrue(all.ShouldSuppressWarning(5' 6));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsTrue(all.ShouldSuppressWarning(5' 6));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsTrue(all.ShouldSuppressWarning(11' 12));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsTrue(all.ShouldSuppressWarning(11' 12));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsFalse(all.ShouldSuppressWarning(10' 12));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsFalse(all.ShouldSuppressWarning(10' 12));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsFalse(all.ShouldSuppressWarning(10' 11));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsFalse(all.ShouldSuppressWarning(10' 11));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsFalse(all.ShouldSuppressWarning(8' 9));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsFalse(all.ShouldSuppressWarning(8' 9));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsTrue(all.ShouldSuppressWarning(8' 10));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsTrue(all.ShouldSuppressWarning(8' 10));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsTrue(all.ShouldSuppressWarning(8' 12));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsTrue(all.ShouldSuppressWarning(8' 12));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsTrue(all.ShouldSuppressWarning(0' 3));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsTrue(all.ShouldSuppressWarning(1' 4));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsTrue(all.ShouldSuppressWarning(2' 5));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsTrue(all.ShouldSuppressWarning(2' 5));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: Assert.IsTrue(all.ShouldSuppressWarning(0' 6));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: for (int i = 0; i < 7; i++) 				for (int j = 7; j <= 12; j++) 					Assert.IsFalse(all.ShouldSuppressWarning(i' j));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: for (int i = 0; i < 7; i++) 				for (int j = 7; j <= 12; j++) 					Assert.IsFalse(all.ShouldSuppressWarning(i' j));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: for (int i = 0; i < 7; i++) 				for (int j = 7; j <= 12; j++) 					Assert.IsFalse(all.ShouldSuppressWarning(i' j));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: for (int i = 8; i < 12; i++) 				Assert.IsTrue(all.ShouldSuppressWarning(7' i));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: for (int i = 8; i < 12; i++) 				Assert.IsTrue(all.ShouldSuppressWarning(7' i));
Magic Number,Loyc.LLParserGenerator,LlpgCoreTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgCoreTests.cs,SlashWarningTests,The following statement contains a magic number: for (int i = 8; i < 12; i++) 				Assert.IsTrue(all.ShouldSuppressWarning(7' i));
Magic Number,Loyc.LLParserGenerator,LlpgParserTests,C:\repos\qwertie_Loyc\Main\LLLPG\Tests\LlpgParserTests.cs,Stage1Les_SimpleTests,The following statement contains a magic number: TestStage1("123"' F.Literal(123));
Magic Number,Loyc.LLPG,Macros,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\Macros.cs,rule,The following statement contains a magic number: if ((isToken = node.Calls(_token' 2)) || node.Calls(_rule' 2)) { 				node = context.PreProcessChildren(); 				LNode sig = node.Args[0]; 				// Ugh. Because the rule has been macro-processed' "rule X::Y ..."  				// has become "rule #var(Y'X) ...". We must allow this' because in  				// case of something like "rule X(arg::int)::Y" we actually do want 				// the argument to become `#var(int' arg)`; so just reverse the 				// transform that we didn't want. 				if (sig.Calls(S.Var' 2)) 					sig = F.Call(S.ColonColon' sig.Args[1]' sig.Args[0]);  				LNode name = sig' returnType = F.Void; 				if (sig.Calls(S.ColonColon' 2)) { 					returnType = sig.Args[1]; 					name = sig.Args[0]; 				} 				if (LeMP.Prelude.Les.Macros.IsComplexId(name)) 					name = F.Call(name); // def requires an argument list 				 				VList<LNode> args = name.Args; 				name = name.Target; 				 				LNode newBody = ParseRuleBody(node.Args[1]' context); 				if (newBody != null) 					return node.With(isToken ? _hash_token : _hash_rule'  						returnType' name' F.List(args)' newBody); 			}
Magic Number,Loyc.LLPG,Macros,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\Macros.cs,rule,The following statement contains a magic number: if ((isToken = node.Calls(_token' 2)) || node.Calls(_rule' 2)) { 				node = context.PreProcessChildren(); 				LNode sig = node.Args[0]; 				// Ugh. Because the rule has been macro-processed' "rule X::Y ..."  				// has become "rule #var(Y'X) ...". We must allow this' because in  				// case of something like "rule X(arg::int)::Y" we actually do want 				// the argument to become `#var(int' arg)`; so just reverse the 				// transform that we didn't want. 				if (sig.Calls(S.Var' 2)) 					sig = F.Call(S.ColonColon' sig.Args[1]' sig.Args[0]);  				LNode name = sig' returnType = F.Void; 				if (sig.Calls(S.ColonColon' 2)) { 					returnType = sig.Args[1]; 					name = sig.Args[0]; 				} 				if (LeMP.Prelude.Les.Macros.IsComplexId(name)) 					name = F.Call(name); // def requires an argument list 				 				VList<LNode> args = name.Args; 				name = name.Target; 				 				LNode newBody = ParseRuleBody(node.Args[1]' context); 				if (newBody != null) 					return node.With(isToken ? _hash_token : _hash_rule'  						returnType' name' F.List(args)' newBody); 			}
Magic Number,Loyc.LLPG,Macros,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\Macros.cs,rule,The following statement contains a magic number: if ((isToken = node.Calls(_token' 2)) || node.Calls(_rule' 2)) { 				node = context.PreProcessChildren(); 				LNode sig = node.Args[0]; 				// Ugh. Because the rule has been macro-processed' "rule X::Y ..."  				// has become "rule #var(Y'X) ...". We must allow this' because in  				// case of something like "rule X(arg::int)::Y" we actually do want 				// the argument to become `#var(int' arg)`; so just reverse the 				// transform that we didn't want. 				if (sig.Calls(S.Var' 2)) 					sig = F.Call(S.ColonColon' sig.Args[1]' sig.Args[0]);  				LNode name = sig' returnType = F.Void; 				if (sig.Calls(S.ColonColon' 2)) { 					returnType = sig.Args[1]; 					name = sig.Args[0]; 				} 				if (LeMP.Prelude.Les.Macros.IsComplexId(name)) 					name = F.Call(name); // def requires an argument list 				 				VList<LNode> args = name.Args; 				name = name.Target; 				 				LNode newBody = ParseRuleBody(node.Args[1]' context); 				if (newBody != null) 					return node.With(isToken ? _hash_token : _hash_rule'  						returnType' name' F.List(args)' newBody); 			}
Magic Number,Loyc.LLPG,Macros,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\Macros.cs,rule,The following statement contains a magic number: if ((isToken = node.Calls(_token' 2)) || node.Calls(_rule' 2)) { 				node = context.PreProcessChildren(); 				LNode sig = node.Args[0]; 				// Ugh. Because the rule has been macro-processed' "rule X::Y ..."  				// has become "rule #var(Y'X) ...". We must allow this' because in  				// case of something like "rule X(arg::int)::Y" we actually do want 				// the argument to become `#var(int' arg)`; so just reverse the 				// transform that we didn't want. 				if (sig.Calls(S.Var' 2)) 					sig = F.Call(S.ColonColon' sig.Args[1]' sig.Args[0]);  				LNode name = sig' returnType = F.Void; 				if (sig.Calls(S.ColonColon' 2)) { 					returnType = sig.Args[1]; 					name = sig.Args[0]; 				} 				if (LeMP.Prelude.Les.Macros.IsComplexId(name)) 					name = F.Call(name); // def requires an argument list 				 				VList<LNode> args = name.Args; 				name = name.Target; 				 				LNode newBody = ParseRuleBody(node.Args[1]' context); 				if (newBody != null) 					return node.With(isToken ? _hash_token : _hash_rule'  						returnType' name' F.List(args)' newBody); 			}
Magic Number,Loyc.LLPG,Macros,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\Macros.cs,ECSharpRule,The following statement contains a magic number: if (!(isProp = node.Calls(S.Property' 4)) && !node.Calls(S.Fn' 4)) 				return null;
Magic Number,Loyc.LLPG,Macros,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\Macros.cs,ECSharpRule,The following statement contains a magic number: if (!(isProp = node.Calls(S.Property' 4)) && !node.Calls(S.Fn' 4)) 				return null;
Magic Number,Loyc.LLPG,Macros,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\Macros.cs,ECSharpRule,The following statement contains a magic number: LNode args = node.Args[2];
Magic Number,Loyc.LLPG,Macros,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\Macros.cs,run_LLLPG,The following statement contains a magic number: if (node.ArgCount != 2  				|| (helper = node.Args[0].Value as IPGCodeGenHelper) == null  				|| !(hasBraces = (body = node.Args[1]).Calls(S.Braces))) 			{ 				string msg = Localize.Localized("Expected run_LLLPG(helper_object' {...})."); 				if (hasBraces) msg = " " + Localize.Localized("An auxiliary macro is required to supply the helper object."); 				context.Write(Severity.Note' node' msg); 				return null; 			}
Magic Number,Loyc.LLPG,Macros,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\Macros.cs,run_LLLPG,The following statement contains a magic number: for (int i = 0; i < stmts.Count; i++) 			{ 				LNode stmt = stmts[i]; 				bool isToken; 				if ((isToken = stmt.Calls(_hash_token' 4)) || stmt.Calls(_hash_rule' 4)) { 					LNode basis = stmt.WithTarget(S.Fn); 					LNode methodBody = stmt.Args.Last;  					// basis has the form #fn(ReturnType' Name' #(Args)) 					var rule = MakeRuleObject(isToken' ref basis' context); 					if (rule != null) { 						var prev = rules.FirstOrDefault(pair => pair.A.Name == rule.Name); 						if (prev.A != null) 							context.Sink.Error(rule.Basis' "The rule name «{0}» was used before at {1}"' rule.Name' prev.A.Basis.Range.Start); 						else 							rules.Add(Pair.Create(rule' methodBody));  						stmts[i] = null; // remove processed rules from the list 					} 				} else { 					if (stmt.Calls(_rule) || stmt.Calls(_token)) 						context.Sink.Error(stmt' "A rule should have the form rule(Name(Args)::ReturnType' @{...})"); 				} 			}
Magic Number,Loyc.LLPG,Macros,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\Macros.cs,run_LLLPG,The following statement contains a magic number: for (int i = 0; i < stmts.Count; i++) 			{ 				LNode stmt = stmts[i]; 				bool isToken; 				if ((isToken = stmt.Calls(_hash_token' 4)) || stmt.Calls(_hash_rule' 4)) { 					LNode basis = stmt.WithTarget(S.Fn); 					LNode methodBody = stmt.Args.Last;  					// basis has the form #fn(ReturnType' Name' #(Args)) 					var rule = MakeRuleObject(isToken' ref basis' context); 					if (rule != null) { 						var prev = rules.FirstOrDefault(pair => pair.A.Name == rule.Name); 						if (prev.A != null) 							context.Sink.Error(rule.Basis' "The rule name «{0}» was used before at {1}"' rule.Name' prev.A.Basis.Range.Start); 						else 							rules.Add(Pair.Create(rule' methodBody));  						stmts[i] = null; // remove processed rules from the list 					} 				} else { 					if (stmt.Calls(_rule) || stmt.Calls(_token)) 						context.Sink.Error(stmt' "A rule should have the form rule(Name(Args)::ReturnType' @{...})"); 				} 			}
Magic Number,Loyc.LLPG,Macros,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\Macros.cs,ApplyRuleOptions,The following statement contains a magic number: node = node.WithAttrs(node.Attrs.WhereSelect(attr => { 				if (attr.ArgCount > 1) 					return attr; 				LNode key = attr.Target ?? attr; 				object value = null; 				if (attr.ArgCount == 1) 					value = attr.Args[0].Value; 				switch (key.Name.Name) { 					case "fullLLk": case "FullLLk": 						SetOption<bool>(context' key' value ?? G.BoxedTrue' v => rule.FullLLk = v); 						break; 					case "#private": case "private": 						SetOption<bool>(context' key' value ?? G.BoxedTrue' v => rule.IsPrivate = v); 						return attr; // keep attribute 					case "#public": case "#internal": case "#protected": 					case "public": case "internal": case "protected": // this is before macros run' and non-special names are used in LES 						rule.IsPrivate = false; 						return attr; // keep attribute 					case "token": case "Token": 						SetOption<bool>(context' key' value ?? G.BoxedTrue' v => rule.IsToken = v); 						break; 					case "start": case "Start": 						SetOption<bool>(context' key' value ?? G.BoxedTrue' v => rule.IsStartingRule = v); 						break; 					case "#extern": case "extern": case "Extern": 						SetOption<bool>(context' key' value ?? G.BoxedTrue' v => rule.IsExternal = v); 						break; 					case "#inline": case "inline": case "Inline": 					case "#fragment": case "fragment": 						SetOption<bool>(context' key' value ?? G.BoxedTrue' v => rule.IsInline = v); 						break; 					case "k": case "K": case "LL": 						SetOption<int>(context' key' value' k => rule.K = k); 						break; 					case "recognizer": case "Recognizer": 						LNode sig = attr.Args[0' null]; 						if (sig != null) { 							if (sig.Calls(S.Braces' 1)) 								sig = sig.Args[0];  							// Invoke macros here so that LES code like "public fn Foo()::bool" 							// is transformed into a method signature. 							sig = context.PreProcess(sig); 						} 						if (sig != null && sig.CallsMin(S.Fn' 3)) 							rule.MakeRecognizerVersion(sig).TryWrapperNeeded(); 						else 							context.Sink.Error(sig' "'recognizer' expects one parameter' a method signature."); 						break; 					default: 						return attr; 				} 				return NoValue.Value; 			}).ToArray());
Duplicate Code,Loyc.LLParserGenerator,AntlrStyleParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\AntlrStyleParserGrammar.out.cs,RulesAndStuff,The method contains a code clone-set at the following line numbers (starting from the method definition): ((4' 38)' (45' 79))
Missing Default,Loyc.LLParserGenerator,StageOneParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\StageOneParser.cs,AssignExpr,The following switch statement is missing a default case: switch ((TT) LA(1)) { 				case TT.And: 				case TT.AndNot: 				case TT.Any: 				case TT.Id: 				case TT.In: 				case TT.InvertSet: 				case TT.LBrace: 				case TT.LBrack: 				case TT.Literal: 				case TT.LParen: 				case TT.Minus: 					{ 						op = MatchAny(); 						var b = AssignExpr(); 						#line 103 "StageOneParserGrammar.ecs" 						Infix(ref a' (Symbol) op.Value' b); 						#line default 					} 					break; 				}
Missing Default,Loyc.LLParserGenerator,StageOneParser,C:\repos\qwertie_Loyc\Main\LLLPG\ParsersAndMacros\StageOneParser.cs,RangeExpr,The following switch statement is missing a default case: switch ((TT) LA(1)) { 				case TT.Any: 				case TT.Id: 				case TT.In: 				case TT.LBrace: 				case TT.LBrack: 				case TT.Literal: 				case TT.LParen: 				case TT.Minus: 					{ 						var op = MatchAny(); 						var b = PrimaryExpr(); 						#line 120 "StageOneParserGrammar.ecs" 						Infix(ref a' (Symbol) op.Value' b); 						#line default 					} 					break; 				}
