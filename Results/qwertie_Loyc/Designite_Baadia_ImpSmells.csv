Implementation smell,Namespace,Class,File,Method,Description
Long Method,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The method has 280 lines of code.
Complex Method,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,HandleMouseUp,Cyclomatic complexity of the method is 9
Complex Method,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,TryInterpretAsBox,Cyclomatic complexity of the method is 8
Complex Method,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,InterpretAsPolyline,Cyclomatic complexity of the method is 11
Complex Method,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,HitTest,Cyclomatic complexity of the method is 8
Complex Method,BoxDiagrams,TextBox,C:\repos\qwertie_Loyc\Baadia\Shapes\TextBox.cs,HitTest,Cyclomatic complexity of the method is 10
Complex Method,Util.WinForms,GestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\Util\GestureAnalyzer.cs,AddFiltered,Cyclomatic complexity of the method is 9
Complex Method,Util.WinForms,LLShapeLayer,C:\repos\qwertie_Loyc\Baadia\Util\LLShapeControl.cs,AutoDraw,Cyclomatic complexity of the method is 9
Long Parameter List,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,ShowEraseDuringDrag,The method has 5 parameters. Parameters: state' adorners' eraseSet' simplified' cancel
Long Parameter List,Util.WinForms,LLShape,C:\repos\qwertie_Loyc\Baadia\Util\LLShapes.cs,DrawPolygon,The method has 5 parameters. Parameters: g' style' points' divisions' opacity
Long Parameter List,Util.WinForms,LLShape,C:\repos\qwertie_Loyc\Baadia\Util\LLShapes.cs,HitTestPolyline,The method has 5 parameters. Parameters: point' radius' points' divisions' projected
Long Parameter List,Util.WinForms,LLShape,C:\repos\qwertie_Loyc\Baadia\Util\LLShapes.cs,HitTestPolygon,The method has 5 parameters. Parameters: point' radius' points' divisions' projected
Long Parameter List,Util.WinForms,LLMarkerRotated,C:\repos\qwertie_Loyc\Baadia\Util\LLShapes.cs,LLMarkerRotated,The method has 5 parameters. Parameters: style' point' radius' type' angleDeg
Long Parameter List,Util.WinForms,LLQuadraticCurve,C:\repos\qwertie_Loyc\Baadia\Util\LLShapes.cs,Flatten,The method has 5 parameters. Parameters: a' b' c' out' per
Long Parameter List,Util.WinForms,LLTextShape,C:\repos\qwertie_Loyc\Baadia\Util\LLShapes.cs,LLTextShape,The method has 5 parameters. Parameters: style' text' justify' location' maxSize
Long Parameter List,Util.WinForms,LLTextShape,C:\repos\qwertie_Loyc\Baadia\Util\LLShapes.cs,HitTest1D,The method has 5 parameters. Parameters: point' location' size' maxSize' alignment
Long Statement,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,DetectNewShapeDuringDrag,The length of the statement  "			adorners.Add(new LLPolyline(DiagramControl.MouseLineStyle' state.Points.Select(p => p.Point).AsList()) { ZOrder = 0x100 });" is 123.
Long Statement,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,DetectNewShapeDuringDrag,The length of the statement  "					adorners.Add(new LLMarker(new DrawStyle { LineColor = Color.Gainsboro' FillColor = Color.Gray }' s.StartSS' 5' MarkerPolygon.Circle));" is 134.
Long Statement,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,RecognizeBoxOrLines,The length of the statement  "				shape = (Shape)TryInterpretAsBox(sections2' (line.FromAnchor ?? line.ToAnchor) != null' out potentialSelection) ?? line;" is 120.
Long Statement,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The length of the statement  "			this.menuOpen.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.O)));" is 126.
Long Statement,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The length of the statement  "			this.menuSave.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.S)));" is 126.
Long Statement,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The length of the statement  "			this.menuExit.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Alt | System.Windows.Forms.Keys.F4)));" is 123.
Long Statement,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The length of the statement  "			this.menuCut.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.X)));" is 125.
Long Statement,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The length of the statement  "			this.menuCopy.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.C)));" is 126.
Long Statement,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The length of the statement  "			this.menuPaste.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.V)));" is 127.
Long Statement,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The length of the statement  "			this.menuDuplicate.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.D)));" is 131.
Long Statement,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The length of the statement  "			this.menuClearText.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.Delete)));" is 136.
Long Statement,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The length of the statement  "			this.menuSelectAll.ShortcutKeys = ((System.Windows.Forms.Keys)((System.Windows.Forms.Keys.Control | System.Windows.Forms.Keys.A)));" is 131.
Long Statement,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The length of the statement  "			this._diagramCtrl.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom) " is 148.
Long Statement,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AddLLShapesTo,The length of the statement  "						Style' TextTopLeft.Text' LLTextShape.JustifyUpperCenter' Points[half]' new VectorT(midVec.Length()' 100)) { AngleDeg = (float)midVec.AngleDeg() });" is 147.
Long Statement,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AttachedAnchorChanged,The length of the statement  "					} else if (points.Count >= 4 && (itsc2 = points[0].To(points[1]).ComputeIntersection(points[2].To(points[3]))) != null) {" is 121.
Long Statement,Util.WinForms,LLTextShape,C:\repos\qwertie_Loyc\Baadia\Util\LLShapes.cs,Draw,The length of the statement  "				g.DrawString(Text' Style.Font' Style.TextBrush(Opacity)' new RectangleF(0' 0' MaxSize.Value.X' MaxSize.Value.Y)' Justify);" is 122.
Complex Conditional,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,HitTest,The conditional expression  "best == null || (resultSel && !bestSel) || (bestSel == resultSel && bestZOrder < zOrder)"  is complex.
Complex Conditional,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,MouseClickStarted,The conditional expression  "htresult != null && htresult.AllowsDrag 				&& !Control.SelectedShapes.Contains(htresult.Shape) 				&& (System.Windows.Forms.Control.ModifierKeys & Keys.Control) == 0 				&& htresult.Shape is Shape"  is complex.
Complex Conditional,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,OnShapesDeletedAction,The conditional expression  "_fromAnchor != null && deleted.Contains(_fromAnchor.Shape) 				|| _toAnchor != null && deleted.Contains(_toAnchor.Shape)"  is complex.
Complex Conditional,Util.WinForms,LLShapeLayer,C:\repos\qwertie_Loyc\Baadia\Util\LLShapeControl.cs,AutoDraw,The conditional expression  "IsInvalidated || _bmp.PixelFormat != pixFmt || _bmp.Width != width || _bmp.Height != height"  is complex.
Virtual Method Call from Constructor,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,DiagramControl,The constructor "DiagramControl" calls a virtual method "AddLayerAbove".
Virtual Method Call from Constructor,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,DiagramControl,The constructor "DiagramControl" calls a virtual method "AddLayerAbove".
Virtual Method Call from Constructor,Util.WinForms,GestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\Util\GestureAnalyzer.cs,GestureAnalyzer,The constructor "GestureAnalyzer" calls a virtual method "AddFiltered".
Virtual Method Call from Constructor,Util.WinForms,GestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\Util\GestureAnalyzer.cs,GestureAnalyzer,The constructor "GestureAnalyzer" calls a virtual method "AnalyzeGesture".
Virtual Method Call from Constructor,Util.WinForms,GestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\Util\GestureAnalyzer.cs,GestureAnalyzer,The constructor "GestureAnalyzer" calls a virtual method "AnalyzeGesture".
Empty Catch Block,Util.Collections,ChildList<Parent;T>,C:\repos\qwertie_Loyc\Baadia\Util\OwnedList.cs,OnListChanging,The method has an empty catch block.
Empty Catch Block,Util.Collections,ChildList<Parent;T>,C:\repos\qwertie_Loyc\Baadia\Util\OwnedList.cs,OnListChanging,The method has an empty catch block.
Empty Catch Block,Util.Collections,ChildList<Parent;T>,C:\repos\qwertie_Loyc\Baadia\Util\OwnedList.cs,OnListChanging,The method has an empty catch block.
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,DiagramControl,The following statement contains a magic number: LineStyle = new DiagramDrawStyle { LineColor = Color.Black' LineWidth = 2' TextColor = Color.Blue' FillColor = Color.FromArgb(64' Color.Gray) };
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,DiagramControl,The following statement contains a magic number: LineStyle = new DiagramDrawStyle { LineColor = Color.Black' LineWidth = 2' TextColor = Color.Blue' FillColor = Color.FromArgb(64' Color.Gray) };
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,DiagramControl,The following statement contains a magic number: MarkerRadius = 5;
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,Zoom,The following statement contains a magic number: PointT center = ToShapeSpace(new PointT(size.Width / 2' size.Height / 2));
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,Zoom,The following statement contains a magic number: PointT center = ToShapeSpace(new PointT(size.Width / 2' size.Height / 2));
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,DuplicateSelected,The following statement contains a magic number: if (run) 			{ 				// Equivalent to copy + paste 				var buf = SerializeSelected(); 				buf.Position = 0; 				PasteAndSelect(buf' new VectorT(20' 20)); 			}
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,DuplicateSelected,The following statement contains a magic number: if (run) 			{ 				// Equivalent to copy + paste 				var buf = SerializeSelected(); 				buf.Position = 0; 				PasteAndSelect(buf' new VectorT(20' 20)); 			}
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,Copy,The following statement contains a magic number: if (run) 			{ 				var buf = SerializeSelected(); 				var data = new DataObject();  				data.SetData("DiagramDocument"' buf.ToArray());  				var sortedShapes = _selectedShapes.OrderBy(s => 				{ 					var c = s.BBox.Center(); 					return c.Y + c.X / 10; 				}); 				var text = StringExt.Join("\n\n"' sortedShapes 					.Select(s => s.PlainText()).Where(t => !string.IsNullOrEmpty(t))); 				if (!string.IsNullOrEmpty(text)) 					data.SetText(text);  				// Crazy Clipboard deletes data by default on app exit! 				// need 'true' parameter to prevent loss of data on exit 				Clipboard.SetDataObject(data' true); 			}
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,Paste,The following statement contains a magic number: if (Clipboard.ContainsData("DiagramDocument")) 			{ 				if (run) 				{ 					var buf = Clipboard.GetData("DiagramDocument") as byte[]; 					if (buf != null) 						PasteAndSelect(new MemoryStream(buf)' VectorT.Zero); 				} 				return true; 			} 			else if (Clipboard.ContainsText()) 			{ 				if (run) 				{ 					var text = Clipboard.GetText();  					DoOrUndo act = null; 					if (_focusShape != null && (act = _focusShape.AppendTextAction(text)) != null) 						_doc.UndoStack.Do(act' true); 					else 					{ 						var textBox = new TextBox(new BoundingBox<Coord>(0' 0' 300' 200)) 						{ 							Text = text' 							TextJustify = LLTextShape.JustifyMiddleCenter' 							BoxType = BoxType.Borderless' 							Style = BoxStyle 						}; 						_doc.AddShape(textBox); 					} 				} 				return true; 			}
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,Paste,The following statement contains a magic number: if (Clipboard.ContainsData("DiagramDocument")) 			{ 				if (run) 				{ 					var buf = Clipboard.GetData("DiagramDocument") as byte[]; 					if (buf != null) 						PasteAndSelect(new MemoryStream(buf)' VectorT.Zero); 				} 				return true; 			} 			else if (Clipboard.ContainsText()) 			{ 				if (run) 				{ 					var text = Clipboard.GetText();  					DoOrUndo act = null; 					if (_focusShape != null && (act = _focusShape.AppendTextAction(text)) != null) 						_doc.UndoStack.Do(act' true); 					else 					{ 						var textBox = new TextBox(new BoundingBox<Coord>(0' 0' 300' 200)) 						{ 							Text = text' 							TextJustify = LLTextShape.JustifyMiddleCenter' 							BoxType = BoxType.Borderless' 							Style = BoxStyle 						}; 						_doc.AddShape(textBox); 					} 				} 				return true; 			}
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,OnKeyPress,The following statement contains a magic number: if (!e.Handled) { 				// Should we add text to _focusShape or create a new text shape? 				bool ignorePanel = false; 				if (_focusShape != null && _focusShape.IsPanel && string.IsNullOrEmpty(_focusShape.PlainText())) 					ignorePanel = true; 				if (_focusShape != null && !ignorePanel) { 					_focusShape.OnKeyPress(e); 				} else if (e.KeyChar >= 32 && _lastClickLocation != null) { 					var pt = _lastClickLocation.Value; 					int w = (Width / 4).PutInRange(100' 400); 					int h = (Height / 8).PutInRange(50' 200); 					var newShape = new TextBox(new BoundingBox<float>(pt.X - w / 2' pt.Y' pt.X + w / 2' pt.Y + h)) { 						Text = e.KeyChar.ToString()' 						BoxType = BoxType.Borderless' 						TextJustify = LLTextShape.JustifyUpperCenter' 						Style = BoxStyle 					}; 					AddShape(newShape); 				} 			}
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,OnKeyPress,The following statement contains a magic number: if (!e.Handled) { 				// Should we add text to _focusShape or create a new text shape? 				bool ignorePanel = false; 				if (_focusShape != null && _focusShape.IsPanel && string.IsNullOrEmpty(_focusShape.PlainText())) 					ignorePanel = true; 				if (_focusShape != null && !ignorePanel) { 					_focusShape.OnKeyPress(e); 				} else if (e.KeyChar >= 32 && _lastClickLocation != null) { 					var pt = _lastClickLocation.Value; 					int w = (Width / 4).PutInRange(100' 400); 					int h = (Height / 8).PutInRange(50' 200); 					var newShape = new TextBox(new BoundingBox<float>(pt.X - w / 2' pt.Y' pt.X + w / 2' pt.Y + h)) { 						Text = e.KeyChar.ToString()' 						BoxType = BoxType.Borderless' 						TextJustify = LLTextShape.JustifyUpperCenter' 						Style = BoxStyle 					}; 					AddShape(newShape); 				} 			}
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,OnKeyPress,The following statement contains a magic number: if (!e.Handled) { 				// Should we add text to _focusShape or create a new text shape? 				bool ignorePanel = false; 				if (_focusShape != null && _focusShape.IsPanel && string.IsNullOrEmpty(_focusShape.PlainText())) 					ignorePanel = true; 				if (_focusShape != null && !ignorePanel) { 					_focusShape.OnKeyPress(e); 				} else if (e.KeyChar >= 32 && _lastClickLocation != null) { 					var pt = _lastClickLocation.Value; 					int w = (Width / 4).PutInRange(100' 400); 					int h = (Height / 8).PutInRange(50' 200); 					var newShape = new TextBox(new BoundingBox<float>(pt.X - w / 2' pt.Y' pt.X + w / 2' pt.Y + h)) { 						Text = e.KeyChar.ToString()' 						BoxType = BoxType.Borderless' 						TextJustify = LLTextShape.JustifyUpperCenter' 						Style = BoxStyle 					}; 					AddShape(newShape); 				} 			}
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,OnKeyPress,The following statement contains a magic number: if (!e.Handled) { 				// Should we add text to _focusShape or create a new text shape? 				bool ignorePanel = false; 				if (_focusShape != null && _focusShape.IsPanel && string.IsNullOrEmpty(_focusShape.PlainText())) 					ignorePanel = true; 				if (_focusShape != null && !ignorePanel) { 					_focusShape.OnKeyPress(e); 				} else if (e.KeyChar >= 32 && _lastClickLocation != null) { 					var pt = _lastClickLocation.Value; 					int w = (Width / 4).PutInRange(100' 400); 					int h = (Height / 8).PutInRange(50' 200); 					var newShape = new TextBox(new BoundingBox<float>(pt.X - w / 2' pt.Y' pt.X + w / 2' pt.Y + h)) { 						Text = e.KeyChar.ToString()' 						BoxType = BoxType.Borderless' 						TextJustify = LLTextShape.JustifyUpperCenter' 						Style = BoxStyle 					}; 					AddShape(newShape); 				} 			}
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,OnKeyPress,The following statement contains a magic number: if (!e.Handled) { 				// Should we add text to _focusShape or create a new text shape? 				bool ignorePanel = false; 				if (_focusShape != null && _focusShape.IsPanel && string.IsNullOrEmpty(_focusShape.PlainText())) 					ignorePanel = true; 				if (_focusShape != null && !ignorePanel) { 					_focusShape.OnKeyPress(e); 				} else if (e.KeyChar >= 32 && _lastClickLocation != null) { 					var pt = _lastClickLocation.Value; 					int w = (Width / 4).PutInRange(100' 400); 					int h = (Height / 8).PutInRange(50' 200); 					var newShape = new TextBox(new BoundingBox<float>(pt.X - w / 2' pt.Y' pt.X + w / 2' pt.Y + h)) { 						Text = e.KeyChar.ToString()' 						BoxType = BoxType.Borderless' 						TextJustify = LLTextShape.JustifyUpperCenter' 						Style = BoxStyle 					}; 					AddShape(newShape); 				} 			}
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,OnKeyPress,The following statement contains a magic number: if (!e.Handled) { 				// Should we add text to _focusShape or create a new text shape? 				bool ignorePanel = false; 				if (_focusShape != null && _focusShape.IsPanel && string.IsNullOrEmpty(_focusShape.PlainText())) 					ignorePanel = true; 				if (_focusShape != null && !ignorePanel) { 					_focusShape.OnKeyPress(e); 				} else if (e.KeyChar >= 32 && _lastClickLocation != null) { 					var pt = _lastClickLocation.Value; 					int w = (Width / 4).PutInRange(100' 400); 					int h = (Height / 8).PutInRange(50' 200); 					var newShape = new TextBox(new BoundingBox<float>(pt.X - w / 2' pt.Y' pt.X + w / 2' pt.Y + h)) { 						Text = e.KeyChar.ToString()' 						BoxType = BoxType.Borderless' 						TextJustify = LLTextShape.JustifyUpperCenter' 						Style = BoxStyle 					}; 					AddShape(newShape); 				} 			}
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,OnKeyPress,The following statement contains a magic number: if (!e.Handled) { 				// Should we add text to _focusShape or create a new text shape? 				bool ignorePanel = false; 				if (_focusShape != null && _focusShape.IsPanel && string.IsNullOrEmpty(_focusShape.PlainText())) 					ignorePanel = true; 				if (_focusShape != null && !ignorePanel) { 					_focusShape.OnKeyPress(e); 				} else if (e.KeyChar >= 32 && _lastClickLocation != null) { 					var pt = _lastClickLocation.Value; 					int w = (Width / 4).PutInRange(100' 400); 					int h = (Height / 8).PutInRange(50' 200); 					var newShape = new TextBox(new BoundingBox<float>(pt.X - w / 2' pt.Y' pt.X + w / 2' pt.Y + h)) { 						Text = e.KeyChar.ToString()' 						BoxType = BoxType.Borderless' 						TextJustify = LLTextShape.JustifyUpperCenter' 						Style = BoxStyle 					}; 					AddShape(newShape); 				} 			}
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,OnKeyPress,The following statement contains a magic number: if (!e.Handled) { 				// Should we add text to _focusShape or create a new text shape? 				bool ignorePanel = false; 				if (_focusShape != null && _focusShape.IsPanel && string.IsNullOrEmpty(_focusShape.PlainText())) 					ignorePanel = true; 				if (_focusShape != null && !ignorePanel) { 					_focusShape.OnKeyPress(e); 				} else if (e.KeyChar >= 32 && _lastClickLocation != null) { 					var pt = _lastClickLocation.Value; 					int w = (Width / 4).PutInRange(100' 400); 					int h = (Height / 8).PutInRange(50' 200); 					var newShape = new TextBox(new BoundingBox<float>(pt.X - w / 2' pt.Y' pt.X + w / 2' pt.Y + h)) { 						Text = e.KeyChar.ToString()' 						BoxType = BoxType.Borderless' 						TextJustify = LLTextShape.JustifyUpperCenter' 						Style = BoxStyle 					}; 					AddShape(newShape); 				} 			}
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,OnKeyPress,The following statement contains a magic number: if (!e.Handled) { 				// Should we add text to _focusShape or create a new text shape? 				bool ignorePanel = false; 				if (_focusShape != null && _focusShape.IsPanel && string.IsNullOrEmpty(_focusShape.PlainText())) 					ignorePanel = true; 				if (_focusShape != null && !ignorePanel) { 					_focusShape.OnKeyPress(e); 				} else if (e.KeyChar >= 32 && _lastClickLocation != null) { 					var pt = _lastClickLocation.Value; 					int w = (Width / 4).PutInRange(100' 400); 					int h = (Height / 8).PutInRange(50' 200); 					var newShape = new TextBox(new BoundingBox<float>(pt.X - w / 2' pt.Y' pt.X + w / 2' pt.Y + h)) { 						Text = e.KeyChar.ToString()' 						BoxType = BoxType.Borderless' 						TextJustify = LLTextShape.JustifyUpperCenter' 						Style = BoxStyle 					}; 					AddShape(newShape); 				} 			}
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,BeginRemoveAnimation,The following statement contains a magic number: var cancellingTimer = new Timer { Interval = 30' Enabled = true };
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,BeginRemoveAnimation,The following statement contains a magic number: int opacity = 255;
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,BeginRemoveAnimation,The following statement contains a magic number: cancellingTimer.Tick += (s' e) => 			{ 				opacity -= 32; 				if (opacity > 0) 				{ 					foreach (var pair in cancellingShapes) 						pair.A.Opacity = (byte)(pair.B * opacity >> 8); 					cancellingLayer.Invalidate(); 				} 				else 				{ 					DisposeLayerAt(Layers.IndexOf(cancellingLayer)); 					cancellingTimer.Dispose(); 					cancellingLayer.Dispose(); 				} 			};
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,BeginRemoveAnimation,The following statement contains a magic number: cancellingTimer.Tick += (s' e) => 			{ 				opacity -= 32; 				if (opacity > 0) 				{ 					foreach (var pair in cancellingShapes) 						pair.A.Opacity = (byte)(pair.B * opacity >> 8); 					cancellingLayer.Invalidate(); 				} 				else 				{ 					DisposeLayerAt(Layers.IndexOf(cancellingLayer)); 					cancellingTimer.Dispose(); 					cancellingLayer.Dispose(); 				} 			};
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,PageUp,The following statement contains a magic number: if (run) Scroll(new VectorT(0' -Math.Max(ClientSize.Height - OneLineScrollAmt' ClientSize.Height / 2)));
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,PageDown,The following statement contains a magic number: if (run) Scroll(new VectorT(0' Math.Max(ClientSize.Height - OneLineScrollAmt' ClientSize.Height / 2)));
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,ZoomIn,The following statement contains a magic number: if (run) Zoom(256f/181);
Magic Number,BoxDiagrams,DiagramControl,C:\repos\qwertie_Loyc\Baadia\DiagramControl.cs,ZoomOut,The following statement contains a magic number: if (run) Zoom(181/256f);
Magic Number,BoxDiagrams,DiagramDocumentCore,C:\repos\qwertie_Loyc\Baadia\DiagramDocumentCore.cs,GetProtobufModel,The following statement contains a magic number: if (_pbModel == null) { 				_pbModel = TypeModel.Create(); 				_pbModel.AllowParseableTypes=true; 				_pbModel.Add(typeof(Font)' false).SetSurrogate(typeof(ProtoFont)); 				_pbModel.Add(typeof(Color)' false).SetSurrogate(typeof(ProtoColor)); 				_pbModel.Add(typeof(StringFormat)' false).SetSurrogate(typeof(ProtoStringFormat)); 				_pbModel.Add(typeof(Point<float>)' true).Add("X"' "Y"); 				_pbModel.Add(typeof(DrawStyle)' true).AddSubType(100' typeof(DiagramDrawStyle)); 				_pbModel[typeof(BoundingBox<float>)].Add("X1"' "X2"' "Y1"' "Y2"); 				_pbModel[typeof(BoundingBox<float>)].UseConstructor = false; 				Debug.WriteLine(_pbModel.GetSchema(typeof(DiagramDocumentCore))); 			}
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,HandleMouseUp,The following statement contains a magic number: if (!state.IsDrag) 			{ 				if (state.Clicks >= 2) 				{ 					if (Control.SelectedShapes.Count != 0) 					{ 						var htr = state.ClickedShape; 						foreach (var shape in Control.SelectedShapes) 						{ 							DoOrUndo action = shape.DoubleClickAction(htr.Shape == shape ? htr : null); 							if (action != null) 								_doc.UndoStack.Do(action' false); 						} 						_doc.UndoStack.FinishGroup(); 					} 					else 					{ 						// Create marker shape 						newShape = new Marker(Control.BoxStyle' state.FirstPoint' Control.MarkerRadius' Control.MarkerType); 					} 				} 				else 				{ 					Control.ClickSelect(state.ClickedShape != null ? state.ClickedShape.Shape as Shape : null); 					Control._lastClickLocation = state.FirstPoint; 				} 			}
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,ShowEraseDuringDrag,The following statement contains a magic number: DiagramControl.EraseLineStyle.LineColor = Color.FromArgb(128' Control.BackColor);
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,ShowEraseDuringDrag,The following statement contains a magic number: if (cancel) 			{ 				eraseLine.Style = Control.LineStyle; 				Control.BeginRemoveAnimation(adorners); 				adorners.Clear(); 				state.IsComplete = true; 			} 			else 			{ 				// Show which shapes are erased by drawing them in the background color 				foreach (Shape s in eraseSet) 				{ 					Shape s_ = s.Clone(); 					s_.Style = (DiagramDrawStyle)s.Style.Clone(); 					s_.Style.FillColor = s_.Style.LineColor = s_.Style.TextColor = Color.FromArgb(192' Control.BackColor); 					// avoid an outline artifact' in which color from the edges of the  					// original shape bleeds through by a variable amount that depends  					// on subpixel offsets. 					s_.Style.LineWidth++; 					s_.AddLLShapesTo(adorners); 				} 			}
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,AngleMod8,The following statement contains a magic number: return (int)Math.Round(v.Angle() * (4 / Math.PI)) & 7;
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,AngleMod8,The following statement contains a magic number: return (int)Math.Round(v.Angle() * (4 / Math.PI)) & 7;
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,RecognizeBoxOrLines,The following statement contains a magic number: EliminateTinySections(sections1' 10);
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,RecognizeBoxOrLines,The following statement contains a magic number: EliminateTinySections(sections2' 10 + (int)(sections1.Sum(s => s.LengthPx) * 0.05));
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,RecognizeBoxOrLines,The following statement contains a magic number: EliminateTinySections(sections2' 10 + (int)(sections1.Sum(s => s.LengthPx) * 0.05));
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,TurnBetween,The following statement contains a magic number: return (b.AngleMod8 - a.AngleMod8) & 7;
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,TryInterpretAsBox,The following statement contains a magic number: int minSides = oneSideAnchored ? 4 : 2;
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,TryInterpretAsBox,The following statement contains a magic number: int minSides = oneSideAnchored ? 4 : 2;
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,TryInterpretAsBox,The following statement contains a magic number: if (sections.Count >= minSides && sections.Count <= 5) 			{ 				int turn = TurnBetween(sections[0]' sections[1]); 				if ((sections[0].AngleMod8 & 1) == 0 && (turn == 2 || turn == 6)) 				{ 					for (int i = 1; i < sections.Count; i++) 						if (TurnBetween(sections[i - 1]' sections[i]) != turn) 							return null;  					VectorT dif; 					if (sections.Count == 2) 						potentialSelection = (dif = sections[1].EndSS.Sub(sections[0].StartSS)).X > 0 && dif.Y > 0; 					if (sections.Count > 2 || potentialSelection) 					{ 						var tolerance = Control.InputTransform.Transform(new VectorT(20' 20)).Abs(); 						var extents = sections.Take(3).Select(s => s.StartSS.To(s.EndSS).ToBoundingBox()).Union(); 						if (sections.Count < 4 || extents.Inflated(tolerance.X' tolerance.Y).Contains(sections[3].EndSS)) 						{ 							// Confirmed' we can interpret as a box 							return new TextBox(extents) { Style = Control.BoxStyle }; 						} 					} 				} 			}
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,TryInterpretAsBox,The following statement contains a magic number: if (sections.Count >= minSides && sections.Count <= 5) 			{ 				int turn = TurnBetween(sections[0]' sections[1]); 				if ((sections[0].AngleMod8 & 1) == 0 && (turn == 2 || turn == 6)) 				{ 					for (int i = 1; i < sections.Count; i++) 						if (TurnBetween(sections[i - 1]' sections[i]) != turn) 							return null;  					VectorT dif; 					if (sections.Count == 2) 						potentialSelection = (dif = sections[1].EndSS.Sub(sections[0].StartSS)).X > 0 && dif.Y > 0; 					if (sections.Count > 2 || potentialSelection) 					{ 						var tolerance = Control.InputTransform.Transform(new VectorT(20' 20)).Abs(); 						var extents = sections.Take(3).Select(s => s.StartSS.To(s.EndSS).ToBoundingBox()).Union(); 						if (sections.Count < 4 || extents.Inflated(tolerance.X' tolerance.Y).Contains(sections[3].EndSS)) 						{ 							// Confirmed' we can interpret as a box 							return new TextBox(extents) { Style = Control.BoxStyle }; 						} 					} 				} 			}
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,TryInterpretAsBox,The following statement contains a magic number: if (sections.Count >= minSides && sections.Count <= 5) 			{ 				int turn = TurnBetween(sections[0]' sections[1]); 				if ((sections[0].AngleMod8 & 1) == 0 && (turn == 2 || turn == 6)) 				{ 					for (int i = 1; i < sections.Count; i++) 						if (TurnBetween(sections[i - 1]' sections[i]) != turn) 							return null;  					VectorT dif; 					if (sections.Count == 2) 						potentialSelection = (dif = sections[1].EndSS.Sub(sections[0].StartSS)).X > 0 && dif.Y > 0; 					if (sections.Count > 2 || potentialSelection) 					{ 						var tolerance = Control.InputTransform.Transform(new VectorT(20' 20)).Abs(); 						var extents = sections.Take(3).Select(s => s.StartSS.To(s.EndSS).ToBoundingBox()).Union(); 						if (sections.Count < 4 || extents.Inflated(tolerance.X' tolerance.Y).Contains(sections[3].EndSS)) 						{ 							// Confirmed' we can interpret as a box 							return new TextBox(extents) { Style = Control.BoxStyle }; 						} 					} 				} 			}
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,TryInterpretAsBox,The following statement contains a magic number: if (sections.Count >= minSides && sections.Count <= 5) 			{ 				int turn = TurnBetween(sections[0]' sections[1]); 				if ((sections[0].AngleMod8 & 1) == 0 && (turn == 2 || turn == 6)) 				{ 					for (int i = 1; i < sections.Count; i++) 						if (TurnBetween(sections[i - 1]' sections[i]) != turn) 							return null;  					VectorT dif; 					if (sections.Count == 2) 						potentialSelection = (dif = sections[1].EndSS.Sub(sections[0].StartSS)).X > 0 && dif.Y > 0; 					if (sections.Count > 2 || potentialSelection) 					{ 						var tolerance = Control.InputTransform.Transform(new VectorT(20' 20)).Abs(); 						var extents = sections.Take(3).Select(s => s.StartSS.To(s.EndSS).ToBoundingBox()).Union(); 						if (sections.Count < 4 || extents.Inflated(tolerance.X' tolerance.Y).Contains(sections[3].EndSS)) 						{ 							// Confirmed' we can interpret as a box 							return new TextBox(extents) { Style = Control.BoxStyle }; 						} 					} 				} 			}
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,TryInterpretAsBox,The following statement contains a magic number: if (sections.Count >= minSides && sections.Count <= 5) 			{ 				int turn = TurnBetween(sections[0]' sections[1]); 				if ((sections[0].AngleMod8 & 1) == 0 && (turn == 2 || turn == 6)) 				{ 					for (int i = 1; i < sections.Count; i++) 						if (TurnBetween(sections[i - 1]' sections[i]) != turn) 							return null;  					VectorT dif; 					if (sections.Count == 2) 						potentialSelection = (dif = sections[1].EndSS.Sub(sections[0].StartSS)).X > 0 && dif.Y > 0; 					if (sections.Count > 2 || potentialSelection) 					{ 						var tolerance = Control.InputTransform.Transform(new VectorT(20' 20)).Abs(); 						var extents = sections.Take(3).Select(s => s.StartSS.To(s.EndSS).ToBoundingBox()).Union(); 						if (sections.Count < 4 || extents.Inflated(tolerance.X' tolerance.Y).Contains(sections[3].EndSS)) 						{ 							// Confirmed' we can interpret as a box 							return new TextBox(extents) { Style = Control.BoxStyle }; 						} 					} 				} 			}
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,TryInterpretAsBox,The following statement contains a magic number: if (sections.Count >= minSides && sections.Count <= 5) 			{ 				int turn = TurnBetween(sections[0]' sections[1]); 				if ((sections[0].AngleMod8 & 1) == 0 && (turn == 2 || turn == 6)) 				{ 					for (int i = 1; i < sections.Count; i++) 						if (TurnBetween(sections[i - 1]' sections[i]) != turn) 							return null;  					VectorT dif; 					if (sections.Count == 2) 						potentialSelection = (dif = sections[1].EndSS.Sub(sections[0].StartSS)).X > 0 && dif.Y > 0; 					if (sections.Count > 2 || potentialSelection) 					{ 						var tolerance = Control.InputTransform.Transform(new VectorT(20' 20)).Abs(); 						var extents = sections.Take(3).Select(s => s.StartSS.To(s.EndSS).ToBoundingBox()).Union(); 						if (sections.Count < 4 || extents.Inflated(tolerance.X' tolerance.Y).Contains(sections[3].EndSS)) 						{ 							// Confirmed' we can interpret as a box 							return new TextBox(extents) { Style = Control.BoxStyle }; 						} 					} 				} 			}
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,TryInterpretAsBox,The following statement contains a magic number: if (sections.Count >= minSides && sections.Count <= 5) 			{ 				int turn = TurnBetween(sections[0]' sections[1]); 				if ((sections[0].AngleMod8 & 1) == 0 && (turn == 2 || turn == 6)) 				{ 					for (int i = 1; i < sections.Count; i++) 						if (TurnBetween(sections[i - 1]' sections[i]) != turn) 							return null;  					VectorT dif; 					if (sections.Count == 2) 						potentialSelection = (dif = sections[1].EndSS.Sub(sections[0].StartSS)).X > 0 && dif.Y > 0; 					if (sections.Count > 2 || potentialSelection) 					{ 						var tolerance = Control.InputTransform.Transform(new VectorT(20' 20)).Abs(); 						var extents = sections.Take(3).Select(s => s.StartSS.To(s.EndSS).ToBoundingBox()).Union(); 						if (sections.Count < 4 || extents.Inflated(tolerance.X' tolerance.Y).Contains(sections[3].EndSS)) 						{ 							// Confirmed' we can interpret as a box 							return new TextBox(extents) { Style = Control.BoxStyle }; 						} 					} 				} 			}
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,TryInterpretAsBox,The following statement contains a magic number: if (sections.Count >= minSides && sections.Count <= 5) 			{ 				int turn = TurnBetween(sections[0]' sections[1]); 				if ((sections[0].AngleMod8 & 1) == 0 && (turn == 2 || turn == 6)) 				{ 					for (int i = 1; i < sections.Count; i++) 						if (TurnBetween(sections[i - 1]' sections[i]) != turn) 							return null;  					VectorT dif; 					if (sections.Count == 2) 						potentialSelection = (dif = sections[1].EndSS.Sub(sections[0].StartSS)).X > 0 && dif.Y > 0; 					if (sections.Count > 2 || potentialSelection) 					{ 						var tolerance = Control.InputTransform.Transform(new VectorT(20' 20)).Abs(); 						var extents = sections.Take(3).Select(s => s.StartSS.To(s.EndSS).ToBoundingBox()).Union(); 						if (sections.Count < 4 || extents.Inflated(tolerance.X' tolerance.Y).Contains(sections[3].EndSS)) 						{ 							// Confirmed' we can interpret as a box 							return new TextBox(extents) { Style = Control.BoxStyle }; 						} 					} 				} 			}
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,TryInterpretAsBox,The following statement contains a magic number: if (sections.Count >= minSides && sections.Count <= 5) 			{ 				int turn = TurnBetween(sections[0]' sections[1]); 				if ((sections[0].AngleMod8 & 1) == 0 && (turn == 2 || turn == 6)) 				{ 					for (int i = 1; i < sections.Count; i++) 						if (TurnBetween(sections[i - 1]' sections[i]) != turn) 							return null;  					VectorT dif; 					if (sections.Count == 2) 						potentialSelection = (dif = sections[1].EndSS.Sub(sections[0].StartSS)).X > 0 && dif.Y > 0; 					if (sections.Count > 2 || potentialSelection) 					{ 						var tolerance = Control.InputTransform.Transform(new VectorT(20' 20)).Abs(); 						var extents = sections.Take(3).Select(s => s.StartSS.To(s.EndSS).ToBoundingBox()).Union(); 						if (sections.Count < 4 || extents.Inflated(tolerance.X' tolerance.Y).Contains(sections[3].EndSS)) 						{ 							// Confirmed' we can interpret as a box 							return new TextBox(extents) { Style = Control.BoxStyle }; 						} 					} 				} 			}
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,TryInterpretAsBox,The following statement contains a magic number: if (sections.Count >= minSides && sections.Count <= 5) 			{ 				int turn = TurnBetween(sections[0]' sections[1]); 				if ((sections[0].AngleMod8 & 1) == 0 && (turn == 2 || turn == 6)) 				{ 					for (int i = 1; i < sections.Count; i++) 						if (TurnBetween(sections[i - 1]' sections[i]) != turn) 							return null;  					VectorT dif; 					if (sections.Count == 2) 						potentialSelection = (dif = sections[1].EndSS.Sub(sections[0].StartSS)).X > 0 && dif.Y > 0; 					if (sections.Count > 2 || potentialSelection) 					{ 						var tolerance = Control.InputTransform.Transform(new VectorT(20' 20)).Abs(); 						var extents = sections.Take(3).Select(s => s.StartSS.To(s.EndSS).ToBoundingBox()).Union(); 						if (sections.Count < 4 || extents.Inflated(tolerance.X' tolerance.Y).Contains(sections[3].EndSS)) 						{ 							// Confirmed' we can interpret as a box 							return new TextBox(extents) { Style = Control.BoxStyle }; 						} 					} 				} 			}
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,InterpretAsPolyline,The following statement contains a magic number: for (int i = 0; i < sections.Count; i++) 			{ 				int angleMod8 = sections[i].AngleMod8; 				var startSS = sections[i].StartSS; 				var endSS = sections[i].EndSS;  				Vector<float> vector = Mod8Vectors[angleMod8]; 				Vector<float> perpVector = vector.Rot90();  				bool isStartLine = i == 0; 				bool isEndLine = i == sections.Count - 1; 				if (isStartLine) 				{ 					if (shape.FromAnchor != null) 						startSS = shape.FromAnchor.Point; 				} 				if (isEndLine) 				{ 					if ((shape.ToAnchor = Control.GetBestAnchor(endSS' angleMod8 + 4)) != null) 						endSS = shape.ToAnchor.Point; 					// Also consider forming a closed shape 					else if (shape.Points.Count > 1 						&& shape.Points[0].Sub(endSS).Length() <= DiagramControl.AnchorSnapDistance 						&& Math.Abs(vector.Cross(shape.Points[1].Sub(shape.Points[0]))) > 0.001f) 						endSS = shape.Points[0]; 				}  				if (isStartLine) 					curLine = startSS.To(startSS.Add(vector)); 				else 				{ 					curLine = endSS.Sub(vector).To(endSS); 					PointT? itsc = prevLine.ComputeIntersection(curLine' LineType.Infinite); 					if (itsc.HasValue) 						startSS = itsc.Value; 				}  				shape.Points.Add(startSS);  				if (isEndLine) 				{ 					if (isStartLine) 					{ 						Debug.Assert(shape.Points.Count == 1); 						var adjustedStart = startSS.ProjectOntoInfiniteLine(endSS.Sub(vector).To(endSS)); 						var adjustedEnd = endSS.ProjectOntoInfiniteLine(curLine); 						if (shape.FromAnchor != null) 						{ 							if (shape.ToAnchor != null) 							{ 								// Both ends anchored => do nothing' allow unusual angle 							} 							else 							{ 								// Adjust endpoint to maintain angle 								endSS = adjustedEnd; 							} 						} 						else 						{ 							if (shape.ToAnchor != null) 								// End anchored only => alter start point 								shape.Points[0] = adjustedStart; 							else 							{ 								// Neither end anchored => use average line 								shape.Points[0] = startSS.To(adjustedStart).Midpoint(); 								endSS = endSS.To(adjustedEnd).Midpoint(); 							} 						} 					} 					shape.Points.Add(endSS); 				} 				prevLine = curLine; 			}
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,AngleError,The following statement contains a magic number: double dif = vec.Angle() - angleMod8 * (Math.PI / 4);
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,AngleError,The following statement contains a magic number: dif = MathEx.Mod(dif' 2 * Math.PI);
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,AngleError,The following statement contains a magic number: if (dif > Math.PI) 				dif = 2 * Math.PI - dif;
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,RecognizeScribbleForEraseOrCancel,The following statement contains a magic number: var tolerance = state._inputTransform.Transform(new VectorT(0' 10)).Length();
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,RecognizeScribbleForEraseOrCancel,The following statement contains a magic number: List<int> reversals = FindReversals(simplifiedMP' 3);
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,RecognizeScribbleForEraseOrCancel,The following statement contains a magic number: if (reversals.Count >= 3) 			{ 				simplifiedSS = simplifiedMP.Select(p => state._inputTransform.Transform(p)).ToList(); 				// 3 reversals confirmed. Now decide: erase or cancel? 				int[] timeStampsMs = FindTimeStamps(state.UnfilteredMousePoints' simplifiedMP); 				int t0 = timeStampsMs[reversals[0]]' t1 = timeStampsMs[reversals[2]] - t0; 				cancel = t0 > t1 + 500;  				// Now test the formula LL*c > CHA as explained above 				IListSource<PointT> simplifiedMP_ = cancel ? simplifiedMP.Slice(reversals[0]) : simplifiedMP.AsListSource(); 				float LL = simplifiedMP_.AdjacentPairs().Sum(pair => pair.A.Sub(pair.B).Length()); 				var hull = PointMath.ComputeConvexHull(simplifiedMP); 				float CHA = PolygonMath.PolygonArea(hull); 				if (LL * EraseNubWidth > CHA) 				{ 					// Erasure confirmed. 					if (cancel) 						return EmptyList<Shape>.Value;  					// Figure out which shapes to erase. To do this' we compute for  					// each shape the amount of the scribble that overlaps that shape. 					var simplifiedSS_ = simplifiedSS; 					return _doc.Shapes.Where(s => ShouldErase(s' simplifiedSS_)).ToList(); 				} 			}
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,RecognizeScribbleForEraseOrCancel,The following statement contains a magic number: if (reversals.Count >= 3) 			{ 				simplifiedSS = simplifiedMP.Select(p => state._inputTransform.Transform(p)).ToList(); 				// 3 reversals confirmed. Now decide: erase or cancel? 				int[] timeStampsMs = FindTimeStamps(state.UnfilteredMousePoints' simplifiedMP); 				int t0 = timeStampsMs[reversals[0]]' t1 = timeStampsMs[reversals[2]] - t0; 				cancel = t0 > t1 + 500;  				// Now test the formula LL*c > CHA as explained above 				IListSource<PointT> simplifiedMP_ = cancel ? simplifiedMP.Slice(reversals[0]) : simplifiedMP.AsListSource(); 				float LL = simplifiedMP_.AdjacentPairs().Sum(pair => pair.A.Sub(pair.B).Length()); 				var hull = PointMath.ComputeConvexHull(simplifiedMP); 				float CHA = PolygonMath.PolygonArea(hull); 				if (LL * EraseNubWidth > CHA) 				{ 					// Erasure confirmed. 					if (cancel) 						return EmptyList<Shape>.Value;  					// Figure out which shapes to erase. To do this' we compute for  					// each shape the amount of the scribble that overlaps that shape. 					var simplifiedSS_ = simplifiedSS; 					return _doc.Shapes.Where(s => ShouldErase(s' simplifiedSS_)).ToList(); 				} 			}
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,RecognizeScribbleForEraseOrCancel,The following statement contains a magic number: if (reversals.Count >= 3) 			{ 				simplifiedSS = simplifiedMP.Select(p => state._inputTransform.Transform(p)).ToList(); 				// 3 reversals confirmed. Now decide: erase or cancel? 				int[] timeStampsMs = FindTimeStamps(state.UnfilteredMousePoints' simplifiedMP); 				int t0 = timeStampsMs[reversals[0]]' t1 = timeStampsMs[reversals[2]] - t0; 				cancel = t0 > t1 + 500;  				// Now test the formula LL*c > CHA as explained above 				IListSource<PointT> simplifiedMP_ = cancel ? simplifiedMP.Slice(reversals[0]) : simplifiedMP.AsListSource(); 				float LL = simplifiedMP_.AdjacentPairs().Sum(pair => pair.A.Sub(pair.B).Length()); 				var hull = PointMath.ComputeConvexHull(simplifiedMP); 				float CHA = PolygonMath.PolygonArea(hull); 				if (LL * EraseNubWidth > CHA) 				{ 					// Erasure confirmed. 					if (cancel) 						return EmptyList<Shape>.Value;  					// Figure out which shapes to erase. To do this' we compute for  					// each shape the amount of the scribble that overlaps that shape. 					var simplifiedSS_ = simplifiedSS; 					return _doc.Shapes.Where(s => ShouldErase(s' simplifiedSS_)).ToList(); 				} 			}
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,FindReversals,The following statement contains a magic number: for (int i = 1' c = points.Count; i < c - 1; i++) 			{ 				PointT p0 = points[i - 1]' p1 = points[i]' p2 = points[i + 1]; 				VectorT v1 = p1.Sub(p0)' v2 = p2.Sub(p1); 				if (v1.Dot(v2) < 0 && MathEx.Mod(v1.AngleDeg() - v2.AngleDeg()' 360).IsInRange(150' 210)) 				{ 					reversals.Add(i); 					if (reversals.Count >= stopAfter) 						break; 				} 			}
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,FindReversals,The following statement contains a magic number: for (int i = 1' c = points.Count; i < c - 1; i++) 			{ 				PointT p0 = points[i - 1]' p1 = points[i]' p2 = points[i + 1]; 				VectorT v1 = p1.Sub(p0)' v2 = p2.Sub(p1); 				if (v1.Dot(v2) < 0 && MathEx.Mod(v1.AngleDeg() - v2.AngleDeg()' 360).IsInRange(150' 210)) 				{ 					reversals.Add(i); 					if (reversals.Count >= stopAfter) 						break; 				} 			}
Magic Number,BoxDiagrams,DiagramGestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\DiagramGestureAnalyzer.cs,FindReversals,The following statement contains a magic number: for (int i = 1' c = points.Count; i < c - 1; i++) 			{ 				PointT p0 = points[i - 1]' p1 = points[i]' p2 = points[i + 1]; 				VectorT v1 = p1.Sub(p0)' v2 = p2.Sub(p1); 				if (v1.Dot(v2) < 0 && MathEx.Mod(v1.AngleDeg() - v2.AngleDeg()' 360).IsInRange(150' 210)) 				{ 					reversals.Add(i); 					if (reversals.Count >= stopAfter) 						break; 				} 			}
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(278' 6);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(278' 6);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(35' 13);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(35' 13);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.TabIndex = 3;
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._cbLineStyle.Location = new System.Drawing.Point(319' 2);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._cbLineStyle.Location = new System.Drawing.Point(319' 2);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._cbLineStyle.Size = new System.Drawing.Size(95' 21);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._cbLineStyle.Size = new System.Drawing.Size(95' 21);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._cbLineStyle.TabIndex = 4;
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(89' 6);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(89' 6);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(82' 13);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(82' 13);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._btnZoomIn.Location = new System.Drawing.Point(488' 1);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._btnZoomIn.Size = new System.Drawing.Size(38' 28);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._btnZoomIn.Size = new System.Drawing.Size(38' 28);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._btnZoomIn.TabIndex = 6;
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._btnZoomOut.Location = new System.Drawing.Point(527' 1);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._btnZoomOut.Size = new System.Drawing.Size(38' 28);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._btnZoomOut.Size = new System.Drawing.Size(38' 28);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._btnZoomOut.TabIndex = 7;
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size(84' 24);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.Size = new System.Drawing.Size(84' 24);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuStrip1.TabIndex = 7;
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.fileToolStripMenuItem.Size = new System.Drawing.Size(37' 20);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.fileToolStripMenuItem.Size = new System.Drawing.Size(37' 20);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuNew.Size = new System.Drawing.Size(155' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuNew.Size = new System.Drawing.Size(155' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuOpen.Size = new System.Drawing.Size(155' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuOpen.Size = new System.Drawing.Size(155' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuSave.Size = new System.Drawing.Size(155' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuSave.Size = new System.Drawing.Size(155' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuSaveAs.Size = new System.Drawing.Size(155' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuSaveAs.Size = new System.Drawing.Size(155' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator1.Size = new System.Drawing.Size(152' 6);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator1.Size = new System.Drawing.Size(152' 6);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuExit.Size = new System.Drawing.Size(155' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuExit.Size = new System.Drawing.Size(155' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.editToolStripMenuItem.Size = new System.Drawing.Size(39' 20);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.editToolStripMenuItem.Size = new System.Drawing.Size(39' 20);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuCut.Size = new System.Drawing.Size(177' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuCut.Size = new System.Drawing.Size(177' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuCopy.Size = new System.Drawing.Size(177' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuCopy.Size = new System.Drawing.Size(177' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuPaste.Size = new System.Drawing.Size(177' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuPaste.Size = new System.Drawing.Size(177' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuDelete.Size = new System.Drawing.Size(177' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuDelete.Size = new System.Drawing.Size(177' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator3.Size = new System.Drawing.Size(174' 6);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator3.Size = new System.Drawing.Size(174' 6);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuDuplicate.Size = new System.Drawing.Size(177' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuDuplicate.Size = new System.Drawing.Size(177' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuClearText.Size = new System.Drawing.Size(177' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuClearText.Size = new System.Drawing.Size(177' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator2.Size = new System.Drawing.Size(174' 6);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator2.Size = new System.Drawing.Size(174' 6);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuSelectAll.Size = new System.Drawing.Size(177' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.menuSelectAll.Size = new System.Drawing.Size(177' 22);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.customComboBox1.Location = new System.Drawing.Point(177' 3);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.customComboBox1.Location = new System.Drawing.Point(177' 3);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.customComboBox1.Size = new System.Drawing.Size(95' 21);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.customComboBox1.Size = new System.Drawing.Size(95' 21);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.customComboBox1.TabIndex = 2;
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._diagramCtrl.Location = new System.Drawing.Point(0' 29);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._diagramCtrl.Size = new System.Drawing.Size(581' 286);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._diagramCtrl.Size = new System.Drawing.Size(581' 286);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._arrowheadCtrl.Location = new System.Drawing.Point(420' 3);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._arrowheadCtrl.Location = new System.Drawing.Point(420' 3);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._arrowheadCtrl.Size = new System.Drawing.Size(62' 24);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._arrowheadCtrl.Size = new System.Drawing.Size(62' 24);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this._arrowheadCtrl.TabIndex = 5;
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(581' 315);
Magic Number,BoxDiagrams,MainForm,C:\repos\qwertie_Loyc\Baadia\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(581' 315);
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AddLLShapesTo,The following statement contains a magic number: if (Points.Count >= 2) { 				// Add arrows 				LineSegment<float> firstLine = Points[1].To(Points[0]); 				LineSegment<float> lastLine = Points[Points.Count - 2].To(Points[Points.Count - 1]); 				if (FromArrow != null) { 					var arrow = FromArrow.LLShape(Style' ref firstLine); 					arrow.ZOrder = z; 					list.Add(arrow); 				} 				if (ToArrow != null) { 					var arrow = ToArrow.LLShape(Style' ref lastLine); 					arrow.ZOrder = z; 					list.Add(arrow); 				}  				// Adjust endpoints if necessary to subtract space used by the arrows 				List<PointT> points = Points; 				if (firstLine.B != Points[0] || lastLine.B != Points[Points.Count - 1]) { 					points = new List<PointT>(points); 					points[0] = firstLine.B; 					points[points.Count-1] = lastLine.B; 				}  				// Add main line 				list.Add(new LLPolyline(Style' points) { ZOrder = z });  				// Hacky temporary solution for text 				int half = (Points.Count - 1) / 2; 				var midVec = Points[half + 1].Sub(Points[half]); 				if (TextTopLeft.Text != null) { 					list.Add(new LLTextShape( 						Style' TextTopLeft.Text' LLTextShape.JustifyUpperCenter' Points[half]' new VectorT(midVec.Length()' 100)) { AngleDeg = (float)midVec.AngleDeg() }); 				} 			}
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AddLLShapesTo,The following statement contains a magic number: if (Points.Count >= 2) { 				// Add arrows 				LineSegment<float> firstLine = Points[1].To(Points[0]); 				LineSegment<float> lastLine = Points[Points.Count - 2].To(Points[Points.Count - 1]); 				if (FromArrow != null) { 					var arrow = FromArrow.LLShape(Style' ref firstLine); 					arrow.ZOrder = z; 					list.Add(arrow); 				} 				if (ToArrow != null) { 					var arrow = ToArrow.LLShape(Style' ref lastLine); 					arrow.ZOrder = z; 					list.Add(arrow); 				}  				// Adjust endpoints if necessary to subtract space used by the arrows 				List<PointT> points = Points; 				if (firstLine.B != Points[0] || lastLine.B != Points[Points.Count - 1]) { 					points = new List<PointT>(points); 					points[0] = firstLine.B; 					points[points.Count-1] = lastLine.B; 				}  				// Add main line 				list.Add(new LLPolyline(Style' points) { ZOrder = z });  				// Hacky temporary solution for text 				int half = (Points.Count - 1) / 2; 				var midVec = Points[half + 1].Sub(Points[half]); 				if (TextTopLeft.Text != null) { 					list.Add(new LLTextShape( 						Style' TextTopLeft.Text' LLTextShape.JustifyUpperCenter' Points[half]' new VectorT(midVec.Length()' 100)) { AngleDeg = (float)midVec.AngleDeg() }); 				} 			}
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AddLLShapesTo,The following statement contains a magic number: if (Points.Count >= 2) { 				// Add arrows 				LineSegment<float> firstLine = Points[1].To(Points[0]); 				LineSegment<float> lastLine = Points[Points.Count - 2].To(Points[Points.Count - 1]); 				if (FromArrow != null) { 					var arrow = FromArrow.LLShape(Style' ref firstLine); 					arrow.ZOrder = z; 					list.Add(arrow); 				} 				if (ToArrow != null) { 					var arrow = ToArrow.LLShape(Style' ref lastLine); 					arrow.ZOrder = z; 					list.Add(arrow); 				}  				// Adjust endpoints if necessary to subtract space used by the arrows 				List<PointT> points = Points; 				if (firstLine.B != Points[0] || lastLine.B != Points[Points.Count - 1]) { 					points = new List<PointT>(points); 					points[0] = firstLine.B; 					points[points.Count-1] = lastLine.B; 				}  				// Add main line 				list.Add(new LLPolyline(Style' points) { ZOrder = z });  				// Hacky temporary solution for text 				int half = (Points.Count - 1) / 2; 				var midVec = Points[half + 1].Sub(Points[half]); 				if (TextTopLeft.Text != null) { 					list.Add(new LLTextShape( 						Style' TextTopLeft.Text' LLTextShape.JustifyUpperCenter' Points[half]' new VectorT(midVec.Length()' 100)) { AngleDeg = (float)midVec.AngleDeg() }); 				} 			}
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AddLLShapesTo,The following statement contains a magic number: if (Points.Count >= 2) { 				// Add arrows 				LineSegment<float> firstLine = Points[1].To(Points[0]); 				LineSegment<float> lastLine = Points[Points.Count - 2].To(Points[Points.Count - 1]); 				if (FromArrow != null) { 					var arrow = FromArrow.LLShape(Style' ref firstLine); 					arrow.ZOrder = z; 					list.Add(arrow); 				} 				if (ToArrow != null) { 					var arrow = ToArrow.LLShape(Style' ref lastLine); 					arrow.ZOrder = z; 					list.Add(arrow); 				}  				// Adjust endpoints if necessary to subtract space used by the arrows 				List<PointT> points = Points; 				if (firstLine.B != Points[0] || lastLine.B != Points[Points.Count - 1]) { 					points = new List<PointT>(points); 					points[0] = firstLine.B; 					points[points.Count-1] = lastLine.B; 				}  				// Add main line 				list.Add(new LLPolyline(Style' points) { ZOrder = z });  				// Hacky temporary solution for text 				int half = (Points.Count - 1) / 2; 				var midVec = Points[half + 1].Sub(Points[half]); 				if (TextTopLeft.Text != null) { 					list.Add(new LLTextShape( 						Style' TextTopLeft.Text' LLTextShape.JustifyUpperCenter' Points[half]' new VectorT(midVec.Length()' 100)) { AngleDeg = (float)midVec.AngleDeg() }); 				} 			}
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AngleMod256,The following statement contains a magic number: return (byte)(v.Angle() * (128.0 / Math.PI));
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AutoHandleAnchorsChanged,The following statement contains a magic number: Debug.Assert(Points.Count >= 2);
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AttachedAnchorChanged,The following statement contains a magic number: return @do => 			{ 				IList<PointT> points = Points; 				if (toSide) points = points.Reverse(); 				 				Debug.Assert(points.Count >= 2); 				if (points.Count < 2) 					return;  				_bbox = null; 				if (@do) { 					// save undo info in either (p0' p1) or (old) for complicated cases 					p0 = points[0]; 					p1 = points[1]; 					old = new List<PointT>(Points); 					 					var newAnchor = anchor.Point; 					LineSegment<float> one = newAnchor.To(newAnchor.Add(points[1].Sub(points[0])))' two; 					if (points.Count > 2) 						two = points[1].To(points[2]); 					else 						two = one.B.To(one.B.Add(one.B.Sub(one.A).Rot90())); // fake it  					points[0] = newAnchor; 					PointT? itsc = one.ComputeIntersection(two' LineType.Infinite)' itsc2; 					if (itsc != null && !(points.Count == 2 && (toSide ? _fromAnchor : _toAnchor) != null)) 						points[1] = itsc.Value; 					else 						itsc = points[1];  					if (points.Count >= 3 && points[1] == points[2]) { 						int remove = 1; 						if (points.Count > 3) { 							int a0 = AngleMod256(points[1].Sub(points[0]))' a1 = AngleMod256(points[3].Sub(points[2])); 							if ((a0 & 127) == (a1 & 127)) 								remove = 2; 						} 						points.RemoveRange(1' remove); 					} else if (points.Count >= 4 && (itsc2 = points[0].To(points[1]).ComputeIntersection(points[2].To(points[3]))) != null) { 						points.RemoveRange(1' 2); 						points.Insert(1' itsc2.Value); 					} else 						old = null; // save memory 				} else { 					if (old != null) 						Points = old; 					else { 						points[0] = p0; 						points[1] = p1; 					} 				} 			};
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AttachedAnchorChanged,The following statement contains a magic number: return @do => 			{ 				IList<PointT> points = Points; 				if (toSide) points = points.Reverse(); 				 				Debug.Assert(points.Count >= 2); 				if (points.Count < 2) 					return;  				_bbox = null; 				if (@do) { 					// save undo info in either (p0' p1) or (old) for complicated cases 					p0 = points[0]; 					p1 = points[1]; 					old = new List<PointT>(Points); 					 					var newAnchor = anchor.Point; 					LineSegment<float> one = newAnchor.To(newAnchor.Add(points[1].Sub(points[0])))' two; 					if (points.Count > 2) 						two = points[1].To(points[2]); 					else 						two = one.B.To(one.B.Add(one.B.Sub(one.A).Rot90())); // fake it  					points[0] = newAnchor; 					PointT? itsc = one.ComputeIntersection(two' LineType.Infinite)' itsc2; 					if (itsc != null && !(points.Count == 2 && (toSide ? _fromAnchor : _toAnchor) != null)) 						points[1] = itsc.Value; 					else 						itsc = points[1];  					if (points.Count >= 3 && points[1] == points[2]) { 						int remove = 1; 						if (points.Count > 3) { 							int a0 = AngleMod256(points[1].Sub(points[0]))' a1 = AngleMod256(points[3].Sub(points[2])); 							if ((a0 & 127) == (a1 & 127)) 								remove = 2; 						} 						points.RemoveRange(1' remove); 					} else if (points.Count >= 4 && (itsc2 = points[0].To(points[1]).ComputeIntersection(points[2].To(points[3]))) != null) { 						points.RemoveRange(1' 2); 						points.Insert(1' itsc2.Value); 					} else 						old = null; // save memory 				} else { 					if (old != null) 						Points = old; 					else { 						points[0] = p0; 						points[1] = p1; 					} 				} 			};
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AttachedAnchorChanged,The following statement contains a magic number: return @do => 			{ 				IList<PointT> points = Points; 				if (toSide) points = points.Reverse(); 				 				Debug.Assert(points.Count >= 2); 				if (points.Count < 2) 					return;  				_bbox = null; 				if (@do) { 					// save undo info in either (p0' p1) or (old) for complicated cases 					p0 = points[0]; 					p1 = points[1]; 					old = new List<PointT>(Points); 					 					var newAnchor = anchor.Point; 					LineSegment<float> one = newAnchor.To(newAnchor.Add(points[1].Sub(points[0])))' two; 					if (points.Count > 2) 						two = points[1].To(points[2]); 					else 						two = one.B.To(one.B.Add(one.B.Sub(one.A).Rot90())); // fake it  					points[0] = newAnchor; 					PointT? itsc = one.ComputeIntersection(two' LineType.Infinite)' itsc2; 					if (itsc != null && !(points.Count == 2 && (toSide ? _fromAnchor : _toAnchor) != null)) 						points[1] = itsc.Value; 					else 						itsc = points[1];  					if (points.Count >= 3 && points[1] == points[2]) { 						int remove = 1; 						if (points.Count > 3) { 							int a0 = AngleMod256(points[1].Sub(points[0]))' a1 = AngleMod256(points[3].Sub(points[2])); 							if ((a0 & 127) == (a1 & 127)) 								remove = 2; 						} 						points.RemoveRange(1' remove); 					} else if (points.Count >= 4 && (itsc2 = points[0].To(points[1]).ComputeIntersection(points[2].To(points[3]))) != null) { 						points.RemoveRange(1' 2); 						points.Insert(1' itsc2.Value); 					} else 						old = null; // save memory 				} else { 					if (old != null) 						Points = old; 					else { 						points[0] = p0; 						points[1] = p1; 					} 				} 			};
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AttachedAnchorChanged,The following statement contains a magic number: return @do => 			{ 				IList<PointT> points = Points; 				if (toSide) points = points.Reverse(); 				 				Debug.Assert(points.Count >= 2); 				if (points.Count < 2) 					return;  				_bbox = null; 				if (@do) { 					// save undo info in either (p0' p1) or (old) for complicated cases 					p0 = points[0]; 					p1 = points[1]; 					old = new List<PointT>(Points); 					 					var newAnchor = anchor.Point; 					LineSegment<float> one = newAnchor.To(newAnchor.Add(points[1].Sub(points[0])))' two; 					if (points.Count > 2) 						two = points[1].To(points[2]); 					else 						two = one.B.To(one.B.Add(one.B.Sub(one.A).Rot90())); // fake it  					points[0] = newAnchor; 					PointT? itsc = one.ComputeIntersection(two' LineType.Infinite)' itsc2; 					if (itsc != null && !(points.Count == 2 && (toSide ? _fromAnchor : _toAnchor) != null)) 						points[1] = itsc.Value; 					else 						itsc = points[1];  					if (points.Count >= 3 && points[1] == points[2]) { 						int remove = 1; 						if (points.Count > 3) { 							int a0 = AngleMod256(points[1].Sub(points[0]))' a1 = AngleMod256(points[3].Sub(points[2])); 							if ((a0 & 127) == (a1 & 127)) 								remove = 2; 						} 						points.RemoveRange(1' remove); 					} else if (points.Count >= 4 && (itsc2 = points[0].To(points[1]).ComputeIntersection(points[2].To(points[3]))) != null) { 						points.RemoveRange(1' 2); 						points.Insert(1' itsc2.Value); 					} else 						old = null; // save memory 				} else { 					if (old != null) 						Points = old; 					else { 						points[0] = p0; 						points[1] = p1; 					} 				} 			};
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AttachedAnchorChanged,The following statement contains a magic number: return @do => 			{ 				IList<PointT> points = Points; 				if (toSide) points = points.Reverse(); 				 				Debug.Assert(points.Count >= 2); 				if (points.Count < 2) 					return;  				_bbox = null; 				if (@do) { 					// save undo info in either (p0' p1) or (old) for complicated cases 					p0 = points[0]; 					p1 = points[1]; 					old = new List<PointT>(Points); 					 					var newAnchor = anchor.Point; 					LineSegment<float> one = newAnchor.To(newAnchor.Add(points[1].Sub(points[0])))' two; 					if (points.Count > 2) 						two = points[1].To(points[2]); 					else 						two = one.B.To(one.B.Add(one.B.Sub(one.A).Rot90())); // fake it  					points[0] = newAnchor; 					PointT? itsc = one.ComputeIntersection(two' LineType.Infinite)' itsc2; 					if (itsc != null && !(points.Count == 2 && (toSide ? _fromAnchor : _toAnchor) != null)) 						points[1] = itsc.Value; 					else 						itsc = points[1];  					if (points.Count >= 3 && points[1] == points[2]) { 						int remove = 1; 						if (points.Count > 3) { 							int a0 = AngleMod256(points[1].Sub(points[0]))' a1 = AngleMod256(points[3].Sub(points[2])); 							if ((a0 & 127) == (a1 & 127)) 								remove = 2; 						} 						points.RemoveRange(1' remove); 					} else if (points.Count >= 4 && (itsc2 = points[0].To(points[1]).ComputeIntersection(points[2].To(points[3]))) != null) { 						points.RemoveRange(1' 2); 						points.Insert(1' itsc2.Value); 					} else 						old = null; // save memory 				} else { 					if (old != null) 						Points = old; 					else { 						points[0] = p0; 						points[1] = p1; 					} 				} 			};
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AttachedAnchorChanged,The following statement contains a magic number: return @do => 			{ 				IList<PointT> points = Points; 				if (toSide) points = points.Reverse(); 				 				Debug.Assert(points.Count >= 2); 				if (points.Count < 2) 					return;  				_bbox = null; 				if (@do) { 					// save undo info in either (p0' p1) or (old) for complicated cases 					p0 = points[0]; 					p1 = points[1]; 					old = new List<PointT>(Points); 					 					var newAnchor = anchor.Point; 					LineSegment<float> one = newAnchor.To(newAnchor.Add(points[1].Sub(points[0])))' two; 					if (points.Count > 2) 						two = points[1].To(points[2]); 					else 						two = one.B.To(one.B.Add(one.B.Sub(one.A).Rot90())); // fake it  					points[0] = newAnchor; 					PointT? itsc = one.ComputeIntersection(two' LineType.Infinite)' itsc2; 					if (itsc != null && !(points.Count == 2 && (toSide ? _fromAnchor : _toAnchor) != null)) 						points[1] = itsc.Value; 					else 						itsc = points[1];  					if (points.Count >= 3 && points[1] == points[2]) { 						int remove = 1; 						if (points.Count > 3) { 							int a0 = AngleMod256(points[1].Sub(points[0]))' a1 = AngleMod256(points[3].Sub(points[2])); 							if ((a0 & 127) == (a1 & 127)) 								remove = 2; 						} 						points.RemoveRange(1' remove); 					} else if (points.Count >= 4 && (itsc2 = points[0].To(points[1]).ComputeIntersection(points[2].To(points[3]))) != null) { 						points.RemoveRange(1' 2); 						points.Insert(1' itsc2.Value); 					} else 						old = null; // save memory 				} else { 					if (old != null) 						Points = old; 					else { 						points[0] = p0; 						points[1] = p1; 					} 				} 			};
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AttachedAnchorChanged,The following statement contains a magic number: return @do => 			{ 				IList<PointT> points = Points; 				if (toSide) points = points.Reverse(); 				 				Debug.Assert(points.Count >= 2); 				if (points.Count < 2) 					return;  				_bbox = null; 				if (@do) { 					// save undo info in either (p0' p1) or (old) for complicated cases 					p0 = points[0]; 					p1 = points[1]; 					old = new List<PointT>(Points); 					 					var newAnchor = anchor.Point; 					LineSegment<float> one = newAnchor.To(newAnchor.Add(points[1].Sub(points[0])))' two; 					if (points.Count > 2) 						two = points[1].To(points[2]); 					else 						two = one.B.To(one.B.Add(one.B.Sub(one.A).Rot90())); // fake it  					points[0] = newAnchor; 					PointT? itsc = one.ComputeIntersection(two' LineType.Infinite)' itsc2; 					if (itsc != null && !(points.Count == 2 && (toSide ? _fromAnchor : _toAnchor) != null)) 						points[1] = itsc.Value; 					else 						itsc = points[1];  					if (points.Count >= 3 && points[1] == points[2]) { 						int remove = 1; 						if (points.Count > 3) { 							int a0 = AngleMod256(points[1].Sub(points[0]))' a1 = AngleMod256(points[3].Sub(points[2])); 							if ((a0 & 127) == (a1 & 127)) 								remove = 2; 						} 						points.RemoveRange(1' remove); 					} else if (points.Count >= 4 && (itsc2 = points[0].To(points[1]).ComputeIntersection(points[2].To(points[3]))) != null) { 						points.RemoveRange(1' 2); 						points.Insert(1' itsc2.Value); 					} else 						old = null; // save memory 				} else { 					if (old != null) 						Points = old; 					else { 						points[0] = p0; 						points[1] = p1; 					} 				} 			};
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AttachedAnchorChanged,The following statement contains a magic number: return @do => 			{ 				IList<PointT> points = Points; 				if (toSide) points = points.Reverse(); 				 				Debug.Assert(points.Count >= 2); 				if (points.Count < 2) 					return;  				_bbox = null; 				if (@do) { 					// save undo info in either (p0' p1) or (old) for complicated cases 					p0 = points[0]; 					p1 = points[1]; 					old = new List<PointT>(Points); 					 					var newAnchor = anchor.Point; 					LineSegment<float> one = newAnchor.To(newAnchor.Add(points[1].Sub(points[0])))' two; 					if (points.Count > 2) 						two = points[1].To(points[2]); 					else 						two = one.B.To(one.B.Add(one.B.Sub(one.A).Rot90())); // fake it  					points[0] = newAnchor; 					PointT? itsc = one.ComputeIntersection(two' LineType.Infinite)' itsc2; 					if (itsc != null && !(points.Count == 2 && (toSide ? _fromAnchor : _toAnchor) != null)) 						points[1] = itsc.Value; 					else 						itsc = points[1];  					if (points.Count >= 3 && points[1] == points[2]) { 						int remove = 1; 						if (points.Count > 3) { 							int a0 = AngleMod256(points[1].Sub(points[0]))' a1 = AngleMod256(points[3].Sub(points[2])); 							if ((a0 & 127) == (a1 & 127)) 								remove = 2; 						} 						points.RemoveRange(1' remove); 					} else if (points.Count >= 4 && (itsc2 = points[0].To(points[1]).ComputeIntersection(points[2].To(points[3]))) != null) { 						points.RemoveRange(1' 2); 						points.Insert(1' itsc2.Value); 					} else 						old = null; // save memory 				} else { 					if (old != null) 						Points = old; 					else { 						points[0] = p0; 						points[1] = p1; 					} 				} 			};
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AttachedAnchorChanged,The following statement contains a magic number: return @do => 			{ 				IList<PointT> points = Points; 				if (toSide) points = points.Reverse(); 				 				Debug.Assert(points.Count >= 2); 				if (points.Count < 2) 					return;  				_bbox = null; 				if (@do) { 					// save undo info in either (p0' p1) or (old) for complicated cases 					p0 = points[0]; 					p1 = points[1]; 					old = new List<PointT>(Points); 					 					var newAnchor = anchor.Point; 					LineSegment<float> one = newAnchor.To(newAnchor.Add(points[1].Sub(points[0])))' two; 					if (points.Count > 2) 						two = points[1].To(points[2]); 					else 						two = one.B.To(one.B.Add(one.B.Sub(one.A).Rot90())); // fake it  					points[0] = newAnchor; 					PointT? itsc = one.ComputeIntersection(two' LineType.Infinite)' itsc2; 					if (itsc != null && !(points.Count == 2 && (toSide ? _fromAnchor : _toAnchor) != null)) 						points[1] = itsc.Value; 					else 						itsc = points[1];  					if (points.Count >= 3 && points[1] == points[2]) { 						int remove = 1; 						if (points.Count > 3) { 							int a0 = AngleMod256(points[1].Sub(points[0]))' a1 = AngleMod256(points[3].Sub(points[2])); 							if ((a0 & 127) == (a1 & 127)) 								remove = 2; 						} 						points.RemoveRange(1' remove); 					} else if (points.Count >= 4 && (itsc2 = points[0].To(points[1]).ComputeIntersection(points[2].To(points[3]))) != null) { 						points.RemoveRange(1' 2); 						points.Insert(1' itsc2.Value); 					} else 						old = null; // save memory 				} else { 					if (old != null) 						Points = old; 					else { 						points[0] = p0; 						points[1] = p1; 					} 				} 			};
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AttachedAnchorChanged,The following statement contains a magic number: return @do => 			{ 				IList<PointT> points = Points; 				if (toSide) points = points.Reverse(); 				 				Debug.Assert(points.Count >= 2); 				if (points.Count < 2) 					return;  				_bbox = null; 				if (@do) { 					// save undo info in either (p0' p1) or (old) for complicated cases 					p0 = points[0]; 					p1 = points[1]; 					old = new List<PointT>(Points); 					 					var newAnchor = anchor.Point; 					LineSegment<float> one = newAnchor.To(newAnchor.Add(points[1].Sub(points[0])))' two; 					if (points.Count > 2) 						two = points[1].To(points[2]); 					else 						two = one.B.To(one.B.Add(one.B.Sub(one.A).Rot90())); // fake it  					points[0] = newAnchor; 					PointT? itsc = one.ComputeIntersection(two' LineType.Infinite)' itsc2; 					if (itsc != null && !(points.Count == 2 && (toSide ? _fromAnchor : _toAnchor) != null)) 						points[1] = itsc.Value; 					else 						itsc = points[1];  					if (points.Count >= 3 && points[1] == points[2]) { 						int remove = 1; 						if (points.Count > 3) { 							int a0 = AngleMod256(points[1].Sub(points[0]))' a1 = AngleMod256(points[3].Sub(points[2])); 							if ((a0 & 127) == (a1 & 127)) 								remove = 2; 						} 						points.RemoveRange(1' remove); 					} else if (points.Count >= 4 && (itsc2 = points[0].To(points[1]).ComputeIntersection(points[2].To(points[3]))) != null) { 						points.RemoveRange(1' 2); 						points.Insert(1' itsc2.Value); 					} else 						old = null; // save memory 				} else { 					if (old != null) 						Points = old; 					else { 						points[0] = p0; 						points[1] = p1; 					} 				} 			};
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AttachedAnchorChanged,The following statement contains a magic number: return @do => 			{ 				IList<PointT> points = Points; 				if (toSide) points = points.Reverse(); 				 				Debug.Assert(points.Count >= 2); 				if (points.Count < 2) 					return;  				_bbox = null; 				if (@do) { 					// save undo info in either (p0' p1) or (old) for complicated cases 					p0 = points[0]; 					p1 = points[1]; 					old = new List<PointT>(Points); 					 					var newAnchor = anchor.Point; 					LineSegment<float> one = newAnchor.To(newAnchor.Add(points[1].Sub(points[0])))' two; 					if (points.Count > 2) 						two = points[1].To(points[2]); 					else 						two = one.B.To(one.B.Add(one.B.Sub(one.A).Rot90())); // fake it  					points[0] = newAnchor; 					PointT? itsc = one.ComputeIntersection(two' LineType.Infinite)' itsc2; 					if (itsc != null && !(points.Count == 2 && (toSide ? _fromAnchor : _toAnchor) != null)) 						points[1] = itsc.Value; 					else 						itsc = points[1];  					if (points.Count >= 3 && points[1] == points[2]) { 						int remove = 1; 						if (points.Count > 3) { 							int a0 = AngleMod256(points[1].Sub(points[0]))' a1 = AngleMod256(points[3].Sub(points[2])); 							if ((a0 & 127) == (a1 & 127)) 								remove = 2; 						} 						points.RemoveRange(1' remove); 					} else if (points.Count >= 4 && (itsc2 = points[0].To(points[1]).ComputeIntersection(points[2].To(points[3]))) != null) { 						points.RemoveRange(1' 2); 						points.Insert(1' itsc2.Value); 					} else 						old = null; // save memory 				} else { 					if (old != null) 						Points = old; 					else { 						points[0] = p0; 						points[1] = p1; 					} 				} 			};
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AttachedAnchorChanged,The following statement contains a magic number: return @do => 			{ 				IList<PointT> points = Points; 				if (toSide) points = points.Reverse(); 				 				Debug.Assert(points.Count >= 2); 				if (points.Count < 2) 					return;  				_bbox = null; 				if (@do) { 					// save undo info in either (p0' p1) or (old) for complicated cases 					p0 = points[0]; 					p1 = points[1]; 					old = new List<PointT>(Points); 					 					var newAnchor = anchor.Point; 					LineSegment<float> one = newAnchor.To(newAnchor.Add(points[1].Sub(points[0])))' two; 					if (points.Count > 2) 						two = points[1].To(points[2]); 					else 						two = one.B.To(one.B.Add(one.B.Sub(one.A).Rot90())); // fake it  					points[0] = newAnchor; 					PointT? itsc = one.ComputeIntersection(two' LineType.Infinite)' itsc2; 					if (itsc != null && !(points.Count == 2 && (toSide ? _fromAnchor : _toAnchor) != null)) 						points[1] = itsc.Value; 					else 						itsc = points[1];  					if (points.Count >= 3 && points[1] == points[2]) { 						int remove = 1; 						if (points.Count > 3) { 							int a0 = AngleMod256(points[1].Sub(points[0]))' a1 = AngleMod256(points[3].Sub(points[2])); 							if ((a0 & 127) == (a1 & 127)) 								remove = 2; 						} 						points.RemoveRange(1' remove); 					} else if (points.Count >= 4 && (itsc2 = points[0].To(points[1]).ComputeIntersection(points[2].To(points[3]))) != null) { 						points.RemoveRange(1' 2); 						points.Insert(1' itsc2.Value); 					} else 						old = null; // save memory 				} else { 					if (old != null) 						Points = old; 					else { 						points[0] = p0; 						points[1] = p1; 					} 				} 			};
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AttachedAnchorChanged,The following statement contains a magic number: return @do => 			{ 				IList<PointT> points = Points; 				if (toSide) points = points.Reverse(); 				 				Debug.Assert(points.Count >= 2); 				if (points.Count < 2) 					return;  				_bbox = null; 				if (@do) { 					// save undo info in either (p0' p1) or (old) for complicated cases 					p0 = points[0]; 					p1 = points[1]; 					old = new List<PointT>(Points); 					 					var newAnchor = anchor.Point; 					LineSegment<float> one = newAnchor.To(newAnchor.Add(points[1].Sub(points[0])))' two; 					if (points.Count > 2) 						two = points[1].To(points[2]); 					else 						two = one.B.To(one.B.Add(one.B.Sub(one.A).Rot90())); // fake it  					points[0] = newAnchor; 					PointT? itsc = one.ComputeIntersection(two' LineType.Infinite)' itsc2; 					if (itsc != null && !(points.Count == 2 && (toSide ? _fromAnchor : _toAnchor) != null)) 						points[1] = itsc.Value; 					else 						itsc = points[1];  					if (points.Count >= 3 && points[1] == points[2]) { 						int remove = 1; 						if (points.Count > 3) { 							int a0 = AngleMod256(points[1].Sub(points[0]))' a1 = AngleMod256(points[3].Sub(points[2])); 							if ((a0 & 127) == (a1 & 127)) 								remove = 2; 						} 						points.RemoveRange(1' remove); 					} else if (points.Count >= 4 && (itsc2 = points[0].To(points[1]).ComputeIntersection(points[2].To(points[3]))) != null) { 						points.RemoveRange(1' 2); 						points.Insert(1' itsc2.Value); 					} else 						old = null; // save memory 				} else { 					if (old != null) 						Points = old; 					else { 						points[0] = p0; 						points[1] = p1; 					} 				} 			};
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AttachedAnchorChanged,The following statement contains a magic number: return @do => 			{ 				IList<PointT> points = Points; 				if (toSide) points = points.Reverse(); 				 				Debug.Assert(points.Count >= 2); 				if (points.Count < 2) 					return;  				_bbox = null; 				if (@do) { 					// save undo info in either (p0' p1) or (old) for complicated cases 					p0 = points[0]; 					p1 = points[1]; 					old = new List<PointT>(Points); 					 					var newAnchor = anchor.Point; 					LineSegment<float> one = newAnchor.To(newAnchor.Add(points[1].Sub(points[0])))' two; 					if (points.Count > 2) 						two = points[1].To(points[2]); 					else 						two = one.B.To(one.B.Add(one.B.Sub(one.A).Rot90())); // fake it  					points[0] = newAnchor; 					PointT? itsc = one.ComputeIntersection(two' LineType.Infinite)' itsc2; 					if (itsc != null && !(points.Count == 2 && (toSide ? _fromAnchor : _toAnchor) != null)) 						points[1] = itsc.Value; 					else 						itsc = points[1];  					if (points.Count >= 3 && points[1] == points[2]) { 						int remove = 1; 						if (points.Count > 3) { 							int a0 = AngleMod256(points[1].Sub(points[0]))' a1 = AngleMod256(points[3].Sub(points[2])); 							if ((a0 & 127) == (a1 & 127)) 								remove = 2; 						} 						points.RemoveRange(1' remove); 					} else if (points.Count >= 4 && (itsc2 = points[0].To(points[1]).ComputeIntersection(points[2].To(points[3]))) != null) { 						points.RemoveRange(1' 2); 						points.Insert(1' itsc2.Value); 					} else 						old = null; // save memory 				} else { 					if (old != null) 						Points = old; 					else { 						points[0] = p0; 						points[1] = p1; 					} 				} 			};
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AttachedAnchorChanged,The following statement contains a magic number: return @do => 			{ 				IList<PointT> points = Points; 				if (toSide) points = points.Reverse(); 				 				Debug.Assert(points.Count >= 2); 				if (points.Count < 2) 					return;  				_bbox = null; 				if (@do) { 					// save undo info in either (p0' p1) or (old) for complicated cases 					p0 = points[0]; 					p1 = points[1]; 					old = new List<PointT>(Points); 					 					var newAnchor = anchor.Point; 					LineSegment<float> one = newAnchor.To(newAnchor.Add(points[1].Sub(points[0])))' two; 					if (points.Count > 2) 						two = points[1].To(points[2]); 					else 						two = one.B.To(one.B.Add(one.B.Sub(one.A).Rot90())); // fake it  					points[0] = newAnchor; 					PointT? itsc = one.ComputeIntersection(two' LineType.Infinite)' itsc2; 					if (itsc != null && !(points.Count == 2 && (toSide ? _fromAnchor : _toAnchor) != null)) 						points[1] = itsc.Value; 					else 						itsc = points[1];  					if (points.Count >= 3 && points[1] == points[2]) { 						int remove = 1; 						if (points.Count > 3) { 							int a0 = AngleMod256(points[1].Sub(points[0]))' a1 = AngleMod256(points[3].Sub(points[2])); 							if ((a0 & 127) == (a1 & 127)) 								remove = 2; 						} 						points.RemoveRange(1' remove); 					} else if (points.Count >= 4 && (itsc2 = points[0].To(points[1]).ComputeIntersection(points[2].To(points[3]))) != null) { 						points.RemoveRange(1' 2); 						points.Insert(1' itsc2.Value); 					} else 						old = null; // save memory 				} else { 					if (old != null) 						Points = old; 					else { 						points[0] = p0; 						points[1] = p1; 					} 				} 			};
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AttachedAnchorChanged,The following statement contains a magic number: return @do => 			{ 				IList<PointT> points = Points; 				if (toSide) points = points.Reverse(); 				 				Debug.Assert(points.Count >= 2); 				if (points.Count < 2) 					return;  				_bbox = null; 				if (@do) { 					// save undo info in either (p0' p1) or (old) for complicated cases 					p0 = points[0]; 					p1 = points[1]; 					old = new List<PointT>(Points); 					 					var newAnchor = anchor.Point; 					LineSegment<float> one = newAnchor.To(newAnchor.Add(points[1].Sub(points[0])))' two; 					if (points.Count > 2) 						two = points[1].To(points[2]); 					else 						two = one.B.To(one.B.Add(one.B.Sub(one.A).Rot90())); // fake it  					points[0] = newAnchor; 					PointT? itsc = one.ComputeIntersection(two' LineType.Infinite)' itsc2; 					if (itsc != null && !(points.Count == 2 && (toSide ? _fromAnchor : _toAnchor) != null)) 						points[1] = itsc.Value; 					else 						itsc = points[1];  					if (points.Count >= 3 && points[1] == points[2]) { 						int remove = 1; 						if (points.Count > 3) { 							int a0 = AngleMod256(points[1].Sub(points[0]))' a1 = AngleMod256(points[3].Sub(points[2])); 							if ((a0 & 127) == (a1 & 127)) 								remove = 2; 						} 						points.RemoveRange(1' remove); 					} else if (points.Count >= 4 && (itsc2 = points[0].To(points[1]).ComputeIntersection(points[2].To(points[3]))) != null) { 						points.RemoveRange(1' 2); 						points.Insert(1' itsc2.Value); 					} else 						old = null; // save memory 				} else { 					if (old != null) 						Points = old; 					else { 						points[0] = p0; 						points[1] = p1; 					} 				} 			};
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AttachedAnchorChanged,The following statement contains a magic number: return @do => 			{ 				IList<PointT> points = Points; 				if (toSide) points = points.Reverse(); 				 				Debug.Assert(points.Count >= 2); 				if (points.Count < 2) 					return;  				_bbox = null; 				if (@do) { 					// save undo info in either (p0' p1) or (old) for complicated cases 					p0 = points[0]; 					p1 = points[1]; 					old = new List<PointT>(Points); 					 					var newAnchor = anchor.Point; 					LineSegment<float> one = newAnchor.To(newAnchor.Add(points[1].Sub(points[0])))' two; 					if (points.Count > 2) 						two = points[1].To(points[2]); 					else 						two = one.B.To(one.B.Add(one.B.Sub(one.A).Rot90())); // fake it  					points[0] = newAnchor; 					PointT? itsc = one.ComputeIntersection(two' LineType.Infinite)' itsc2; 					if (itsc != null && !(points.Count == 2 && (toSide ? _fromAnchor : _toAnchor) != null)) 						points[1] = itsc.Value; 					else 						itsc = points[1];  					if (points.Count >= 3 && points[1] == points[2]) { 						int remove = 1; 						if (points.Count > 3) { 							int a0 = AngleMod256(points[1].Sub(points[0]))' a1 = AngleMod256(points[3].Sub(points[2])); 							if ((a0 & 127) == (a1 & 127)) 								remove = 2; 						} 						points.RemoveRange(1' remove); 					} else if (points.Count >= 4 && (itsc2 = points[0].To(points[1]).ComputeIntersection(points[2].To(points[3]))) != null) { 						points.RemoveRange(1' 2); 						points.Insert(1' itsc2.Value); 					} else 						old = null; // save memory 				} else { 					if (old != null) 						Points = old; 					else { 						points[0] = p0; 						points[1] = p1; 					} 				} 			};
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AngleMod8,The following statement contains a magic number: return (int)Math.Round(v.Angle() * (4 / Math.PI)) & 7;
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,AngleMod8,The following statement contains a magic number: return (int)Math.Round(v.Angle() * (4 / Math.PI)) & 7;
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,HitTest,The following statement contains a magic number: if (where != null) 			{ 				if (sel == SelType.Yes) { 					int seg = (int)where.Value; 					var angle = AngleMod8(Points[seg+1].Sub(Points[seg])); 					switch (angle & 3) { 						case 0: return new HitTestResult(this' Cursors.SizeNS' seg); 						case 1: return new HitTestResult(this' Cursors.SizeNESW' seg); 						case 2: return new HitTestResult(this' Cursors.SizeWE' seg); 						case 3: return new HitTestResult(this' Cursors.SizeNWSE' seg); 					} 				} else { 					return new HitTestResult(this' Cursors.Arrow' -1); 				} 			}
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,HitTest,The following statement contains a magic number: if (where != null) 			{ 				if (sel == SelType.Yes) { 					int seg = (int)where.Value; 					var angle = AngleMod8(Points[seg+1].Sub(Points[seg])); 					switch (angle & 3) { 						case 0: return new HitTestResult(this' Cursors.SizeNS' seg); 						case 1: return new HitTestResult(this' Cursors.SizeNESW' seg); 						case 2: return new HitTestResult(this' Cursors.SizeWE' seg); 						case 3: return new HitTestResult(this' Cursors.SizeNWSE' seg); 					} 				} else { 					return new HitTestResult(this' Cursors.Arrow' -1); 				} 			}
Magic Number,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,HitTest,The following statement contains a magic number: if (where != null) 			{ 				if (sel == SelType.Yes) { 					int seg = (int)where.Value; 					var angle = AngleMod8(Points[seg+1].Sub(Points[seg])); 					switch (angle & 3) { 						case 0: return new HitTestResult(this' Cursors.SizeNS' seg); 						case 1: return new HitTestResult(this' Cursors.SizeNESW' seg); 						case 2: return new HitTestResult(this' Cursors.SizeWE' seg); 						case 3: return new HitTestResult(this' Cursors.SizeNWSE' seg); 					} 				} else { 					return new HitTestResult(this' Cursors.Arrow' -1); 				} 			}
Magic Number,BoxDiagrams,Marker,C:\repos\qwertie_Loyc\Baadia\Shapes\Marker.cs,PB_BD,The following statement contains a magic number: LL = new LLMarker(Style' default(PointT)' 10' MarkerPolygon.UpTriangle);
Magic Number,BoxDiagrams,TextBox,C:\repos\qwertie_Loyc\Baadia\Shapes\TextBox.cs,GetNearestAnchor,The following statement contains a magic number: if (vert) { 				frac = ((p.X - Left) / (Right - Left)).PutInRange(0' 1); 				if (vec.Y > 0) // bottom 					a = Anchor(() => new PointT(Left + frac * (Right - Left)' Bottom)' 7 << 5); 				else // top 					a = Anchor(() => new PointT(Left + frac * (Right - Left)' Top)' 7 << 1); 			} else { 				if (vec.X > 0) // right 					a = Anchor(() => new PointT(Right' Top + frac * (Bottom - Top))' 0x83); 				else // left 					a = Anchor(() => new PointT(Left' Top + frac * (Bottom - Top))' 7 << 3); 			}
Magic Number,BoxDiagrams,TextBox,C:\repos\qwertie_Loyc\Baadia\Shapes\TextBox.cs,GetNearestAnchor,The following statement contains a magic number: if (vert) { 				frac = ((p.X - Left) / (Right - Left)).PutInRange(0' 1); 				if (vec.Y > 0) // bottom 					a = Anchor(() => new PointT(Left + frac * (Right - Left)' Bottom)' 7 << 5); 				else // top 					a = Anchor(() => new PointT(Left + frac * (Right - Left)' Top)' 7 << 1); 			} else { 				if (vec.X > 0) // right 					a = Anchor(() => new PointT(Right' Top + frac * (Bottom - Top))' 0x83); 				else // left 					a = Anchor(() => new PointT(Left' Top + frac * (Bottom - Top))' 7 << 3); 			}
Magic Number,BoxDiagrams,TextBox,C:\repos\qwertie_Loyc\Baadia\Shapes\TextBox.cs,GetNearestAnchor,The following statement contains a magic number: if (vert) { 				frac = ((p.X - Left) / (Right - Left)).PutInRange(0' 1); 				if (vec.Y > 0) // bottom 					a = Anchor(() => new PointT(Left + frac * (Right - Left)' Bottom)' 7 << 5); 				else // top 					a = Anchor(() => new PointT(Left + frac * (Right - Left)' Top)' 7 << 1); 			} else { 				if (vec.X > 0) // right 					a = Anchor(() => new PointT(Right' Top + frac * (Bottom - Top))' 0x83); 				else // left 					a = Anchor(() => new PointT(Left' Top + frac * (Bottom - Top))' 7 << 3); 			}
Magic Number,BoxDiagrams,TextBox,C:\repos\qwertie_Loyc\Baadia\Shapes\TextBox.cs,GetNearestAnchor,The following statement contains a magic number: if (vert) { 				frac = ((p.X - Left) / (Right - Left)).PutInRange(0' 1); 				if (vec.Y > 0) // bottom 					a = Anchor(() => new PointT(Left + frac * (Right - Left)' Bottom)' 7 << 5); 				else // top 					a = Anchor(() => new PointT(Left + frac * (Right - Left)' Top)' 7 << 1); 			} else { 				if (vec.X > 0) // right 					a = Anchor(() => new PointT(Right' Top + frac * (Bottom - Top))' 0x83); 				else // left 					a = Anchor(() => new PointT(Left' Top + frac * (Bottom - Top))' 7 << 3); 			}
Magic Number,BoxDiagrams,TextBox,C:\repos\qwertie_Loyc\Baadia\Shapes\TextBox.cs,GetNearestAnchor,The following statement contains a magic number: if (vert) { 				frac = ((p.X - Left) / (Right - Left)).PutInRange(0' 1); 				if (vec.Y > 0) // bottom 					a = Anchor(() => new PointT(Left + frac * (Right - Left)' Bottom)' 7 << 5); 				else // top 					a = Anchor(() => new PointT(Left + frac * (Right - Left)' Top)' 7 << 1); 			} else { 				if (vec.X > 0) // right 					a = Anchor(() => new PointT(Right' Top + frac * (Bottom - Top))' 0x83); 				else // left 					a = Anchor(() => new PointT(Left' Top + frac * (Bottom - Top))' 7 << 3); 			}
Magic Number,BoxDiagrams,TextBox,C:\repos\qwertie_Loyc\Baadia\Shapes\TextBox.cs,HitTest,The following statement contains a magic number: if (sel != SelType.No || (BoxType != BoxType.Borderless && !_isPanel)) 			{ 				if (sel != SelType.Yes) 					hitTestRadius *= 2; 				var bbox2 = BBox.Deflated(hitTestRadius.X' hitTestRadius.Y); 				if (bbox2.Contains(pos)) 					return new HitTestResult(this' Cursors.SizeAll' RF.Top | RF.Bottom | RF.Left | RF.Right); 			}
Magic Number,BoxDiagrams,TextBox,C:\repos\qwertie_Loyc\Baadia\Shapes\TextBox.cs,OnKeyPress,The following statement contains a magic number: if (ch >= 32 || ch == '\r') { 				if (ch == '\r') ch = '\n'; 				UndoStack.Do(@do => { 					if (@do) 						this.Text += ch; 					else 						this.Text = this.Text.Left(this.Text.Length - 1); 				}' true); 			}
Magic Number,Util.WinForms,DragPoint,C:\repos\qwertie_Loyc\Baadia\Util\GestureAnalyzer.cs,DragPoint,The following statement contains a magic number: MsecSincePrev = (ushort)ms.PutInRange(0' 65535);
Magic Number,Util.WinForms,DragPoint,C:\repos\qwertie_Loyc\Baadia\Util\GestureAnalyzer.cs,DragPoint,The following statement contains a magic number: AngleMod256 = (byte)(prevPts.Count == 0 ? 0 : (int) 				((Point.Sub(prevPts[prevPts.Count - 1].Point)).Angle() * (128.0 / Math.PI)));
Magic Number,Util.WinForms,DragPoint,C:\repos\qwertie_Loyc\Baadia\Util\GestureAnalyzer.cs,SecPer1000px,The following statement contains a magic number: for (int i = prevPts.Count - 1; i >= 0; i--) 			{ 				var dif = next - (next = prevPts[i].Point); 				dist += dif.Length(); 				if (ms > 100) 					break; 				ms += prevPts[i].MsecSincePrev; 			}
Magic Number,Util.WinForms,GestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\Util\GestureAnalyzer.cs,AddFiltered,The following statement contains a magic number: if (points.Count < 2) 				return AddIfFarEnough(points' dp);
Magic Number,Util.WinForms,GestureAnalyzer,C:\repos\qwertie_Loyc\Baadia\Util\GestureAnalyzer.cs,AddFiltered,The following statement contains a magic number: if (iFirst > 0) 			{ 				// 3. Between here and there' identify the farthest point away from the 				//    new point (dp.Point). 				var region = ((IList<DragPoint>)points).Slice(iFirst); 				int offsFarthest = region.IndexOfMax(p => (p.Point.Sub(dp.Point)).Quadrance()); 				int iFarthest = iFirst + offsFarthest; 				// 4. Make sure that all the points between here and there are close to 				//    this line (within' say... 8 pixels). If so' we have erasure. 				var seg = dp.Point.To(points[iFarthest].Point); 				if (region.All(p => p.Point.DistanceTo(seg) < EraseThreshold2)) 				{ 					// 5. Respond to erasure by deleting all the points between there 					//    and here' not including the first or last point. 					// 5b. Consider adding the intersection point found in step 2b to 					//    the point list' before adding the new point. 					points.Resize(iFirst); 					if (points.Count == 0 || (points.Last.Point.Sub(beginning)).Length() >= MinDistBetweenDragPoints) 						points.Add(new DragPoint(beginning' 10' points)); 				} 			}
Magic Number,Util.WinForms,DrawStyle,C:\repos\qwertie_Loyc\Baadia\Util\DrawStyle.cs,MixOpacity,The following statement contains a magic number: return Color.FromArgb(one.A * (two + (two >> 7)) >> 8' one);
Magic Number,Util.WinForms,DrawStyle,C:\repos\qwertie_Loyc\Baadia\Util\DrawStyle.cs,MixOpacity,The following statement contains a magic number: return Color.FromArgb(one.A * (two + (two >> 7)) >> 8' one);
Magic Number,Util.WinForms,DrawStyle,C:\repos\qwertie_Loyc\Baadia\Util\DrawStyle.cs,Pen,The following statement contains a magic number: if (opacity >= 255) 				return _pen = _pen ?? NewPen(LineColor' LineWidth' LineStyle); 			else 				return NewPen(MixOpacity(LineColor' opacity)' LineWidth' LineStyle);
Magic Number,Util.WinForms,DrawStyle,C:\repos\qwertie_Loyc\Baadia\Util\DrawStyle.cs,NewPen,The following statement contains a magic number: return c.A < 5 ? null : new Pen(c' w) { DashStyle = ls };
Magic Number,Util.WinForms,DrawStyle,C:\repos\qwertie_Loyc\Baadia\Util\DrawStyle.cs,Brush,The following statement contains a magic number: if (opacity >= 255) 				return _brush = _brush ?? NewBrush(FillColor); 			else 				return NewBrush(MixOpacity(FillColor' opacity));
Magic Number,Util.WinForms,DrawStyle,C:\repos\qwertie_Loyc\Baadia\Util\DrawStyle.cs,NewBrush,The following statement contains a magic number: return c.A < 5 ? null : new SolidBrush(c);
Magic Number,Util.WinForms,DrawStyle,C:\repos\qwertie_Loyc\Baadia\Util\DrawStyle.cs,TextBrush,The following statement contains a magic number: if (opacity >= 255) 				return _textBrush = _textBrush ?? NewBrush(TextColor); 			else 				return NewBrush(MixOpacity(TextColor' opacity));
Magic Number,Util.WinForms,LLShapeControl,C:\repos\qwertie_Loyc\Baadia\Util\LLShapeControl.cs,DrawLayers,The following statement contains a magic number: if (IsDesignTime) { 				_designStyle = _designStyle ?? new DrawStyle(); 				_designStyle.Font = Font; 				_designStyle.TextColor = ForeColor; 				if (_layers.Count != 0 && _layers.All(l => !l.Shapes.Any())) 					_layers[0].Shapes = new LLShape[] { new LLTextShape(_designStyle' GetType().Name' null' new Point<float>(3' 3)) }; 			}
Magic Number,Util.WinForms,LLShapeControl,C:\repos\qwertie_Loyc\Baadia\Util\LLShapeControl.cs,DrawLayers,The following statement contains a magic number: if (IsDesignTime) { 				_designStyle = _designStyle ?? new DrawStyle(); 				_designStyle.Font = Font; 				_designStyle.TextColor = ForeColor; 				if (_layers.Count != 0 && _layers.All(l => !l.Shapes.Any())) 					_layers[0].Shapes = new LLShape[] { new LLTextShape(_designStyle' GetType().Name' null' new Point<float>(3' 3)) }; 			}
Magic Number,Util.WinForms,LLShape,C:\repos\qwertie_Loyc\Baadia\Util\LLShapes.cs,LLShape,The following statement contains a magic number: Opacity = 255;
Magic Number,Util.WinForms,LLShape,C:\repos\qwertie_Loyc\Baadia\Util\LLShapes.cs,AddPolygon,The following statement contains a magic number: if (points.Length > 2) 				gp.AddPolygon(points); 			else if (points.Length == 2) 				gp.AddLine(points[0]' points[1]);
Magic Number,Util.WinForms,LLShape,C:\repos\qwertie_Loyc\Baadia\Util\LLShapes.cs,AddPolygon,The following statement contains a magic number: if (points.Length > 2) 				gp.AddPolygon(points); 			else if (points.Length == 2) 				gp.AddLine(points[0]' points[1]);
Magic Number,Util.WinForms,LLQuadraticCurve,C:\repos\qwertie_Loyc\Baadia\Util\LLShapes.cs,Flatten,The following statement contains a magic number: if (Points.Count <= 2) 				Flattened = Points.SelectArray(p => p.AsBCL()); 			else { 				int totalCount = PointsPerSeg * (Points.Count - 1) + 1; 				Flattened = new PointF[totalCount]; 				int offs = 0; 				Coord per = 1f / PointsPerSeg; 				for (int i = 0; i < Points.Count - 2; i++) { 					bool last = i == Points.Count - 2; 					PointT a = Points[i]' b = Points[i + 1]' c = Points[i + 2]; 					PointT a_ = i == 0 ? a : a.To(b).Midpoint(); 					PointT c_ = last ? c : b.To(c).Midpoint(); 					Flatten(a_' b' c_' Flattened.Slice(offs' PointsPerSeg)' per); 					offs += PointsPerSeg; 				} 				Flattened[Flattened.Length - 1] = Points[Points.Count - 1].AsBCL(); 			}
Magic Number,Util.WinForms,LLQuadraticCurve,C:\repos\qwertie_Loyc\Baadia\Util\LLShapes.cs,Flatten,The following statement contains a magic number: if (Points.Count <= 2) 				Flattened = Points.SelectArray(p => p.AsBCL()); 			else { 				int totalCount = PointsPerSeg * (Points.Count - 1) + 1; 				Flattened = new PointF[totalCount]; 				int offs = 0; 				Coord per = 1f / PointsPerSeg; 				for (int i = 0; i < Points.Count - 2; i++) { 					bool last = i == Points.Count - 2; 					PointT a = Points[i]' b = Points[i + 1]' c = Points[i + 2]; 					PointT a_ = i == 0 ? a : a.To(b).Midpoint(); 					PointT c_ = last ? c : b.To(c).Midpoint(); 					Flatten(a_' b' c_' Flattened.Slice(offs' PointsPerSeg)' per); 					offs += PointsPerSeg; 				} 				Flattened[Flattened.Length - 1] = Points[Points.Count - 1].AsBCL(); 			}
Magic Number,Util.WinForms,LLQuadraticCurve,C:\repos\qwertie_Loyc\Baadia\Util\LLShapes.cs,Flatten,The following statement contains a magic number: if (Points.Count <= 2) 				Flattened = Points.SelectArray(p => p.AsBCL()); 			else { 				int totalCount = PointsPerSeg * (Points.Count - 1) + 1; 				Flattened = new PointF[totalCount]; 				int offs = 0; 				Coord per = 1f / PointsPerSeg; 				for (int i = 0; i < Points.Count - 2; i++) { 					bool last = i == Points.Count - 2; 					PointT a = Points[i]' b = Points[i + 1]' c = Points[i + 2]; 					PointT a_ = i == 0 ? a : a.To(b).Midpoint(); 					PointT c_ = last ? c : b.To(c).Midpoint(); 					Flatten(a_' b' c_' Flattened.Slice(offs' PointsPerSeg)' per); 					offs += PointsPerSeg; 				} 				Flattened[Flattened.Length - 1] = Points[Points.Count - 1].AsBCL(); 			}
Magic Number,Util.WinForms,LLQuadraticCurve,C:\repos\qwertie_Loyc\Baadia\Util\LLShapes.cs,Flatten,The following statement contains a magic number: if (Points.Count <= 2) 				Flattened = Points.SelectArray(p => p.AsBCL()); 			else { 				int totalCount = PointsPerSeg * (Points.Count - 1) + 1; 				Flattened = new PointF[totalCount]; 				int offs = 0; 				Coord per = 1f / PointsPerSeg; 				for (int i = 0; i < Points.Count - 2; i++) { 					bool last = i == Points.Count - 2; 					PointT a = Points[i]' b = Points[i + 1]' c = Points[i + 2]; 					PointT a_ = i == 0 ? a : a.To(b).Midpoint(); 					PointT c_ = last ? c : b.To(c).Midpoint(); 					Flatten(a_' b' c_' Flattened.Slice(offs' PointsPerSeg)' per); 					offs += PointsPerSeg; 				} 				Flattened[Flattened.Length - 1] = Points[Points.Count - 1].AsBCL(); 			}
Missing Default,BoxDiagrams,LineOrArrow,C:\repos\qwertie_Loyc\Baadia\Shapes\LineOrArrow.cs,HitTest,The following switch statement is missing a default case: switch (angle & 3) { 						case 0: return new HitTestResult(this' Cursors.SizeNS' seg); 						case 1: return new HitTestResult(this' Cursors.SizeNESW' seg); 						case 2: return new HitTestResult(this' Cursors.SizeWE' seg); 						case 3: return new HitTestResult(this' Cursors.SizeNWSE' seg); 					}
