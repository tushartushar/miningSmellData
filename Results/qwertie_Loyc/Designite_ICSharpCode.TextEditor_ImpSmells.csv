Implementation smell,Namespace,Class,File,Method,Description
Long Method,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,ParseLine,The method has 236 lines of code.
Long Method,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,PaintLinePart,The method has 184 lines of code.
Long Method,ICSharpCode.TextEditor,TextAreaMouseHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaMouseHandler.cs,OnMouseDown,The method has 107 lines of code.
Long Method,ICSharpCode.TextEditor,FoldMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\FoldMargin.cs,PaintFoldMarker,The method has 102 lines of code.
Long Method,ICSharpCode.TextEditor.Util,RtfWriter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\RtfWriter.cs,BuildFileContent,The method has 103 lines of code.
Complex Method,ICSharpCode.TextEditor.Document,DefaultDocument,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\DefaultDocument.cs,UpdateSegmentListOnDocumentChange,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.TextEditor.Document,DefaultFormattingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\FormattingStrategy\DefaultFormattingStrategy.cs,SmartReplaceLine,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,ResolveRuleSetReferences,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,MarkTokens,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,MarkTokensInLine,Cyclomatic complexity of the method is 11
Complex Method,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,ParseLine,Cyclomatic complexity of the method is 35
Complex Method,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,PushCurWord,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.TextEditor.Document,HighlightingDefinitionParser,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\HighlightingDefinitionParser.cs,Parse,Cyclomatic complexity of the method is 17
Complex Method,ICSharpCode.TextEditor.Document,HighlightRuleSet,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\HighlightRuleSet.cs,HighlightRuleSet,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.TextEditor.Document,Span,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\Span.cs,Span,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.TextEditor.Document,LineSegment,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\LineManager\LineSegment.cs,RemovedLinePart,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.TextEditor.Document,SelectionManager,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\Selection\SelectionManager.cs,RemoveSelectedText,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.TextEditor,TextArea,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextArea.cs,SearchMatchingBracket,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.TextEditor,TextArea,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextArea.cs,OnMouseMove,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.TextEditor,TextArea,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextArea.cs,OnPaint,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.TextEditor,TextArea,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextArea.cs,SimulateKeyPress,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.TextEditor,TextAreaClipboardHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaClipboardHandler.cs,Paste,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,PaintDocumentLine,Cyclomatic complexity of the method is 14
Complex Method,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,PaintLinePart,Cyclomatic complexity of the method is 32
Complex Method,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,CountColumns,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,GetDrawingXPos,Cyclomatic complexity of the method is 10
Complex Method,ICSharpCode.TextEditor,TextAreaMouseHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaMouseHandler.cs,OnToolTipRequest,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.TextEditor,TextAreaMouseHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaMouseHandler.cs,TextAreaMouseMove,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.TextEditor,TextAreaMouseHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaMouseHandler.cs,OnMouseDown,Cyclomatic complexity of the method is 12
Complex Method,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,HandleMouseDown,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.TextEditor,FoldMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\FoldMargin.cs,PaintFoldMarker,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.TextEditor,TextAreaDragDropHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaDragDropHandler.cs,OnDragDrop,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.TextEditor.Util,AugmentableRedBlackTree<T;Host>,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\AugmentableRedBlackTree.cs,RemoveNode,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.TextEditor.Util,AugmentableRedBlackTree<T;Host>,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\AugmentableRedBlackTree.cs,FixTreeOnDelete,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.TextEditor.Actions,ToggleLineComment,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,Execute,Cyclomatic complexity of the method is 9
Complex Method,ICSharpCode.TextEditor.Actions,ToggleBlockComment,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,FindSelectedCommentRegion,Cyclomatic complexity of the method is 13
Complex Method,ICSharpCode.TextEditor.Actions,WordBackspace,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,Execute,Cyclomatic complexity of the method is 8
Complex Method,ICSharpCode.TextEditor.Gui.CompletionWindow,CodeCompletionListView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\CompletionWindow\CodeCompletionListView.cs,SelectItemWithStart,Cyclomatic complexity of the method is 9
Long Parameter List,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,GetColor,The method has 5 parameters. Parameters: ruleSet' document' currentSegment' currentOffset' currentLength
Long Parameter List,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,OverrideSpan,The method has 5 parameters. Parameters: spanBegin' document' words' span' lineOffset
Long Parameter List,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,MatchExpr,The method has 5 parameters. Parameters: lineSegment' expr' index' document' ignoreCase
Long Parameter List,ICSharpCode.TextEditor.Document,TextWord,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\TextWord.cs,TextWord,The method has 6 parameters. Parameters: document' line' offset' length' color' hasDefaultColor
Long Parameter List,ICSharpCode.TextEditor.Document,FoldMarker,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\FoldingStrategy\FoldMarker.cs,FoldMarker,The method has 5 parameters. Parameters: document' offset' length' foldText' isFolded
Long Parameter List,ICSharpCode.TextEditor.Document,FoldMarker,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\FoldingStrategy\FoldMarker.cs,FoldMarker,The method has 5 parameters. Parameters: document' startLine' startColumn' endLine' endColumn
Long Parameter List,ICSharpCode.TextEditor.Document,FoldMarker,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\FoldingStrategy\FoldMarker.cs,FoldMarker,The method has 6 parameters. Parameters: document' startLine' startColumn' endLine' endColumn' foldType
Long Parameter List,ICSharpCode.TextEditor.Document,FoldMarker,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\FoldingStrategy\FoldMarker.cs,FoldMarker,The method has 7 parameters. Parameters: document' startLine' startColumn' endLine' endColumn' foldType' foldText
Long Parameter List,ICSharpCode.TextEditor.Document,FoldMarker,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\FoldingStrategy\FoldMarker.cs,FoldMarker,The method has 8 parameters. Parameters: document' startLine' startColumn' endLine' endColumn' foldType' foldText' isFolded
Long Parameter List,ICSharpCode.TextEditor.Document,TextMarker,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\MarkerStrategy\TextMarker.cs,TextMarker,The method has 5 parameters. Parameters: offset' length' textMarkerType' color' foreColor
Long Parameter List,ICSharpCode.TextEditor,TextEditorControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextEditorControl.cs,Advance,The method has 5 parameters. Parameters: x' y' maxWidth' size' fontHeight
Long Parameter List,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,PaintFoldingText,The method has 6 parameters. Parameters: g' lineNumber' physicalXPos' lineRectangle' text' drawSelected
Long Parameter List,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,PaintLinePart,The method has 6 parameters. Parameters: g' lineNumber' startColumn' endColumn' lineRectangle' physicalXPos
Long Parameter List,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,DrawDocumentWord,The method has 6 parameters. Parameters: g' word' position' font' foreColor' backBrush
Long Parameter List,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,GetLogicalColumnInternal,The method has 6 parameters. Parameters: g' line' start' end' drawingPos' targetVisualPosX
Long Parameter List,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,CountColumns,The method has 5 parameters. Parameters: column' start' end' logicalLine' g
Long Parameter List,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,DrawString,The method has 6 parameters. Parameters: g' text' font' color' x' y
Long Parameter List,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,DrawEOLMarker,The method has 5 parameters. Parameters: g' color' backBrush' x' y
Long Parameter List,ICSharpCode.TextEditor,DrawableLine,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\DrawableLine.cs,DrawDocumentWord,The method has 5 parameters. Parameters: g' word' position' font' foreColor
Long Parameter List,ICSharpCode.TextEditor,DrawableLine,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\DrawableLine.cs,DrawLine,The method has 5 parameters. Parameters: g' xPos' xOffset' yPos' c
Long Parameter List,ICSharpCode.TextEditor.Util,AugmentableRedBlackTree<T;Host>,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\AugmentableRedBlackTree.cs,CheckNodeProperties,The method has 5 parameters. Parameters: node' parentNode' parentColor' blackCount' expectedBlackCount
Long Parameter List,ICSharpCode.TextEditor.Util,TextUtility,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TextUtility.cs,RegionMatches,The method has 5 parameters. Parameters: document' casesensitive' offset' length' word
Long Parameter List,ICSharpCode.TextEditor.Util,TextUtility,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TextUtility.cs,RegionMatches,The method has 5 parameters. Parameters: document' casesensitive' offset' length' word
Long Parameter List,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,GetLeftHandSideDrawingSizeHelpTipFromCombinedDescription,The method has 6 parameters. Parameters: control' graphics' font' countMessage' description' p
Long Parameter List,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,GetDrawingSizeHelpTipFromCombinedDescription,The method has 5 parameters. Parameters: control' graphics' font' countMessage' description
Long Parameter List,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,DrawHelpTipFromCombinedDescription,The method has 5 parameters. Parameters: control' graphics' font' countMessage' description
Long Parameter List,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,DrawFixedWidthHelpTipFromCombinedDescription,The method has 5 parameters. Parameters: control' graphics' font' countMessage' description
Long Parameter List,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,GetDrawingSizeDrawHelpTip,The method has 6 parameters. Parameters: control' graphics' font' countMessage' basicDescription' documentation
Long Parameter List,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,GetLeftHandSideDrawingSizeDrawHelpTip,The method has 7 parameters. Parameters: control' graphics' font' countMessage' basicDescription' documentation' p
Long Parameter List,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,DrawHelpTip,The method has 6 parameters. Parameters: control' graphics' font' countMessage' basicDescription' documentation
Long Parameter List,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,DrawFixedWidthHelpTip,The method has 6 parameters. Parameters: control' graphics' font' countMessage' basicDescription' documentation
Long Parameter List,ICSharpCode.TextEditor.Actions,ToggleLineComment,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,RemoveCommentAt,The method has 5 parameters. Parameters: document' comment' selection' y1' y2
Long Parameter List,ICSharpCode.TextEditor.Actions,ToggleLineComment,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,SetCommentAt,The method has 5 parameters. Parameters: document' comment' selection' y1' y2
Long Parameter List,ICSharpCode.TextEditor.Actions,ToggleLineComment,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,ShouldComment,The method has 5 parameters. Parameters: document' comment' selection' startLine' endLine
Long Parameter List,ICSharpCode.TextEditor.Actions,ToggleBlockComment,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,FindSelectedCommentRegion,The method has 5 parameters. Parameters: document' commentStart' commentEnd' selectionStartOffset' selectionEndOffset
Long Parameter List,ICSharpCode.TextEditor.Actions,ToggleBlockComment,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,SetCommentAt,The method has 5 parameters. Parameters: document' offsetStart' offsetEnd' commentStart' commentEnd
Long Parameter List,ICSharpCode.TextEditor.Gui.CompletionWindow,CodeCompletionWindow,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\CompletionWindow\CodeCompletionWindow.cs,ShowCompletionWindow,The method has 5 parameters. Parameters: parent' control' fileName' completionDataProvider' firstChar
Long Parameter List,ICSharpCode.TextEditor.Gui.CompletionWindow,CodeCompletionWindow,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\CompletionWindow\CodeCompletionWindow.cs,ShowCompletionWindow,The method has 7 parameters. Parameters: parent' control' fileName' completionDataProvider' firstChar' showDeclarationWindow' fixedListViewWidth
Long Parameter List,ICSharpCode.TextEditor.Gui.CompletionWindow,CodeCompletionWindow,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\CompletionWindow\CodeCompletionWindow.cs,CodeCompletionWindow,The method has 6 parameters. Parameters: completionDataProvider' completionData' parentForm' control' showDeclarationWindow' fixedListViewWidth
Long Identifier,ICSharpCode.TextEditor,Caret,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\Caret.cs,,The length of the parameter firePositionChangedAfterUpdateEnd is 33.
Long Statement,ICSharpCode.TextEditor.Document,DefaultFormattingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\FormattingStrategy\DefaultFormattingStrategy.cs,SmartReplaceLine,The length of the statement  "					document.Replace(lineOffset + pos + newLineTextTrim.Length' line.Length - pos - newLineTextTrim.Length' newLineText.Substring(newLineText.Length - endWhitespaceLength));" is 169.
Long Statement,ICSharpCode.TextEditor.Document,DefaultFormattingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\FormattingStrategy\DefaultFormattingStrategy.cs,IndentLine,The length of the statement  "					throw new NotSupportedException("Unsupported value for IndentStyle: " + textArea.Document.TextEditorProperties.IndentStyle);" is 124.
Long Statement,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,ResolveRuleSetReferences,The length of the statement  "							throw new HighlightingDefinitionInvalidException("The RuleSet " + aSpan.Rule + " could not be found in mode definition " + this.Name);" is 134.
Long Statement,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,ResolveExternalReferences,The length of the statement  "						throw new HighlightingDefinitionInvalidException("The mode defintion " + ruleSet.Reference + " which is refered from the " + this.Name + " mode definition could not be found");" is 176.
Long Statement,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,ResolveExternalReferences,The length of the statement  "						throw new HighlightingDefinitionInvalidException("The mode defintion " + ruleSet.Reference + " which is refered from the " + this.Name + " mode definition does not implement IHighlightingStrategyUsingRuleSets");" is 211.
Long Statement,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,MarkTokens,The length of the statement  "				currentSpanStack = ((previousLine != null && previousLine.HighlightSpanStack != null) ? previousLine.HighlightSpanStack.Clone() : null);" is 136.
Long Statement,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,MarkTokensInLine,The length of the statement  "			currentSpanStack = ((previousLine != null && previousLine.HighlightSpanStack != null) ? previousLine.HighlightSpanStack.Clone() : null);" is 136.
Long Statement,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,MarkTokens,The length of the statement  "//				document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.SingleLine' document.GetLineNumberForOffset(document.Caret.Offset)));" is 136.
Long Statement,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,ParseLine,The length of the statement  "				if (!inSpan && (Char.IsDigit(ch) || (ch == '.' && i + 1 < currentLineLength && Char.IsDigit(document.GetCharAt(currentLineOffset + i + 1)))) && currentLength == 0) {" is 165.
Long Statement,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,ParseLine,The length of the statement  "					if (ch == '0' && i + 1 < currentLineLength && Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1)) == 'X') { // hex digits" is 129.
Long Statement,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,ParseLine,The length of the statement  "						if (i + 1 < currentLineLength && (document.GetCharAt(currentLineOffset + i + 1) == '+' || document.GetCharAt(currentLine.Offset + i + 1) == '-')) {" is 147.
Long Statement,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,PushCurWord,The length of the statement  "//									document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.SingleLine' document.GetLineNumberForOffset(document.Caret.Offset)));" is 141.
Long Statement,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,PushCurWord,The length of the statement  "					words.Add(new TextWord(document' currentLine' currentOffset' currentLength' markNext != null ? markNext : c' hasDefaultColor));" is 127.
Long Statement,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,PushCurWord,The length of the statement  "					HighlightColor c = markNext != null ? markNext : GetColor(activeRuleSet' document' currentLine' currentOffset' currentLength);" is 126.
Long Statement,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,MatchExpr,The length of the statement  "											char docChar = ignoreCase ? Char.ToUpperInvariant(document.GetCharAt(lineSegment.Offset + index + j + k)) : document.GetCharAt(lineSegment.Offset + index + j + k);" is 163.
Long Statement,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,MatchExpr,The length of the statement  "											char docChar = ignoreCase ? Char.ToUpperInvariant(document.GetCharAt(lineSegment.Offset + index - whatmatch.Length + k)) : document.GetCharAt(lineSegment.Offset + index - whatmatch.Length + k);" is 193.
Long Statement,ICSharpCode.TextEditor.Document,HighlightingDefinitionParser,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\HighlightingDefinitionParser.cs,Parse,The length of the statement  "				Stream shemaStream = typeof(HighlightingDefinitionParser).Assembly.GetManifestResourceStream("ICSharpCode.TextEditor.Resources.Mode.xsd");" is 138.
Long Statement,ICSharpCode.TextEditor.Document,HighlightingDefinitionParser,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\HighlightingDefinitionParser.cs,Parse,The length of the statement  "					KeyValuePair<SyntaxMode' ISyntaxModeFileProvider> entry = HighlightingManager.Manager.FindHighlighterEntry(doc.DocumentElement.GetAttribute("extends"));" is 152.
Long Statement,ICSharpCode.TextEditor.Document,HighlightingDefinitionParser,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\HighlightingDefinitionParser.cs,Parse,The length of the statement  "						throw new HighlightingDefinitionInvalidException("Cannot find referenced highlighting source " + doc.DocumentElement.GetAttribute("extends"));" is 142.
Long Statement,ICSharpCode.TextEditor.Document,HighlightingDefinitionParser,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\HighlightingDefinitionParser.cs,Parse,The length of the statement  "								highlighter.SetColorFor(el.GetAttribute("name")' el.HasAttribute("bgcolor") ? new HighlightBackground(el) : new HighlightColor(el));" is 132.
Long Statement,ICSharpCode.TextEditor.Document,HighlightingDefinitionParser,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\HighlightingDefinitionParser.cs,Parse,The length of the statement  "				throw new HighlightingDefinitionInvalidException("Could not load mode definition file '" + syntaxMode.FileName + "'.\n"' e);" is 124.
Long Statement,ICSharpCode.TextEditor.Document,HighlightingManager,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\HighlightingManager.cs,LoadDefinition,The length of the statement  "					throw new HighlightingDefinitionInvalidException("The name specified in the .xshd '" + highlightingStrategy.Name + "' must be equal the syntax mode name '" + syntaxMode.Name + "'");" is 181.
Long Statement,ICSharpCode.TextEditor.Document,TextWord,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\TextWord.cs,Split,The length of the statement  "			TextWord after = new TextWord(word.document' word.line' word.offset + pos' word.length - pos' word.color' word.hasDefaultColor);" is 128.
Long Statement,ICSharpCode.TextEditor.Document,LineManager,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\LineManager\LineManager.cs,GetNextVisibleLineAbove,The length of the statement  "					while (curLineNumber < TotalNumberOfLines && (curLineNumber >= lineCollection.Count || !document.FoldingManager.IsLineVisible(curLineNumber))) {" is 144.
Long Statement,ICSharpCode.TextEditor.Document,LineSegment,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\LineManager\LineSegment.cs,ToString,The length of the statement  "				return "[LineSegment: (deleted) Length = " + Length + "' TotalLength = " + TotalLength + "' DelimiterLength = " + delimiterLength + "]";" is 136.
Long Statement,ICSharpCode.TextEditor.Document,LineSegment,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\LineManager\LineSegment.cs,ToString,The length of the statement  "				return "[LineSegment: LineNumber=" + LineNumber + "' Offset = "+ Offset +"' Length = " + Length + "' TotalLength = " + TotalLength + "' DelimiterLength = " + delimiterLength + "]";" is 180.
Long Statement,ICSharpCode.TextEditor.Document,LineLengthChangeEventArgs,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\LineManager\LineManagerEventArgs.cs,ToString,The length of the statement  "			return string.Format("[LineLengthEventArgs Document={0} LineSegment={1} LengthDelta={2}]"' this.Document' this.LineSegment' this.lengthDelta);" is 142.
Long Statement,ICSharpCode.TextEditor.Document,GapTextBufferStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\TextBufferStrategy\GapTextBufferStrategy.cs,GetText,The length of the statement  "				throw new ArgumentOutOfRangeException("length"' length' "0 <= length' offset(" + offset + ")+length <= " + Length.ToString());" is 126.
Long Statement,ICSharpCode.TextEditor.Document,GapTextBufferStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\TextBufferStrategy\GapTextBufferStrategy.cs,MakeNewBuffer,The length of the statement  "				Array.Copy(buffer' gapEndOffset' newBuffer' newBuffer.Length - (buffer.Length - gapEndOffset)' buffer.Length - gapEndOffset);" is 125.
Long Statement,ICSharpCode.TextEditor.Document,DefaultSelection,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\Selection\DefaultSelection.cs,ContainsPosition,The length of the statement  "				startPosition.Y == position.Y && startPosition.X <= position.X && (startPosition.Y != endPosition.Y || position.X <= endPosition.X) ||" is 134.
Long Statement,ICSharpCode.TextEditor.Document,SelectionManager,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\Selection\SelectionManager.cs,SetSelection,The length of the statement  "				document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.LinesBetween' selection.StartPosition.Y' selection.EndPosition.Y));" is 128.
Long Statement,ICSharpCode.TextEditor.Document,SelectionManager,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\Selection\SelectionManager.cs,ClearWithoutUpdate,The length of the statement  "				document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.LinesBetween' selection.StartPosition.Y' selection.EndPosition.Y));" is 128.
Long Statement,ICSharpCode.TextEditor.Document,SelectionManager,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\Selection\SelectionManager.cs,ClearSelection,The length of the statement  "			TextLocation newSelectionStart = textArea.TextView.GetLogicalPosition(mousepos.X - textArea.TextView.DrawingPosition.X' mousepos.Y - textArea.TextView.DrawingPosition.Y);" is 170.
Long Statement,ICSharpCode.TextEditor.Document,SyntaxMode,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\SyntaxModes\SyntaxMode.cs,ToString,The length of the statement  "			return String.Format("[SyntaxMode: FileName={0}' Name={1}' Extensions=({2})]"' fileName' name' String.Join("'"' extensions));" is 125.
Long Statement,ICSharpCode.TextEditor.Document,ResourceSyntaxModeProvider,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\SyntaxModes\ResourceSyntaxModeProvider.cs,GetSyntaxModeFile,The length of the statement  "			return new XmlTextReader(assembly.GetManifestResourceStream("ICSharpCode.TextEditor.Resources." + syntaxMode.FileName));" is 120.
Long Statement,ICSharpCode.TextEditor.Document,FileSyntaxModeProvider,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\SyntaxModes\FileSyntaxModeProvider.cs,GetSyntaxModeFile,The length of the statement  "				throw new HighlightingDefinitionInvalidException("Can't load highlighting definition " + syntaxModeFile + " (file not found)!");" is 128.
Long Statement,ICSharpCode.TextEditor,Caret,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\Caret.cs,UpdateCaretPosition,The length of the statement  "					if (textArea.MotherTextAreaControl.TextEditorProperties.LineViewerStyle == LineViewerStyle.FullRow && oldLine != line) {" is 120.
Long Statement,ICSharpCode.TextEditor,TextArea,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextArea.cs,SearchMatchingBracket,The length of the statement  "			if (textView.Highlight != null && textView.Highlight.OpenBrace.Y >=0 && textView.Highlight.OpenBrace.Y < Document.TotalNumberOfLines) {" is 135.
Long Statement,ICSharpCode.TextEditor,TextArea,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextArea.cs,SearchMatchingBracket,The length of the statement  "			if (textView.Highlight != null && textView.Highlight.CloseBrace.Y >=0 && textView.Highlight.CloseBrace.Y < Document.TotalNumberOfLines) {" is 137.
Long Statement,ICSharpCode.TextEditor,TextArea,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextArea.cs,OnMouseMove,The length of the statement  "				TextLocation realmousepos = TextView.GetLogicalPosition(e.X - TextView.DrawingPosition.X' e.Y - TextView.DrawingPosition.Y);" is 124.
Long Statement,ICSharpCode.TextEditor,TextArea,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextArea.cs,ReplaceChar,The length of the statement  "			if (Document.TextEditorProperties.DocumentSelectionMode == DocumentSelectionMode.Normal && SelectionManager.SelectionCollection.Count > 0) {" is 140.
Long Statement,ICSharpCode.TextEditor,TextArea,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextArea.cs,InvalidateLines,The length of the statement  "			int height    = Math.Min(textView.DrawingPosition.Height' (int)((1 + lineEnd - lineBegin) * (textView.FontHeight + 1)));" is 120.
Long Statement,ICSharpCode.TextEditor,TextEditorControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextEditorControl.cs,MeasurePrintingHeight,The length of the statement  "						SizeF drawingSize = g.MeasureString(word.Word' word.GetFont(fontContainer)' new SizeF(maxWidth' fontHeight * 100)' printingStringFormat);" is 137.
Long Statement,ICSharpCode.TextEditor,TextEditorControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextEditorControl.cs,DrawLine,The length of the statement  "						SizeF drawingSize = g.MeasureString(word.Word' word.GetFont(fontContainer)' new SizeF(margin.Width' fontHeight * 100)' printingStringFormat);" is 141.
Long Statement,ICSharpCode.TextEditor,TextEditorControlBase,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextEditorControlBase.cs,OnReloadHighlighting,The length of the statement  "					Document.HighlightingStrategy = HighlightingStrategyFactory.CreateHighlightingStrategy(Document.HighlightingStrategy.Name);" is 123.
Long Statement,ICSharpCode.TextEditor,TextAreaClipboardHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaClipboardHandler.cs,Cut,The length of the statement  "				textArea.SelectionManager.SetSelection(textArea.Document.OffsetToPosition(lineWhereCaretIs.Offset)' textArea.Document.OffsetToPosition(lineWhereCaretIs.Offset + lineWhereCaretIs.TotalLength));" is 192.
Long Statement,ICSharpCode.TextEditor,TextAreaClipboardHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaClipboardHandler.cs,Copy,The length of the statement  "			if (!CopyTextToClipboard(textArea.SelectionManager.SelectedText) && textArea.Document.TextEditorProperties.CutCopyWholeLine) {" is 126.
Long Statement,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,PaintDocumentLine,The length of the statement  "					List<FoldMarker> starts = textArea.Document.FoldingManager.GetFoldedFoldingsWithStartAfterColumn(lineNumber' column - 1);" is 121.
Long Statement,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,PaintDocumentLine,The length of the statement  "							physicalXPos = PaintLinePart(g' lineNumber' column' textArea.Document.GetLineSegment(lineNumber).Length' lineRectangle' physicalXPos);" is 134.
Long Statement,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,PaintDocumentLine,The length of the statement  "					bool drawSelected = ColumnRange.WholeColumn.Equals(selectionRange2) || firstFolding.StartColumn >= selectionRange2.StartColumn && firstFolding.EndColumn <= selectionRange2.EndColumn;" is 182.
Long Statement,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,PaintDocumentLine,The length of the statement  "				physicalXPos = PaintLinePart(g' lineNumber' 0' textArea.Document.GetLineSegment(lineNumber).Length' lineRectangle' physicalXPos);" is 129.
Long Statement,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,PaintDocumentLine,The length of the statement  "				bool  selectionBeyondEOL = selectionRange.EndColumn > currentLine.Length || ColumnRange.WholeColumn.Equals(selectionRange);" is 123.
Long Statement,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,PaintDocumentLine,The length of the statement  "					physicalXPos += DrawEOLMarker(g' eolMarkerColor.Color' selectionBeyondEOL ? bgColorBrush : backgroundBrush' physicalXPos' lineRectangle.Y);" is 139.
Long Statement,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,PaintDocumentLine,The length of the statement  "						g.FillRectangle(BrushRegistry.GetBrush(selectionColor.BackgroundColor)' new RectangleF(physicalXPos' lineRectangle.Y' WideSpaceWidth' lineRectangle.Height));" is 157.
Long Statement,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,PaintDocumentLine,The length of the statement  "				                new RectangleF(physicalXPos' lineRectangle.Y' lineRectangle.Width - physicalXPos + lineRectangle.X' lineRectangle.Height));" is 123.
Long Statement,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,DrawLineMarkerAtLine,The length of the statement  "			return lineNumber == base.textArea.Caret.Line && textArea.MotherTextAreaControl.TextEditorProperties.LineViewerStyle == LineViewerStyle.FullRow;" is 144.
Long Statement,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,PaintFoldingText,The length of the statement  "			Brush               bgColorBrush    = drawSelected ? BrushRegistry.GetBrush(selectionColor.BackgroundColor) : GetBgColorBrush(lineNumber);" is 138.
Long Statement,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,PaintFoldingText,The length of the statement  "			g.DrawRectangle(BrushRegistry.GetPen(drawSelected ? Color.DarkGray : Color.Gray)' rect.X' rect.Y' rect.Width' rect.Height);" is 123.
Long Statement,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,PaintLinePart,The length of the statement  "                IList<TextMarker> markers = Document.MarkerStrategy.GetMarkers(currentLine.Offset + currentWordOffset' currentWord.Length);" is 123.
Long Statement,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,PaintLinePart,The length of the statement  "						DrawBracketHighlight(g' new Rectangle((int)wordRectangle.X' lineRectangle.Y' (int)wordRectangle.Width - 1' lineRectangle.Height - 1));" is 134.
Long Statement,ICSharpCode.TextEditor,GutterMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\GutterMargin.cs,Paint,The length of the statement  "			Brush fillBrush = textArea.Enabled ? BrushRegistry.GetBrush(lineNumberPainterColor.BackgroundColor) : SystemBrushes.InactiveBorder;" is 131.
Long Statement,ICSharpCode.TextEditor,GutterMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\GutterMargin.cs,Paint,The length of the statement  "					int curLine = textArea.Document.GetFirstLogicalLine(textArea.Document.GetVisibleLine(textArea.TextView.FirstVisibleLine) + y);" is 126.
Long Statement,ICSharpCode.TextEditor,GutterMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\GutterMargin.cs,HandleMouseDown,The length of the statement  "								textArea.SelectionManager.SetSelection(new DefaultSelection(textArea.Document' selectionStartPos' new TextLocation(0' realline + 1)));" is 134.
Long Statement,ICSharpCode.TextEditor,GutterMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\GutterMargin.cs,HandleMouseDown,The length of the statement  "								textArea.SelectionManager.SetSelection(new DefaultSelection(textArea.Document' selectionStartPos' new TextLocation(textArea.Document.GetLineSegment(realline).Length + 1' realline)));" is 182.
Long Statement,ICSharpCode.TextEditor,GutterMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\GutterMargin.cs,HandleMouseDown,The length of the statement  "							textArea.SelectionManager.SetSelection(new DefaultSelection(textArea.Document' selectionStartPos' new TextLocation(selectionStartPos.X' selectionStartPos.Y)));" is 159.
Long Statement,ICSharpCode.TextEditor,GutterMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\GutterMargin.cs,HandleMouseDown,The length of the statement  "							textArea.SelectionManager.ExtendSelection(new TextLocation(selectionStartPos.X' selectionStartPos.Y)' new TextLocation(0' realline));" is 133.
Long Statement,ICSharpCode.TextEditor,GutterMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\GutterMargin.cs,HandleMouseDown,The length of the statement  "						textArea.SelectionManager.SetSelection(new DefaultSelection(textArea.Document' selectionStartPos' new TextLocation(selectionStartPos.X' selectionStartPos.Y + 1)));" is 163.
Long Statement,ICSharpCode.TextEditor,GutterMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\GutterMargin.cs,HandleMouseDown,The length of the statement  "						textArea.SelectionManager.SetSelection(new DefaultSelection(textArea.Document' new TextLocation(0' realline)' new TextLocation(textArea.Document.GetLineSegment(realline).Length + 1' selectionStartPos.Y)));" is 205.
Long Statement,ICSharpCode.TextEditor,TextAreaControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaControl.cs,SetScrollBarBounds,The length of the statement  "			vScrollBar.Bounds = new Rectangle(textArea.Bounds.Right' 0' SystemInformation.HorizontalScrollBarArrowWidth' Height - SystemInformation.VerticalScrollBarArrowHeight);" is 166.
Long Statement,ICSharpCode.TextEditor,TextAreaControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaControl.cs,AdjustScrollBars,The length of the statement  "			int lastLine = this.Document.GetFirstLogicalLine(textArea.TextView.FirstPhysicalLine + textArea.TextView.VisibleLineCount);" is 123.
Long Statement,ICSharpCode.TextEditor,TextAreaControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaControl.cs,ScrollTo,The length of the statement  "						hScrollBar.Value = (int)Math.Max(0' Math.Min(hScrollBar.Maximum' (pos - textArea.TextView.VisibleColumnCount + scrollMarginHeight)));" is 133.
Long Statement,ICSharpCode.TextEditor,TextAreaControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaControl.cs,ScrollTo,The length of the statement  "				this.vScrollBar.Value =  Math.Max(0' Math.Min(this.vScrollBar.Maximum' (line - scrollMarginHeight + 3) * textArea.TextView.FontHeight)) ;" is 137.
Long Statement,ICSharpCode.TextEditor,TextAreaControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaControl.cs,ScrollTo,The length of the statement  "						this.vScrollBar.Value =  Math.Max(0' Math.Min(this.vScrollBar.Maximum' (line - scrollMarginHeight - 1) * textArea.TextView.FontHeight)) ;" is 137.
Long Statement,ICSharpCode.TextEditor,TextAreaControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaControl.cs,CenterViewOn,The length of the statement  "				this.vScrollBar.Value =  Math.Max(0' Math.Min(this.vScrollBar.Maximum' (line - scrollMarginHeight + 3) * textArea.TextView.FontHeight)) ;" is 137.
Long Statement,ICSharpCode.TextEditor,TextAreaMouseHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaMouseHandler.cs,ExtendSelectionToMouse,The length of the statement  "			if (!minSelection.IsEmpty && textArea.SelectionManager.SelectionCollection.Count > 0 && textArea.SelectionManager.selectFrom.where == WhereFrom.TArea) {" is 152.
Long Statement,ICSharpCode.TextEditor,TextAreaMouseHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaMouseHandler.cs,ExtendSelectionToMouse,The length of the statement  "				if (textArea.SelectionManager.GreaterEqPos(max' realmousepos) && textArea.SelectionManager.GreaterEqPos(realmousepos' min)) {" is 125.
Long Statement,ICSharpCode.TextEditor,TextAreaMouseHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaMouseHandler.cs,OnMouseDown,The length of the statement  "						TextLocation realmousepos = textArea.TextView.GetLogicalPosition(mousepos.X - textArea.TextView.DrawingPosition.X' mousepos.Y - textArea.TextView.DrawingPosition.Y);" is 165.
Long Statement,ICSharpCode.TextEditor,TextAreaMouseHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaMouseHandler.cs,OnMouseDown,The length of the statement  "					TextLocation realmousepos = textArea.TextView.GetLogicalPosition(mousepos.X - textArea.TextView.DrawingPosition.X' mousepos.Y - textArea.TextView.DrawingPosition.Y);" is 165.
Long Statement,ICSharpCode.TextEditor,TextAreaMouseHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaMouseHandler.cs,FindWordStart,The length of the statement  "			} else  if (IsSelectableChar(document.GetCharAt(offset)) || (offset > 0 && Char.IsWhiteSpace(document.GetCharAt(offset)) && IsSelectableChar(document.GetCharAt(offset - 1))))  {" is 177.
Long Statement,ICSharpCode.TextEditor,TextAreaMouseHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaMouseHandler.cs,FindWordStart,The length of the statement  "				if (offset > 0 && !Char.IsWhiteSpace(document.GetCharAt(offset - 1)) && !IsSelectableChar(document.GetCharAt(offset - 1)) ) {" is 125.
Long Statement,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,Paint,The length of the statement  "			g.FillRectangle(SystemBrushes.Control' new Rectangle(drawingPosition.X' rect.Top' drawingPosition.Width - 1' rect.Height));" is 123.
Long Statement,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,Paint,The length of the statement  "			g.DrawLine(SystemPens.ControlDark' base.drawingPosition.Right - 1' rect.Top' base.drawingPosition.Right - 1' rect.Bottom);" is 122.
Long Statement,ICSharpCode.TextEditor,FoldMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\FoldMargin.cs,Paint,The length of the statement  "			for (int y = 0; y < (DrawingPosition.Height + textArea.TextView.VisibleLineDrawingRemainder) / textArea.TextView.FontHeight + 1; ++y) {" is 135.
Long Statement,ICSharpCode.TextEditor,FoldMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\FoldMargin.cs,Paint,The length of the statement  "						g.FillRectangle(BrushRegistry.GetBrush(textArea.Enabled ? lineNumberPainterColor.BackgroundColor : SystemColors.InactiveBorder)'" is 128.
Long Statement,ICSharpCode.TextEditor,FoldMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\FoldMargin.cs,Paint,The length of the statement  "						g.FillRectangle(BrushRegistry.GetBrush(textArea.Enabled ? lineNumberPainterColor.BackgroundColor : SystemColors.InactiveBorder)' markerRectangle);" is 146.
Long Statement,ICSharpCode.TextEditor,FoldMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\FoldMargin.cs,PaintFoldMarker,The length of the statement  "					g.DrawLine(BrushRegistry.GetPen(isEndSelected || (isStartSelected && isVisible) || isBetweenSelected ? selectedFoldLine.Color : foldLineColor.Color)'" is 149.
Long Statement,ICSharpCode.TextEditor,HRuler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\HRuler.cs,OnPaint,The length of the statement  "			for (float x = textArea.TextView.DrawingPosition.Left; x < textArea.TextView.DrawingPosition.Right; x += textArea.TextView.WideSpaceWidth) {" is 140.
Long Statement,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,GetLeftHandSideDrawingSizeHelpTipFromCombinedDescription,The length of the statement  "			return GetLeftHandSideDrawingSizeDrawHelpTip(control' graphics' font' countMessage' basicDescription' documentation' p);" is 120.
Long Statement,ICSharpCode.TextEditor.Util,WeakCollection<T>,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\WeakCollection.cs,CheckNoEnumerator,The length of the statement  "				throw new InvalidOperationException("The WeakCollection is already being enumerated' it cannot be modified at the same time. Ensure you dispose the first enumerator before modifying the WeakCollection.");" is 204.
Long Statement,ICSharpCode.TextEditor.Util,WeakCollection<T>,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\WeakCollection.cs,GetEnumerator,The length of the statement  "				throw new InvalidOperationException("The WeakCollection is already being enumerated' it cannot be enumerated twice at the same time. Ensure you dispose the first enumerator before using another enumerator.");" is 208.
Long Statement,ICSharpCode.TextEditor.Actions,CaretUp,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\CaretActions.cs,Execute,The length of the statement  "				                      textArea.TextView.DrawingPosition.Y + (visualLine - 1) * textArea.TextView.FontHeight - textArea.TextView.TextArea.VirtualTop.Y);" is 129.
Long Statement,ICSharpCode.TextEditor.Actions,ShiftTab,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,RemoveTabs,The length of the statement  "					string newLine = TextUtilities.LeadingWhiteSpaceToTabs(document.GetText(line.Offset'line.Length)'document.Properties.Get("TabIndent"' 4));" is 138.
Long Statement,ICSharpCode.TextEditor.Actions,ShiftTab,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,RemoveTabs,The length of the statement  "							for (leadingSpaces = 1; leadingSpaces < line.Length && document.GetCharAt(line.Offset + leadingSpaces) == ' '; leadingSpaces++) {" is 129.
Long Statement,ICSharpCode.TextEditor.Actions,ToggleBlockComment,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,Execute,The length of the statement  "				selectionEndOffset = textArea.SelectionManager.SelectionCollection[textArea.SelectionManager.SelectionCollection.Count - 1].EndOffset;" is 134.
Long Statement,ICSharpCode.TextEditor.Actions,ToggleBlockComment,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,Execute,The length of the statement  "			BlockCommentRegion commentRegion = FindSelectedCommentRegion(textArea.Document' commentStart' commentEnd' selectionStartOffset' selectionEndOffset);" is 148.
Long Statement,ICSharpCode.TextEditor.Actions,BlockCommentRegion,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,Equals,The length of the statement  "			return this.commentStart == other.commentStart && this.commentEnd == other.commentEnd && this.startOffset == other.startOffset && this.endOffset == other.endOffset;" is 164.
Long Statement,ICSharpCode.TextEditor.Actions,Backspace,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,Execute,The length of the statement  "						textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.PositionToEnd' new TextLocation(0' curLineNr - 1)));" is 122.
Long Statement,ICSharpCode.TextEditor.Actions,Backspace,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,Execute,The length of the statement  "						textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.PositionToLineEnd' new TextLocation(textArea.Caret.Offset - textArea.Document.GetLineSegment(curLineNr).Offset' curLineNr)));" is 195.
Long Statement,ICSharpCode.TextEditor.Actions,Delete,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,Execute,The length of the statement  "//						textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.PositionToLineEnd' new TextLocation(textArea.Caret.Offset - textArea.Document.GetLineSegment(curLineNr).Offset' curLineNr)));" is 203.
Long Statement,ICSharpCode.TextEditor.Actions,MovePageDown,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,Execute,The length of the statement  "			int requestedLineNumber = Math.Min(textArea.Document.GetNextVisibleLineAbove(curLineNr' textArea.TextView.VisibleLineCount)' textArea.Document.TotalNumberOfLines - 1);" is 167.
Long Statement,ICSharpCode.TextEditor.Actions,MovePageUp,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,Execute,The length of the statement  "			int requestedLineNumber = Math.Max(textArea.Document.GetNextVisibleLineBelow(curLineNr' textArea.TextView.VisibleLineCount)' 0);" is 128.
Long Statement,ICSharpCode.TextEditor.Actions,Return,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,Execute,The length of the statement  "				textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.PositionToEnd' new TextLocation(0' curLineNr - 1)));" is 122.
Long Statement,ICSharpCode.TextEditor.Actions,WordBackspace,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,Execute,The length of the statement  "			textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.PositionToEnd' new TextLocation(0' textArea.Document.GetLineNumberForOffset(textArea.Caret.Offset))));" is 172.
Long Statement,ICSharpCode.TextEditor.Actions,DeleteWord,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,Execute,The length of the statement  "			textArea.Document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.PositionToEnd' new TextLocation(0' textArea.Document.GetLineNumberForOffset(textArea.Caret.Offset))));" is 172.
Long Statement,ICSharpCode.TextEditor.Actions,ConvertLeadingTabsToSpaces,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\FormatActions.cs,Convert,The length of the statement  "					for(whiteSpace = 0; whiteSpace < line.Length && Char.IsWhiteSpace(document.GetCharAt(line.Offset + whiteSpace)); whiteSpace++) {" is 128.
Long Statement,ICSharpCode.TextEditor.Actions,ConvertLeadingSpacesToTabs,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\FormatActions.cs,Convert,The length of the statement  "					string newLine = TextUtilities.LeadingWhiteSpaceToTabs(document.GetText(line.Offset'line.Length)' document.TextEditorProperties.TabIndent);" is 139.
Long Statement,ICSharpCode.TextEditor.Gui.CompletionWindow,CodeCompletionWindow,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\CompletionWindow\CodeCompletionWindow.cs,ShowCompletionWindow,The length of the statement  "			ICompletionData[] completionData = completionDataProvider.GenerateCompletionData(fileName' control.ActiveTextAreaControl.TextArea' firstChar);" is 142.
Long Statement,ICSharpCode.TextEditor.Gui.CompletionWindow,CodeCompletionWindow,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\CompletionWindow\CodeCompletionWindow.cs,ShowCompletionWindow,The length of the statement  "			CodeCompletionWindow codeCompletionWindow = new CodeCompletionWindow(completionDataProvider' completionData' parent' control' showDeclarationWindow' fixedListViewWidth);" is 169.
Long Statement,ICSharpCode.TextEditor.Gui.InsightWindow,InsightWindow,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\InsightWindow\InsightWindow.cs,CaretOffsetChanged,The length of the statement  "			int ypos = (control.ActiveTextAreaControl.Document.GetVisibleLine(caretPos.Y) + 1) * control.ActiveTextAreaControl.TextArea.TextView.FontHeight" is 143.
Long Statement,ICSharpCode.TextEditor.Gui.InsightWindow,InsightWindow,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\InsightWindow\InsightWindow.cs,CaretOffsetChanged,The length of the statement  "			int rulerHeight = control.TextEditorProperties.ShowHorizontalRuler ? control.ActiveTextAreaControl.TextArea.TextView.FontHeight : 0;" is 132.
Complex Conditional,ICSharpCode.TextEditor.Document,BookmarkManager,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\BookmarkManager\BookmarkManager.cs,GetFirstMark,The conditional expression  "predicate(bookmark[i]) && bookmark[i].IsEnabled && (first == null || bookmark[i].LineNumber < first.LineNumber)"  is complex.
Complex Conditional,ICSharpCode.TextEditor.Document,BookmarkManager,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\BookmarkManager\BookmarkManager.cs,GetLastMark,The conditional expression  "predicate(bookmark[i]) && bookmark[i].IsEnabled && (last == null || bookmark[i].LineNumber > last.LineNumber)"  is complex.
Complex Conditional,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,ParseLine,The conditional expression  "activeSpan != null && activeSpan.End != null && activeSpan.End.Length == 1 						&& escapeCharacter == activeSpan.End[0]"  is complex.
Complex Conditional,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,ParseLine,The conditional expression  "!inSpan && (Char.IsDigit(ch) || (ch == '.' && i + 1 < currentLineLength && Char.IsDigit(document.GetCharAt(currentLineOffset + i + 1)))) && currentLength == 0"  is complex.
Complex Conditional,ICSharpCode.TextEditor.Document,FoldingManager,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\FoldingStrategy\FoldingManager.cs,GetFoldingsFromPosition,The conditional expression  "(fm.StartLine == line && column > fm.StartColumn && !(fm.EndLine == line && column >= fm.EndColumn)) || 					    (fm.EndLine == line && column < fm.EndColumn && !(fm.StartLine == line && column <= fm.StartColumn)) || 					    (line > fm.StartLine && line < fm.EndLine)"  is complex.
Complex Conditional,ICSharpCode.TextEditor.Document,FoldingManager,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\FoldingStrategy\FoldingManager.cs,GetTopLevelFoldedFoldings,The conditional expression  "fm.IsFolded && (fm.StartLine > end.Y || fm.StartLine == end.Y && fm.StartColumn >= end.X)"  is complex.
Complex Conditional,ICSharpCode.TextEditor.Document,MarkerStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\MarkerStrategy\MarkerStrategy.cs,GetMarkers,The conditional expression  "markerOffset <= offset && offset <= markerEndOffset || 				    // end in marker region                     markerOffset <= endOffset && endOffset <= markerEndOffset || 				    // marker start in region                     offset <= markerOffset && markerOffset <= endOffset || 				    // marker end in region                     offset <= markerEndOffset && markerEndOffset <= endOffset"  is complex.
Complex Conditional,ICSharpCode.TextEditor,Ime,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\Ime.cs,Ime,The conditional expression  "PROCESSOR_ARCHITEW6432 == "IA64" || PROCESSOR_ARCHITEW6432 == "AMD64" || Environment.OSVersion.Platform == PlatformID.Unix || Environment.Version >= new Version(4'0)"  is complex.
Complex Conditional,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,PaintLinePart,The conditional expression  "highlight.OpenBrace.Y == lineNumber && highlight.OpenBrace.X == currentWordOffset || 					    highlight.CloseBrace.Y == lineNumber && highlight.CloseBrace.X == currentWordOffset"  is complex.
Complex Conditional,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,GetDrawingXPos,The conditional expression  "f == null || !(f.StartLine < logicalLine || f.StartLine == logicalLine && f.StartColumn < logicalColumn)"  is complex.
Complex Conditional,ICSharpCode.TextEditor,TextAreaMouseHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaMouseHandler.cs,FindWordStart,The conditional expression  "IsSelectableChar(document.GetCharAt(offset)) || (offset > 0 && Char.IsWhiteSpace(document.GetCharAt(offset)) && IsSelectableChar(document.GetCharAt(offset - 1)))"  is complex.
Complex Conditional,ICSharpCode.TextEditor.Util,AugmentableRedBlackTree<T;Host>,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\AugmentableRedBlackTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == BLACK 			    && sibling.color == BLACK 			    && GetColor(sibling.left) == BLACK 			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.TextEditor.Util,AugmentableRedBlackTree<T;Host>,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\AugmentableRedBlackTree.cs,FixTreeOnDelete,The conditional expression  "parentNode.color == RED 			    && sibling.color == BLACK 			    && GetColor(sibling.left) == BLACK 			    && GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.TextEditor.Util,AugmentableRedBlackTree<T;Host>,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\AugmentableRedBlackTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.left && 			    sibling.color == BLACK && 			    GetColor(sibling.left) == RED && 			    GetColor(sibling.right) == BLACK"  is complex.
Complex Conditional,ICSharpCode.TextEditor.Util,AugmentableRedBlackTree<T;Host>,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\AugmentableRedBlackTree.cs,FixTreeOnDelete,The conditional expression  "node == parentNode.right && 			         sibling.color == BLACK && 			         GetColor(sibling.right) == RED && 			         GetColor(sibling.left) == BLACK"  is complex.
Complex Conditional,ICSharpCode.TextEditor.Actions,ToggleBlockComment,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,Execute,The conditional expression  "commentStart == null || commentStart.Length == 0 || commentEnd == null || commentEnd.Length == 0"  is complex.
Complex Conditional,ICSharpCode.TextEditor.Gui.CompletionWindow,CodeCompletionWindow,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\CompletionWindow\CodeCompletionWindow.cs,CodeCompletionListViewSelectedItemChanged,The conditional expression  "showDeclarationWindow && data != null && data.Description != null && data.Description.Length > 0"  is complex.
Virtual Method Call from Constructor,ICSharpCode.TextEditor,TextEditorControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextEditorControl.cs,TextEditorControl,The constructor "TextEditorControl" calls a virtual method "InitializeTextAreaControl".
Virtual Method Call from Constructor,ICSharpCode.TextEditor.Gui.CompletionWindow,AbstractCompletionWindow,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\CompletionWindow\AbstractCompletionWindow.cs,AbstractCompletionWindow,The constructor "AbstractCompletionWindow" calls a virtual method "SetLocation".
Empty Catch Block,ICSharpCode.TextEditor.Document,FoldingManager,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\FoldingStrategy\FoldingManager.cs,DeserializeFromString,The method has an empty catch block.
Empty Catch Block,ICSharpCode.TextEditor,TextAreaClipboardHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaClipboardHandler.cs,SafeSetClipboard,The method has an empty catch block.
Magic Number,ICSharpCode.TextEditor.Document,TextUtilities,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\TextUtilities.cs,GetExpressionBeforeOffset,The following statement contains a magic number: while (offset - 1 > 0) { 				switch (document.GetCharAt(offset - 1)) { 					case '\n': 					case '\r': 					case '}': 						goto done; //						offset = SearchBracketBackward(document' offset - 2' '{'''}'); //						break; 					case ']': 						offset = SearchBracketBackward(document' offset - 2' '[''']'); 						break; 					case ')': 						offset = SearchBracketBackward(document' offset - 2' '(''')'); 						break; 					case '.': 						--offset; 						break; 					case '"': 						if (offset < initialOffset - 1) { 							return null; 						} 						return "\"\""; 					case '\'': 						if (offset < initialOffset - 1) { 							return null; 						} 						return "'a'"; 					case '>': 						if (document.GetCharAt(offset - 2) == '-') { 							offset -= 2; 							break; 						} 						goto done; 					default: 						if (Char.IsWhiteSpace(document.GetCharAt(offset - 1))) { 							--offset; 							break; 						} 						int start = offset - 1; 						if (!IsLetterDigitOrUnderscore(document.GetCharAt(start))) { 							goto done; 						} 						 						while (start > 0 && IsLetterDigitOrUnderscore(document.GetCharAt(start - 1))) { 							--start; 						} 						string word = document.GetText(start' offset - start).Trim(); 						switch (word) { 							case "ref": 							case "out": 							case "in": 							case "return": 							case "throw": 							case "case": 								goto done; 						} 						 						if (word.Length > 0 && !IsLetterDigitOrUnderscore(word[0])) { 							goto done; 						} 						offset = start; 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor.Document,TextUtilities,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\TextUtilities.cs,GetExpressionBeforeOffset,The following statement contains a magic number: while (offset - 1 > 0) { 				switch (document.GetCharAt(offset - 1)) { 					case '\n': 					case '\r': 					case '}': 						goto done; //						offset = SearchBracketBackward(document' offset - 2' '{'''}'); //						break; 					case ']': 						offset = SearchBracketBackward(document' offset - 2' '[''']'); 						break; 					case ')': 						offset = SearchBracketBackward(document' offset - 2' '(''')'); 						break; 					case '.': 						--offset; 						break; 					case '"': 						if (offset < initialOffset - 1) { 							return null; 						} 						return "\"\""; 					case '\'': 						if (offset < initialOffset - 1) { 							return null; 						} 						return "'a'"; 					case '>': 						if (document.GetCharAt(offset - 2) == '-') { 							offset -= 2; 							break; 						} 						goto done; 					default: 						if (Char.IsWhiteSpace(document.GetCharAt(offset - 1))) { 							--offset; 							break; 						} 						int start = offset - 1; 						if (!IsLetterDigitOrUnderscore(document.GetCharAt(start))) { 							goto done; 						} 						 						while (start > 0 && IsLetterDigitOrUnderscore(document.GetCharAt(start - 1))) { 							--start; 						} 						string word = document.GetText(start' offset - start).Trim(); 						switch (word) { 							case "ref": 							case "out": 							case "in": 							case "return": 							case "throw": 							case "case": 								goto done; 						} 						 						if (word.Length > 0 && !IsLetterDigitOrUnderscore(word[0])) { 							goto done; 						} 						offset = start; 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor.Document,TextUtilities,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\TextUtilities.cs,GetExpressionBeforeOffset,The following statement contains a magic number: while (offset - 1 > 0) { 				switch (document.GetCharAt(offset - 1)) { 					case '\n': 					case '\r': 					case '}': 						goto done; //						offset = SearchBracketBackward(document' offset - 2' '{'''}'); //						break; 					case ']': 						offset = SearchBracketBackward(document' offset - 2' '[''']'); 						break; 					case ')': 						offset = SearchBracketBackward(document' offset - 2' '(''')'); 						break; 					case '.': 						--offset; 						break; 					case '"': 						if (offset < initialOffset - 1) { 							return null; 						} 						return "\"\""; 					case '\'': 						if (offset < initialOffset - 1) { 							return null; 						} 						return "'a'"; 					case '>': 						if (document.GetCharAt(offset - 2) == '-') { 							offset -= 2; 							break; 						} 						goto done; 					default: 						if (Char.IsWhiteSpace(document.GetCharAt(offset - 1))) { 							--offset; 							break; 						} 						int start = offset - 1; 						if (!IsLetterDigitOrUnderscore(document.GetCharAt(start))) { 							goto done; 						} 						 						while (start > 0 && IsLetterDigitOrUnderscore(document.GetCharAt(start - 1))) { 							--start; 						} 						string word = document.GetText(start' offset - start).Trim(); 						switch (word) { 							case "ref": 							case "out": 							case "in": 							case "return": 							case "throw": 							case "case": 								goto done; 						} 						 						if (word.Length > 0 && !IsLetterDigitOrUnderscore(word[0])) { 							goto done; 						} 						offset = start; 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor.Document,TextUtilities,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\TextUtilities.cs,GetExpressionBeforeOffset,The following statement contains a magic number: while (offset - 1 > 0) { 				switch (document.GetCharAt(offset - 1)) { 					case '\n': 					case '\r': 					case '}': 						goto done; //						offset = SearchBracketBackward(document' offset - 2' '{'''}'); //						break; 					case ']': 						offset = SearchBracketBackward(document' offset - 2' '[''']'); 						break; 					case ')': 						offset = SearchBracketBackward(document' offset - 2' '(''')'); 						break; 					case '.': 						--offset; 						break; 					case '"': 						if (offset < initialOffset - 1) { 							return null; 						} 						return "\"\""; 					case '\'': 						if (offset < initialOffset - 1) { 							return null; 						} 						return "'a'"; 					case '>': 						if (document.GetCharAt(offset - 2) == '-') { 							offset -= 2; 							break; 						} 						goto done; 					default: 						if (Char.IsWhiteSpace(document.GetCharAt(offset - 1))) { 							--offset; 							break; 						} 						int start = offset - 1; 						if (!IsLetterDigitOrUnderscore(document.GetCharAt(start))) { 							goto done; 						} 						 						while (start > 0 && IsLetterDigitOrUnderscore(document.GetCharAt(start - 1))) { 							--start; 						} 						string word = document.GetText(start' offset - start).Trim(); 						switch (word) { 							case "ref": 							case "out": 							case "in": 							case "return": 							case "throw": 							case "case": 								goto done; 						} 						 						if (word.Length > 0 && !IsLetterDigitOrUnderscore(word[0])) { 							goto done; 						} 						offset = start; 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,MarkTokens,The following statement contains a magic number: if (spanChanged || inputLines.Count > 20) { 				// if the span was changed (more than inputLines lines had to be reevaluated) 				// or if there are many lines in inputLines' it's faster to update the whole 				// text area instead of many small segments 				document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.WholeTextArea)); 			} else { //				document.Caret.ValidateCaretPos(); //				document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.SingleLine' document.GetLineNumberForOffset(document.Caret.Offset))); // 				foreach (LineSegment lineToProcess in inputLines) { 					document.RequestUpdate(new TextAreaUpdate(TextAreaUpdateType.SingleLine' lineToProcess.LineNumber)); 				} 				 			}
Magic Number,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,ParseLine,The following statement contains a magic number: for (int i = 0; i < currentLineLength; ++i) 			{ 			    char ch = document.GetCharAt(currentLineOffset + i); 			    switch (ch) 			    { 			        case '\n': 			        case '\r': 			            PushCurWord(document' ref markNext' words); 			            ++currentOffset; 			            continue; 			        case ' ': 			            PushCurWord(document' ref markNext' words); 			            if (activeSpan != null && activeSpan.Color.HasBackground) 			            { 			                words.Add(new TextWord.SpaceTextWord(activeSpan.Color)); 			            } 			            else 			            { 			                words.Add(TextWord.Space); 			            } 			            ++currentOffset; 			            continue; 			        case '\t': 			            PushCurWord(document' ref markNext' words); 			            if (activeSpan != null && activeSpan.Color.HasBackground) 			            { 			                words.Add(new TextWord.TabTextWord(activeSpan.Color)); 			            } 			            else 			            { 			                words.Add(TextWord.Tab); 			            } 			            ++currentOffset; 			            continue; 			    }     		    // handle escape characters 				char escapeCharacter = '\0'; 				if (activeSpan != null && activeSpan.EscapeCharacter != '\0') { 					escapeCharacter = activeSpan.EscapeCharacter; 				} else if (activeRuleSet != null) { 					escapeCharacter = activeRuleSet.EscapeCharacter; 				} 				if (escapeCharacter != '\0' && escapeCharacter == ch) { 					// we found the escape character 					if (activeSpan != null && activeSpan.End != null && activeSpan.End.Length == 1 						&& escapeCharacter == activeSpan.End[0]) 					{ 						// the escape character is a end-doubling escape character 						// it may count as escape only when the next character is the escape' too 						if (i + 1 < currentLineLength) { 							if (document.GetCharAt(currentLineOffset + i + 1) == escapeCharacter) { 								currentLength += 2; 								PushCurWord(document' ref markNext' words); 								++i; 								continue; 							} 						} 					} else { 						// this is a normal \-style escape 						++currentLength; 						if (i + 1 < currentLineLength) { 							++currentLength; 						} 						PushCurWord(document' ref markNext' words); 						++i; 						continue; 					} 				} 							 				// highlight digits 				if (!inSpan && (Char.IsDigit(ch) || (ch == '.' && i + 1 < currentLineLength && Char.IsDigit(document.GetCharAt(currentLineOffset + i + 1)))) && currentLength == 0) { 					bool ishex = false; 					bool isfloatingpoint = false; 								 					if (ch == '0' && i + 1 < currentLineLength && Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1)) == 'X') { // hex digits 						const string hex = "0123456789ABCDEF"; 						++currentLength; 						++i; // skip 'x' 						++currentLength; 						ishex = true; 						while (i + 1 < currentLineLength && hex.IndexOf(Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1))) != -1) { 							++i; 							++currentLength; 						} 					} else { 						++currentLength; 						while (i + 1 < currentLineLength && Char.IsDigit(document.GetCharAt(currentLineOffset + i + 1))) { 							++i; 							++currentLength; 						} 					} 					if (!ishex && i + 1 < currentLineLength && document.GetCharAt(currentLineOffset + i + 1) == '.') { 						isfloatingpoint = true; 						++i; 						++currentLength; 						while (i + 1 < currentLineLength && Char.IsDigit(document.GetCharAt(currentLineOffset + i + 1))) { 							++i; 							++currentLength; 						} 					} 								 					if (i + 1 < currentLineLength && Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1)) == 'E') { 						isfloatingpoint = true; 						++i; 						++currentLength; 						if (i + 1 < currentLineLength && (document.GetCharAt(currentLineOffset + i + 1) == '+' || document.GetCharAt(currentLine.Offset + i + 1) == '-')) { 							++i; 							++currentLength; 						} 						while (i + 1 < currentLine.Length && Char.IsDigit(document.GetCharAt(currentLineOffset + i + 1))) { 							++i; 							++currentLength; 						} 					} 								 					if (i + 1 < currentLine.Length) { 						char nextch = Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1)); 						if (nextch == 'F' || nextch == 'M' || nextch == 'D') { 							isfloatingpoint = true; 							++i; 							++currentLength; 						} 					} 								 					if (!isfloatingpoint) { 						bool isunsigned = false; 						if (i + 1 < currentLineLength && Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1)) == 'U') { 							++i; 							++currentLength; 							isunsigned = true; 						} 						if (i + 1 < currentLineLength && Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1)) == 'L') { 							++i; 							++currentLength; 							if (!isunsigned && i + 1 < currentLineLength && Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1)) == 'U') { 								++i; 								++currentLength; 							} 						} 					} 								 					words.Add(new TextWord(document' currentLine' currentOffset' currentLength' DigitColor' false)); 					currentOffset += currentLength; 					currentLength = 0; 					continue; 				}  				// Check for SPAN ENDs 				if (inSpan) { 					if (activeSpan.End != null && activeSpan.End.Length > 0) { 						if (MatchExpr(currentLine' activeSpan.End' i' document' activeSpan.IgnoreCase)) { 							PushCurWord(document' ref markNext' words); 							string regex = GetRegString(currentLine' activeSpan.End' i' document); 							currentLength += regex.Length; 							words.Add(new TextWord(document' currentLine' currentOffset' currentLength' activeSpan.EndColor' false)); 							currentOffset += currentLength; 							currentLength = 0; 							i += regex.Length - 1; 							currentSpanStack.Pop(); 							UpdateSpanStateVariables(); 							continue; 						} 					} 				}                  // check for SPAN BEGIN                 if (activeRuleSet != null) {                     Span mySpan = null;                     foreach (Span span in activeRuleSet.Spans)                     {                         if (span.IsBeginSingleWord && currentLength != 0)                             continue;                         if (span.IsBeginStartOfLine.HasValue &&                             span.IsBeginStartOfLine.Value !=                             (currentLength == 0 && words.TrueForAll(                                 delegate(TextWord textWord) { return textWord.Type != TextWordType.Word; })))                             continue;                         if (!MatchExpr(currentLine' span.Begin' i' document' activeRuleSet.IgnoreCase))                             continue;                         mySpan = span;                         break;                     }                     if (mySpan != null)                     {                         PushCurWord(document' ref markNext' words);                         string regex = GetRegString(currentLine' mySpan.Begin' i' document);                          if (!OverrideSpan(regex' document' words' mySpan' ref i))                         {                             currentLength += regex.Length;                             words.Add(new TextWord(document' currentLine' currentOffset' currentLength' mySpan.BeginColor' false));                             currentOffset += currentLength;                             currentLength = 0;                              i += regex.Length - 1;                             if (currentSpanStack == null)                                 currentSpanStack = new SpanStack();                             currentSpanStack.Push(mySpan);                             mySpan.IgnoreCase = activeRuleSet.IgnoreCase;                              UpdateSpanStateVariables();                         }                         continue;                     }                 } 							 				// check if the char is a delimiter 				if (activeRuleSet != null && (int)ch < 256 && activeRuleSet.Delimiters[(int)ch]) { 					PushCurWord(document' ref markNext' words); 					if (currentOffset + currentLength +1 < currentLine.Length) { 						++currentLength;                         PushCurWord(document' ref markNext' words);                         continue; 					} 				}                  ++currentLength; 			}
Magic Number,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,ParseLine,The following statement contains a magic number: for (int i = 0; i < currentLineLength; ++i) 			{ 			    char ch = document.GetCharAt(currentLineOffset + i); 			    switch (ch) 			    { 			        case '\n': 			        case '\r': 			            PushCurWord(document' ref markNext' words); 			            ++currentOffset; 			            continue; 			        case ' ': 			            PushCurWord(document' ref markNext' words); 			            if (activeSpan != null && activeSpan.Color.HasBackground) 			            { 			                words.Add(new TextWord.SpaceTextWord(activeSpan.Color)); 			            } 			            else 			            { 			                words.Add(TextWord.Space); 			            } 			            ++currentOffset; 			            continue; 			        case '\t': 			            PushCurWord(document' ref markNext' words); 			            if (activeSpan != null && activeSpan.Color.HasBackground) 			            { 			                words.Add(new TextWord.TabTextWord(activeSpan.Color)); 			            } 			            else 			            { 			                words.Add(TextWord.Tab); 			            } 			            ++currentOffset; 			            continue; 			    }     		    // handle escape characters 				char escapeCharacter = '\0'; 				if (activeSpan != null && activeSpan.EscapeCharacter != '\0') { 					escapeCharacter = activeSpan.EscapeCharacter; 				} else if (activeRuleSet != null) { 					escapeCharacter = activeRuleSet.EscapeCharacter; 				} 				if (escapeCharacter != '\0' && escapeCharacter == ch) { 					// we found the escape character 					if (activeSpan != null && activeSpan.End != null && activeSpan.End.Length == 1 						&& escapeCharacter == activeSpan.End[0]) 					{ 						// the escape character is a end-doubling escape character 						// it may count as escape only when the next character is the escape' too 						if (i + 1 < currentLineLength) { 							if (document.GetCharAt(currentLineOffset + i + 1) == escapeCharacter) { 								currentLength += 2; 								PushCurWord(document' ref markNext' words); 								++i; 								continue; 							} 						} 					} else { 						// this is a normal \-style escape 						++currentLength; 						if (i + 1 < currentLineLength) { 							++currentLength; 						} 						PushCurWord(document' ref markNext' words); 						++i; 						continue; 					} 				} 							 				// highlight digits 				if (!inSpan && (Char.IsDigit(ch) || (ch == '.' && i + 1 < currentLineLength && Char.IsDigit(document.GetCharAt(currentLineOffset + i + 1)))) && currentLength == 0) { 					bool ishex = false; 					bool isfloatingpoint = false; 								 					if (ch == '0' && i + 1 < currentLineLength && Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1)) == 'X') { // hex digits 						const string hex = "0123456789ABCDEF"; 						++currentLength; 						++i; // skip 'x' 						++currentLength; 						ishex = true; 						while (i + 1 < currentLineLength && hex.IndexOf(Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1))) != -1) { 							++i; 							++currentLength; 						} 					} else { 						++currentLength; 						while (i + 1 < currentLineLength && Char.IsDigit(document.GetCharAt(currentLineOffset + i + 1))) { 							++i; 							++currentLength; 						} 					} 					if (!ishex && i + 1 < currentLineLength && document.GetCharAt(currentLineOffset + i + 1) == '.') { 						isfloatingpoint = true; 						++i; 						++currentLength; 						while (i + 1 < currentLineLength && Char.IsDigit(document.GetCharAt(currentLineOffset + i + 1))) { 							++i; 							++currentLength; 						} 					} 								 					if (i + 1 < currentLineLength && Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1)) == 'E') { 						isfloatingpoint = true; 						++i; 						++currentLength; 						if (i + 1 < currentLineLength && (document.GetCharAt(currentLineOffset + i + 1) == '+' || document.GetCharAt(currentLine.Offset + i + 1) == '-')) { 							++i; 							++currentLength; 						} 						while (i + 1 < currentLine.Length && Char.IsDigit(document.GetCharAt(currentLineOffset + i + 1))) { 							++i; 							++currentLength; 						} 					} 								 					if (i + 1 < currentLine.Length) { 						char nextch = Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1)); 						if (nextch == 'F' || nextch == 'M' || nextch == 'D') { 							isfloatingpoint = true; 							++i; 							++currentLength; 						} 					} 								 					if (!isfloatingpoint) { 						bool isunsigned = false; 						if (i + 1 < currentLineLength && Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1)) == 'U') { 							++i; 							++currentLength; 							isunsigned = true; 						} 						if (i + 1 < currentLineLength && Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1)) == 'L') { 							++i; 							++currentLength; 							if (!isunsigned && i + 1 < currentLineLength && Char.ToUpper(document.GetCharAt(currentLineOffset + i + 1)) == 'U') { 								++i; 								++currentLength; 							} 						} 					} 								 					words.Add(new TextWord(document' currentLine' currentOffset' currentLength' DigitColor' false)); 					currentOffset += currentLength; 					currentLength = 0; 					continue; 				}  				// Check for SPAN ENDs 				if (inSpan) { 					if (activeSpan.End != null && activeSpan.End.Length > 0) { 						if (MatchExpr(currentLine' activeSpan.End' i' document' activeSpan.IgnoreCase)) { 							PushCurWord(document' ref markNext' words); 							string regex = GetRegString(currentLine' activeSpan.End' i' document); 							currentLength += regex.Length; 							words.Add(new TextWord(document' currentLine' currentOffset' currentLength' activeSpan.EndColor' false)); 							currentOffset += currentLength; 							currentLength = 0; 							i += regex.Length - 1; 							currentSpanStack.Pop(); 							UpdateSpanStateVariables(); 							continue; 						} 					} 				}                  // check for SPAN BEGIN                 if (activeRuleSet != null) {                     Span mySpan = null;                     foreach (Span span in activeRuleSet.Spans)                     {                         if (span.IsBeginSingleWord && currentLength != 0)                             continue;                         if (span.IsBeginStartOfLine.HasValue &&                             span.IsBeginStartOfLine.Value !=                             (currentLength == 0 && words.TrueForAll(                                 delegate(TextWord textWord) { return textWord.Type != TextWordType.Word; })))                             continue;                         if (!MatchExpr(currentLine' span.Begin' i' document' activeRuleSet.IgnoreCase))                             continue;                         mySpan = span;                         break;                     }                     if (mySpan != null)                     {                         PushCurWord(document' ref markNext' words);                         string regex = GetRegString(currentLine' mySpan.Begin' i' document);                          if (!OverrideSpan(regex' document' words' mySpan' ref i))                         {                             currentLength += regex.Length;                             words.Add(new TextWord(document' currentLine' currentOffset' currentLength' mySpan.BeginColor' false));                             currentOffset += currentLength;                             currentLength = 0;                              i += regex.Length - 1;                             if (currentSpanStack == null)                                 currentSpanStack = new SpanStack();                             currentSpanStack.Push(mySpan);                             mySpan.IgnoreCase = activeRuleSet.IgnoreCase;                              UpdateSpanStateVariables();                         }                         continue;                     }                 } 							 				// check if the char is a delimiter 				if (activeRuleSet != null && (int)ch < 256 && activeRuleSet.Delimiters[(int)ch]) { 					PushCurWord(document' ref markNext' words); 					if (currentOffset + currentLength +1 < currentLine.Length) { 						++currentLength;                         PushCurWord(document' ref markNext' words);                         continue; 					} 				}                  ++currentLength; 			}
Magic Number,ICSharpCode.TextEditor.Document,FontContainer,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\FontContainer.cs,ParseFont,The following statement contains a magic number: return new Font(descr[1]' Single.Parse(descr[3]));
Magic Number,ICSharpCode.TextEditor.Document,HighlightColor,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\HighlightColor.cs,ParseColorString,The following statement contains a magic number: if (cNames.Length == 2) { 				// hack : can't figure out how to parse doubles with '.' (culture info might set the '.' to ''') 				double factor = Double.Parse(cNames[1]) / 100; 				c = Color.FromArgb((int)((double)c.R * factor)' (int)((double)c.G * factor)' (int)((double)c.B * factor)); 			}
Magic Number,ICSharpCode.TextEditor.Document,HighlightColor,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\HighlightColor.cs,ParseColorString,The following statement contains a magic number: if (cNames.Length == 2) { 				// hack : can't figure out how to parse doubles with '.' (culture info might set the '.' to ''') 				double factor = Double.Parse(cNames[1]) / 100; 				c = Color.FromArgb((int)((double)c.R * factor)' (int)((double)c.G * factor)' (int)((double)c.B * factor)); 			}
Magic Number,ICSharpCode.TextEditor.Document,HighlightColor,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\HighlightColor.cs,ParseColor,The following statement contains a magic number: int a = 255;
Magic Number,ICSharpCode.TextEditor.Document,HighlightColor,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\HighlightColor.cs,ParseColor,The following statement contains a magic number: if (c.Length > 7) { 				offset = 2; 				a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber); 			}
Magic Number,ICSharpCode.TextEditor.Document,HighlightColor,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\HighlightColor.cs,ParseColor,The following statement contains a magic number: if (c.Length > 7) { 				offset = 2; 				a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber); 			}
Magic Number,ICSharpCode.TextEditor.Document,HighlightColor,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\HighlightColor.cs,ParseColor,The following statement contains a magic number: if (c.Length > 7) { 				offset = 2; 				a = Int32.Parse(c.Substring(1'2)' NumberStyles.HexNumber); 			}
Magic Number,ICSharpCode.TextEditor.Document,HighlightColor,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\HighlightColor.cs,ParseColor,The following statement contains a magic number: int r = Int32.Parse(c.Substring(1 + offset'2)' NumberStyles.HexNumber);
Magic Number,ICSharpCode.TextEditor.Document,HighlightColor,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\HighlightColor.cs,ParseColor,The following statement contains a magic number: int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber);
Magic Number,ICSharpCode.TextEditor.Document,HighlightColor,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\HighlightColor.cs,ParseColor,The following statement contains a magic number: int g = Int32.Parse(c.Substring(3 + offset'2)' NumberStyles.HexNumber);
Magic Number,ICSharpCode.TextEditor.Document,HighlightColor,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\HighlightColor.cs,ParseColor,The following statement contains a magic number: int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber);
Magic Number,ICSharpCode.TextEditor.Document,HighlightColor,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\HighlightColor.cs,ParseColor,The following statement contains a magic number: int b = Int32.Parse(c.Substring(5 + offset'2)' NumberStyles.HexNumber);
Magic Number,ICSharpCode.TextEditor.Document,LineManager,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\LineManager\LineManager.cs,NextDelimiter,The following statement contains a magic number: for (int i = offset; i < text.Length; i++) { 				switch (text[i]) { 					case '\r': 						if (i + 1 < text.Length) { 							if (text[i + 1] == '\n') { 								delimiterSegment.Offset = i; 								delimiterSegment.Length = 2; 								return delimiterSegment; 							} 						} 						#if DATACONSISTENCYTEST 						Debug.Assert(false' "Found lone \\r' data consistency problems?"); 						#endif 						goto case '\n'; 					case '\n': 						delimiterSegment.Offset = i; 						delimiterSegment.Length = 1; 						return delimiterSegment; 				} 			}
Magic Number,ICSharpCode.TextEditor.Document,IndentFoldingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\FoldingStrategy\IndentFoldingStrategy.cs,GetLevel,The following statement contains a magic number: for (int i = offset; i < document.TextLength; ++i) { 				char c = document.GetCharAt(i); 				if (c == '\t' || (c == ' ' && ++spaces == 4)) { 					spaces = 0; 					++level; 				} else { 					break; 				} 			}
Magic Number,ICSharpCode.TextEditor.Document,FoldingManager,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\FoldingStrategy\FoldingManager.cs,DeserializeFromString,The following statement contains a magic number: try { 				string[] lines = str.Split('\n'); 				for (int i = 0; i < lines.Length && lines[i].Length > 0; i += 4) { 					int    offset = Int32.Parse(lines[i]); 					int    length = Int32.Parse(lines[i + 1]); 					string text   = lines[i + 2]; 					bool isFolded = Boolean.Parse(lines[i + 3]); 					bool found    = false; 					foreach (FoldMarker marker in foldMarker) { 						if (marker.Offset == offset && marker.Length == length) { 							marker.IsFolded = isFolded; 							found = true; 							break; 						} 					} 					if (!found) { 						foldMarker.Add(new FoldMarker(document' offset' length' text' isFolded)); 					} 				} 				if (lines.Length > 0) { 					NotifyFoldingsChanged(EventArgs.Empty); 				} 			} catch (Exception) { 			}
Magic Number,ICSharpCode.TextEditor.Document,FoldingManager,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\FoldingStrategy\FoldingManager.cs,DeserializeFromString,The following statement contains a magic number: try { 				string[] lines = str.Split('\n'); 				for (int i = 0; i < lines.Length && lines[i].Length > 0; i += 4) { 					int    offset = Int32.Parse(lines[i]); 					int    length = Int32.Parse(lines[i + 1]); 					string text   = lines[i + 2]; 					bool isFolded = Boolean.Parse(lines[i + 3]); 					bool found    = false; 					foreach (FoldMarker marker in foldMarker) { 						if (marker.Offset == offset && marker.Length == length) { 							marker.IsFolded = isFolded; 							found = true; 							break; 						} 					} 					if (!found) { 						foldMarker.Add(new FoldMarker(document' offset' length' text' isFolded)); 					} 				} 				if (lines.Length > 0) { 					NotifyFoldingsChanged(EventArgs.Empty); 				} 			} catch (Exception) { 			}
Magic Number,ICSharpCode.TextEditor.Document,FoldingManager,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\FoldingStrategy\FoldingManager.cs,DeserializeFromString,The following statement contains a magic number: try { 				string[] lines = str.Split('\n'); 				for (int i = 0; i < lines.Length && lines[i].Length > 0; i += 4) { 					int    offset = Int32.Parse(lines[i]); 					int    length = Int32.Parse(lines[i + 1]); 					string text   = lines[i + 2]; 					bool isFolded = Boolean.Parse(lines[i + 3]); 					bool found    = false; 					foreach (FoldMarker marker in foldMarker) { 						if (marker.Offset == offset && marker.Length == length) { 							marker.IsFolded = isFolded; 							found = true; 							break; 						} 					} 					if (!found) { 						foldMarker.Add(new FoldMarker(document' offset' length' text' isFolded)); 					} 				} 				if (lines.Length > 0) { 					NotifyFoldingsChanged(EventArgs.Empty); 				} 			} catch (Exception) { 			}
Magic Number,ICSharpCode.TextEditor.Document,ColumnRange,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\Selection\ColumnRange.cs,GetHashCode,The following statement contains a magic number: return startColumn + (endColumn << 16);
Magic Number,ICSharpCode.TextEditor.Document,DefaultTextEditorProperties,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\DefaultTextEditorProperties.cs,DefaultTextEditorProperties,The following statement contains a magic number: if (DefaultFont == null) { 				DefaultFont = new Font("Courier New"' 10); 			}
Magic Number,ICSharpCode.TextEditor,TextLocation,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\TextLocation.cs,GetHashCode,The following statement contains a magic number: return unchecked (87 * x.GetHashCode() ^ y.GetHashCode());
Magic Number,ICSharpCode.TextEditor,Ime,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\Ime.cs,Ime,The following statement contains a magic number: if (PROCESSOR_ARCHITEW6432 == "IA64" || PROCESSOR_ARCHITEW6432 == "AMD64" || Environment.OSVersion.Platform == PlatformID.Unix || Environment.Version >= new Version(4'0)) { 				disableIME = true; 			} else { 				this.hIMEWnd = ImmGetDefaultIMEWnd(hWnd); 			}
Magic Number,ICSharpCode.TextEditor,Caret,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\Caret.cs,CreateCaret,The following statement contains a magic number: while (!caretCreated) { 				switch (caretMode) { 					case CaretMode.InsertMode: 						caretCreated = caretImplementation.Create(2' textArea.TextView.FontHeight); 						break; 					case CaretMode.OverwriteMode: 						caretCreated = caretImplementation.Create((int)textArea.TextView.SpaceWidth' textArea.TextView.FontHeight); 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor,ManagedCaret,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\Caret.cs,Create,The following statement contains a magic number: this.width = width - 2;
Magic Number,ICSharpCode.TextEditor,TextArea,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextArea.cs,SetToolTip,The following statement contains a magic number: if (text == null) { 				toolTip.Hide(); 			} else { 				Point p = Control.MousePosition; 				Point cp = PointToClient(p); 				if (lineNumber >= 0) { 					lineNumber = this.Document.GetVisibleLine(lineNumber); 					p.Y = (p.Y - cp.Y) + (lineNumber * this.TextView.FontHeight) - this.virtualTop.Y; 				} 				p.Offset(3' 3); 				toolTip.Owner = this.FindForm(); 				toolTip.Location = p; 				toolTip.Description = text; 				toolTip.HideOnClick = true; 				toolTip.Show(); 			}
Magic Number,ICSharpCode.TextEditor,TextArea,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextArea.cs,SetToolTip,The following statement contains a magic number: if (text == null) { 				toolTip.Hide(); 			} else { 				Point p = Control.MousePosition; 				Point cp = PointToClient(p); 				if (lineNumber >= 0) { 					lineNumber = this.Document.GetVisibleLine(lineNumber); 					p.Y = (p.Y - cp.Y) + (lineNumber * this.TextView.FontHeight) - this.virtualTop.Y; 				} 				p.Offset(3' 3); 				toolTip.Owner = this.FindForm(); 				toolTip.Location = p; 				toolTip.Description = text; 				toolTip.HideOnClick = true; 				toolTip.Show(); 			}
Magic Number,ICSharpCode.TextEditor,TextArea,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextArea.cs,RequestToolTip,The following statement contains a magic number: toolTipRectangle = new Rectangle(mousePos.X - 4' mousePos.Y - 4' 8' 8);
Magic Number,ICSharpCode.TextEditor,TextArea,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextArea.cs,RequestToolTip,The following statement contains a magic number: toolTipRectangle = new Rectangle(mousePos.X - 4' mousePos.Y - 4' 8' 8);
Magic Number,ICSharpCode.TextEditor,TextArea,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextArea.cs,RequestToolTip,The following statement contains a magic number: toolTipRectangle = new Rectangle(mousePos.X - 4' mousePos.Y - 4' 8' 8);
Magic Number,ICSharpCode.TextEditor,TextArea,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextArea.cs,RequestToolTip,The following statement contains a magic number: toolTipRectangle = new Rectangle(mousePos.X - 4' mousePos.Y - 4' 8' 8);
Magic Number,ICSharpCode.TextEditor,TextArea,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextArea.cs,InvalidateLines,The following statement contains a magic number: Rectangle r = new Rectangle(0' 			                            y - 1 - this.virtualTop.Y' 			                            Width' 			                            height + 3);
Magic Number,ICSharpCode.TextEditor,TextEditorControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextEditorControl.cs,Split,The following statement contains a magic number: if (secondaryTextArea == null) { 				secondaryTextArea = new TextAreaControl(this); 				secondaryTextArea.Dock = DockStyle.Bottom; 				secondaryTextArea.Height = Height / 2; 				 				secondaryTextArea.TextArea.GotFocus += delegate { 					SetActiveTextAreaControl(secondaryTextArea); 				}; 				 				textAreaSplitter =  new Splitter(); 				textAreaSplitter.BorderStyle = BorderStyle.FixedSingle ; 				textAreaSplitter.Height = 8; 				textAreaSplitter.Dock = DockStyle.Bottom; 				textAreaPanel.Controls.Add(textAreaSplitter); 				textAreaPanel.Controls.Add(secondaryTextArea); 				InitializeTextAreaControl(secondaryTextArea); 				secondaryTextArea.OptionsChanged(); 			} else { 				SetActiveTextAreaControl(primaryTextArea); 				 				textAreaPanel.Controls.Remove(secondaryTextArea); 				textAreaPanel.Controls.Remove(textAreaSplitter); 				 				secondaryTextArea.Dispose(); 				textAreaSplitter.Dispose(); 				secondaryTextArea = null; 				textAreaSplitter  = null; 			}
Magic Number,ICSharpCode.TextEditor,TextEditorControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextEditorControl.cs,Split,The following statement contains a magic number: if (secondaryTextArea == null) { 				secondaryTextArea = new TextAreaControl(this); 				secondaryTextArea.Dock = DockStyle.Bottom; 				secondaryTextArea.Height = Height / 2; 				 				secondaryTextArea.TextArea.GotFocus += delegate { 					SetActiveTextAreaControl(secondaryTextArea); 				}; 				 				textAreaSplitter =  new Splitter(); 				textAreaSplitter.BorderStyle = BorderStyle.FixedSingle ; 				textAreaSplitter.Height = 8; 				textAreaSplitter.Dock = DockStyle.Bottom; 				textAreaPanel.Controls.Add(textAreaSplitter); 				textAreaPanel.Controls.Add(secondaryTextArea); 				InitializeTextAreaControl(secondaryTextArea); 				secondaryTextArea.OptionsChanged(); 			} else { 				SetActiveTextAreaControl(primaryTextArea); 				 				textAreaPanel.Controls.Remove(secondaryTextArea); 				textAreaPanel.Controls.Remove(textAreaSplitter); 				 				secondaryTextArea.Dispose(); 				textAreaSplitter.Dispose(); 				secondaryTextArea = null; 				textAreaSplitter  = null; 			}
Magic Number,ICSharpCode.TextEditor,TextEditorControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextEditorControl.cs,BeginPrint,The following statement contains a magic number: float[] tabStops = new float[100];
Magic Number,ICSharpCode.TextEditor,TextEditorControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextEditorControl.cs,MeasurePrintingHeight,The following statement contains a magic number: foreach (TextWord word in line.Words) { 				switch (word.Type) { 					case TextWordType.Space: 						Advance(ref xPos' ref yPos' maxWidth' primaryTextArea.TextArea.TextView.SpaceWidth' fontHeight); //						if (!gotNonWhitespace) { //							curTabIndent = xPos; //						} 						break; 					case TextWordType.Tab: 						Advance(ref xPos' ref yPos' maxWidth' TabIndent * primaryTextArea.TextArea.TextView.WideSpaceWidth' fontHeight); //						if (!gotNonWhitespace) { //							curTabIndent = xPos; //						} 						break; 					case TextWordType.Word: //						if (!gotNonWhitespace) { //							gotNonWhitespace = true; //							curTabIndent    += TabIndent * primaryTextArea.TextArea.TextView.GetWidth(' '); //						} 						SizeF drawingSize = g.MeasureString(word.Word' word.GetFont(fontContainer)' new SizeF(maxWidth' fontHeight * 100)' printingStringFormat); 						Advance(ref xPos' ref yPos' maxWidth' drawingSize.Width' fontHeight); 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor,TextEditorControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextEditorControl.cs,DrawLine,The following statement contains a magic number: foreach (TextWord word in line.Words) { 				switch (word.Type) { 					case TextWordType.Space: 						Advance(ref xPos' ref yPos' margin.Width' primaryTextArea.TextArea.TextView.SpaceWidth' fontHeight); //						if (!gotNonWhitespace) { //							curTabIndent = xPos; //						} 						break; 					case TextWordType.Tab: 						Advance(ref xPos' ref yPos' margin.Width' TabIndent * primaryTextArea.TextArea.TextView.WideSpaceWidth' fontHeight); //						if (!gotNonWhitespace) { //							curTabIndent = xPos; //						} 						break; 					case TextWordType.Word: //						if (!gotNonWhitespace) { //							gotNonWhitespace = true; //							curTabIndent    += TabIndent * primaryTextArea.TextArea.TextView.GetWidth(' '); //						} 						g.DrawString(word.Word' word.GetFont(fontContainer)' BrushRegistry.GetBrush(word.Color)' xPos + margin.X' yPos); 						SizeF drawingSize = g.MeasureString(word.Word' word.GetFont(fontContainer)' new SizeF(margin.Width' fontHeight * 100)' printingStringFormat); 						Advance(ref xPos' ref yPos' margin.Width' drawingSize.Width' fontHeight); 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor,TextEditorControlBase,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextEditorControlBase.cs,ParseFont,The following statement contains a magic number: return new Font(descr[1]' Single.Parse(descr[3]));
Magic Number,ICSharpCode.TextEditor,TextAreaClipboardHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaClipboardHandler.cs,SafeSetClipboard,The following statement contains a magic number: try { 				Clipboard.SetDataObject(dataObject' true); 			} catch (ExternalException) { 				Timer timer = new Timer(); 				timer.Interval = 100; 				timer.Tick += delegate { 					timer.Stop(); 					timer.Dispose(); 					if (SafeSetClipboardDataVersion == version) { 						try { 							Clipboard.SetDataObject(dataObject' true' 10' 50); 						} catch (ExternalException) { } 					} 				}; 				timer.Start(); 			}
Magic Number,ICSharpCode.TextEditor,TextAreaClipboardHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaClipboardHandler.cs,SafeSetClipboard,The following statement contains a magic number: try { 				Clipboard.SetDataObject(dataObject' true); 			} catch (ExternalException) { 				Timer timer = new Timer(); 				timer.Interval = 100; 				timer.Tick += delegate { 					timer.Stop(); 					timer.Dispose(); 					if (SafeSetClipboardDataVersion == version) { 						try { 							Clipboard.SetDataObject(dataObject' true' 10' 50); 						} catch (ExternalException) { } 					} 				}; 				timer.Start(); 			}
Magic Number,ICSharpCode.TextEditor,TextAreaClipboardHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaClipboardHandler.cs,SafeSetClipboard,The following statement contains a magic number: try { 				Clipboard.SetDataObject(dataObject' true); 			} catch (ExternalException) { 				Timer timer = new Timer(); 				timer.Interval = 100; 				timer.Tick += delegate { 					timer.Stop(); 					timer.Dispose(); 					if (SafeSetClipboardDataVersion == version) { 						try { 							Clipboard.SetDataObject(dataObject' true' 10' 50); 						} catch (ExternalException) { } 					} 				}; 				timer.Start(); 			}
Magic Number,ICSharpCode.TextEditor,TextAreaClipboardHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaClipboardHandler.cs,Paste,The following statement contains a magic number: for (int i = 0;; i++) { 				try { 					IDataObject data = Clipboard.GetDataObject(); 					if (data == null) 						return; 					bool fullLine = data.GetDataPresent(LineSelectedType); 					if (data.GetDataPresent(DataFormats.UnicodeText)) { 						string text = (string)data.GetData(DataFormats.UnicodeText); 						// we got NullReferenceExceptions here' apparently the clipboard can contain null strings 						if (!string.IsNullOrEmpty(text)) { 							textArea.Document.UndoStack.StartUndoGroup(); 							try { 								if (textArea.SelectionManager.HasSomethingSelected) { 									textArea.Caret.Position = textArea.SelectionManager.SelectionCollection[0].StartPosition; 									textArea.SelectionManager.RemoveSelectedText(); 								} 								if (fullLine) { 									int col = textArea.Caret.Column; 									textArea.Caret.Column = 0; 									if (!textArea.IsReadOnly(textArea.Caret.Offset)) 										textArea.InsertString(text); 									textArea.Caret.Column = col; 								} else { 									// textArea.EnableCutOrPaste already checked readonly for this case 									textArea.InsertString(text); 								} 							} finally { 								textArea.Document.UndoStack.EndUndoGroup(); 							} 						} 					} 					return; 				} catch (ExternalException) { 					// GetDataObject does not provide RetryTimes parameter 					if (i > 5) throw; 				} 			}
Magic Number,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,DrawMarkerDraw,The following statement contains a magic number: foreach (MarkerToDraw m in markersToDraw) { 				TextMarker marker = m.marker; 				RectangleF drawingRect = m.drawingRect; 				float drawYPos = drawingRect.Bottom - 1; 				switch (marker.TextMarkerType) { 					case TextMarkerType.Underlined: 						g.DrawLine(BrushRegistry.GetPen(marker.Color)' drawingRect.X' drawYPos' drawingRect.Right' drawYPos); 						break; 					case TextMarkerType.WaveLine: 						int reminder = ((int)drawingRect.X) % 6; 						for (float i = (int)drawingRect.X - reminder; i < drawingRect.Right; i += 6) { 							g.DrawLine(BrushRegistry.GetPen(marker.Color)' i'     drawYPos + 3 - 4' i + 3' drawYPos + 1 - 4); 							if (i + 3 < drawingRect.Right) { 								g.DrawLine(BrushRegistry.GetPen(marker.Color)' i + 3' drawYPos + 1 - 4' i + 6' drawYPos + 3 - 4); 							} 						} 						break; 					case TextMarkerType.SolidBlock: 						g.FillRectangle(BrushRegistry.GetBrush(marker.Color)' drawingRect); 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,DrawMarkerDraw,The following statement contains a magic number: foreach (MarkerToDraw m in markersToDraw) { 				TextMarker marker = m.marker; 				RectangleF drawingRect = m.drawingRect; 				float drawYPos = drawingRect.Bottom - 1; 				switch (marker.TextMarkerType) { 					case TextMarkerType.Underlined: 						g.DrawLine(BrushRegistry.GetPen(marker.Color)' drawingRect.X' drawYPos' drawingRect.Right' drawYPos); 						break; 					case TextMarkerType.WaveLine: 						int reminder = ((int)drawingRect.X) % 6; 						for (float i = (int)drawingRect.X - reminder; i < drawingRect.Right; i += 6) { 							g.DrawLine(BrushRegistry.GetPen(marker.Color)' i'     drawYPos + 3 - 4' i + 3' drawYPos + 1 - 4); 							if (i + 3 < drawingRect.Right) { 								g.DrawLine(BrushRegistry.GetPen(marker.Color)' i + 3' drawYPos + 1 - 4' i + 6' drawYPos + 3 - 4); 							} 						} 						break; 					case TextMarkerType.SolidBlock: 						g.FillRectangle(BrushRegistry.GetBrush(marker.Color)' drawingRect); 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,DrawMarkerDraw,The following statement contains a magic number: foreach (MarkerToDraw m in markersToDraw) { 				TextMarker marker = m.marker; 				RectangleF drawingRect = m.drawingRect; 				float drawYPos = drawingRect.Bottom - 1; 				switch (marker.TextMarkerType) { 					case TextMarkerType.Underlined: 						g.DrawLine(BrushRegistry.GetPen(marker.Color)' drawingRect.X' drawYPos' drawingRect.Right' drawYPos); 						break; 					case TextMarkerType.WaveLine: 						int reminder = ((int)drawingRect.X) % 6; 						for (float i = (int)drawingRect.X - reminder; i < drawingRect.Right; i += 6) { 							g.DrawLine(BrushRegistry.GetPen(marker.Color)' i'     drawYPos + 3 - 4' i + 3' drawYPos + 1 - 4); 							if (i + 3 < drawingRect.Right) { 								g.DrawLine(BrushRegistry.GetPen(marker.Color)' i + 3' drawYPos + 1 - 4' i + 6' drawYPos + 3 - 4); 							} 						} 						break; 					case TextMarkerType.SolidBlock: 						g.FillRectangle(BrushRegistry.GetBrush(marker.Color)' drawingRect); 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,DrawMarkerDraw,The following statement contains a magic number: foreach (MarkerToDraw m in markersToDraw) { 				TextMarker marker = m.marker; 				RectangleF drawingRect = m.drawingRect; 				float drawYPos = drawingRect.Bottom - 1; 				switch (marker.TextMarkerType) { 					case TextMarkerType.Underlined: 						g.DrawLine(BrushRegistry.GetPen(marker.Color)' drawingRect.X' drawYPos' drawingRect.Right' drawYPos); 						break; 					case TextMarkerType.WaveLine: 						int reminder = ((int)drawingRect.X) % 6; 						for (float i = (int)drawingRect.X - reminder; i < drawingRect.Right; i += 6) { 							g.DrawLine(BrushRegistry.GetPen(marker.Color)' i'     drawYPos + 3 - 4' i + 3' drawYPos + 1 - 4); 							if (i + 3 < drawingRect.Right) { 								g.DrawLine(BrushRegistry.GetPen(marker.Color)' i + 3' drawYPos + 1 - 4' i + 6' drawYPos + 3 - 4); 							} 						} 						break; 					case TextMarkerType.SolidBlock: 						g.FillRectangle(BrushRegistry.GetBrush(marker.Color)' drawingRect); 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,DrawMarkerDraw,The following statement contains a magic number: foreach (MarkerToDraw m in markersToDraw) { 				TextMarker marker = m.marker; 				RectangleF drawingRect = m.drawingRect; 				float drawYPos = drawingRect.Bottom - 1; 				switch (marker.TextMarkerType) { 					case TextMarkerType.Underlined: 						g.DrawLine(BrushRegistry.GetPen(marker.Color)' drawingRect.X' drawYPos' drawingRect.Right' drawYPos); 						break; 					case TextMarkerType.WaveLine: 						int reminder = ((int)drawingRect.X) % 6; 						for (float i = (int)drawingRect.X - reminder; i < drawingRect.Right; i += 6) { 							g.DrawLine(BrushRegistry.GetPen(marker.Color)' i'     drawYPos + 3 - 4' i + 3' drawYPos + 1 - 4); 							if (i + 3 < drawingRect.Right) { 								g.DrawLine(BrushRegistry.GetPen(marker.Color)' i + 3' drawYPos + 1 - 4' i + 6' drawYPos + 3 - 4); 							} 						} 						break; 					case TextMarkerType.SolidBlock: 						g.FillRectangle(BrushRegistry.GetBrush(marker.Color)' drawingRect); 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,DrawMarkerDraw,The following statement contains a magic number: foreach (MarkerToDraw m in markersToDraw) { 				TextMarker marker = m.marker; 				RectangleF drawingRect = m.drawingRect; 				float drawYPos = drawingRect.Bottom - 1; 				switch (marker.TextMarkerType) { 					case TextMarkerType.Underlined: 						g.DrawLine(BrushRegistry.GetPen(marker.Color)' drawingRect.X' drawYPos' drawingRect.Right' drawYPos); 						break; 					case TextMarkerType.WaveLine: 						int reminder = ((int)drawingRect.X) % 6; 						for (float i = (int)drawingRect.X - reminder; i < drawingRect.Right; i += 6) { 							g.DrawLine(BrushRegistry.GetPen(marker.Color)' i'     drawYPos + 3 - 4' i + 3' drawYPos + 1 - 4); 							if (i + 3 < drawingRect.Right) { 								g.DrawLine(BrushRegistry.GetPen(marker.Color)' i + 3' drawYPos + 1 - 4' i + 6' drawYPos + 3 - 4); 							} 						} 						break; 					case TextMarkerType.SolidBlock: 						g.FillRectangle(BrushRegistry.GetBrush(marker.Color)' drawingRect); 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,DrawMarkerDraw,The following statement contains a magic number: foreach (MarkerToDraw m in markersToDraw) { 				TextMarker marker = m.marker; 				RectangleF drawingRect = m.drawingRect; 				float drawYPos = drawingRect.Bottom - 1; 				switch (marker.TextMarkerType) { 					case TextMarkerType.Underlined: 						g.DrawLine(BrushRegistry.GetPen(marker.Color)' drawingRect.X' drawYPos' drawingRect.Right' drawYPos); 						break; 					case TextMarkerType.WaveLine: 						int reminder = ((int)drawingRect.X) % 6; 						for (float i = (int)drawingRect.X - reminder; i < drawingRect.Right; i += 6) { 							g.DrawLine(BrushRegistry.GetPen(marker.Color)' i'     drawYPos + 3 - 4' i + 3' drawYPos + 1 - 4); 							if (i + 3 < drawingRect.Right) { 								g.DrawLine(BrushRegistry.GetPen(marker.Color)' i + 3' drawYPos + 1 - 4' i + 6' drawYPos + 3 - 4); 							} 						} 						break; 					case TextMarkerType.SolidBlock: 						g.FillRectangle(BrushRegistry.GetBrush(marker.Color)' drawingRect); 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,DrawMarkerDraw,The following statement contains a magic number: foreach (MarkerToDraw m in markersToDraw) { 				TextMarker marker = m.marker; 				RectangleF drawingRect = m.drawingRect; 				float drawYPos = drawingRect.Bottom - 1; 				switch (marker.TextMarkerType) { 					case TextMarkerType.Underlined: 						g.DrawLine(BrushRegistry.GetPen(marker.Color)' drawingRect.X' drawYPos' drawingRect.Right' drawYPos); 						break; 					case TextMarkerType.WaveLine: 						int reminder = ((int)drawingRect.X) % 6; 						for (float i = (int)drawingRect.X - reminder; i < drawingRect.Right; i += 6) { 							g.DrawLine(BrushRegistry.GetPen(marker.Color)' i'     drawYPos + 3 - 4' i + 3' drawYPos + 1 - 4); 							if (i + 3 < drawingRect.Right) { 								g.DrawLine(BrushRegistry.GetPen(marker.Color)' i + 3' drawYPos + 1 - 4' i + 6' drawYPos + 3 - 4); 							} 						} 						break; 					case TextMarkerType.SolidBlock: 						g.FillRectangle(BrushRegistry.GetBrush(marker.Color)' drawingRect); 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,DrawMarkerDraw,The following statement contains a magic number: foreach (MarkerToDraw m in markersToDraw) { 				TextMarker marker = m.marker; 				RectangleF drawingRect = m.drawingRect; 				float drawYPos = drawingRect.Bottom - 1; 				switch (marker.TextMarkerType) { 					case TextMarkerType.Underlined: 						g.DrawLine(BrushRegistry.GetPen(marker.Color)' drawingRect.X' drawYPos' drawingRect.Right' drawYPos); 						break; 					case TextMarkerType.WaveLine: 						int reminder = ((int)drawingRect.X) % 6; 						for (float i = (int)drawingRect.X - reminder; i < drawingRect.Right; i += 6) { 							g.DrawLine(BrushRegistry.GetPen(marker.Color)' i'     drawYPos + 3 - 4' i + 3' drawYPos + 1 - 4); 							if (i + 3 < drawingRect.Right) { 								g.DrawLine(BrushRegistry.GetPen(marker.Color)' i + 3' drawYPos + 1 - 4' i + 6' drawYPos + 3 - 4); 							} 						} 						break; 					case TextMarkerType.SolidBlock: 						g.FillRectangle(BrushRegistry.GetBrush(marker.Color)' drawingRect); 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,DrawMarkerDraw,The following statement contains a magic number: foreach (MarkerToDraw m in markersToDraw) { 				TextMarker marker = m.marker; 				RectangleF drawingRect = m.drawingRect; 				float drawYPos = drawingRect.Bottom - 1; 				switch (marker.TextMarkerType) { 					case TextMarkerType.Underlined: 						g.DrawLine(BrushRegistry.GetPen(marker.Color)' drawingRect.X' drawYPos' drawingRect.Right' drawYPos); 						break; 					case TextMarkerType.WaveLine: 						int reminder = ((int)drawingRect.X) % 6; 						for (float i = (int)drawingRect.X - reminder; i < drawingRect.Right; i += 6) { 							g.DrawLine(BrushRegistry.GetPen(marker.Color)' i'     drawYPos + 3 - 4' i + 3' drawYPos + 1 - 4); 							if (i + 3 < drawingRect.Right) { 								g.DrawLine(BrushRegistry.GetPen(marker.Color)' i + 3' drawYPos + 1 - 4' i + 6' drawYPos + 3 - 4); 							} 						} 						break; 					case TextMarkerType.SolidBlock: 						g.FillRectangle(BrushRegistry.GetBrush(marker.Color)' drawingRect); 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,DrawMarkerDraw,The following statement contains a magic number: foreach (MarkerToDraw m in markersToDraw) { 				TextMarker marker = m.marker; 				RectangleF drawingRect = m.drawingRect; 				float drawYPos = drawingRect.Bottom - 1; 				switch (marker.TextMarkerType) { 					case TextMarkerType.Underlined: 						g.DrawLine(BrushRegistry.GetPen(marker.Color)' drawingRect.X' drawYPos' drawingRect.Right' drawYPos); 						break; 					case TextMarkerType.WaveLine: 						int reminder = ((int)drawingRect.X) % 6; 						for (float i = (int)drawingRect.X - reminder; i < drawingRect.Right; i += 6) { 							g.DrawLine(BrushRegistry.GetPen(marker.Color)' i'     drawYPos + 3 - 4' i + 3' drawYPos + 1 - 4); 							if (i + 3 < drawingRect.Right) { 								g.DrawLine(BrushRegistry.GetPen(marker.Color)' i + 3' drawYPos + 1 - 4' i + 6' drawYPos + 3 - 4); 							} 						} 						break; 					case TextMarkerType.SolidBlock: 						g.FillRectangle(BrushRegistry.GetBrush(marker.Color)' drawingRect); 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,DrawMarkerDraw,The following statement contains a magic number: foreach (MarkerToDraw m in markersToDraw) { 				TextMarker marker = m.marker; 				RectangleF drawingRect = m.drawingRect; 				float drawYPos = drawingRect.Bottom - 1; 				switch (marker.TextMarkerType) { 					case TextMarkerType.Underlined: 						g.DrawLine(BrushRegistry.GetPen(marker.Color)' drawingRect.X' drawYPos' drawingRect.Right' drawYPos); 						break; 					case TextMarkerType.WaveLine: 						int reminder = ((int)drawingRect.X) % 6; 						for (float i = (int)drawingRect.X - reminder; i < drawingRect.Right; i += 6) { 							g.DrawLine(BrushRegistry.GetPen(marker.Color)' i'     drawYPos + 3 - 4' i + 3' drawYPos + 1 - 4); 							if (i + 3 < drawingRect.Right) { 								g.DrawLine(BrushRegistry.GetPen(marker.Color)' i + 3' drawYPos + 1 - 4' i + 6' drawYPos + 3 - 4); 							} 						} 						break; 					case TextMarkerType.SolidBlock: 						g.FillRectangle(BrushRegistry.GetBrush(marker.Color)' drawingRect); 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,GetDrawingXPos,The following statement contains a magic number: for (i = foldings.Count - 1; i >= 0; --i) { 				f = foldings[i]; 				if (f.StartLine < logicalLine || f.StartLine == logicalLine && f.StartColumn < logicalColumn) { 					break; 				} 				FoldMarker f2 = foldings[i / 2]; 				if (f2.StartLine > logicalLine || f2.StartLine == logicalLine && f2.StartColumn >= logicalColumn) { 					i /= 2; 				} 			}
Magic Number,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,GetDrawingXPos,The following statement contains a magic number: for (i = foldings.Count - 1; i >= 0; --i) { 				f = foldings[i]; 				if (f.StartLine < logicalLine || f.StartLine == logicalLine && f.StartColumn < logicalColumn) { 					break; 				} 				FoldMarker f2 = foldings[i / 2]; 				if (f2.StartLine > logicalLine || f2.StartLine == logicalLine && f2.StartColumn >= logicalColumn) { 					i /= 2; 				} 			}
Magic Number,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,DrawBracketHighlight,The following statement contains a magic number: g.FillRectangle(BrushRegistry.GetBrush(Color.FromArgb(50' 0' 0' 255))' rect);
Magic Number,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,DrawBracketHighlight,The following statement contains a magic number: g.FillRectangle(BrushRegistry.GetBrush(Color.FromArgb(50' 0' 0' 255))' rect);
Magic Number,ICSharpCode.TextEditor,TextAreaControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaControl.cs,AdjustScrollBarsClearCache,The following statement contains a magic number: if (lineLengthCache != null) { 				if (lineLengthCache.Length < this.Document.TotalNumberOfLines + 2 * LineLengthCacheAdditionalSize) { 					lineLengthCache = null; 				} else { 					Array.Clear(lineLengthCache' 0' lineLengthCache.Length); 				} 			}
Magic Number,ICSharpCode.TextEditor,TextAreaControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaControl.cs,AdjustScrollBars,The following statement contains a magic number: hScrollBar.Maximum = (Math.Max(max + 20' textArea.TextView.VisibleColumnCount - 1));
Magic Number,ICSharpCode.TextEditor,TextAreaControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaControl.cs,HandleMouseWheel,The following statement contains a magic number: if ((Control.ModifierKeys & Keys.Control) != 0 && TextEditorProperties.MouseWheelTextZoom) { 				if (scrollDistance > 0) { 					motherTextEditorControl.Font = new Font(motherTextEditorControl.Font.Name' 					                                        motherTextEditorControl.Font.Size + 1); 				} else { 					motherTextEditorControl.Font = new Font(motherTextEditorControl.Font.Name' 					                                        Math.Max(6' motherTextEditorControl.Font.Size - 1)); 				} 			} else { 				if (TextEditorProperties.MouseWheelScrollDown) 					scrollDistance = -scrollDistance; 				int newValue = vScrollBar.Value + vScrollBar.SmallChange * scrollDistance; 				vScrollBar.Value = Math.Max(vScrollBar.Minimum' Math.Min(vScrollBar.Maximum - vScrollBar.LargeChange + 1' newValue)); 			}
Magic Number,ICSharpCode.TextEditor,TextAreaControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaControl.cs,ScrollTo,The following statement contains a magic number: if (line - scrollMarginHeight + 3 < curLineMin) { 				this.vScrollBar.Value =  Math.Max(0' Math.Min(this.vScrollBar.Maximum' (line - scrollMarginHeight + 3) * textArea.TextView.FontHeight)) ; 				VScrollBarValueChanged(this' EventArgs.Empty); 			} else { 				int curLineMax = curLineMin + this.textArea.TextView.VisibleLineCount; 				if (line + scrollMarginHeight - 1 > curLineMax) { 					if (this.textArea.TextView.VisibleLineCount == 1) { 						this.vScrollBar.Value =  Math.Max(0' Math.Min(this.vScrollBar.Maximum' (line - scrollMarginHeight - 1) * textArea.TextView.FontHeight)) ; 					} else { 						this.vScrollBar.Value = Math.Min(this.vScrollBar.Maximum' 						                                 (line - this.textArea.TextView.VisibleLineCount + scrollMarginHeight - 1)* textArea.TextView.FontHeight) ; 					} 					VScrollBarValueChanged(this' EventArgs.Empty); 				} 			}
Magic Number,ICSharpCode.TextEditor,TextAreaControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaControl.cs,ScrollTo,The following statement contains a magic number: if (line - scrollMarginHeight + 3 < curLineMin) { 				this.vScrollBar.Value =  Math.Max(0' Math.Min(this.vScrollBar.Maximum' (line - scrollMarginHeight + 3) * textArea.TextView.FontHeight)) ; 				VScrollBarValueChanged(this' EventArgs.Empty); 			} else { 				int curLineMax = curLineMin + this.textArea.TextView.VisibleLineCount; 				if (line + scrollMarginHeight - 1 > curLineMax) { 					if (this.textArea.TextView.VisibleLineCount == 1) { 						this.vScrollBar.Value =  Math.Max(0' Math.Min(this.vScrollBar.Maximum' (line - scrollMarginHeight - 1) * textArea.TextView.FontHeight)) ; 					} else { 						this.vScrollBar.Value = Math.Min(this.vScrollBar.Maximum' 						                                 (line - this.textArea.TextView.VisibleLineCount + scrollMarginHeight - 1)* textArea.TextView.FontHeight) ; 					} 					VScrollBarValueChanged(this' EventArgs.Empty); 				} 			}
Magic Number,ICSharpCode.TextEditor,TextAreaControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaControl.cs,CenterViewOn,The following statement contains a magic number: line -= textArea.TextView.VisibleLineCount / 2;
Magic Number,ICSharpCode.TextEditor,TextAreaControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaControl.cs,CenterViewOn,The following statement contains a magic number: if (Math.Abs(curLineMin - line) > treshold) { 				// scroll: 				this.vScrollBar.Value =  Math.Max(0' Math.Min(this.vScrollBar.Maximum' (line - scrollMarginHeight + 3) * textArea.TextView.FontHeight)) ; 				VScrollBarValueChanged(this' EventArgs.Empty); 			}
Magic Number,ICSharpCode.TextEditor,TextAreaControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaControl.cs,WndProc,The following statement contains a magic number: if (m.Msg == 0x007B) { // handle WM_CONTEXTMENU 				if (ShowContextMenu != null) { 					long lParam = m.LParam.ToInt64(); 					int x = unchecked((short)(lParam & 0xffff)); 					int y = unchecked((short)((lParam & 0xffff0000) >> 16)); 					if (x == -1 && y == -1) { 						Point pos = Caret.ScreenPosition; 						ShowContextMenu(this' new MouseEventArgs(MouseButtons.None' 0' pos.X' pos.Y + textArea.TextView.FontHeight' 0)); 					} else { 						Point pos = PointToClient(new Point(x' y)); 						ShowContextMenu(this' new MouseEventArgs(MouseButtons.Right' 1' pos.X' pos.Y' 0)); 					} 				} 			}
Magic Number,ICSharpCode.TextEditor,TextAreaMouseHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaMouseHandler.cs,OnToolTipRequest,The following statement contains a magic number: if (marker != null && marker.IsFolded) { 				StringBuilder sb = new StringBuilder(marker.InnerText); 				 				// max 10 lines 				int endLines = 0; 				for (int i = 0; i < sb.Length; ++i) { 					if (sb[i] == '\n') { 						++endLines; 						if (endLines >= 10) { 							sb.Remove(i + 1' sb.Length - i - 1); 							sb.Append(Environment.NewLine); 							sb.Append("..."); 							break; 							 						} 					} 				} 				sb.Replace("\t"' "    "); 				e.ShowToolTip(sb.ToString()); 				return; 			}
Magic Number,ICSharpCode.TextEditor,TextAreaMouseHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaMouseHandler.cs,TextAreaMouseMove,The following statement contains a magic number: if (clickedOnSelectedText) { 				if (Math.Abs(mousedownpos.X - e.X) >= SystemInformation.DragSize.Width / 2 || 				    Math.Abs(mousedownpos.Y - e.Y) >= SystemInformation.DragSize.Height / 2) 				{ 					clickedOnSelectedText = false; 					ISelection selection = textArea.SelectionManager.GetSelectionAt(textArea.Caret.Offset); 					if (selection != null) { 						string text = selection.SelectedText; 						bool isReadOnly = SelectionManager.SelectionIsReadOnly(textArea.Document' selection); 						if (text != null && text.Length > 0) { 							DataObject dataObject = new DataObject (); 							dataObject.SetData(DataFormats.UnicodeText' true' text); 							dataObject.SetData(selection); 							dodragdrop = true; 							textArea.DoDragDrop(dataObject' isReadOnly ? DragDropEffects.All & ~DragDropEffects.Move : DragDropEffects.All); 						} 					} 				} 				 				return; 			}
Magic Number,ICSharpCode.TextEditor,TextAreaMouseHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaMouseHandler.cs,TextAreaMouseMove,The following statement contains a magic number: if (clickedOnSelectedText) { 				if (Math.Abs(mousedownpos.X - e.X) >= SystemInformation.DragSize.Width / 2 || 				    Math.Abs(mousedownpos.Y - e.Y) >= SystemInformation.DragSize.Height / 2) 				{ 					clickedOnSelectedText = false; 					ISelection selection = textArea.SelectionManager.GetSelectionAt(textArea.Caret.Offset); 					if (selection != null) { 						string text = selection.SelectedText; 						bool isReadOnly = SelectionManager.SelectionIsReadOnly(textArea.Document' selection); 						if (text != null && text.Length > 0) { 							DataObject dataObject = new DataObject (); 							dataObject.SetData(DataFormats.UnicodeText' true' text); 							dataObject.SetData(selection); 							dodragdrop = true; 							textArea.DoDragDrop(dataObject' isReadOnly ? DragDropEffects.All & ~DragDropEffects.Move : DragDropEffects.All); 						} 					} 				} 				 				return; 			}
Magic Number,ICSharpCode.TextEditor,TextAreaMouseHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaMouseHandler.cs,OnMouseDown,The following statement contains a magic number: if (textArea.TextView.DrawingPosition.Contains(mousepos.X' mousepos.Y)) { 				gotmousedown = true; 				textArea.SelectionManager.selectFrom.where = WhereFrom.TArea; 				button = e.Button; 				 				// double-click 				if (button == MouseButtons.Left && e.Clicks == 2) { 					int deltaX   = Math.Abs(lastmousedownpos.X - e.X); 					int deltaY   = Math.Abs(lastmousedownpos.Y - e.Y); 					if (deltaX <= SystemInformation.DoubleClickSize.Width && 					    deltaY <= SystemInformation.DoubleClickSize.Height) { 						DoubleClickSelectionExtend(); 						lastmousedownpos = new Point(e.X' e.Y);  						if (textArea.SelectionManager.selectFrom.where == WhereFrom.Gutter) { 							if (!minSelection.IsEmpty && !maxSelection.IsEmpty && textArea.SelectionManager.SelectionCollection.Count > 0) { 								textArea.SelectionManager.SelectionCollection[0].StartPosition = minSelection; 								textArea.SelectionManager.SelectionCollection[0].EndPosition = maxSelection; 								textArea.SelectionManager.SelectionStart = minSelection;  								minSelection = TextLocation.Empty; 								maxSelection = TextLocation.Empty; 							} 						} 						return; 					} 				} 				minSelection = TextLocation.Empty; 				maxSelection = TextLocation.Empty; 				 				lastmousedownpos = mousedownpos = new Point(e.X' e.Y); 				 				if (button == MouseButtons.Left) { 					FoldMarker marker = textArea.TextView.GetFoldMarkerFromPosition(mousepos.X - textArea.TextView.DrawingPosition.X' 					                                                                mousepos.Y - textArea.TextView.DrawingPosition.Y); 					if (marker != null && marker.IsFolded) { 						if (textArea.SelectionManager.HasSomethingSelected) { 							clickedOnSelectedText = true; 						} 						 						TextLocation startLocation = new TextLocation(marker.StartColumn' marker.StartLine); 						TextLocation endLocation = new TextLocation(marker.EndColumn' marker.EndLine); 						textArea.SelectionManager.SetSelection(new DefaultSelection(textArea.TextView.Document' startLocation' endLocation)); 						textArea.Caret.Position = startLocation; 						textArea.SetDesiredColumn(); 						textArea.Focus(); 						return; 					}  					if ((Control.ModifierKeys & Keys.Shift) == Keys.Shift) { 						ExtendSelectionToMouse(); 					} else { 						TextLocation realmousepos = textArea.TextView.GetLogicalPosition(mousepos.X - textArea.TextView.DrawingPosition.X' mousepos.Y - textArea.TextView.DrawingPosition.Y); 						clickedOnSelectedText = false; 						 						int offset = textArea.Document.PositionToOffset(realmousepos); 						 						if (textArea.SelectionManager.HasSomethingSelected && 						    textArea.SelectionManager.IsSelected(offset)) { 							clickedOnSelectedText = true; 						} else { 							textArea.SelectionManager.ClearSelection(); 							if (mousepos.Y > 0 && mousepos.Y < textArea.TextView.DrawingPosition.Height) { 								TextLocation pos = new TextLocation(); 								pos.Y = Math.Min(textArea.Document.TotalNumberOfLines - 1'  realmousepos.Y); 								pos.X = realmousepos.X; 								textArea.Caret.Position = pos; 								textArea.SetDesiredColumn(); 							} 						} 					} 				} else if (button == MouseButtons.Right) { 					// Rightclick sets the cursor to the click position unless 					// the previous selection was clicked 					TextLocation realmousepos = textArea.TextView.GetLogicalPosition(mousepos.X - textArea.TextView.DrawingPosition.X' mousepos.Y - textArea.TextView.DrawingPosition.Y); 					int offset = textArea.Document.PositionToOffset(realmousepos); 					if (!textArea.SelectionManager.HasSomethingSelected || 					    !textArea.SelectionManager.IsSelected(offset)) 					{ 						textArea.SelectionManager.ClearSelection(); 						if (mousepos.Y > 0 && mousepos.Y < textArea.TextView.DrawingPosition.Height) { 							TextLocation pos = new TextLocation(); 							pos.Y = Math.Min(textArea.Document.TotalNumberOfLines - 1'  realmousepos.Y); 							pos.X = realmousepos.X; 							textArea.Caret.Position = pos; 							textArea.SetDesiredColumn(); 						} 					} 				} 			}
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,DrawBreakpoint,The following statement contains a magic number: int diameter = Math.Min(iconBarWidth - 2' textArea.TextView.FontHeight);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,DrawBreakpoint,The following statement contains a magic number: Rectangle rect = new Rectangle(1' 			                               y + (textArea.TextView.FontHeight - diameter) / 2' 			                               diameter' 			                               diameter);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,DrawBreakpoint,The following statement contains a magic number: using (GraphicsPath path = new GraphicsPath()) { 				path.AddEllipse(rect); 				using (PathGradientBrush pthGrBrush = new PathGradientBrush(path)) { 					pthGrBrush.CenterPoint = new PointF(rect.Left + rect.Width / 3 ' rect.Top + rect.Height / 3); 					pthGrBrush.CenterColor = Color.MistyRose; 					Color[] colors = {isHealthy ? Color.Firebrick : Color.Olive}; 					pthGrBrush.SurroundColors = colors; 					 					if (isEnabled) { 						g.FillEllipse(pthGrBrush' rect); 					} else { 						g.FillEllipse(SystemBrushes.Control' rect); 						using (Pen pen = new Pen(pthGrBrush)) { 							g.DrawEllipse(pen' new Rectangle(rect.X + 1' rect.Y + 1' rect.Width - 2' rect.Height - 2)); 						} 					} 				} 			}
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,DrawBreakpoint,The following statement contains a magic number: using (GraphicsPath path = new GraphicsPath()) { 				path.AddEllipse(rect); 				using (PathGradientBrush pthGrBrush = new PathGradientBrush(path)) { 					pthGrBrush.CenterPoint = new PointF(rect.Left + rect.Width / 3 ' rect.Top + rect.Height / 3); 					pthGrBrush.CenterColor = Color.MistyRose; 					Color[] colors = {isHealthy ? Color.Firebrick : Color.Olive}; 					pthGrBrush.SurroundColors = colors; 					 					if (isEnabled) { 						g.FillEllipse(pthGrBrush' rect); 					} else { 						g.FillEllipse(SystemBrushes.Control' rect); 						using (Pen pen = new Pen(pthGrBrush)) { 							g.DrawEllipse(pen' new Rectangle(rect.X + 1' rect.Y + 1' rect.Width - 2' rect.Height - 2)); 						} 					} 				} 			}
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,DrawBreakpoint,The following statement contains a magic number: using (GraphicsPath path = new GraphicsPath()) { 				path.AddEllipse(rect); 				using (PathGradientBrush pthGrBrush = new PathGradientBrush(path)) { 					pthGrBrush.CenterPoint = new PointF(rect.Left + rect.Width / 3 ' rect.Top + rect.Height / 3); 					pthGrBrush.CenterColor = Color.MistyRose; 					Color[] colors = {isHealthy ? Color.Firebrick : Color.Olive}; 					pthGrBrush.SurroundColors = colors; 					 					if (isEnabled) { 						g.FillEllipse(pthGrBrush' rect); 					} else { 						g.FillEllipse(SystemBrushes.Control' rect); 						using (Pen pen = new Pen(pthGrBrush)) { 							g.DrawEllipse(pen' new Rectangle(rect.X + 1' rect.Y + 1' rect.Width - 2' rect.Height - 2)); 						} 					} 				} 			}
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,DrawBreakpoint,The following statement contains a magic number: using (GraphicsPath path = new GraphicsPath()) { 				path.AddEllipse(rect); 				using (PathGradientBrush pthGrBrush = new PathGradientBrush(path)) { 					pthGrBrush.CenterPoint = new PointF(rect.Left + rect.Width / 3 ' rect.Top + rect.Height / 3); 					pthGrBrush.CenterColor = Color.MistyRose; 					Color[] colors = {isHealthy ? Color.Firebrick : Color.Olive}; 					pthGrBrush.SurroundColors = colors; 					 					if (isEnabled) { 						g.FillEllipse(pthGrBrush' rect); 					} else { 						g.FillEllipse(SystemBrushes.Control' rect); 						using (Pen pen = new Pen(pthGrBrush)) { 							g.DrawEllipse(pen' new Rectangle(rect.X + 1' rect.Y + 1' rect.Width - 2' rect.Height - 2)); 						} 					} 				} 			}
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,DrawBookmark,The following statement contains a magic number: int delta = textArea.TextView.FontHeight / 8;
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,DrawBookmark,The following statement contains a magic number: Rectangle rect = new Rectangle(1' y + delta' base.drawingPosition.Width - 4' textArea.TextView.FontHeight - delta * 2);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,DrawBookmark,The following statement contains a magic number: Rectangle rect = new Rectangle(1' y + delta' base.drawingPosition.Width - 4' textArea.TextView.FontHeight - delta * 2);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,DrawArrow,The following statement contains a magic number: int delta = textArea.TextView.FontHeight / 8;
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,DrawArrow,The following statement contains a magic number: Rectangle rect = new Rectangle(1' y + delta' base.drawingPosition.Width - 4' textArea.TextView.FontHeight - delta * 2);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,DrawArrow,The following statement contains a magic number: Rectangle rect = new Rectangle(1' y + delta' base.drawingPosition.Width - 4' textArea.TextView.FontHeight - delta * 2);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,CreateArrowGraphicsPath,The following statement contains a magic number: int halfX = r.Width / 2;
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,CreateArrowGraphicsPath,The following statement contains a magic number: int halfY = r.Height/ 2;
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,CreateArrowGraphicsPath,The following statement contains a magic number: gp.AddLine(r.X' r.Y + halfY/2' r.X + halfX' r.Y + halfY/2);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,CreateArrowGraphicsPath,The following statement contains a magic number: gp.AddLine(r.X' r.Y + halfY/2' r.X + halfX' r.Y + halfY/2);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,CreateArrowGraphicsPath,The following statement contains a magic number: gp.AddLine(r.X + halfX' r.Y + halfY/2' r.X + halfX' r.Y);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,CreateArrowGraphicsPath,The following statement contains a magic number: gp.AddLine(r.X + halfX' r.Bottom' r.X + halfX' r.Bottom - halfY/2);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,CreateArrowGraphicsPath,The following statement contains a magic number: gp.AddLine(r.X + halfX' r.Bottom - halfY/2' r.X' r.Bottom - halfY/2);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,CreateArrowGraphicsPath,The following statement contains a magic number: gp.AddLine(r.X + halfX' r.Bottom - halfY/2' r.X' r.Bottom - halfY/2);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,CreateArrowGraphicsPath,The following statement contains a magic number: gp.AddLine(r.X' r.Bottom - halfY/2' r.X' r.Y + halfY/2);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,CreateArrowGraphicsPath,The following statement contains a magic number: gp.AddLine(r.X' r.Bottom - halfY/2' r.X' r.Y + halfY/2);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,CreateRoundRectGraphicsPath,The following statement contains a magic number: int radius = r.Width / 2;
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,CreateRoundRectGraphicsPath,The following statement contains a magic number: gp.AddArc(r.Right - radius' r.Y' radius' radius' 270' 90);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,CreateRoundRectGraphicsPath,The following statement contains a magic number: gp.AddArc(r.Right - radius' r.Y' radius' radius' 270' 90);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,CreateRoundRectGraphicsPath,The following statement contains a magic number: gp.AddArc(r.Right - radius' r.Bottom - radius' radius' radius' 0' 90);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,CreateRoundRectGraphicsPath,The following statement contains a magic number: gp.AddArc(r.X' r.Bottom - radius' radius' radius' 90' 90);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,CreateRoundRectGraphicsPath,The following statement contains a magic number: gp.AddArc(r.X' r.Bottom - radius' radius' radius' 90' 90);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,CreateRoundRectGraphicsPath,The following statement contains a magic number: gp.AddArc(r.X' r.Y' radius' radius' 180' 90);
Magic Number,ICSharpCode.TextEditor,IconBarMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\IconBarMargin.cs,CreateRoundRectGraphicsPath,The following statement contains a magic number: gp.AddArc(r.X' r.Y' radius' radius' 180' 90);
Magic Number,ICSharpCode.TextEditor,FoldMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\FoldMargin.cs,PaintFoldMarker,The following statement contains a magic number: foldMarkerSize -= (foldMarkerSize) % 2;
Magic Number,ICSharpCode.TextEditor,FoldMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\FoldMargin.cs,PaintFoldMarker,The following statement contains a magic number: int foldMarkerYPos = drawingRectangle.Y + (int)((drawingRectangle.Height - foldMarkerSize) / 2);
Magic Number,ICSharpCode.TextEditor,FoldMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\FoldMargin.cs,PaintFoldMarker,The following statement contains a magic number: int xPos = drawingRectangle.X + (drawingRectangle.Width - foldMarkerSize) / 2 + foldMarkerSize / 2;
Magic Number,ICSharpCode.TextEditor,FoldMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\FoldMargin.cs,PaintFoldMarker,The following statement contains a magic number: int xPos = drawingRectangle.X + (drawingRectangle.Width - foldMarkerSize) / 2 + foldMarkerSize / 2;
Magic Number,ICSharpCode.TextEditor,FoldMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\FoldMargin.cs,PaintFoldMarker,The following statement contains a magic number: if (isFoldStart) { 				bool isVisible         = true; 				bool moreLinedOpenFold = false; 				foreach (FoldMarker foldMarker in foldingsWithStart) { 					if (foldMarker.IsFolded) { 						isVisible = false; 					} else { 						moreLinedOpenFold = foldMarker.EndLine > foldMarker.StartLine; 					} 				} 				 				bool isFoldEndFromUpperFold = false; 				foreach (FoldMarker foldMarker in foldingsWithEnd) { 					if (foldMarker.EndLine > foldMarker.StartLine && !foldMarker.IsFolded) { 						isFoldEndFromUpperFold = true; 					} 				} 				 				DrawFoldMarker(g' new RectangleF(drawingRectangle.X + (drawingRectangle.Width - foldMarkerSize) / 2' 				                                 foldMarkerYPos' 				                                 foldMarkerSize' 				                                 foldMarkerSize)' 				               isVisible' 				               isStartSelected 				              ); 				 				// draw line above fold marker 				if (isBetween || isFoldEndFromUpperFold) { 					g.DrawLine(BrushRegistry.GetPen(isBetweenSelected ? selectedFoldLine.Color : foldLineColor.Color)' 					           xPos' 					           drawingRectangle.Top' 					           xPos' 					           foldMarkerYPos - 1); 				} 				 				// draw line below fold marker 				if (isBetween || moreLinedOpenFold) { 					g.DrawLine(BrushRegistry.GetPen(isEndSelected || (isStartSelected && isVisible) || isBetweenSelected ? selectedFoldLine.Color : foldLineColor.Color)' 					           xPos' 					           foldMarkerYPos + foldMarkerSize + 1' 					           xPos' 					           drawingRectangle.Bottom); 				} 			} else { 				if (isFoldEnd) { 					int midy = drawingRectangle.Top + drawingRectangle.Height / 2; 					 					// draw fold end marker 					g.DrawLine(BrushRegistry.GetPen(isEndSelected ? selectedFoldLine.Color : foldLineColor.Color)' 					           xPos' 					           midy' 					           xPos + foldMarkerSize / 2' 					           midy); 					 					// draw line above fold end marker 					// must be drawn after fold marker because it might have a different color than the fold marker 					g.DrawLine(BrushRegistry.GetPen(isBetweenSelected || isEndSelected ? selectedFoldLine.Color : foldLineColor.Color)' 					           xPos' 					           drawingRectangle.Top' 					           xPos' 					           midy); 					 					// draw line below fold end marker 					if (isBetween) { 						g.DrawLine(BrushRegistry.GetPen(isBetweenSelected ? selectedFoldLine.Color : foldLineColor.Color)' 						           xPos' 						           midy + 1' 						           xPos' 						           drawingRectangle.Bottom); 					} 				} else if (isBetween) { 					// just draw the line :) 					g.DrawLine(BrushRegistry.GetPen(isBetweenSelected ? selectedFoldLine.Color : foldLineColor.Color)' 					           xPos' 					           drawingRectangle.Top' 					           xPos' 					           drawingRectangle.Bottom); 				} 			}
Magic Number,ICSharpCode.TextEditor,FoldMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\FoldMargin.cs,PaintFoldMarker,The following statement contains a magic number: if (isFoldStart) { 				bool isVisible         = true; 				bool moreLinedOpenFold = false; 				foreach (FoldMarker foldMarker in foldingsWithStart) { 					if (foldMarker.IsFolded) { 						isVisible = false; 					} else { 						moreLinedOpenFold = foldMarker.EndLine > foldMarker.StartLine; 					} 				} 				 				bool isFoldEndFromUpperFold = false; 				foreach (FoldMarker foldMarker in foldingsWithEnd) { 					if (foldMarker.EndLine > foldMarker.StartLine && !foldMarker.IsFolded) { 						isFoldEndFromUpperFold = true; 					} 				} 				 				DrawFoldMarker(g' new RectangleF(drawingRectangle.X + (drawingRectangle.Width - foldMarkerSize) / 2' 				                                 foldMarkerYPos' 				                                 foldMarkerSize' 				                                 foldMarkerSize)' 				               isVisible' 				               isStartSelected 				              ); 				 				// draw line above fold marker 				if (isBetween || isFoldEndFromUpperFold) { 					g.DrawLine(BrushRegistry.GetPen(isBetweenSelected ? selectedFoldLine.Color : foldLineColor.Color)' 					           xPos' 					           drawingRectangle.Top' 					           xPos' 					           foldMarkerYPos - 1); 				} 				 				// draw line below fold marker 				if (isBetween || moreLinedOpenFold) { 					g.DrawLine(BrushRegistry.GetPen(isEndSelected || (isStartSelected && isVisible) || isBetweenSelected ? selectedFoldLine.Color : foldLineColor.Color)' 					           xPos' 					           foldMarkerYPos + foldMarkerSize + 1' 					           xPos' 					           drawingRectangle.Bottom); 				} 			} else { 				if (isFoldEnd) { 					int midy = drawingRectangle.Top + drawingRectangle.Height / 2; 					 					// draw fold end marker 					g.DrawLine(BrushRegistry.GetPen(isEndSelected ? selectedFoldLine.Color : foldLineColor.Color)' 					           xPos' 					           midy' 					           xPos + foldMarkerSize / 2' 					           midy); 					 					// draw line above fold end marker 					// must be drawn after fold marker because it might have a different color than the fold marker 					g.DrawLine(BrushRegistry.GetPen(isBetweenSelected || isEndSelected ? selectedFoldLine.Color : foldLineColor.Color)' 					           xPos' 					           drawingRectangle.Top' 					           xPos' 					           midy); 					 					// draw line below fold end marker 					if (isBetween) { 						g.DrawLine(BrushRegistry.GetPen(isBetweenSelected ? selectedFoldLine.Color : foldLineColor.Color)' 						           xPos' 						           midy + 1' 						           xPos' 						           drawingRectangle.Bottom); 					} 				} else if (isBetween) { 					// just draw the line :) 					g.DrawLine(BrushRegistry.GetPen(isBetweenSelected ? selectedFoldLine.Color : foldLineColor.Color)' 					           xPos' 					           drawingRectangle.Top' 					           xPos' 					           drawingRectangle.Bottom); 				} 			}
Magic Number,ICSharpCode.TextEditor,FoldMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\FoldMargin.cs,PaintFoldMarker,The following statement contains a magic number: if (isFoldStart) { 				bool isVisible         = true; 				bool moreLinedOpenFold = false; 				foreach (FoldMarker foldMarker in foldingsWithStart) { 					if (foldMarker.IsFolded) { 						isVisible = false; 					} else { 						moreLinedOpenFold = foldMarker.EndLine > foldMarker.StartLine; 					} 				} 				 				bool isFoldEndFromUpperFold = false; 				foreach (FoldMarker foldMarker in foldingsWithEnd) { 					if (foldMarker.EndLine > foldMarker.StartLine && !foldMarker.IsFolded) { 						isFoldEndFromUpperFold = true; 					} 				} 				 				DrawFoldMarker(g' new RectangleF(drawingRectangle.X + (drawingRectangle.Width - foldMarkerSize) / 2' 				                                 foldMarkerYPos' 				                                 foldMarkerSize' 				                                 foldMarkerSize)' 				               isVisible' 				               isStartSelected 				              ); 				 				// draw line above fold marker 				if (isBetween || isFoldEndFromUpperFold) { 					g.DrawLine(BrushRegistry.GetPen(isBetweenSelected ? selectedFoldLine.Color : foldLineColor.Color)' 					           xPos' 					           drawingRectangle.Top' 					           xPos' 					           foldMarkerYPos - 1); 				} 				 				// draw line below fold marker 				if (isBetween || moreLinedOpenFold) { 					g.DrawLine(BrushRegistry.GetPen(isEndSelected || (isStartSelected && isVisible) || isBetweenSelected ? selectedFoldLine.Color : foldLineColor.Color)' 					           xPos' 					           foldMarkerYPos + foldMarkerSize + 1' 					           xPos' 					           drawingRectangle.Bottom); 				} 			} else { 				if (isFoldEnd) { 					int midy = drawingRectangle.Top + drawingRectangle.Height / 2; 					 					// draw fold end marker 					g.DrawLine(BrushRegistry.GetPen(isEndSelected ? selectedFoldLine.Color : foldLineColor.Color)' 					           xPos' 					           midy' 					           xPos + foldMarkerSize / 2' 					           midy); 					 					// draw line above fold end marker 					// must be drawn after fold marker because it might have a different color than the fold marker 					g.DrawLine(BrushRegistry.GetPen(isBetweenSelected || isEndSelected ? selectedFoldLine.Color : foldLineColor.Color)' 					           xPos' 					           drawingRectangle.Top' 					           xPos' 					           midy); 					 					// draw line below fold end marker 					if (isBetween) { 						g.DrawLine(BrushRegistry.GetPen(isBetweenSelected ? selectedFoldLine.Color : foldLineColor.Color)' 						           xPos' 						           midy + 1' 						           xPos' 						           drawingRectangle.Bottom); 					} 				} else if (isBetween) { 					// just draw the line :) 					g.DrawLine(BrushRegistry.GetPen(isBetweenSelected ? selectedFoldLine.Color : foldLineColor.Color)' 					           xPos' 					           drawingRectangle.Top' 					           xPos' 					           drawingRectangle.Bottom); 				} 			}
Magic Number,ICSharpCode.TextEditor,FoldMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\FoldMargin.cs,DrawFoldMarker,The following statement contains a magic number: int mid    = intRect.Height / 2 + intRect.Height % 2;
Magic Number,ICSharpCode.TextEditor,FoldMargin,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\FoldMargin.cs,DrawFoldMarker,The following statement contains a magic number: int mid    = intRect.Height / 2 + intRect.Height % 2;
Magic Number,ICSharpCode.TextEditor,TextAreaDragDropHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaDragDropHandler.cs,GetDragDropEffect,The following statement contains a magic number: if ((e.AllowedEffect & DragDropEffects.Move) > 0 && 			    (e.AllowedEffect & DragDropEffects.Copy) > 0) { 				return (e.KeyState & 8) > 0 ? DragDropEffects.Copy : DragDropEffects.Move; 			} else if ((e.AllowedEffect & DragDropEffects.Move) > 0) { 				return DragDropEffects.Move; 			} else if ((e.AllowedEffect & DragDropEffects.Copy) > 0) { 				return DragDropEffects.Copy; 			}
Magic Number,ICSharpCode.TextEditor,HRuler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\HRuler.cs,OnPaint,The following statement contains a magic number: for (float x = textArea.TextView.DrawingPosition.Left; x < textArea.TextView.DrawingPosition.Right; x += textArea.TextView.WideSpaceWidth) { 				int offset = (Height * 2) / 3; 				if (num % 5 == 0) { 					offset = (Height * 4) / 5; 				} 				 				if (num % 10 == 0) { 					offset = 1; 				} 				++num; 				g.DrawLine(Pens.Black' 				           (int)x' offset' (int)x' Height - offset); 			}
Magic Number,ICSharpCode.TextEditor,HRuler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\HRuler.cs,OnPaint,The following statement contains a magic number: for (float x = textArea.TextView.DrawingPosition.Left; x < textArea.TextView.DrawingPosition.Right; x += textArea.TextView.WideSpaceWidth) { 				int offset = (Height * 2) / 3; 				if (num % 5 == 0) { 					offset = (Height * 4) / 5; 				} 				 				if (num % 10 == 0) { 					offset = 1; 				} 				++num; 				g.DrawLine(Pens.Black' 				           (int)x' offset' (int)x' Height - offset); 			}
Magic Number,ICSharpCode.TextEditor,HRuler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\HRuler.cs,OnPaint,The following statement contains a magic number: for (float x = textArea.TextView.DrawingPosition.Left; x < textArea.TextView.DrawingPosition.Right; x += textArea.TextView.WideSpaceWidth) { 				int offset = (Height * 2) / 3; 				if (num % 5 == 0) { 					offset = (Height * 4) / 5; 				} 				 				if (num % 10 == 0) { 					offset = 1; 				} 				++num; 				g.DrawLine(Pens.Black' 				           (int)x' offset' (int)x' Height - offset); 			}
Magic Number,ICSharpCode.TextEditor,HRuler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\HRuler.cs,OnPaint,The following statement contains a magic number: for (float x = textArea.TextView.DrawingPosition.Left; x < textArea.TextView.DrawingPosition.Right; x += textArea.TextView.WideSpaceWidth) { 				int offset = (Height * 2) / 3; 				if (num % 5 == 0) { 					offset = (Height * 4) / 5; 				} 				 				if (num % 10 == 0) { 					offset = 1; 				} 				++num; 				g.DrawLine(Pens.Black' 				           (int)x' offset' (int)x' Height - offset); 			}
Magic Number,ICSharpCode.TextEditor,HRuler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\HRuler.cs,OnPaint,The following statement contains a magic number: for (float x = textArea.TextView.DrawingPosition.Left; x < textArea.TextView.DrawingPosition.Right; x += textArea.TextView.WideSpaceWidth) { 				int offset = (Height * 2) / 3; 				if (num % 5 == 0) { 					offset = (Height * 4) / 5; 				} 				 				if (num % 10 == 0) { 					offset = 1; 				} 				++num; 				g.DrawLine(Pens.Black' 				           (int)x' offset' (int)x' Height - offset); 			}
Magic Number,ICSharpCode.TextEditor,HRuler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\HRuler.cs,OnPaint,The following statement contains a magic number: for (float x = textArea.TextView.DrawingPosition.Left; x < textArea.TextView.DrawingPosition.Right; x += textArea.TextView.WideSpaceWidth) { 				int offset = (Height * 2) / 3; 				if (num % 5 == 0) { 					offset = (Height * 4) / 5; 				} 				 				if (num % 10 == 0) { 					offset = 1; 				} 				++num; 				g.DrawLine(Pens.Black' 				           (int)x' offset' (int)x' Height - offset); 			}
Magic Number,ICSharpCode.TextEditor,DrawableLine,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\DrawableLine.cs,DrawDocumentWord,The following statement contains a magic number: SizeF wordSize = g.MeasureString(word' font' 32768' sf);
Magic Number,ICSharpCode.TextEditor,DrawableLine,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\DrawableLine.cs,DrawLine,The following statement contains a magic number: foreach (SimpleTextWord word in words) { 				switch (word.Type) { 					case TextWordType.Space: 						xPos += spaceSize.Width; 						break; 					case TextWordType.Tab: 						float tabWidth = spaceSize.Width * 4; 						xPos += tabWidth; 						xPos = (int)((xPos + 2) / tabWidth) * tabWidth; 						break; 					case TextWordType.Word: 						xPos += DrawDocumentWord(g' 						                         word.Word' 						                         new PointF(xPos + xOffset' yPos)' 						                         word.Bold ? boldMonospacedFont : monospacedFont' 						                         c == Color.Empty ? word.Color : c 						                        ); 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor,DrawableLine,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\DrawableLine.cs,DrawLine,The following statement contains a magic number: foreach (SimpleTextWord word in words) { 				switch (word.Type) { 					case TextWordType.Space: 						xPos += spaceSize.Width; 						break; 					case TextWordType.Tab: 						float tabWidth = spaceSize.Width * 4; 						xPos += tabWidth; 						xPos = (int)((xPos + 2) / tabWidth) * tabWidth; 						break; 					case TextWordType.Word: 						xPos += DrawDocumentWord(g' 						                         word.Word' 						                         new PointF(xPos + xOffset' yPos)' 						                         word.Bold ? boldMonospacedFont : monospacedFont' 						                         c == Color.Empty ? word.Color : c 						                        ); 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor,DrawableLine,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\DrawableLine.cs,MeasureWidth,The following statement contains a magic number: foreach (SimpleTextWord word in words) { 				switch (word.Type) { 					case TextWordType.Space: 						xPos += spaceSize.Width; 						break; 					case TextWordType.Tab: 						float tabWidth = spaceSize.Width * 4; 						xPos += tabWidth; 						xPos = (int)((xPos + 2) / tabWidth) * tabWidth; 						break; 					case TextWordType.Word: 						if (word.Word != null && word.Word.Length > 0) { 							xPos += g.MeasureString(word.Word' word.Bold ? boldMonospacedFont : monospacedFont' 32768' sf).Width; 						} 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor,DrawableLine,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\DrawableLine.cs,MeasureWidth,The following statement contains a magic number: foreach (SimpleTextWord word in words) { 				switch (word.Type) { 					case TextWordType.Space: 						xPos += spaceSize.Width; 						break; 					case TextWordType.Tab: 						float tabWidth = spaceSize.Width * 4; 						xPos += tabWidth; 						xPos = (int)((xPos + 2) / tabWidth) * tabWidth; 						break; 					case TextWordType.Word: 						if (word.Word != null && word.Word.Length > 0) { 							xPos += g.MeasureString(word.Word' word.Bold ? boldMonospacedFont : monospacedFont' 32768' sf).Width; 						} 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor,DrawableLine,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\DrawableLine.cs,MeasureWidth,The following statement contains a magic number: foreach (SimpleTextWord word in words) { 				switch (word.Type) { 					case TextWordType.Space: 						xPos += spaceSize.Width; 						break; 					case TextWordType.Tab: 						float tabWidth = spaceSize.Width * 4; 						xPos += tabWidth; 						xPos = (int)((xPos + 2) / tabWidth) * tabWidth; 						break; 					case TextWordType.Word: 						if (word.Word != null && word.Word.Length > 0) { 							xPos += g.MeasureString(word.Word' word.Bold ? boldMonospacedFont : monospacedFont' 32768' sf).Width; 						} 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor.Util,AugmentableRedBlackTree<T;Host>,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\AugmentableRedBlackTree.cs,AppendTreeToString,The following statement contains a magic number: indent += 2;
Magic Number,ICSharpCode.TextEditor.Util,RtfWriter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\RtfWriter.cs,BuildFileContent,The following statement contains a magic number: foreach (ISelection selection in textArea.SelectionManager.SelectionCollection) { 				int selectionOffset    = textArea.Document.PositionToOffset(selection.StartPosition); 				int selectionEndOffset = textArea.Document.PositionToOffset(selection.EndPosition); 				for (int i = selection.StartPosition.Y; i <= selection.EndPosition.Y; ++i) { 					LineSegment line = textArea.Document.GetLineSegment(i); 					int offset = line.Offset; 					if (line.Words == null) { 						continue; 					} 					 					foreach (TextWord word in line.Words) { 						switch (word.Type) { 							case TextWordType.Space: 								if (selection.ContainsOffset(offset)) { 									rtf.Append(' '); 								} 								++offset; 								break; 							 							case TextWordType.Tab: 								if (selection.ContainsOffset(offset)) { 									rtf.Append(@"\tab"); 								} 								++offset; 								escapeSequence = true; 								break; 							 							case TextWordType.Word: 								Color c = word.Color; 								 								if (offset + word.Word.Length > selectionOffset && offset < selectionEndOffset) { 									string colorstr = c.R + "' " + c.G + "' " + c.B; 									 									if (!colors.ContainsKey(colorstr)) { 										colors[colorstr] = ++colorNum; 										colorString.Append(@"\red" + c.R + @"\green" + c.G + @"\blue" + c.B + ";"); 									} 									if (c != curColor || firstLine) { 										rtf.Append(@"\cf" + colors[colorstr].ToString()); 										curColor = c; 										escapeSequence = true; 									} 									 									if (oldItalic != word.Italic) { 										if (word.Italic) { 											rtf.Append(@"\i"); 										} else { 											rtf.Append(@"\i0"); 										} 										oldItalic = word.Italic; 										escapeSequence = true; 									} 									 									if (oldBold != word.Bold) { 										if (word.Bold) { 											rtf.Append(@"\b"); 										} else { 											rtf.Append(@"\b0"); 										} 										oldBold = word.Bold; 										escapeSequence = true; 									} 									 									if (firstLine) { 										rtf.Append(@"\f0\fs" + (textArea.TextEditorProperties.Font.Size * 2)); 										firstLine = false; 									} 									if (escapeSequence) { 										rtf.Append(' '); 										escapeSequence = false; 									} 									string printWord; 									if (offset < selectionOffset) { 										printWord = word.Word.Substring(selectionOffset - offset); 									} else if (offset + word.Word.Length > selectionEndOffset) { 										printWord = word.Word.Substring(0' (offset + word.Word.Length) - selectionEndOffset); 									} else { 										printWord = word.Word; 									} 									 									AppendText(rtf' printWord); 								} 								offset += word.Length; 								break; 						} 					} 					if (offset < selectionEndOffset) { 						rtf.Append(@"\par"); 					} 					rtf.Append('\n'); 				} 			}
Magic Number,ICSharpCode.TextEditor.Util,RtfWriter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\RtfWriter.cs,AppendText,The following statement contains a magic number: foreach (char c in text) { 				switch (c) { 					case '\\': 						rtfOutput.Append(@"\\"); 						break; 					case '{': 						rtfOutput.Append("\\{"); 						break; 					case '}': 						rtfOutput.Append("\\}"); 						break; 					default: 						if (c < 256) { 							rtfOutput.Append(c); 						} else { 							// yes' RTF really expects signed 16-bit integers! 							rtfOutput.Append("\\u" + unchecked((short)c).ToString() + "?"); 						} 						break; 				} 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainter.cs,GetTipSize,The following statement contains a magic number: SizeF maxLayoutSize = new SizeF(workingArea.Right - screenLocation.X - HorizontalBorder * 2' 			                                workingArea.Bottom - screenLocation.Y - VerticalBorder * 2);
Magic Number,ICSharpCode.TextEditor.Util,TipPainter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainter.cs,GetTipSize,The following statement contains a magic number: SizeF maxLayoutSize = new SizeF(workingArea.Right - screenLocation.X - HorizontalBorder * 2' 			                                workingArea.Bottom - screenLocation.Y - VerticalBorder * 2);
Magic Number,ICSharpCode.TextEditor.Util,TipPainter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainter.cs,GetTipSize,The following statement contains a magic number: if (maxLayoutSize.Width > 0 && maxLayoutSize.Height > 0) { 				graphics.TextRenderingHint = 					TextRenderingHint.AntiAliasGridFit; 				 				tipData.SetMaximumSize(maxLayoutSize); 				tipSizeF = tipData.GetRequiredSize(); 				tipData.SetAllocatedSize(tipSizeF); 				 				tipSizeF += new SizeF(HorizontalBorder * 2' 				                      VerticalBorder   * 2); 				tipSize = Size.Ceiling(tipSizeF); 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainter.cs,GetTipSize,The following statement contains a magic number: if (maxLayoutSize.Width > 0 && maxLayoutSize.Height > 0) { 				graphics.TextRenderingHint = 					TextRenderingHint.AntiAliasGridFit; 				 				tipData.SetMaximumSize(maxLayoutSize); 				tipSizeF = tipData.GetRequiredSize(); 				tipData.SetAllocatedSize(tipSizeF); 				 				tipSizeF += new SizeF(HorizontalBorder * 2' 				                      VerticalBorder   * 2); 				tipSize = Size.Ceiling(tipSizeF); 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainter.cs,GetLeftHandSideTipSize,The following statement contains a magic number: SizeF maxLayoutSize = new SizeF(screenLocation.X - HorizontalBorder * 2' 			                                workingArea.Bottom - screenLocation.Y - VerticalBorder * 2);
Magic Number,ICSharpCode.TextEditor.Util,TipPainter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainter.cs,GetLeftHandSideTipSize,The following statement contains a magic number: SizeF maxLayoutSize = new SizeF(screenLocation.X - HorizontalBorder * 2' 			                                workingArea.Bottom - screenLocation.Y - VerticalBorder * 2);
Magic Number,ICSharpCode.TextEditor.Util,TipPainter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainter.cs,GetLeftHandSideTipSize,The following statement contains a magic number: if (maxLayoutSize.Width > 0 && maxLayoutSize.Height > 0) { 				graphics.TextRenderingHint = 					TextRenderingHint.AntiAliasGridFit; 				 				tipData.SetMaximumSize(maxLayoutSize); 				tipSizeF = tipData.GetRequiredSize(); 				tipData.SetAllocatedSize(tipSizeF); 				 				tipSizeF += new SizeF(HorizontalBorder * 2' 				                      VerticalBorder   * 2); 				tipSize = Size.Ceiling(tipSizeF); 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainter.cs,GetLeftHandSideTipSize,The following statement contains a magic number: if (maxLayoutSize.Width > 0 && maxLayoutSize.Height > 0) { 				graphics.TextRenderingHint = 					TextRenderingHint.AntiAliasGridFit; 				 				tipData.SetMaximumSize(maxLayoutSize); 				tipSizeF = tipData.GetRequiredSize(); 				tipData.SetAllocatedSize(tipSizeF); 				 				tipSizeF += new SizeF(HorizontalBorder * 2' 				                      VerticalBorder   * 2); 				tipSize = Size.Ceiling(tipSizeF); 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainter.cs,DrawTip,The following statement contains a magic number: SizeF maxLayoutSize = new SizeF(workingArea.Right - screenLocation.X - HorizontalBorder * 2' 			                                workingArea.Bottom - screenLocation.Y - VerticalBorder * 2);
Magic Number,ICSharpCode.TextEditor.Util,TipPainter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainter.cs,DrawTip,The following statement contains a magic number: SizeF maxLayoutSize = new SizeF(workingArea.Right - screenLocation.X - HorizontalBorder * 2' 			                                workingArea.Bottom - screenLocation.Y - VerticalBorder * 2);
Magic Number,ICSharpCode.TextEditor.Util,TipPainter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainter.cs,DrawTip,The following statement contains a magic number: if (maxLayoutSize.Width > 0 && maxLayoutSize.Height > 0) { 				graphics.TextRenderingHint = 					TextRenderingHint.AntiAliasGridFit; 				 				tipData.SetMaximumSize(maxLayoutSize); 				tipSizeF = tipData.GetRequiredSize(); 				tipData.SetAllocatedSize(tipSizeF); 				 				tipSizeF += new SizeF(HorizontalBorder * 2' 				                      VerticalBorder   * 2); 				tipSize = Size.Ceiling(tipSizeF); 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainter.cs,DrawTip,The following statement contains a magic number: if (maxLayoutSize.Width > 0 && maxLayoutSize.Height > 0) { 				graphics.TextRenderingHint = 					TextRenderingHint.AntiAliasGridFit; 				 				tipData.SetMaximumSize(maxLayoutSize); 				tipSizeF = tipData.GetRequiredSize(); 				tipData.SetAllocatedSize(tipSizeF); 				 				tipSizeF += new SizeF(HorizontalBorder * 2' 				                      VerticalBorder   * 2); 				tipSize = Size.Ceiling(tipSizeF); 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainter.cs,DrawFixedWidthTip,The following statement contains a magic number: SizeF maxLayoutSize = new SizeF(screenLocation.X - HorizontalBorder * 2' 			                                workingArea.Bottom - screenLocation.Y - VerticalBorder * 2);
Magic Number,ICSharpCode.TextEditor.Util,TipPainter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainter.cs,DrawFixedWidthTip,The following statement contains a magic number: SizeF maxLayoutSize = new SizeF(screenLocation.X - HorizontalBorder * 2' 			                                workingArea.Bottom - screenLocation.Y - VerticalBorder * 2);
Magic Number,ICSharpCode.TextEditor.Util,TipPainter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainter.cs,DrawFixedWidthTip,The following statement contains a magic number: if (maxLayoutSize.Width > 0 && maxLayoutSize.Height > 0) { 				graphics.TextRenderingHint = 					TextRenderingHint.AntiAliasGridFit; 				 				tipData.SetMaximumSize(maxLayoutSize); 				tipSizeF = tipData.GetRequiredSize(); 				tipData.SetAllocatedSize(tipSizeF); 				 				tipSizeF += new SizeF(HorizontalBorder * 2' 				                      VerticalBorder   * 2); 				tipSize = Size.Ceiling(tipSizeF); 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainter.cs,DrawFixedWidthTip,The following statement contains a magic number: if (maxLayoutSize.Width > 0 && maxLayoutSize.Height > 0) { 				graphics.TextRenderingHint = 					TextRenderingHint.AntiAliasGridFit; 				 				tipData.SetMaximumSize(maxLayoutSize); 				tipSizeF = tipData.GetRequiredSize(); 				tipData.SetAllocatedSize(tipSizeF); 				 				tipSizeF += new SizeF(HorizontalBorder * 2' 				                      VerticalBorder   * 2); 				tipSize = Size.Ceiling(tipSizeF); 			}
Magic Number,ICSharpCode.TextEditor.Util,CountTipText,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipText.cs,DrawTriangle,The following statement contains a magic number: Brush brush = BrushRegistry.GetBrush(Color.FromArgb(192' 192' 192));
Magic Number,ICSharpCode.TextEditor.Util,CountTipText,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipText.cs,DrawTriangle,The following statement contains a magic number: Brush brush = BrushRegistry.GetBrush(Color.FromArgb(192' 192' 192));
Magic Number,ICSharpCode.TextEditor.Util,CountTipText,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipText.cs,DrawTriangle,The following statement contains a magic number: Brush brush = BrushRegistry.GetBrush(Color.FromArgb(192' 192' 192));
Magic Number,ICSharpCode.TextEditor.Util,CountTipText,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipText.cs,DrawTriangle,The following statement contains a magic number: float triHeight2 = triHeight / 2;
Magic Number,ICSharpCode.TextEditor.Util,CountTipText,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipText.cs,DrawTriangle,The following statement contains a magic number: float triHeight4 = triHeight / 4;
Magic Number,ICSharpCode.TextEditor.Util,CountTipText,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipText.cs,DrawTriangle,The following statement contains a magic number: if (flipped) { 				base.Graphics.FillPolygon(brush' new PointF[] { 				                          	new PointF(x'                y + triHeight2 - triHeight4)' 				                          	new PointF(x + triWidth / 2' y + triHeight2 + triHeight4)' 				                          	new PointF(x + triWidth'     y + triHeight2 - triHeight4)' 				                          }); 				 			} else { 				base.Graphics.FillPolygon(brush' new PointF[] { 				                          	new PointF(x'                y +  triHeight2 + triHeight4)' 				                          	new PointF(x + triWidth / 2' y +  triHeight2 - triHeight4)' 				                          	new PointF(x + triWidth'     y +  triHeight2 + triHeight4)' 				                          }); 			}
Magic Number,ICSharpCode.TextEditor.Util,CountTipText,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipText.cs,DrawTriangle,The following statement contains a magic number: if (flipped) { 				base.Graphics.FillPolygon(brush' new PointF[] { 				                          	new PointF(x'                y + triHeight2 - triHeight4)' 				                          	new PointF(x + triWidth / 2' y + triHeight2 + triHeight4)' 				                          	new PointF(x + triWidth'     y + triHeight2 - triHeight4)' 				                          }); 				 			} else { 				base.Graphics.FillPolygon(brush' new PointF[] { 				                          	new PointF(x'                y +  triHeight2 + triHeight4)' 				                          	new PointF(x + triWidth / 2' y +  triHeight2 - triHeight4)' 				                          	new PointF(x + triWidth'     y +  triHeight2 + triHeight4)' 				                          }); 			}
Magic Number,ICSharpCode.TextEditor.Util,CountTipText,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipText.cs,Draw,The following statement contains a magic number: if (tipText != null && tipText.Length > 0) { 				base.Draw(new PointF(location.X + triWidth + 4' location.Y)); 				DrawingRectangle1 = new Rectangle((int)location.X + 2' 				                                  (int)location.Y + 2' 				                                  (int)(triWidth)' 				                                  (int)(triHeight)); 				DrawingRectangle2 = new Rectangle((int)(location.X + base.AllocatedSize.Width - triWidth  - 2)' 				                                  (int)location.Y + 2' 				                                  (int)(triWidth)' 				                                  (int)(triHeight)); 				DrawTriangle(location.X + 2' location.Y + 2' false); 				DrawTriangle(location.X + base.AllocatedSize.Width - triWidth  - 2' location.Y + 2' true); 			}
Magic Number,ICSharpCode.TextEditor.Util,CountTipText,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipText.cs,Draw,The following statement contains a magic number: if (tipText != null && tipText.Length > 0) { 				base.Draw(new PointF(location.X + triWidth + 4' location.Y)); 				DrawingRectangle1 = new Rectangle((int)location.X + 2' 				                                  (int)location.Y + 2' 				                                  (int)(triWidth)' 				                                  (int)(triHeight)); 				DrawingRectangle2 = new Rectangle((int)(location.X + base.AllocatedSize.Width - triWidth  - 2)' 				                                  (int)location.Y + 2' 				                                  (int)(triWidth)' 				                                  (int)(triHeight)); 				DrawTriangle(location.X + 2' location.Y + 2' false); 				DrawTriangle(location.X + base.AllocatedSize.Width - triWidth  - 2' location.Y + 2' true); 			}
Magic Number,ICSharpCode.TextEditor.Util,CountTipText,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipText.cs,Draw,The following statement contains a magic number: if (tipText != null && tipText.Length > 0) { 				base.Draw(new PointF(location.X + triWidth + 4' location.Y)); 				DrawingRectangle1 = new Rectangle((int)location.X + 2' 				                                  (int)location.Y + 2' 				                                  (int)(triWidth)' 				                                  (int)(triHeight)); 				DrawingRectangle2 = new Rectangle((int)(location.X + base.AllocatedSize.Width - triWidth  - 2)' 				                                  (int)location.Y + 2' 				                                  (int)(triWidth)' 				                                  (int)(triHeight)); 				DrawTriangle(location.X + 2' location.Y + 2' false); 				DrawTriangle(location.X + base.AllocatedSize.Width - triWidth  - 2' location.Y + 2' true); 			}
Magic Number,ICSharpCode.TextEditor.Util,CountTipText,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipText.cs,Draw,The following statement contains a magic number: if (tipText != null && tipText.Length > 0) { 				base.Draw(new PointF(location.X + triWidth + 4' location.Y)); 				DrawingRectangle1 = new Rectangle((int)location.X + 2' 				                                  (int)location.Y + 2' 				                                  (int)(triWidth)' 				                                  (int)(triHeight)); 				DrawingRectangle2 = new Rectangle((int)(location.X + base.AllocatedSize.Width - triWidth  - 2)' 				                                  (int)location.Y + 2' 				                                  (int)(triWidth)' 				                                  (int)(triHeight)); 				DrawTriangle(location.X + 2' location.Y + 2' false); 				DrawTriangle(location.X + base.AllocatedSize.Width - triWidth  - 2' location.Y + 2' true); 			}
Magic Number,ICSharpCode.TextEditor.Util,CountTipText,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipText.cs,Draw,The following statement contains a magic number: if (tipText != null && tipText.Length > 0) { 				base.Draw(new PointF(location.X + triWidth + 4' location.Y)); 				DrawingRectangle1 = new Rectangle((int)location.X + 2' 				                                  (int)location.Y + 2' 				                                  (int)(triWidth)' 				                                  (int)(triHeight)); 				DrawingRectangle2 = new Rectangle((int)(location.X + base.AllocatedSize.Width - triWidth  - 2)' 				                                  (int)location.Y + 2' 				                                  (int)(triWidth)' 				                                  (int)(triHeight)); 				DrawTriangle(location.X + 2' location.Y + 2' false); 				DrawTriangle(location.X + base.AllocatedSize.Width - triWidth  - 2' location.Y + 2' true); 			}
Magic Number,ICSharpCode.TextEditor.Util,CountTipText,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipText.cs,Draw,The following statement contains a magic number: if (tipText != null && tipText.Length > 0) { 				base.Draw(new PointF(location.X + triWidth + 4' location.Y)); 				DrawingRectangle1 = new Rectangle((int)location.X + 2' 				                                  (int)location.Y + 2' 				                                  (int)(triWidth)' 				                                  (int)(triHeight)); 				DrawingRectangle2 = new Rectangle((int)(location.X + base.AllocatedSize.Width - triWidth  - 2)' 				                                  (int)location.Y + 2' 				                                  (int)(triWidth)' 				                                  (int)(triHeight)); 				DrawTriangle(location.X + 2' location.Y + 2' false); 				DrawTriangle(location.X + base.AllocatedSize.Width - triWidth  - 2' location.Y + 2' true); 			}
Magic Number,ICSharpCode.TextEditor.Util,CountTipText,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipText.cs,Draw,The following statement contains a magic number: if (tipText != null && tipText.Length > 0) { 				base.Draw(new PointF(location.X + triWidth + 4' location.Y)); 				DrawingRectangle1 = new Rectangle((int)location.X + 2' 				                                  (int)location.Y + 2' 				                                  (int)(triWidth)' 				                                  (int)(triHeight)); 				DrawingRectangle2 = new Rectangle((int)(location.X + base.AllocatedSize.Width - triWidth  - 2)' 				                                  (int)location.Y + 2' 				                                  (int)(triWidth)' 				                                  (int)(triHeight)); 				DrawTriangle(location.X + 2' location.Y + 2' false); 				DrawTriangle(location.X + base.AllocatedSize.Width - triWidth  - 2' location.Y + 2' true); 			}
Magic Number,ICSharpCode.TextEditor.Util,CountTipText,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipText.cs,Draw,The following statement contains a magic number: if (tipText != null && tipText.Length > 0) { 				base.Draw(new PointF(location.X + triWidth + 4' location.Y)); 				DrawingRectangle1 = new Rectangle((int)location.X + 2' 				                                  (int)location.Y + 2' 				                                  (int)(triWidth)' 				                                  (int)(triHeight)); 				DrawingRectangle2 = new Rectangle((int)(location.X + base.AllocatedSize.Width - triWidth  - 2)' 				                                  (int)location.Y + 2' 				                                  (int)(triWidth)' 				                                  (int)(triHeight)); 				DrawTriangle(location.X + 2' location.Y + 2' false); 				DrawTriangle(location.X + base.AllocatedSize.Width - triWidth  - 2' location.Y + 2' true); 			}
Magic Number,ICSharpCode.TextEditor.Util,CountTipText,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipText.cs,Draw,The following statement contains a magic number: if (tipText != null && tipText.Length > 0) { 				base.Draw(new PointF(location.X + triWidth + 4' location.Y)); 				DrawingRectangle1 = new Rectangle((int)location.X + 2' 				                                  (int)location.Y + 2' 				                                  (int)(triWidth)' 				                                  (int)(triHeight)); 				DrawingRectangle2 = new Rectangle((int)(location.X + base.AllocatedSize.Width - triWidth  - 2)' 				                                  (int)location.Y + 2' 				                                  (int)(triWidth)' 				                                  (int)(triHeight)); 				DrawTriangle(location.X + 2' location.Y + 2' false); 				DrawTriangle(location.X + base.AllocatedSize.Width - triWidth  - 2' location.Y + 2' true); 			}
Magic Number,ICSharpCode.TextEditor.Util,CountTipText,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipText.cs,OnMaximumSizeChanged,The following statement contains a magic number: if (IsTextVisible()) { 				SizeF tipSize = Graphics.MeasureString 					(tipText' tipFont' MaximumSize' 					 GetInternalStringFormat()); 				tipSize.Width += triWidth * 2 + 8; 				SetRequiredSize(tipSize); 			} else { 				SetRequiredSize(SizeF.Empty); 			}
Magic Number,ICSharpCode.TextEditor.Util,CountTipText,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipText.cs,OnMaximumSizeChanged,The following statement contains a magic number: if (IsTextVisible()) { 				SizeF tipSize = Graphics.MeasureString 					(tipText' tipFont' MaximumSize' 					 GetInternalStringFormat()); 				tipSize.Width += triWidth * 2 + 8; 				SetRequiredSize(tipSize); 			} else { 				SetRequiredSize(SizeF.Empty); 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,GetLeftHandSideDrawingSizeHelpTipFromCombinedDescription,The following statement contains a magic number: if (IsVisibleText(description)) { 				string[] splitDescription = description.Split(new char[] { '\n' }' 2); 				 				if (splitDescription.Length > 0) { 					basicDescription = splitDescription[0]; 					 					if (splitDescription.Length > 1) { 						documentation = splitDescription[1].Trim(); 					} 				} 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,GetDrawingSizeHelpTipFromCombinedDescription,The following statement contains a magic number: if (IsVisibleText(description)) { 				string[] splitDescription = description.Split(new char[] { '\n' }' 2); 				 				if (splitDescription.Length > 0) { 					basicDescription = splitDescription[0]; 					 					if (splitDescription.Length > 1) { 						documentation = splitDescription[1].Trim(); 					} 				} 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,DrawHelpTipFromCombinedDescription,The following statement contains a magic number: if (IsVisibleText(description)) { 				string[] splitDescription = description.Split 					(new char[] { '\n' }' 2); 				 				if (splitDescription.Length > 0) { 					basicDescription = splitDescription[0]; 					 					if (splitDescription.Length > 1) { 						documentation = splitDescription[1].Trim(); 					} 				} 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,DrawFixedWidthHelpTipFromCombinedDescription,The following statement contains a magic number: if (IsVisibleText(description)) { 				string[] splitDescription = description.Split 					(new char[] { '\n' }' 2); 				 				if (splitDescription.Length > 0) { 					basicDescription = splitDescription[0]; 					 					if (splitDescription.Length > 1) { 						documentation = splitDescription[1].Trim(); 					} 				} 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,GetDrawingSizeDrawHelpTip,The following statement contains a magic number: if (IsVisibleText(countMessage)     || 			    IsVisibleText(basicDescription) || 			    IsVisibleText(documentation)) { 				// Create all the TipSection objects. 				CountTipText countMessageTip = new CountTipText(graphics' font' countMessage); 				 				TipSpacer countSpacer = new TipSpacer(graphics' new SizeF(IsVisibleText(countMessage) ? 4 : 0' 0)); 				 				TipText descriptionTip = new TipText(graphics' font' basicDescription); 				 				TipSpacer docSpacer = new TipSpacer(graphics' new SizeF(0' IsVisibleText(documentation) ? 4 : 0)); 				 				TipText docTip = new TipText(graphics' font' documentation); 				 				// Now put them together. 				TipSplitter descSplitter = new TipSplitter(graphics' false' 				                                           descriptionTip' 				                                           docSpacer 				                                          ); 				 				TipSplitter mainSplitter = new TipSplitter(graphics' true' 				                                           countMessageTip' 				                                           countSpacer' 				                                           descSplitter); 				 				TipSplitter mainSplitter2 = new TipSplitter(graphics' false' 				                                            mainSplitter' 				                                            docTip); 				 				// Show it. 				Size size = TipPainter.GetTipSize(control' graphics' mainSplitter2); 				DrawingRectangle1 = countMessageTip.DrawingRectangle1; 				DrawingRectangle2 = countMessageTip.DrawingRectangle2; 				return size; 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,GetDrawingSizeDrawHelpTip,The following statement contains a magic number: if (IsVisibleText(countMessage)     || 			    IsVisibleText(basicDescription) || 			    IsVisibleText(documentation)) { 				// Create all the TipSection objects. 				CountTipText countMessageTip = new CountTipText(graphics' font' countMessage); 				 				TipSpacer countSpacer = new TipSpacer(graphics' new SizeF(IsVisibleText(countMessage) ? 4 : 0' 0)); 				 				TipText descriptionTip = new TipText(graphics' font' basicDescription); 				 				TipSpacer docSpacer = new TipSpacer(graphics' new SizeF(0' IsVisibleText(documentation) ? 4 : 0)); 				 				TipText docTip = new TipText(graphics' font' documentation); 				 				// Now put them together. 				TipSplitter descSplitter = new TipSplitter(graphics' false' 				                                           descriptionTip' 				                                           docSpacer 				                                          ); 				 				TipSplitter mainSplitter = new TipSplitter(graphics' true' 				                                           countMessageTip' 				                                           countSpacer' 				                                           descSplitter); 				 				TipSplitter mainSplitter2 = new TipSplitter(graphics' false' 				                                            mainSplitter' 				                                            docTip); 				 				// Show it. 				Size size = TipPainter.GetTipSize(control' graphics' mainSplitter2); 				DrawingRectangle1 = countMessageTip.DrawingRectangle1; 				DrawingRectangle2 = countMessageTip.DrawingRectangle2; 				return size; 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,GetLeftHandSideDrawingSizeDrawHelpTip,The following statement contains a magic number: if (IsVisibleText(countMessage)     || 			    IsVisibleText(basicDescription) || 			    IsVisibleText(documentation)) { 				// Create all the TipSection objects. 				CountTipText countMessageTip = new CountTipText(graphics' font' countMessage); 				 				TipSpacer countSpacer = new TipSpacer(graphics' new SizeF(IsVisibleText(countMessage) ? 4 : 0' 0)); 				 				TipText descriptionTip = new TipText(graphics' font' basicDescription); 				 				TipSpacer docSpacer = new TipSpacer(graphics' new SizeF(0' IsVisibleText(documentation) ? 4 : 0)); 				 				TipText docTip = new TipText(graphics' font' documentation); 				 				// Now put them together. 				TipSplitter descSplitter = new TipSplitter(graphics' false' 				                                           descriptionTip' 				                                           docSpacer 				                                          ); 				 				TipSplitter mainSplitter = new TipSplitter(graphics' true' 				                                           countMessageTip' 				                                           countSpacer' 				                                           descSplitter); 				 				TipSplitter mainSplitter2 = new TipSplitter(graphics' false' 				                                            mainSplitter' 				                                            docTip); 				 				// Show it. 				Size size = TipPainter.GetLeftHandSideTipSize(control' graphics' mainSplitter2' p); 				return size; 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,GetLeftHandSideDrawingSizeDrawHelpTip,The following statement contains a magic number: if (IsVisibleText(countMessage)     || 			    IsVisibleText(basicDescription) || 			    IsVisibleText(documentation)) { 				// Create all the TipSection objects. 				CountTipText countMessageTip = new CountTipText(graphics' font' countMessage); 				 				TipSpacer countSpacer = new TipSpacer(graphics' new SizeF(IsVisibleText(countMessage) ? 4 : 0' 0)); 				 				TipText descriptionTip = new TipText(graphics' font' basicDescription); 				 				TipSpacer docSpacer = new TipSpacer(graphics' new SizeF(0' IsVisibleText(documentation) ? 4 : 0)); 				 				TipText docTip = new TipText(graphics' font' documentation); 				 				// Now put them together. 				TipSplitter descSplitter = new TipSplitter(graphics' false' 				                                           descriptionTip' 				                                           docSpacer 				                                          ); 				 				TipSplitter mainSplitter = new TipSplitter(graphics' true' 				                                           countMessageTip' 				                                           countSpacer' 				                                           descSplitter); 				 				TipSplitter mainSplitter2 = new TipSplitter(graphics' false' 				                                            mainSplitter' 				                                            docTip); 				 				// Show it. 				Size size = TipPainter.GetLeftHandSideTipSize(control' graphics' mainSplitter2' p); 				return size; 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,DrawHelpTip,The following statement contains a magic number: if (IsVisibleText(countMessage)     || 			    IsVisibleText(basicDescription) || 			    IsVisibleText(documentation)) { 				// Create all the TipSection objects. 				CountTipText countMessageTip = new CountTipText(graphics' font' countMessage); 				 				TipSpacer countSpacer = new TipSpacer(graphics' new SizeF(IsVisibleText(countMessage) ? 4 : 0' 0)); 				 				TipText descriptionTip = new TipText(graphics' font' basicDescription); 				 				TipSpacer docSpacer = new TipSpacer(graphics' new SizeF(0' IsVisibleText(documentation) ? 4 : 0)); 				 				TipText docTip = new TipText(graphics' font' documentation); 				 				// Now put them together. 				TipSplitter descSplitter = new TipSplitter(graphics' false' 				                                           descriptionTip' 				                                           docSpacer 				                                          ); 				 				TipSplitter mainSplitter = new TipSplitter(graphics' true' 				                                           countMessageTip' 				                                           countSpacer' 				                                           descSplitter); 				 				TipSplitter mainSplitter2 = new TipSplitter(graphics' false' 				                                            mainSplitter' 				                                            docTip); 				 				// Show it. 				Size size = TipPainter.DrawTip(control' graphics' mainSplitter2); 				DrawingRectangle1 = countMessageTip.DrawingRectangle1; 				DrawingRectangle2 = countMessageTip.DrawingRectangle2; 				return size; 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,DrawHelpTip,The following statement contains a magic number: if (IsVisibleText(countMessage)     || 			    IsVisibleText(basicDescription) || 			    IsVisibleText(documentation)) { 				// Create all the TipSection objects. 				CountTipText countMessageTip = new CountTipText(graphics' font' countMessage); 				 				TipSpacer countSpacer = new TipSpacer(graphics' new SizeF(IsVisibleText(countMessage) ? 4 : 0' 0)); 				 				TipText descriptionTip = new TipText(graphics' font' basicDescription); 				 				TipSpacer docSpacer = new TipSpacer(graphics' new SizeF(0' IsVisibleText(documentation) ? 4 : 0)); 				 				TipText docTip = new TipText(graphics' font' documentation); 				 				// Now put them together. 				TipSplitter descSplitter = new TipSplitter(graphics' false' 				                                           descriptionTip' 				                                           docSpacer 				                                          ); 				 				TipSplitter mainSplitter = new TipSplitter(graphics' true' 				                                           countMessageTip' 				                                           countSpacer' 				                                           descSplitter); 				 				TipSplitter mainSplitter2 = new TipSplitter(graphics' false' 				                                            mainSplitter' 				                                            docTip); 				 				// Show it. 				Size size = TipPainter.DrawTip(control' graphics' mainSplitter2); 				DrawingRectangle1 = countMessageTip.DrawingRectangle1; 				DrawingRectangle2 = countMessageTip.DrawingRectangle2; 				return size; 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,DrawFixedWidthHelpTip,The following statement contains a magic number: if (IsVisibleText(countMessage)     || 			    IsVisibleText(basicDescription) || 			    IsVisibleText(documentation)) { 				// Create all the TipSection objects. 				CountTipText countMessageTip = new CountTipText(graphics' font' countMessage); 				 				TipSpacer countSpacer = new TipSpacer(graphics' new SizeF(IsVisibleText(countMessage) ? 4 : 0' 0)); 				 				TipText descriptionTip = new TipText(graphics' font' basicDescription); 				 				TipSpacer docSpacer = new TipSpacer(graphics' new SizeF(0' IsVisibleText(documentation) ? 4 : 0)); 				 				TipText docTip = new TipText(graphics' font' documentation); 				 				// Now put them together. 				TipSplitter descSplitter = new TipSplitter(graphics' false' 				                                           descriptionTip' 				                                           docSpacer 				                                          ); 				 				TipSplitter mainSplitter = new TipSplitter(graphics' true' 				                                           countMessageTip' 				                                           countSpacer' 				                                           descSplitter); 				 				TipSplitter mainSplitter2 = new TipSplitter(graphics' false' 				                                            mainSplitter' 				                                            docTip); 				 				// Show it. 				Size size = TipPainter.DrawFixedWidthTip(control' graphics' mainSplitter2); 				DrawingRectangle1 = countMessageTip.DrawingRectangle1; 				DrawingRectangle2 = countMessageTip.DrawingRectangle2; 				return size; 			}
Magic Number,ICSharpCode.TextEditor.Util,TipPainterTools,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\TipPainterTools.cs,DrawFixedWidthHelpTip,The following statement contains a magic number: if (IsVisibleText(countMessage)     || 			    IsVisibleText(basicDescription) || 			    IsVisibleText(documentation)) { 				// Create all the TipSection objects. 				CountTipText countMessageTip = new CountTipText(graphics' font' countMessage); 				 				TipSpacer countSpacer = new TipSpacer(graphics' new SizeF(IsVisibleText(countMessage) ? 4 : 0' 0)); 				 				TipText descriptionTip = new TipText(graphics' font' basicDescription); 				 				TipSpacer docSpacer = new TipSpacer(graphics' new SizeF(0' IsVisibleText(documentation) ? 4 : 0)); 				 				TipText docTip = new TipText(graphics' font' documentation); 				 				// Now put them together. 				TipSplitter descSplitter = new TipSplitter(graphics' false' 				                                           descriptionTip' 				                                           docSpacer 				                                          ); 				 				TipSplitter mainSplitter = new TipSplitter(graphics' true' 				                                           countMessageTip' 				                                           countSpacer' 				                                           descSplitter); 				 				TipSplitter mainSplitter2 = new TipSplitter(graphics' false' 				                                            mainSplitter' 				                                            docTip); 				 				// Show it. 				Size size = TipPainter.DrawFixedWidthTip(control' graphics' mainSplitter2); 				DrawingRectangle1 = countMessageTip.DrawingRectangle1; 				DrawingRectangle2 = countMessageTip.DrawingRectangle2; 				return size; 			}
Magic Number,ICSharpCode.TextEditor.Util,FileReader,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\FileReader.cs,IsUnicode,The following statement contains a magic number: return codepage == 65001 || codepage == 65000 || codepage == 1200 || codepage == 1201;
Magic Number,ICSharpCode.TextEditor.Util,FileReader,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\FileReader.cs,IsUnicode,The following statement contains a magic number: return codepage == 65001 || codepage == 65000 || codepage == 1200 || codepage == 1201;
Magic Number,ICSharpCode.TextEditor.Util,FileReader,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\FileReader.cs,IsUnicode,The following statement contains a magic number: return codepage == 65001 || codepage == 65000 || codepage == 1200 || codepage == 1201;
Magic Number,ICSharpCode.TextEditor.Util,FileReader,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\FileReader.cs,IsUnicode,The following statement contains a magic number: return codepage == 65001 || codepage == 65000 || codepage == 1200 || codepage == 1201;
Magic Number,ICSharpCode.TextEditor.Util,FileReader,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\FileReader.cs,OpenStream,The following statement contains a magic number: if (fs.Length >= 2) { 				// the autodetection of StreamReader is not capable of detecting the difference 				// between ISO-8859-1 and UTF-8 without BOM. 				int firstByte = fs.ReadByte(); 				int secondByte = fs.ReadByte(); 				switch ((firstByte << 8) | secondByte) { 					case 0x0000: // either UTF-32 Big Endian or a binary file; use StreamReader 					case 0xfffe: // Unicode BOM (UTF-16 LE or UTF-32 LE) 					case 0xfeff: // UTF-16 BE BOM 					case 0xefbb: // start of UTF-8 BOM 						// StreamReader autodetection works 						fs.Position = 0; 						return new StreamReader(fs); 					default: 						return AutoDetect(fs' (byte)firstByte' (byte)secondByte' defaultEncoding); 				} 			} else { 				if (defaultEncoding != null) { 					return new StreamReader(fs' defaultEncoding); 				} else { 					return new StreamReader(fs); 				} 			}
Magic Number,ICSharpCode.TextEditor.Util,FileReader,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\FileReader.cs,OpenStream,The following statement contains a magic number: if (fs.Length >= 2) { 				// the autodetection of StreamReader is not capable of detecting the difference 				// between ISO-8859-1 and UTF-8 without BOM. 				int firstByte = fs.ReadByte(); 				int secondByte = fs.ReadByte(); 				switch ((firstByte << 8) | secondByte) { 					case 0x0000: // either UTF-32 Big Endian or a binary file; use StreamReader 					case 0xfffe: // Unicode BOM (UTF-16 LE or UTF-32 LE) 					case 0xfeff: // UTF-16 BE BOM 					case 0xefbb: // start of UTF-8 BOM 						// StreamReader autodetection works 						fs.Position = 0; 						return new StreamReader(fs); 					default: 						return AutoDetect(fs' (byte)firstByte' (byte)secondByte' defaultEncoding); 				} 			} else { 				if (defaultEncoding != null) { 					return new StreamReader(fs' defaultEncoding); 				} else { 					return new StreamReader(fs); 				} 			}
Magic Number,ICSharpCode.TextEditor.Util,FileReader,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\FileReader.cs,AutoDetect,The following statement contains a magic number: int max = (int)Math.Min(fs.Length' 500000);
Magic Number,ICSharpCode.TextEditor.Util,FileReader,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\FileReader.cs,AutoDetect,The following statement contains a magic number: const int UTF8  = 2;
Magic Number,ICSharpCode.TextEditor.Util,FileReader,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\FileReader.cs,AutoDetect,The following statement contains a magic number: const int UTF8Sequence = 3;
Magic Number,ICSharpCode.TextEditor.Util,FileReader,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\FileReader.cs,AutoDetect,The following statement contains a magic number: for (int i = 0; i < max; i++) { 				if (i == 0) { 					b = firstByte; 				} else if (i == 1) { 					b = secondByte; 				} else { 					b = (byte)fs.ReadByte(); 				} 				if (b < 0x80) { 					// normal ASCII character 					if (state == UTF8Sequence) { 						state = Error; 						break; 					} 				} else if (b < 0xc0) { 					// 10xxxxxx : continues UTF8 byte sequence 					if (state == UTF8Sequence) { 						--sequenceLength; 						if (sequenceLength < 0) { 							state = Error; 							break; 						} else if (sequenceLength == 0) { 							state = UTF8; 						} 					} else { 						state = Error; 						break; 					} 				} else if (b >= 0xc2 && b < 0xf5) { 					// beginning of byte sequence 					if (state == UTF8 || state == ASCII) { 						state = UTF8Sequence; 						if (b < 0xe0) { 							sequenceLength = 1; // one more byte following 						} else if (b < 0xf0) { 							sequenceLength = 2; // two more bytes following 						} else { 							sequenceLength = 3; // three more bytes following 						} 					} else { 						state = Error; 						break; 					} 				} else { 					// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629) 					state = Error; 					break; 				} 			}
Magic Number,ICSharpCode.TextEditor.Util,FileReader,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\FileReader.cs,AutoDetect,The following statement contains a magic number: for (int i = 0; i < max; i++) { 				if (i == 0) { 					b = firstByte; 				} else if (i == 1) { 					b = secondByte; 				} else { 					b = (byte)fs.ReadByte(); 				} 				if (b < 0x80) { 					// normal ASCII character 					if (state == UTF8Sequence) { 						state = Error; 						break; 					} 				} else if (b < 0xc0) { 					// 10xxxxxx : continues UTF8 byte sequence 					if (state == UTF8Sequence) { 						--sequenceLength; 						if (sequenceLength < 0) { 							state = Error; 							break; 						} else if (sequenceLength == 0) { 							state = UTF8; 						} 					} else { 						state = Error; 						break; 					} 				} else if (b >= 0xc2 && b < 0xf5) { 					// beginning of byte sequence 					if (state == UTF8 || state == ASCII) { 						state = UTF8Sequence; 						if (b < 0xe0) { 							sequenceLength = 1; // one more byte following 						} else if (b < 0xf0) { 							sequenceLength = 2; // two more bytes following 						} else { 							sequenceLength = 3; // three more bytes following 						} 					} else { 						state = Error; 						break; 					} 				} else { 					// 0xc0' 0xc1' 0xf5 to 0xff are invalid in UTF-8 (see RFC 3629) 					state = Error; 					break; 				} 			}
Magic Number,ICSharpCode.TextEditor.Util,WeakCollection<T>,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\WeakCollection.cs,Add,The following statement contains a magic number: if (innerList.Count == innerList.Capacity || (innerList.Count % 32) == 31) 				innerList.RemoveAll(delegate(WeakReference r) { return !r.IsAlive; });
Magic Number,ICSharpCode.TextEditor.Util,WeakCollection<T>,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\WeakCollection.cs,Add,The following statement contains a magic number: if (innerList.Count == innerList.Capacity || (innerList.Count % 32) == 31) 				innerList.RemoveAll(delegate(WeakReference r) { return !r.IsAlive; });
Magic Number,ICSharpCode.TextEditor.Actions,BlockCommentRegion,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,GetHashCode,The following statement contains a magic number: unchecked { 				if (commentStart != null) hashCode += 1000000007 * commentStart.GetHashCode(); 				if (commentEnd != null) hashCode += 1000000009 * commentEnd.GetHashCode(); 				hashCode += 1000000021 * startOffset.GetHashCode(); 				hashCode += 1000000033 * endOffset.GetHashCode(); 			}
Magic Number,ICSharpCode.TextEditor.Actions,BlockCommentRegion,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,GetHashCode,The following statement contains a magic number: unchecked { 				if (commentStart != null) hashCode += 1000000007 * commentStart.GetHashCode(); 				if (commentEnd != null) hashCode += 1000000009 * commentEnd.GetHashCode(); 				hashCode += 1000000021 * startOffset.GetHashCode(); 				hashCode += 1000000033 * endOffset.GetHashCode(); 			}
Magic Number,ICSharpCode.TextEditor.Actions,BlockCommentRegion,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,GetHashCode,The following statement contains a magic number: unchecked { 				if (commentStart != null) hashCode += 1000000007 * commentStart.GetHashCode(); 				if (commentEnd != null) hashCode += 1000000009 * commentEnd.GetHashCode(); 				hashCode += 1000000021 * startOffset.GetHashCode(); 				hashCode += 1000000033 * endOffset.GetHashCode(); 			}
Magic Number,ICSharpCode.TextEditor.Actions,BlockCommentRegion,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,GetHashCode,The following statement contains a magic number: unchecked { 				if (commentStart != null) hashCode += 1000000007 * commentStart.GetHashCode(); 				if (commentEnd != null) hashCode += 1000000009 * commentEnd.GetHashCode(); 				hashCode += 1000000021 * startOffset.GetHashCode(); 				hashCode += 1000000033 * endOffset.GetHashCode(); 			}
Magic Number,ICSharpCode.TextEditor.Gui.CompletionWindow,CodeCompletionWindow,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\CompletionWindow\CodeCompletionWindow.cs,SetDeclarationViewLocation,The following statement contains a magic number: if (rightSpace * 2 > leftSpace) { 				declarationViewWindow.FixedWidth = false; 				pos = new Point(Bounds.Right' Bounds.Top); 				if (declarationViewWindow.Location != pos) { 					declarationViewWindow.Location = pos; 				} 			} else { 				declarationViewWindow.Width = declarationViewWindow.GetRequiredLeftHandSideWidth(new Point(Bounds.Left' Bounds.Top)); 				declarationViewWindow.FixedWidth = true; 				if (Bounds.Left < declarationViewWindow.Width) { 					pos = new Point(0' Bounds.Top); 				} else { 					pos = new Point(Bounds.Left - declarationViewWindow.Width' Bounds.Top); 				} 				if (declarationViewWindow.Location != pos) { 					declarationViewWindow.Location = pos; 				} 				declarationViewWindow.Refresh(); 			}
Magic Number,ICSharpCode.TextEditor.Gui.CompletionWindow,CodeCompletionWindow,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\CompletionWindow\CodeCompletionWindow.cs,GetListViewSize,The following statement contains a magic number: int width = codeCompletionListView.ItemHeight * 10;
Magic Number,ICSharpCode.TextEditor.Gui.CompletionWindow,AbstractCompletionWindow,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\CompletionWindow\AbstractCompletionWindow.cs,AddShadowToWindow,The following statement contains a magic number: if (shadowStatus == 0) { 				// Test OS version 				shadowStatus = -1; // shadow not supported 				if (Environment.OSVersion.Platform == PlatformID.Win32NT) { 					Version ver = Environment.OSVersion.Version; 					if (ver.Major > 5 || ver.Major == 5 && ver.Minor >= 1) { 						shadowStatus = 1; 					} 				} 			}
Magic Number,ICSharpCode.TextEditor.Gui.CompletionWindow,AbstractCompletionWindow,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\CompletionWindow\AbstractCompletionWindow.cs,AddShadowToWindow,The following statement contains a magic number: if (shadowStatus == 0) { 				// Test OS version 				shadowStatus = -1; // shadow not supported 				if (Environment.OSVersion.Platform == PlatformID.Win32NT) { 					Version ver = Environment.OSVersion.Version; 					if (ver.Major > 5 || ver.Major == 5 && ver.Minor >= 1) { 						shadowStatus = 1; 					} 				} 			}
Magic Number,ICSharpCode.TextEditor.Gui.CompletionWindow,CodeCompletionListView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\CompletionWindow\CodeCompletionListView.cs,CenterViewOn,The following statement contains a magic number: int firstItem = index - MaxVisibleItem / 2;
Magic Number,ICSharpCode.TextEditor.Gui.CompletionWindow,CodeCompletionListView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\CompletionWindow\CodeCompletionListView.cs,SelectItemWithStart,The following statement contains a magic number: for (int i = 0; i < completionData.Length; ++i) { 				string itemText = completionData[i].Text; 				string lowerText = itemText.ToLower(); 				if (lowerText.StartsWith(startText)) { 					double priority = completionData[i].Priority; 					int quality; 					if (lowerText == startText) { 						if (itemText == originalStartText) 							quality = 3; 						else 							quality = 2; 					} else if (itemText.StartsWith(originalStartText)) { 						quality = 1; 					} else { 						quality = 0; 					} 					bool useThisItem; 					if (bestQuality < quality) { 						useThisItem = true; 					} else { 						if (bestIndex == selectedItem) { 							useThisItem = false; 						} else if (i == selectedItem) { 							useThisItem = bestQuality == quality; 						} else { 							useThisItem = bestQuality == quality && bestPriority < priority; 						} 					} 					if (useThisItem) { 						bestIndex = i; 						bestPriority = priority; 						bestQuality = quality; 					} 				} 			}
Magic Number,ICSharpCode.TextEditor.Gui.CompletionWindow,CodeCompletionListView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\CompletionWindow\CodeCompletionListView.cs,SelectItemWithStart,The following statement contains a magic number: for (int i = 0; i < completionData.Length; ++i) { 				string itemText = completionData[i].Text; 				string lowerText = itemText.ToLower(); 				if (lowerText.StartsWith(startText)) { 					double priority = completionData[i].Priority; 					int quality; 					if (lowerText == startText) { 						if (itemText == originalStartText) 							quality = 3; 						else 							quality = 2; 					} else if (itemText.StartsWith(originalStartText)) { 						quality = 1; 					} else { 						quality = 0; 					} 					bool useThisItem; 					if (bestQuality < quality) { 						useThisItem = true; 					} else { 						if (bestIndex == selectedItem) { 							useThisItem = false; 						} else if (i == selectedItem) { 							useThisItem = bestQuality == quality; 						} else { 							useThisItem = bestQuality == quality && bestPriority < priority; 						} 					} 					if (useThisItem) { 						bestIndex = i; 						bestPriority = priority; 						bestQuality = quality; 					} 				} 			}
Magic Number,ICSharpCode.TextEditor.Gui.CompletionWindow,CodeCompletionListView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\CompletionWindow\CodeCompletionListView.cs,OnPaint,The following statement contains a magic number: while (curItem < completionData.Length && yPos < Height) { 				RectangleF drawingBackground = new RectangleF(1' yPos' Width - 2' itemHeight); 				if (drawingBackground.IntersectsWith(pe.ClipRectangle)) { 					// draw Background 					if (curItem == selectedItem) { 						g.FillRectangle(SystemBrushes.Highlight' drawingBackground); 					} else { 						g.FillRectangle(SystemBrushes.Window' drawingBackground); 					} 					 					// draw Icon 					int   xPos   = 0; 					if (imageList != null && completionData[curItem].ImageIndex < imageList.Images.Count) { 						g.DrawImage(imageList.Images[completionData[curItem].ImageIndex]' new RectangleF(1' yPos' imageWidth' itemHeight)); 						xPos = imageWidth; 					} 					 					// draw text 					if (curItem == selectedItem) { 						g.DrawString(completionData[curItem].Text' Font' SystemBrushes.HighlightText' xPos' yPos); 					} else { 						g.DrawString(completionData[curItem].Text' Font' SystemBrushes.WindowText' xPos' yPos); 					} 				} 				 				yPos += itemHeight; 				++curItem; 			}
Magic Number,ICSharpCode.TextEditor.Gui.CompletionWindow,CodeCompletionListView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\CompletionWindow\CodeCompletionListView.cs,OnMouseDown,The following statement contains a magic number: while (curItem < completionData.Length && yPos < Height) { 				RectangleF drawingBackground = new RectangleF(1' yPos' Width - 2' itemHeight); 				if (drawingBackground.Contains(e.X' e.Y)) { 					SelectIndex(curItem); 					break; 				} 				yPos += itemHeight; 				++curItem; 			}
Missing Default,ICSharpCode.TextEditor.Document,TextUtilities,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\TextUtilities.cs,GetExpressionBeforeOffset,The following switch statement is missing a default case: switch (word) { 							case "ref": 							case "out": 							case "in": 							case "return": 							case "throw": 							case "case": 								goto done; 						}
Missing Default,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,ParseLine,The following switch statement is missing a default case: switch (ch) 			    { 			        case '\n': 			        case '\r': 			            PushCurWord(document' ref markNext' words); 			            ++currentOffset; 			            continue; 			        case ' ': 			            PushCurWord(document' ref markNext' words); 			            if (activeSpan != null && activeSpan.Color.HasBackground) 			            { 			                words.Add(new TextWord.SpaceTextWord(activeSpan.Color)); 			            } 			            else 			            { 			                words.Add(TextWord.Space); 			            } 			            ++currentOffset; 			            continue; 			        case '\t': 			            PushCurWord(document' ref markNext' words); 			            if (activeSpan != null && activeSpan.Color.HasBackground) 			            { 			                words.Add(new TextWord.TabTextWord(activeSpan.Color)); 			            } 			            else 			            { 			                words.Add(TextWord.Tab); 			            } 			            ++currentOffset; 			            continue; 			    }
Missing Default,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,GetRegString,The following switch statement is missing a default case: switch (expr[i]) { 							case '!': // don't match the following expression 								StringBuilder whatmatch = new StringBuilder(); 								++i; 								while (i < expr.Length && expr[i] != '@') { 									whatmatch.Append(expr[i++]); 								} 								break; 							case '@': // matches @ 								regexpr.Append(document.GetCharAt(lineSegment.Offset + index + j)); 								break; 						}
Missing Default,ICSharpCode.TextEditor.Document,DefaultHighlightingStrategy,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\HighlightingStrategy\DefaultHighlightingStrategy.cs,MatchExpr,The following switch statement is missing a default case: switch (expr[i]) { 							case 'C': // match whitespace or punctuation 								if (index + j == lineSegment.Offset || index + j >= lineSegment.Offset + lineSegment.Length) { 									// nothing (EOL or SOL) 								} else { 									char ch = document.GetCharAt(lineSegment.Offset + index + j); 									if (!Char.IsWhiteSpace(ch) && !Char.IsPunctuation(ch)) { 										return false; 									} 								} 								break; 							case '!': // don't match the following expression 								{ 									StringBuilder whatmatch = new StringBuilder(); 									++i; 									while (i < expr.Length && expr[i] != '@') { 										whatmatch.Append(expr[i++]); 									} 									if (lineSegment.Offset + index + j + whatmatch.Length < document.TextLength) { 										int k = 0; 										for (; k < whatmatch.Length; ++k) { 											char docChar = ignoreCase ? Char.ToUpperInvariant(document.GetCharAt(lineSegment.Offset + index + j + k)) : document.GetCharAt(lineSegment.Offset + index + j + k); 											char spanChar = ignoreCase ? Char.ToUpperInvariant(whatmatch[k]) : whatmatch[k]; 											if (docChar != spanChar) { 												break; 											} 										} 										if (k >= whatmatch.Length) { 											return false; 										} 									} //									--j; 									break; 								} 							case '-': // don't match the  expression before 								{ 									StringBuilder whatmatch = new StringBuilder(); 									++i; 									while (i < expr.Length && expr[i] != '@') { 										whatmatch.Append(expr[i++]); 									} 									if (index - whatmatch.Length >= 0) { 										int k = 0; 										for (; k < whatmatch.Length; ++k) { 											char docChar = ignoreCase ? Char.ToUpperInvariant(document.GetCharAt(lineSegment.Offset + index - whatmatch.Length + k)) : document.GetCharAt(lineSegment.Offset + index - whatmatch.Length + k); 											char spanChar = ignoreCase ? Char.ToUpperInvariant(whatmatch[k]) : whatmatch[k]; 											if (docChar != spanChar) 												break; 										} 										if (k >= whatmatch.Length) { 											return false; 										} 									} //									--j; 									break; 								} 							case '@': // matches @ 								if (index + j >= lineSegment.Length || '@' != document.GetCharAt(lineSegment.Offset + index + j)) { 									return false; 								} 								break; 						}
Missing Default,ICSharpCode.TextEditor.Document,LineManager,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Document\LineManager\LineManager.cs,NextDelimiter,The following switch statement is missing a default case: switch (text[i]) { 					case '\r': 						if (i + 1 < text.Length) { 							if (text[i + 1] == '\n') { 								delimiterSegment.Offset = i; 								delimiterSegment.Length = 2; 								return delimiterSegment; 							} 						} 						#if DATACONSISTENCYTEST 						Debug.Assert(false' "Found lone \\r' data consistency problems?"); 						#endif 						goto case '\n'; 					case '\n': 						delimiterSegment.Offset = i; 						delimiterSegment.Length = 1; 						return delimiterSegment; 				}
Missing Default,ICSharpCode.TextEditor,Caret,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\Caret.cs,CreateCaret,The following switch statement is missing a default case: switch (caretMode) { 					case CaretMode.InsertMode: 						caretCreated = caretImplementation.Create(2' textArea.TextView.FontHeight); 						break; 					case CaretMode.OverwriteMode: 						caretCreated = caretImplementation.Create((int)textArea.TextView.SpaceWidth' textArea.TextView.FontHeight); 						break; 				}
Missing Default,ICSharpCode.TextEditor,TextEditorControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextEditorControl.cs,CommitUpdateRequested,The following switch statement is missing a default case: switch (update.TextAreaUpdateType) { 					case TextAreaUpdateType.PositionToEnd: 						this.primaryTextArea.TextArea.UpdateToEnd(update.Position.Y); 						if (this.secondaryTextArea != null) { 							this.secondaryTextArea.TextArea.UpdateToEnd(update.Position.Y); 						} 						break; 					case TextAreaUpdateType.PositionToLineEnd: 					case TextAreaUpdateType.SingleLine: 						this.primaryTextArea.TextArea.UpdateLine(update.Position.Y); 						if (this.secondaryTextArea != null) { 							this.secondaryTextArea.TextArea.UpdateLine(update.Position.Y); 						} 						break; 					case TextAreaUpdateType.SinglePosition: 						this.primaryTextArea.TextArea.UpdateLine(update.Position.Y' update.Position.X' update.Position.X); 						if (this.secondaryTextArea != null) { 							this.secondaryTextArea.TextArea.UpdateLine(update.Position.Y' update.Position.X' update.Position.X); 						} 						break; 					case TextAreaUpdateType.LinesBetween: 						this.primaryTextArea.TextArea.UpdateLines(update.Position.X' update.Position.Y); 						if (this.secondaryTextArea != null) { 							this.secondaryTextArea.TextArea.UpdateLines(update.Position.X' update.Position.Y); 						} 						break; 					case TextAreaUpdateType.WholeTextArea: 						this.primaryTextArea.TextArea.Invalidate(); 						if (this.secondaryTextArea != null) { 							this.secondaryTextArea.TextArea.Invalidate(); 						} 						break; 				}
Missing Default,ICSharpCode.TextEditor,TextEditorControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextEditorControl.cs,MeasurePrintingHeight,The following switch statement is missing a default case: switch (word.Type) { 					case TextWordType.Space: 						Advance(ref xPos' ref yPos' maxWidth' primaryTextArea.TextArea.TextView.SpaceWidth' fontHeight); //						if (!gotNonWhitespace) { //							curTabIndent = xPos; //						} 						break; 					case TextWordType.Tab: 						Advance(ref xPos' ref yPos' maxWidth' TabIndent * primaryTextArea.TextArea.TextView.WideSpaceWidth' fontHeight); //						if (!gotNonWhitespace) { //							curTabIndent = xPos; //						} 						break; 					case TextWordType.Word: //						if (!gotNonWhitespace) { //							gotNonWhitespace = true; //							curTabIndent    += TabIndent * primaryTextArea.TextArea.TextView.GetWidth(' '); //						} 						SizeF drawingSize = g.MeasureString(word.Word' word.GetFont(fontContainer)' new SizeF(maxWidth' fontHeight * 100)' printingStringFormat); 						Advance(ref xPos' ref yPos' maxWidth' drawingSize.Width' fontHeight); 						break; 				}
Missing Default,ICSharpCode.TextEditor,TextEditorControl,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextEditorControl.cs,DrawLine,The following switch statement is missing a default case: switch (word.Type) { 					case TextWordType.Space: 						Advance(ref xPos' ref yPos' margin.Width' primaryTextArea.TextArea.TextView.SpaceWidth' fontHeight); //						if (!gotNonWhitespace) { //							curTabIndent = xPos; //						} 						break; 					case TextWordType.Tab: 						Advance(ref xPos' ref yPos' margin.Width' TabIndent * primaryTextArea.TextArea.TextView.WideSpaceWidth' fontHeight); //						if (!gotNonWhitespace) { //							curTabIndent = xPos; //						} 						break; 					case TextWordType.Word: //						if (!gotNonWhitespace) { //							gotNonWhitespace = true; //							curTabIndent    += TabIndent * primaryTextArea.TextArea.TextView.GetWidth(' '); //						} 						g.DrawString(word.Word' word.GetFont(fontContainer)' BrushRegistry.GetBrush(word.Color)' xPos + margin.X' yPos); 						SizeF drawingSize = g.MeasureString(word.Word' word.GetFont(fontContainer)' new SizeF(margin.Width' fontHeight * 100)' printingStringFormat); 						Advance(ref xPos' ref yPos' margin.Width' drawingSize.Width' fontHeight); 						break; 				}
Missing Default,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,DrawMarkerDraw,The following switch statement is missing a default case: switch (marker.TextMarkerType) { 					case TextMarkerType.Underlined: 						g.DrawLine(BrushRegistry.GetPen(marker.Color)' drawingRect.X' drawYPos' drawingRect.Right' drawYPos); 						break; 					case TextMarkerType.WaveLine: 						int reminder = ((int)drawingRect.X) % 6; 						for (float i = (int)drawingRect.X - reminder; i < drawingRect.Right; i += 6) { 							g.DrawLine(BrushRegistry.GetPen(marker.Color)' i'     drawYPos + 3 - 4' i + 3' drawYPos + 1 - 4); 							if (i + 3 < drawingRect.Right) { 								g.DrawLine(BrushRegistry.GetPen(marker.Color)' i + 3' drawYPos + 1 - 4' i + 6' drawYPos + 3 - 4); 							} 						} 						break; 					case TextMarkerType.SolidBlock: 						g.FillRectangle(BrushRegistry.GetBrush(marker.Color)' drawingRect); 						break; 				}
Missing Default,ICSharpCode.TextEditor,TextView,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextView.cs,CountColumns,The following switch statement is missing a default case: switch (word.Type) { 						case TextWordType.Space: 							drawingPos += spaceWidth; 							break; 						case TextWordType.Tab: 							// go to next tab position 							drawingPos = (int)((drawingPos + MinTabWidth) / tabIndent / WideSpaceWidth) * tabIndent * WideSpaceWidth; 							drawingPos += tabIndent * WideSpaceWidth; 							break; 						case TextWordType.Word: 							int wordStart = Math.Max(wordOffset' start); 							int wordLength = Math.Min(wordOffset + word.Length' end) - wordStart; 							string text = Document.GetText(currentLine.Offset + wordStart' wordLength); 							drawingPos += MeasureStringWidth(g' text' word.GetFont(fontContainer) ?? fontContainer.RegularFont); 							break; 					}
Missing Default,ICSharpCode.TextEditor,TextAreaMouseHandler,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\TextAreaMouseHandler.cs,TextAreaMouseMove,The following switch statement is missing a default case: switch (textArea.SelectionManager.selectFrom.where) 			{ 				case WhereFrom.Gutter: 					ExtendSelectionToMouse(); 					return;  				case WhereFrom.TArea: 					break;  			}
Missing Default,ICSharpCode.TextEditor,DrawableLine,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\DrawableLine.cs,DrawLine,The following switch statement is missing a default case: switch (word.Type) { 					case TextWordType.Space: 						xPos += spaceSize.Width; 						break; 					case TextWordType.Tab: 						float tabWidth = spaceSize.Width * 4; 						xPos += tabWidth; 						xPos = (int)((xPos + 2) / tabWidth) * tabWidth; 						break; 					case TextWordType.Word: 						xPos += DrawDocumentWord(g' 						                         word.Word' 						                         new PointF(xPos + xOffset' yPos)' 						                         word.Bold ? boldMonospacedFont : monospacedFont' 						                         c == Color.Empty ? word.Color : c 						                        ); 						break; 				}
Missing Default,ICSharpCode.TextEditor,DrawableLine,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\DrawableLine.cs,MeasureWidth,The following switch statement is missing a default case: switch (word.Type) { 					case TextWordType.Space: 						xPos += spaceSize.Width; 						break; 					case TextWordType.Tab: 						float tabWidth = spaceSize.Width * 4; 						xPos += tabWidth; 						xPos = (int)((xPos + 2) / tabWidth) * tabWidth; 						break; 					case TextWordType.Word: 						if (word.Word != null && word.Word.Length > 0) { 							xPos += g.MeasureString(word.Word' word.Bold ? boldMonospacedFont : monospacedFont' 32768' sf).Width; 						} 						break; 				}
Missing Default,ICSharpCode.TextEditor.Util,RtfWriter,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Util\RtfWriter.cs,BuildFileContent,The following switch statement is missing a default case: switch (word.Type) { 							case TextWordType.Space: 								if (selection.ContainsOffset(offset)) { 									rtf.Append(' '); 								} 								++offset; 								break; 							 							case TextWordType.Tab: 								if (selection.ContainsOffset(offset)) { 									rtf.Append(@"\tab"); 								} 								++offset; 								escapeSequence = true; 								break; 							 							case TextWordType.Word: 								Color c = word.Color; 								 								if (offset + word.Word.Length > selectionOffset && offset < selectionEndOffset) { 									string colorstr = c.R + "' " + c.G + "' " + c.B; 									 									if (!colors.ContainsKey(colorstr)) { 										colors[colorstr] = ++colorNum; 										colorString.Append(@"\red" + c.R + @"\green" + c.G + @"\blue" + c.B + ";"); 									} 									if (c != curColor || firstLine) { 										rtf.Append(@"\cf" + colors[colorstr].ToString()); 										curColor = c; 										escapeSequence = true; 									} 									 									if (oldItalic != word.Italic) { 										if (word.Italic) { 											rtf.Append(@"\i"); 										} else { 											rtf.Append(@"\i0"); 										} 										oldItalic = word.Italic; 										escapeSequence = true; 									} 									 									if (oldBold != word.Bold) { 										if (word.Bold) { 											rtf.Append(@"\b"); 										} else { 											rtf.Append(@"\b0"); 										} 										oldBold = word.Bold; 										escapeSequence = true; 									} 									 									if (firstLine) { 										rtf.Append(@"\f0\fs" + (textArea.TextEditorProperties.Font.Size * 2)); 										firstLine = false; 									} 									if (escapeSequence) { 										rtf.Append(' '); 										escapeSequence = false; 									} 									string printWord; 									if (offset < selectionOffset) { 										printWord = word.Word.Substring(selectionOffset - offset); 									} else if (offset + word.Word.Length > selectionEndOffset) { 										printWord = word.Word.Substring(0' (offset + word.Word.Length) - selectionEndOffset); 									} else { 										printWord = word.Word; 									} 									 									AppendText(rtf' printWord); 								} 								offset += word.Length; 								break; 						}
Missing Default,ICSharpCode.TextEditor.Actions,Tab,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,InsertTabAtCaretPosition,The following switch statement is missing a default case: switch (textArea.Caret.CaretMode) { 				case CaretMode.InsertMode: 					textArea.InsertString(GetIndentationString(textArea.Document' textArea)); 					break; 				case CaretMode.OverwriteMode: 					string indentStr = GetIndentationString(textArea.Document' textArea); 					textArea.ReplaceChar(indentStr[0]); 					if (indentStr.Length > 1) { 						textArea.InsertString(indentStr.Substring(1)); 					} 					break; 			}
Missing Default,ICSharpCode.TextEditor.Actions,ToggleEditMode,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Actions\MiscActions.cs,Execute,The following switch statement is missing a default case: switch (textArea.Caret.CaretMode) { 				case CaretMode.InsertMode: 					textArea.Caret.CaretMode = CaretMode.OverwriteMode; 					break; 				case CaretMode.OverwriteMode: 					textArea.Caret.CaretMode = CaretMode.InsertMode; 					break; 			}
Missing Default,ICSharpCode.TextEditor.Gui.CompletionWindow,CodeCompletionWindow,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\CompletionWindow\CodeCompletionWindow.cs,ProcessTextAreaKey,The following switch statement is missing a default case: switch (keyData) { 				case Keys.Home: 					codeCompletionListView.SelectIndex(0); 					return true; 				case Keys.End: 					codeCompletionListView.SelectIndex(completionData.Length-1); 					return true; 				case Keys.PageDown: 					codeCompletionListView.PageDown(); 					return true; 				case Keys.PageUp: 					codeCompletionListView.PageUp(); 					return true; 				case Keys.Down: 					codeCompletionListView.SelectNextItem(); 					return true; 				case Keys.Up: 					codeCompletionListView.SelectPrevItem(); 					return true; 				case Keys.Tab: 					InsertSelectedItem('\t'); 					return true; 				case Keys.Return: 					InsertSelectedItem('\n'); 					return true; 			}
Missing Default,ICSharpCode.TextEditor.Gui.CompletionWindow,AbstractCompletionWindow,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\CompletionWindow\AbstractCompletionWindow.cs,ProcessTextAreaKey,The following switch statement is missing a default case: switch (keyData) { 				case Keys.Escape: 					Close(); 					return true; 			}
Missing Default,ICSharpCode.TextEditor.Gui.InsightWindow,InsightWindow,C:\repos\qwertie_Loyc\Main\ICSharpCode.TextEditor\Project\Src\Gui\InsightWindow\InsightWindow.cs,ProcessTextAreaKey,The following switch statement is missing a default case: switch (keyData) { 				case Keys.Down: 					if (DataProvider != null && DataProvider.InsightDataCount > 0) { 						CurrentData = (CurrentData + 1) % DataProvider.InsightDataCount; 						Refresh(); 					} 					return true; 				case Keys.Up: 					if (DataProvider != null && DataProvider.InsightDataCount > 0) { 						CurrentData = (CurrentData + DataProvider.InsightDataCount - 1) % DataProvider.InsightDataCount; 						Refresh(); 					} 					return true; 			}
