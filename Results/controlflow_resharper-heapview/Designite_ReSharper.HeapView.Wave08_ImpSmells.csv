Implementation smell,Namespace,Class,File,Method,Description
Long Method,JetBrains.ReSharper.HeapView.Analyzers,ClosureAnalyzer,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\ClosureAnalyzer.cs,ReportClosureAllocations,The method has 114 lines of code.
Complex Method,JetBrains.ReSharper.HeapView.Analyzers,BoxingOccurrenceAnalyzer,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\BoxingOccurrenceAnalyzer.cs,CheckReferenceExpression,Cyclomatic complexity of the method is 8
Complex Method,JetBrains.ReSharper.HeapView.Analyzers,ClosureAnalyzer,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\ClosureAnalyzer.cs,ReportClosureAllocations,Cyclomatic complexity of the method is 20
Complex Method,JetBrains.ReSharper.HeapView.Analyzers,ClosureAnalyzer,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\ClosureAnalyzer.cs,FormatClosureDescription,Cyclomatic complexity of the method is 8
Complex Method,JetBrains.ReSharper.HeapView.Analyzers,ClosureAnalyzer,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\ClosureAnalyzer.cs,GetCaptureHighlightingRange,Cyclomatic complexity of the method is 8
Complex Method,JetBrains.ReSharper.HeapView.Analyzers,ClosureAnalyzer,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\ClosureAnalyzer.cs,ReportClosurelessAllocations,Cyclomatic complexity of the method is 9
Complex Method,JetBrains.ReSharper.HeapView.Analyzers,ClosurelessOverloadSearcher,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\ClosurelessOverloadSearcher.cs,CompareSignatures,Cyclomatic complexity of the method is 12
Complex Method,JetBrains.ReSharper.HeapView.Analyzers,ClosurelessOverloadSearcher,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\ClosurelessOverloadSearcher.cs,CompareDelegateTypes,Cyclomatic complexity of the method is 11
Complex Method,JetBrains.ReSharper.HeapView.Analyzers,HeapAllocationAnalyzer,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\HeapAllocationAnalyzer.cs,CheckInvocationInfo,Cyclomatic complexity of the method is 13
Complex Method,JetBrains.ReSharper.HeapView.Analyzers,HeapAllocationAnalyzer,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\HeapAllocationAnalyzer.cs,CollectStringConcatenation,Cyclomatic complexity of the method is 8
Complex Method,JetBrains.ReSharper.HeapView.Analyzers,HeapAllocationAnalyzer,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\HeapAllocationAnalyzer.cs,CheckForeachDeclaration,Cyclomatic complexity of the method is 9
Long Parameter List,JetBrains.ReSharper.HeapView.Analyzers,ClosureAnalyzer,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\ClosureAnalyzer.cs,ReportClosureAllocations,The method has 5 parameters. Parameters: topDeclaration' thisElement' topScope' inspector' consumer
Long Identifier,JetBrains.ReSharper.HeapView.Analyzers,ClosurelessOverloadSearcher,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\ClosurelessOverloadSearcher.cs,CompareDelegateTypes,The length of the parameter candidateDelegateParameterType is 30.
Long Statement,JetBrains.ReSharper.HeapView.Analyzers,BoxingOccurrenceAnalyzer,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\BoxingOccurrenceAnalyzer.cs,CheckExpression,The length of the statement  "          var description = BakeDescriptionWithTypes("conversion from value type '{0}' to reference type '{1}'"' expressionType' targetType); " is 131.
Long Statement,JetBrains.ReSharper.HeapView.Analyzers,ClosureAnalyzer,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\ClosureAnalyzer.cs,ReportAnonymousTypes,The length of the statement  "        var highlighting = new ObjectAllocationHighlighting(queryClause' "transparent identifier anonymous type instantiation"); " is 120.
Complex Conditional,JetBrains.ReSharper.HeapView.Analyzers,ClosurelessOverloadSearcher,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\ClosurelessOverloadSearcher.cs,FindOverloadByParameter,The conditional expression  "typeMember is IMethod closurelessCandidate            && !ReferenceEquals(closurelessCandidate' currentMethod)            && closurelessCandidate.ShortName == shortName            && closurelessCandidate.IsStatic == currentMethod.IsStatic            && closurelessCandidate.IsExtensionMethod == currentMethod.IsExtensionMethod"  is complex.
Magic Number,JetBrains.ReSharper.HeapView.Analyzers,ClosureAnalyzer,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\ClosureAnalyzer.cs,GetCaptureHighlightingRange,The following statement contains a magic number: if (declaration is IRegularParameterDeclaration parameterDeclaration)        {          if (range.TextRange.Length < 3)            range = parameterDeclaration.TypeUsage.GetDocumentRange().SetEndTo(nameEndOffset);            return parameterDeclaration;        }
Magic Number,JetBrains.ReSharper.HeapView.Analyzers,HeapAllocationAnalyzer,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\HeapAllocationAnalyzer.cs,CheckStringConcatenation,The following statement contains a magic number: if (CollectStringConcatenation(concatenation' concatenations' ref allConstants)            && !allConstants            && concatenations.Count > 0)        {          var mostLeftConcatSign = concatenations            .Select(x => x.OperatorSign.GetDocumentRange())            .OrderBy(x => x.TextRange.StartOffset).First();            var operandsCount = concatenations.Count + 1;          var description = "string concatenation"            + (operandsCount <= 2 ? null : $" ({operandsCount} operands)")            + (operandsCount <= 4 ? null : " + params array allocation");            consumer.AddHighlighting(            new ObjectAllocationHighlighting(concatenation' description)'            mostLeftConcatSign);        }
Magic Number,JetBrains.ReSharper.HeapView.Analyzers,HeapAllocationAnalyzer,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\HeapAllocationAnalyzer.cs,CheckStringConcatenation,The following statement contains a magic number: if (CollectStringConcatenation(concatenation' concatenations' ref allConstants)            && !allConstants            && concatenations.Count > 0)        {          var mostLeftConcatSign = concatenations            .Select(x => x.OperatorSign.GetDocumentRange())            .OrderBy(x => x.TextRange.StartOffset).First();            var operandsCount = concatenations.Count + 1;          var description = "string concatenation"            + (operandsCount <= 2 ? null : $" ({operandsCount} operands)")            + (operandsCount <= 4 ? null : " + params array allocation");            consumer.AddHighlighting(            new ObjectAllocationHighlighting(concatenation' description)'            mostLeftConcatSign);        }
Magic Number,JetBrains.ReSharper.HeapView.Analyzers,HeapAllocationAnalyzer,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\HeapAllocationAnalyzer.cs,IsStringConcatOperatorReference,The following statement contains a magic number: if (parameters.Count != 2) return false;
Missing Default,JetBrains.ReSharper.HeapView.Analyzers,BoxingOccurrenceAnalyzer,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\BoxingOccurrenceAnalyzer.cs,Run,The following switch statement is missing a default case: switch (expression)        {          case IInvocationExpression invocationExpression:            CheckInvocationExpression(invocationExpression' consumer);            break;            case IReferenceExpression referenceExpression:            CheckReferenceExpression(referenceExpression' consumer);            break;        }
Missing Default,JetBrains.ReSharper.HeapView.Analyzers,ClosureInspector,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\ClosureAnalyzer.cs,ProcessBeforeInterior,The following switch statement is missing a default case: switch (element)          {            case ICSharpExpression expression:              ProcessExpression(expression);              return;              case IQueryParameterPlatform platform:              myClosures.Push(platform);              return;          }
Missing Default,JetBrains.ReSharper.HeapView.Analyzers,ClosureInspector,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\ClosureAnalyzer.cs,ProcessExpression,The following switch statement is missing a default case: switch (element)          {            case IThisExpression _:            case IBaseExpression _:              AddThisCapture();              break;              case IReferenceExpression referenceExpression when referenceExpression.QualifierExpression is null:              ProcessReferenceExpression(referenceExpression);              break;              case IAnonymousFunctionExpression anonymousFunction:              myClosures.Push(anonymousFunction);              break;          }
Missing Default,JetBrains.ReSharper.HeapView.Analyzers,ClosureInspector,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\ClosureAnalyzer.cs,ProcessReferenceExpression,The following switch statement is missing a default case: switch (resolveResult.DeclaredElement)          {            case IParameter parameter:              ProcessParameter(parameter);              return;              case ILocalVariable localVariable:              ProcessLocalVariable(localVariable);              return;              case ITypeMember typeMember: // .this closure              ProcessTypeMember(typeMember);              return;              case IQueryAnonymousTypeProperty anonymousTypeProperty:              ProcessAnonymousProperty(anonymousTypeProperty);              return;          }
Missing Default,JetBrains.ReSharper.HeapView.Analyzers,HeapAllocationAnalyzer,C:\repos\controlflow_resharper-heapview\ReSharper.HeapView\src\Analyzers\HeapAllocationAnalyzer.cs,Run,The following switch statement is missing a default case: switch (element)        {          // var t = new object();          case IObjectCreationExpression objectCreation:            CheckObjectCreation(objectCreation' consumer);            CheckInvocationInfo(objectCreation' objectCreation.TypeName' consumer);            return;            // var t = new { Foo = 123 };          case IAnonymousObjectCreationExpression anonymousObjectCreation:            CheckAnonymousObjectCreation(anonymousObjectCreation' consumer);            return;            // var xs = new[] {1' 2' 3};          case IArrayCreationExpression arrayCreation:            CheckArrayCreation(arrayCreation' consumer);            return;            // int[] xs = {1' 2' 3};          case IArrayInitializer arrayInitializer:            CheckArrayInitializer(arrayInitializer' consumer);            return;            // F(); when F(params T[] xs);          // F(); when F is iterator          case IInvocationExpression invocationExpression:            CheckInvocationExpression(invocationExpression' consumer);            return;            // Action f = F;          // var xs = Iterator;          case IReferenceExpression referenceExpression:            CheckReferenceExpression(referenceExpression' consumer);            return;            // string s = "abc" + x + "def";          case IAdditiveExpression additiveExpression:            CheckStringConcatenation(additiveExpression' consumer);            return;            // str += "abc";          case IAssignmentExpression assignmentExpression when assignmentExpression.IsCompoundAssignment                                                               && IsStringConcatenation(assignmentExpression):            consumer.AddHighlighting(              new ObjectAllocationHighlighting(assignmentExpression.OperatorSign' "string concatenation")'              assignmentExpression.OperatorSign.GetDocumentRange());            break;            // foreach (var x in xs); when xs.GetEnumerator() is ref-type          // note: produces false-positive for LocalList<T>-produced IList<T>          case IForeachStatement foreachStatement:            CheckForeachDeclaration(foreachStatement' consumer);            return;            // ["params"' "arg"]          case IElementAccessExpression elementAccessExpression:            CheckInvocationInfo(elementAccessExpression' null' consumer);            return;            // : base("params"' "arg")          case IConstructorInitializer constructorInitializer:            CheckInvocationInfo(constructorInitializer' constructorInitializer.Instance' consumer);            return;            // new C { {"params"' "arg"} }          case ICollectionElementInitializer collectionElementInitializer:            CheckInvocationInfo(collectionElementInitializer' null' consumer);            return;        }
