Implementation smell,Namespace,Class,File,Method,Description
Long Method,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The method has 300 lines of code.
Long Method,EXIF,translation,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\translation.cs,translation,The method has 216 lines of code.
Complex Method,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,Cyclomatic complexity of the method is 135
Long Statement,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,GetExifProperties,The length of the statement  "	System.Drawing.Image image = System.Drawing.Image.FromStream (stream' /* useEmbeddedColorManagement = */true' /* validateImageData = */false); " is 142.
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: foreach (System.Drawing.Imaging.PropertyItem p in parr) {  	string v = "";  	string name = (string)myHash [p.Id];  	// tag not found. skip it  	if (name == null)  		continue;  	//  	data += name + ": ";  	//  	//1 = BYTE An 8-bit unsigned integer.'  	if (p.Type == 0x1) {  		v = p.Value [0].ToString ();  	}  	//2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  	else if (p.Type == 0x2) {  		// string					  		v = ascii.GetString (p.Value);  	}  	//3 = SHORT A 16-bit (2 -byte) unsigned integer'  	else if (p.Type == 0x3) {  		// orientation // lookup table					  		switch (p.Id) {  		case 0x8827:  			// ISO  			v = "ISO-" + convertToInt16U (p.Value).ToString ();  			break;  		case 0xA217:  			// sensing method  			{  				switch (convertToInt16U (p.Value)) {  				case 1:  					v = "Not defined";  					break;  				case 2:  					v = "One-chip color area sensor";  					break;  				case 3:  					v = "Two-chip color area sensor";  					break;  				case 4:  					v = "Three-chip color area sensor";  					break;  				case 5:  					v = "Color sequential area sensor";  					break;  				case 7:  					v = "Trilinear sensor";  					break;  				case 8:  					v = "Color sequential linear sensor";  					break;  				default:  					v = " reserved";  					break;  				}  			}  			break;  		case 0x8822:  			// aperture   			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Not defined";  				break;  			case 1:  				v = "Manual";  				break;  			case 2:  				v = "Normal program";  				break;  			case 3:  				v = "Aperture priority";  				break;  			case 4:  				v = "Shutter priority";  				break;  			case 5:  				v = "Creative program (biased toward depth of field)";  				break;  			case 6:  				v = "Action program (biased toward fast shutter speed)";  				break;  			case 7:  				v = "Portrait mode (for closeup photos with the background out of focus)";  				break;  			case 8:  				v = "Landscape mode (for landscape photos with the background in focus)";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9207:  			// metering mode  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Average";  				break;  			case 2:  				v = "CenterWeightedAverage";  				break;  			case 3:  				v = "Spot";  				break;  			case 4:  				v = "MultiSpot";  				break;  			case 5:  				v = "Pattern";  				break;  			case 6:  				v = "Partial";  				break;  			case 255:  				v = "Other";  				break;  			default:  				v = "reserved";  				break;  			}  			break;  		case 0x9208:  			// light source  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "unknown";  					break;  				case 1:  					v = "Daylight";  					break;  				case 2:  					v = "Fluorescent";  					break;  				case 3:  					v = "Tungsten";  					break;  				case 17:  					v = "Standard light A";  					break;  				case 18:  					v = "Standard light B";  					break;  				case 19:  					v = "Standard light C";  					break;  				case 20:  					v = "D55";  					break;  				case 21:  					v = "D65";  					break;  				case 22:  					v = "D75";  					break;  				case 255:  					v = "other";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		case 0x9209:  			{  				switch (convertToInt16U (p.Value)) {  				case 0:  					v = "Flash did not fire";  					break;  				case 1:  					v = "Flash fired";  					break;  				case 5:  					v = "Strobe return light not detected";  					break;  				case 7:  					v = "Strobe return light detected";  					break;  				default:  					v = "reserved";  					break;  				}  			}  			break;  		default:  			v = convertToInt16U (p.Value).ToString ();  			break;  		}  	}  	//4 = LONG A 32-bit (4 -byte) unsigned integer'  	else if (p.Type == 0x4) {  		// orientation // lookup table					  		v = convertToInt32U (p.Value).ToString ();  	}  	//5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  	else if (p.Type == 0x5) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		uint a = convertToInt32U (n);  		uint b = convertToInt32U (d);  		Rational r = new Rational (a' b);  		//  		//convert here  		//  		switch (p.Id) {  		case 0x9202:  			// aperture  			v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  			break;  		case 0x920A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829A:  			v = r.ToDouble ().ToString ();  			break;  		case 0x829D:  			// F-number  			v = "F/" + r.ToDouble ().ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	//7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  	else if (p.Type == 0x7) {  		switch (p.Id) {  		case 0xA300: {  			if (p.Value [0] == 3) {  				v = "DSC";  			}  			else {  				v = "reserved";  			}  			break;  		}  		case 0xA301:  			if (p.Value [0] == 1)  				v = "A directly photographed image";  			else  				v = "Not a directly photographed image";  			break;  		default:  			v = "-";  			break;  		}  	}  	//9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  	else if (p.Type == 0x9) {  		v = convertToInt32 (p.Value).ToString ();  	}  	//10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  	//denominator.  	else if (p.Type == 0xA) {  		// rational  		byte[] n = new byte[p.Len / 2];  		byte[] d = new byte[p.Len / 2];  		Array.Copy (p.Value' 0' n' 0' p.Len / 2);  		Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  		int a = convertToInt32 (n);  		int b = convertToInt32 (d);  		Rational r = new Rational (a' b);  		//  		// convert here  		//  		switch (p.Id) {  		case 0x9201:  			// shutter speed  			v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  			break;  		case 0x9203:  			v = Math.Round (r.ToDouble ()' 4).ToString ();  			break;  		default:  			v = r.ToString ("/");  			break;  		}  	}  	// add it to the list  	if (properties [name] == null)  		properties.Add (name' v);  	// cat it too  	data += v;  	data += this.sp;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x1) {  	v = p.Value [0].ToString ();  }  //2 = ASCII An 8-bit byte containing one 7-bit ASCII code. The final byte is terminated with NULL.'  else if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x2) {  	// string					  	v = ascii.GetString (p.Value);  }  //3 = SHORT A 16-bit (2 -byte) unsigned integer'  else if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x3) {  	// orientation // lookup table					  	switch (p.Id) {  	case 0x8827:  		// ISO  		v = "ISO-" + convertToInt16U (p.Value).ToString ();  		break;  	case 0xA217:  		// sensing method  		{  			switch (convertToInt16U (p.Value)) {  			case 1:  				v = "Not defined";  				break;  			case 2:  				v = "One-chip color area sensor";  				break;  			case 3:  				v = "Two-chip color area sensor";  				break;  			case 4:  				v = "Three-chip color area sensor";  				break;  			case 5:  				v = "Color sequential area sensor";  				break;  			case 7:  				v = "Trilinear sensor";  				break;  			case 8:  				v = "Color sequential linear sensor";  				break;  			default:  				v = " reserved";  				break;  			}  		}  		break;  	case 0x8822:  		// aperture   		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Not defined";  			break;  		case 1:  			v = "Manual";  			break;  		case 2:  			v = "Normal program";  			break;  		case 3:  			v = "Aperture priority";  			break;  		case 4:  			v = "Shutter priority";  			break;  		case 5:  			v = "Creative program (biased toward depth of field)";  			break;  		case 6:  			v = "Action program (biased toward fast shutter speed)";  			break;  		case 7:  			v = "Portrait mode (for closeup photos with the background out of focus)";  			break;  		case 8:  			v = "Landscape mode (for landscape photos with the background in focus)";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9207:  		// metering mode  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Average";  			break;  		case 2:  			v = "CenterWeightedAverage";  			break;  		case 3:  			v = "Spot";  			break;  		case 4:  			v = "MultiSpot";  			break;  		case 5:  			v = "Pattern";  			break;  		case 6:  			v = "Partial";  			break;  		case 255:  			v = "Other";  			break;  		default:  			v = "reserved";  			break;  		}  		break;  	case 0x9208:  		// light source  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "unknown";  				break;  			case 1:  				v = "Daylight";  				break;  			case 2:  				v = "Fluorescent";  				break;  			case 3:  				v = "Tungsten";  				break;  			case 17:  				v = "Standard light A";  				break;  			case 18:  				v = "Standard light B";  				break;  			case 19:  				v = "Standard light C";  				break;  			case 20:  				v = "D55";  				break;  			case 21:  				v = "D65";  				break;  			case 22:  				v = "D75";  				break;  			case 255:  				v = "other";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	case 0x9209:  		{  			switch (convertToInt16U (p.Value)) {  			case 0:  				v = "Flash did not fire";  				break;  			case 1:  				v = "Flash fired";  				break;  			case 5:  				v = "Strobe return light not detected";  				break;  			case 7:  				v = "Strobe return light detected";  				break;  			default:  				v = "reserved";  				break;  			}  		}  		break;  	default:  		v = convertToInt16U (p.Value).ToString ();  		break;  	}  }  //4 = LONG A 32-bit (4 -byte) unsigned integer'  else if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x8827:  	// ISO  	v = "ISO-" + convertToInt16U (p.Value).ToString ();  	break;  case 0xA217:  	// sensing method  	{  		switch (convertToInt16U (p.Value)) {  		case 1:  			v = "Not defined";  			break;  		case 2:  			v = "One-chip color area sensor";  			break;  		case 3:  			v = "Two-chip color area sensor";  			break;  		case 4:  			v = "Three-chip color area sensor";  			break;  		case 5:  			v = "Color sequential area sensor";  			break;  		case 7:  			v = "Trilinear sensor";  			break;  		case 8:  			v = "Color sequential linear sensor";  			break;  		default:  			v = " reserved";  			break;  		}  	}  	break;  case 0x8822:  	// aperture   	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "Not defined";  		break;  	case 1:  		v = "Manual";  		break;  	case 2:  		v = "Normal program";  		break;  	case 3:  		v = "Aperture priority";  		break;  	case 4:  		v = "Shutter priority";  		break;  	case 5:  		v = "Creative program (biased toward depth of field)";  		break;  	case 6:  		v = "Action program (biased toward fast shutter speed)";  		break;  	case 7:  		v = "Portrait mode (for closeup photos with the background out of focus)";  		break;  	case 8:  		v = "Landscape mode (for landscape photos with the background in focus)";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9207:  	// metering mode  	switch (convertToInt16U (p.Value)) {  	case 0:  		v = "unknown";  		break;  	case 1:  		v = "Average";  		break;  	case 2:  		v = "CenterWeightedAverage";  		break;  	case 3:  		v = "Spot";  		break;  	case 4:  		v = "MultiSpot";  		break;  	case 5:  		v = "Pattern";  		break;  	case 6:  		v = "Partial";  		break;  	case 255:  		v = "Other";  		break;  	default:  		v = "reserved";  		break;  	}  	break;  case 0x9208:  	// light source  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "unknown";  			break;  		case 1:  			v = "Daylight";  			break;  		case 2:  			v = "Fluorescent";  			break;  		case 3:  			v = "Tungsten";  			break;  		case 17:  			v = "Standard light A";  			break;  		case 18:  			v = "Standard light B";  			break;  		case 19:  			v = "Standard light C";  			break;  		case 20:  			v = "D55";  			break;  		case 21:  			v = "D65";  			break;  		case 22:  			v = "D75";  			break;  		case 255:  			v = "other";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  case 0x9209:  	{  		switch (convertToInt16U (p.Value)) {  		case 0:  			v = "Flash did not fire";  			break;  		case 1:  			v = "Flash fired";  			break;  		case 5:  			v = "Strobe return light not detected";  			break;  		case 7:  			v = "Strobe return light detected";  			break;  		default:  			v = "reserved";  			break;  		}  	}  	break;  default:  	v = convertToInt16U (p.Value).ToString ();  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 1:  	v = "Not defined";  	break;  case 2:  	v = "One-chip color area sensor";  	break;  case 3:  	v = "Two-chip color area sensor";  	break;  case 4:  	v = "Three-chip color area sensor";  	break;  case 5:  	v = "Color sequential area sensor";  	break;  case 7:  	v = "Trilinear sensor";  	break;  case 8:  	v = "Color sequential linear sensor";  	break;  default:  	v = " reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 1:  	v = "Not defined";  	break;  case 2:  	v = "One-chip color area sensor";  	break;  case 3:  	v = "Two-chip color area sensor";  	break;  case 4:  	v = "Three-chip color area sensor";  	break;  case 5:  	v = "Color sequential area sensor";  	break;  case 7:  	v = "Trilinear sensor";  	break;  case 8:  	v = "Color sequential linear sensor";  	break;  default:  	v = " reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 1:  	v = "Not defined";  	break;  case 2:  	v = "One-chip color area sensor";  	break;  case 3:  	v = "Two-chip color area sensor";  	break;  case 4:  	v = "Three-chip color area sensor";  	break;  case 5:  	v = "Color sequential area sensor";  	break;  case 7:  	v = "Trilinear sensor";  	break;  case 8:  	v = "Color sequential linear sensor";  	break;  default:  	v = " reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 1:  	v = "Not defined";  	break;  case 2:  	v = "One-chip color area sensor";  	break;  case 3:  	v = "Two-chip color area sensor";  	break;  case 4:  	v = "Three-chip color area sensor";  	break;  case 5:  	v = "Color sequential area sensor";  	break;  case 7:  	v = "Trilinear sensor";  	break;  case 8:  	v = "Color sequential linear sensor";  	break;  default:  	v = " reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 1:  	v = "Not defined";  	break;  case 2:  	v = "One-chip color area sensor";  	break;  case 3:  	v = "Two-chip color area sensor";  	break;  case 4:  	v = "Three-chip color area sensor";  	break;  case 5:  	v = "Color sequential area sensor";  	break;  case 7:  	v = "Trilinear sensor";  	break;  case 8:  	v = "Color sequential linear sensor";  	break;  default:  	v = " reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 1:  	v = "Not defined";  	break;  case 2:  	v = "One-chip color area sensor";  	break;  case 3:  	v = "Two-chip color area sensor";  	break;  case 4:  	v = "Three-chip color area sensor";  	break;  case 5:  	v = "Color sequential area sensor";  	break;  case 7:  	v = "Trilinear sensor";  	break;  case 8:  	v = "Color sequential linear sensor";  	break;  default:  	v = " reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "Not defined";  	break;  case 1:  	v = "Manual";  	break;  case 2:  	v = "Normal program";  	break;  case 3:  	v = "Aperture priority";  	break;  case 4:  	v = "Shutter priority";  	break;  case 5:  	v = "Creative program (biased toward depth of field)";  	break;  case 6:  	v = "Action program (biased toward fast shutter speed)";  	break;  case 7:  	v = "Portrait mode (for closeup photos with the background out of focus)";  	break;  case 8:  	v = "Landscape mode (for landscape photos with the background in focus)";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "Not defined";  	break;  case 1:  	v = "Manual";  	break;  case 2:  	v = "Normal program";  	break;  case 3:  	v = "Aperture priority";  	break;  case 4:  	v = "Shutter priority";  	break;  case 5:  	v = "Creative program (biased toward depth of field)";  	break;  case 6:  	v = "Action program (biased toward fast shutter speed)";  	break;  case 7:  	v = "Portrait mode (for closeup photos with the background out of focus)";  	break;  case 8:  	v = "Landscape mode (for landscape photos with the background in focus)";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "Not defined";  	break;  case 1:  	v = "Manual";  	break;  case 2:  	v = "Normal program";  	break;  case 3:  	v = "Aperture priority";  	break;  case 4:  	v = "Shutter priority";  	break;  case 5:  	v = "Creative program (biased toward depth of field)";  	break;  case 6:  	v = "Action program (biased toward fast shutter speed)";  	break;  case 7:  	v = "Portrait mode (for closeup photos with the background out of focus)";  	break;  case 8:  	v = "Landscape mode (for landscape photos with the background in focus)";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "Not defined";  	break;  case 1:  	v = "Manual";  	break;  case 2:  	v = "Normal program";  	break;  case 3:  	v = "Aperture priority";  	break;  case 4:  	v = "Shutter priority";  	break;  case 5:  	v = "Creative program (biased toward depth of field)";  	break;  case 6:  	v = "Action program (biased toward fast shutter speed)";  	break;  case 7:  	v = "Portrait mode (for closeup photos with the background out of focus)";  	break;  case 8:  	v = "Landscape mode (for landscape photos with the background in focus)";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "Not defined";  	break;  case 1:  	v = "Manual";  	break;  case 2:  	v = "Normal program";  	break;  case 3:  	v = "Aperture priority";  	break;  case 4:  	v = "Shutter priority";  	break;  case 5:  	v = "Creative program (biased toward depth of field)";  	break;  case 6:  	v = "Action program (biased toward fast shutter speed)";  	break;  case 7:  	v = "Portrait mode (for closeup photos with the background out of focus)";  	break;  case 8:  	v = "Landscape mode (for landscape photos with the background in focus)";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "Not defined";  	break;  case 1:  	v = "Manual";  	break;  case 2:  	v = "Normal program";  	break;  case 3:  	v = "Aperture priority";  	break;  case 4:  	v = "Shutter priority";  	break;  case 5:  	v = "Creative program (biased toward depth of field)";  	break;  case 6:  	v = "Action program (biased toward fast shutter speed)";  	break;  case 7:  	v = "Portrait mode (for closeup photos with the background out of focus)";  	break;  case 8:  	v = "Landscape mode (for landscape photos with the background in focus)";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "Not defined";  	break;  case 1:  	v = "Manual";  	break;  case 2:  	v = "Normal program";  	break;  case 3:  	v = "Aperture priority";  	break;  case 4:  	v = "Shutter priority";  	break;  case 5:  	v = "Creative program (biased toward depth of field)";  	break;  case 6:  	v = "Action program (biased toward fast shutter speed)";  	break;  case 7:  	v = "Portrait mode (for closeup photos with the background out of focus)";  	break;  case 8:  	v = "Landscape mode (for landscape photos with the background in focus)";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "unknown";  	break;  case 1:  	v = "Average";  	break;  case 2:  	v = "CenterWeightedAverage";  	break;  case 3:  	v = "Spot";  	break;  case 4:  	v = "MultiSpot";  	break;  case 5:  	v = "Pattern";  	break;  case 6:  	v = "Partial";  	break;  case 255:  	v = "Other";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "unknown";  	break;  case 1:  	v = "Average";  	break;  case 2:  	v = "CenterWeightedAverage";  	break;  case 3:  	v = "Spot";  	break;  case 4:  	v = "MultiSpot";  	break;  case 5:  	v = "Pattern";  	break;  case 6:  	v = "Partial";  	break;  case 255:  	v = "Other";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "unknown";  	break;  case 1:  	v = "Average";  	break;  case 2:  	v = "CenterWeightedAverage";  	break;  case 3:  	v = "Spot";  	break;  case 4:  	v = "MultiSpot";  	break;  case 5:  	v = "Pattern";  	break;  case 6:  	v = "Partial";  	break;  case 255:  	v = "Other";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "unknown";  	break;  case 1:  	v = "Average";  	break;  case 2:  	v = "CenterWeightedAverage";  	break;  case 3:  	v = "Spot";  	break;  case 4:  	v = "MultiSpot";  	break;  case 5:  	v = "Pattern";  	break;  case 6:  	v = "Partial";  	break;  case 255:  	v = "Other";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "unknown";  	break;  case 1:  	v = "Average";  	break;  case 2:  	v = "CenterWeightedAverage";  	break;  case 3:  	v = "Spot";  	break;  case 4:  	v = "MultiSpot";  	break;  case 5:  	v = "Pattern";  	break;  case 6:  	v = "Partial";  	break;  case 255:  	v = "Other";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "unknown";  	break;  case 1:  	v = "Average";  	break;  case 2:  	v = "CenterWeightedAverage";  	break;  case 3:  	v = "Spot";  	break;  case 4:  	v = "MultiSpot";  	break;  case 5:  	v = "Pattern";  	break;  case 6:  	v = "Partial";  	break;  case 255:  	v = "Other";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "unknown";  	break;  case 1:  	v = "Daylight";  	break;  case 2:  	v = "Fluorescent";  	break;  case 3:  	v = "Tungsten";  	break;  case 17:  	v = "Standard light A";  	break;  case 18:  	v = "Standard light B";  	break;  case 19:  	v = "Standard light C";  	break;  case 20:  	v = "D55";  	break;  case 21:  	v = "D65";  	break;  case 22:  	v = "D75";  	break;  case 255:  	v = "other";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "unknown";  	break;  case 1:  	v = "Daylight";  	break;  case 2:  	v = "Fluorescent";  	break;  case 3:  	v = "Tungsten";  	break;  case 17:  	v = "Standard light A";  	break;  case 18:  	v = "Standard light B";  	break;  case 19:  	v = "Standard light C";  	break;  case 20:  	v = "D55";  	break;  case 21:  	v = "D65";  	break;  case 22:  	v = "D75";  	break;  case 255:  	v = "other";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "unknown";  	break;  case 1:  	v = "Daylight";  	break;  case 2:  	v = "Fluorescent";  	break;  case 3:  	v = "Tungsten";  	break;  case 17:  	v = "Standard light A";  	break;  case 18:  	v = "Standard light B";  	break;  case 19:  	v = "Standard light C";  	break;  case 20:  	v = "D55";  	break;  case 21:  	v = "D65";  	break;  case 22:  	v = "D75";  	break;  case 255:  	v = "other";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "unknown";  	break;  case 1:  	v = "Daylight";  	break;  case 2:  	v = "Fluorescent";  	break;  case 3:  	v = "Tungsten";  	break;  case 17:  	v = "Standard light A";  	break;  case 18:  	v = "Standard light B";  	break;  case 19:  	v = "Standard light C";  	break;  case 20:  	v = "D55";  	break;  case 21:  	v = "D65";  	break;  case 22:  	v = "D75";  	break;  case 255:  	v = "other";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "unknown";  	break;  case 1:  	v = "Daylight";  	break;  case 2:  	v = "Fluorescent";  	break;  case 3:  	v = "Tungsten";  	break;  case 17:  	v = "Standard light A";  	break;  case 18:  	v = "Standard light B";  	break;  case 19:  	v = "Standard light C";  	break;  case 20:  	v = "D55";  	break;  case 21:  	v = "D65";  	break;  case 22:  	v = "D75";  	break;  case 255:  	v = "other";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "unknown";  	break;  case 1:  	v = "Daylight";  	break;  case 2:  	v = "Fluorescent";  	break;  case 3:  	v = "Tungsten";  	break;  case 17:  	v = "Standard light A";  	break;  case 18:  	v = "Standard light B";  	break;  case 19:  	v = "Standard light C";  	break;  case 20:  	v = "D55";  	break;  case 21:  	v = "D65";  	break;  case 22:  	v = "D75";  	break;  case 255:  	v = "other";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "unknown";  	break;  case 1:  	v = "Daylight";  	break;  case 2:  	v = "Fluorescent";  	break;  case 3:  	v = "Tungsten";  	break;  case 17:  	v = "Standard light A";  	break;  case 18:  	v = "Standard light B";  	break;  case 19:  	v = "Standard light C";  	break;  case 20:  	v = "D55";  	break;  case 21:  	v = "D65";  	break;  case 22:  	v = "D75";  	break;  case 255:  	v = "other";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "unknown";  	break;  case 1:  	v = "Daylight";  	break;  case 2:  	v = "Fluorescent";  	break;  case 3:  	v = "Tungsten";  	break;  case 17:  	v = "Standard light A";  	break;  case 18:  	v = "Standard light B";  	break;  case 19:  	v = "Standard light C";  	break;  case 20:  	v = "D55";  	break;  case 21:  	v = "D65";  	break;  case 22:  	v = "D75";  	break;  case 255:  	v = "other";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "unknown";  	break;  case 1:  	v = "Daylight";  	break;  case 2:  	v = "Fluorescent";  	break;  case 3:  	v = "Tungsten";  	break;  case 17:  	v = "Standard light A";  	break;  case 18:  	v = "Standard light B";  	break;  case 19:  	v = "Standard light C";  	break;  case 20:  	v = "D55";  	break;  case 21:  	v = "D65";  	break;  case 22:  	v = "D75";  	break;  case 255:  	v = "other";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "Flash did not fire";  	break;  case 1:  	v = "Flash fired";  	break;  case 5:  	v = "Strobe return light not detected";  	break;  case 7:  	v = "Strobe return light detected";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (convertToInt16U (p.Value)) {  case 0:  	v = "Flash did not fire";  	break;  case 1:  	v = "Flash fired";  	break;  case 5:  	v = "Strobe return light not detected";  	break;  case 7:  	v = "Strobe return light detected";  	break;  default:  	v = "reserved";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x4) {  	// orientation // lookup table					  	v = convertToInt32U (p.Value).ToString ();  }  //5 = RATIONAL Two LONGs. The first LONG is the numerator and the second LONG expresses the//denominator.'  else if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x5) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	uint a = convertToInt32U (n);  	uint b = convertToInt32U (d);  	Rational r = new Rational (a' b);  	//  	//convert here  	//  	switch (p.Id) {  	case 0x9202:  		// aperture  		v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  		break;  	case 0x920A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829A:  		v = r.ToDouble ().ToString ();  		break;  	case 0x829D:  		// F-number  		v = "F/" + r.ToDouble ().ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  //7 = UNDEFINED An 8-bit byte that can take any value depending on the field definition'  else if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: Array.Copy (p.Value' 0' n' 0' p.Len / 2);  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x9202:  	// aperture  	v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  	break;  case 0x920A:  	v = r.ToDouble ().ToString ();  	break;  case 0x829A:  	v = r.ToDouble ().ToString ();  	break;  case 0x829D:  	// F-number  	v = "F/" + r.ToDouble ().ToString ();  	break;  default:  	v = r.ToString ("/");  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x9202:  	// aperture  	v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  	break;  case 0x920A:  	v = r.ToDouble ().ToString ();  	break;  case 0x829A:  	v = r.ToDouble ().ToString ();  	break;  case 0x829D:  	// F-number  	v = "F/" + r.ToDouble ().ToString ();  	break;  default:  	v = r.ToString ("/");  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: v = "F/" + Math.Round (Math.Pow (Math.Sqrt (2)' r.ToDouble ())' 2).ToString ();  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x7) {  	switch (p.Id) {  	case 0xA300: {  		if (p.Value [0] == 3) {  			v = "DSC";  		}  		else {  			v = "reserved";  		}  		break;  	}  	case 0xA301:  		if (p.Value [0] == 1)  			v = "A directly photographed image";  		else  			v = "Not a directly photographed image";  		break;  	default:  		v = "-";  		break;  	}  }  //9 = SLONG A 32-bit (4 -byte) signed integer (2's complement notation)'  else if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0xA300: {  	if (p.Value [0] == 3) {  		v = "DSC";  	}  	else {  		v = "reserved";  	}  	break;  }  case 0xA301:  	if (p.Value [0] == 1)  		v = "A directly photographed image";  	else  		v = "Not a directly photographed image";  	break;  default:  	v = "-";  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Value [0] == 3) {  	v = "DSC";  }  else {  	v = "reserved";  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0x9) {  	v = convertToInt32 (p.Value).ToString ();  }  //10 = SRATIONAL Two SLONGs. The first SLONG is the numerator and the second SLONG is the  //denominator.  else if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: if (p.Type == 0xA) {  	// rational  	byte[] n = new byte[p.Len / 2];  	byte[] d = new byte[p.Len / 2];  	Array.Copy (p.Value' 0' n' 0' p.Len / 2);  	Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  	int a = convertToInt32 (n);  	int b = convertToInt32 (d);  	Rational r = new Rational (a' b);  	//  	// convert here  	//  	switch (p.Id) {  	case 0x9201:  		// shutter speed  		v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  		break;  	case 0x9203:  		v = Math.Round (r.ToDouble ()' 4).ToString ();  		break;  	default:  		v = r.ToString ("/");  		break;  	}  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: Array.Copy (p.Value' 0' n' 0' p.Len / 2);  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: Array.Copy (p.Value' p.Len / 2' d' 0' p.Len / 2);  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x9201:  	// shutter speed  	v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  	break;  case 0x9203:  	v = Math.Round (r.ToDouble ()' 4).ToString ();  	break;  default:  	v = r.ToString ("/");  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x9201:  	// shutter speed  	v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  	break;  case 0x9203:  	v = Math.Round (r.ToDouble ()' 4).ToString ();  	break;  default:  	v = r.ToString ("/");  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: switch (p.Id) {  case 0x9201:  	// shutter speed  	v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  	break;  case 0x9203:  	v = Math.Round (r.ToDouble ()' 4).ToString ();  	break;  default:  	v = r.ToString ("/");  	break;  }  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: v = "1/" + Math.Round (Math.Pow (2' r.ToDouble ())' 2).ToString ();  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,buildDB,The following statement contains a magic number: v = Math.Round (r.ToDouble ()' 4).ToString ();  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32,The following statement contains a magic number: if (arr.Length != 4)  	return 0;  else  	return arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0];  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32,The following statement contains a magic number: if (arr.Length != 4)  	return 0;  else  	return arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0];  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32,The following statement contains a magic number: if (arr.Length != 4)  	return 0;  else  	return arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0];  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32,The following statement contains a magic number: if (arr.Length != 4)  	return 0;  else  	return arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0];  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32,The following statement contains a magic number: if (arr.Length != 4)  	return 0;  else  	return arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0];  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32,The following statement contains a magic number: if (arr.Length != 4)  	return 0;  else  	return arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0];  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32,The following statement contains a magic number: return arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0];  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32,The following statement contains a magic number: return arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0];  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32,The following statement contains a magic number: return arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0];  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32,The following statement contains a magic number: return arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0];  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32,The following statement contains a magic number: return arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0];  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt16,The following statement contains a magic number: if (arr.Length != 2)  	return 0;  else  	return arr [1] << 8 | arr [0];  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt16,The following statement contains a magic number: if (arr.Length != 2)  	return 0;  else  	return arr [1] << 8 | arr [0];  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt16,The following statement contains a magic number: return arr [1] << 8 | arr [0];  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32U,The following statement contains a magic number: if (arr.Length != 4)  	return 0;  else  	return Convert.ToUInt32 (arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0]);  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32U,The following statement contains a magic number: if (arr.Length != 4)  	return 0;  else  	return Convert.ToUInt32 (arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0]);  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32U,The following statement contains a magic number: if (arr.Length != 4)  	return 0;  else  	return Convert.ToUInt32 (arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0]);  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32U,The following statement contains a magic number: if (arr.Length != 4)  	return 0;  else  	return Convert.ToUInt32 (arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0]);  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32U,The following statement contains a magic number: if (arr.Length != 4)  	return 0;  else  	return Convert.ToUInt32 (arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0]);  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32U,The following statement contains a magic number: if (arr.Length != 4)  	return 0;  else  	return Convert.ToUInt32 (arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0]);  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32U,The following statement contains a magic number: return Convert.ToUInt32 (arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0]);  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32U,The following statement contains a magic number: return Convert.ToUInt32 (arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0]);  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32U,The following statement contains a magic number: return Convert.ToUInt32 (arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0]);  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32U,The following statement contains a magic number: return Convert.ToUInt32 (arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0]);  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt32U,The following statement contains a magic number: return Convert.ToUInt32 (arr [3] << 24 | arr [2] << 16 | arr [1] << 8 | arr [0]);  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt16U,The following statement contains a magic number: if (arr.Length != 2)  	return 0;  else  	return Convert.ToUInt16 (arr [1] << 8 | arr [0]);  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt16U,The following statement contains a magic number: if (arr.Length != 2)  	return 0;  else  	return Convert.ToUInt16 (arr [1] << 8 | arr [0]);  
Magic Number,EXIF,EXIFextractor,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\EXIFextractor.cs,convertToInt16U,The following statement contains a magic number: return Convert.ToUInt16 (arr [1] << 8 | arr [0]);  
Magic Number,EXIF,Rational,C:\repos\gyphie_hydrawallpaper\EXIFExtractor\translation.cs,ToDouble,The following statement contains a magic number: return Math.Round (Convert.ToDouble (n) / Convert.ToDouble (d)' 2);  
