Implementation smell,Namespace,Class,File,Method,Description
Long Method,MethodGen,DeclarationList,C:\repos\mcneel_rhinocommon\methodgen\NativeMethodDeclares.cs,Construct,The method has 120 lines of code.
Long Method,MethodGen,Declaration,C:\repos\mcneel_rhinocommon\methodgen\NativeMethodDeclares.cs,ParameterTypeAsCSharp,The method has 312 lines of code.
Complex Method,MethodGen,NativeMethodDeclares,C:\repos\mcneel_rhinocommon\methodgen\NativeMethodDeclares.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,MethodGen,DeclarationList,C:\repos\mcneel_rhinocommon\methodgen\NativeMethodDeclares.cs,Construct,Cyclomatic complexity of the method is 22
Complex Method,MethodGen,Declaration,C:\repos\mcneel_rhinocommon\methodgen\NativeMethodDeclares.cs,ParameterTypeAsCSharp,Cyclomatic complexity of the method is 98
Complex Method,MethodGen,Program,C:\repos\mcneel_rhinocommon\methodgen\Program.cs,Main,Cyclomatic complexity of the method is 10
Long Statement,MethodGen,CommandlineParser,C:\repos\mcneel_rhinocommon\methodgen\CommandlineParser.cs,ProcessArguments,The length of the statement  "            throw new CommandlineParserException("Unexpected Command Line Argument '" + current_arg + "' - expected another argument after as value."); " is 139.
Long Statement,MethodGen,Declaration,C:\repos\mcneel_rhinocommon\methodgen\NativeMethodDeclares.cs,ParameterTypeAsCSharp,The length of the statement  "        if (sType.Equals("HWND") || sType.Equals("HBITMAP") || sType.Equals("HCURSOR") || sType.Equals("HICON") || sType.Equals("HBRUSH") || sType.Equals("HFONT") || sType.Equals("HMENU") || sType.Equals("HDC")) " is 203.
Long Statement,MethodGen,Declaration,C:\repos\mcneel_rhinocommon\methodgen\NativeMethodDeclares.cs,GetReturnType,The length of the statement  "          else if (rc.Equals("LPUNKNOWN") || rc.Equals("HBITMAP") || rc.Equals("HWND") || rc.Equals("HCURSOR") || rc.Equals("HICON") || rc.Equals("HBRUSH") || rc.Equals("HFONT") || rc.Equals("HMENU") || rc.Equals("HDC")) " is 210.
Long Statement,MethodGen,Program,C:\repos\mcneel_rhinocommon\methodgen\Program.cs,Main,The length of the statement  "          System.Console.WriteLine("Can't locate RDK project directories. This is OK if you are compiling for standalone openNURBS build"); " is 129.
Complex Conditional,MethodGen,Declaration,C:\repos\mcneel_rhinocommon\methodgen\NativeMethodDeclares.cs,ParameterTypeAsCSharp,The conditional expression  "sType.Equals("HWND") || sType.Equals("HBITMAP") || sType.Equals("HCURSOR") || sType.Equals("HICON") || sType.Equals("HBRUSH") || sType.Equals("HFONT") || sType.Equals("HMENU") || sType.Equals("HDC")"  is complex.
Complex Conditional,MethodGen,Declaration,C:\repos\mcneel_rhinocommon\methodgen\NativeMethodDeclares.cs,ParameterTypeAsCSharp,The conditional expression  "s.Equals("int") || s.Equals("uint") || s.Equals("double") || s.Equals("float") || s.Equals("Guid") ||                s.Equals("short") || s.Equals("Int64") || s.Equals("byte")"  is complex.
Complex Conditional,MethodGen,Declaration,C:\repos\mcneel_rhinocommon\methodgen\NativeMethodDeclares.cs,ParameterTypeAsCSharp,The conditional expression  "s.Equals("ON_Arc") ||                s.Equals("ON_BoundingBox") ||                s.Equals("ON_Sphere") ||                s.Equals("ON_Line") ||                s.Equals("ON_Interval") ||                s.Equals("ON_Cylinder") ||                s.Equals("ON_Cone") ||                s.Equals("ON_Torus") ||                s.Equals("ON_Ellipse") ||                s.Equals("ON_Quaternion")"  is complex.
Complex Conditional,MethodGen,Declaration,C:\repos\mcneel_rhinocommon\methodgen\NativeMethodDeclares.cs,GetReturnType,The conditional expression  "rc.Equals("LPUNKNOWN") || rc.Equals("HBITMAP") || rc.Equals("HWND") || rc.Equals("HCURSOR") || rc.Equals("HICON") || rc.Equals("HBRUSH") || rc.Equals("HFONT") || rc.Equals("HMENU") || rc.Equals("HDC")"  is complex.
Magic Number,MethodGen,CommandlineParser,C:\repos\mcneel_rhinocommon\methodgen\CommandlineParser.cs,ProcessArguments,The following statement contains a magic number: for (int i=0; i<args.Length; i++)        {          current_arg = args[i];            if (current_arg.Contains("="))          {            // This is a name-value pair            //   color=white            string[] pair = current_arg.Split("=".ToCharArray()' 2' StringSplitOptions.RemoveEmptyEntries);            string name = pair[0].ToUpperInvariant();            this[name] = pair[1];            }          else if (current_arg.StartsWith("/") && current_arg.Length > 2)          {            // This is also a name-value pair            //   /color white            // but not            //   /x  <== these are just a "switch"; see below            string name = current_arg.TrimStart("/".ToCharArray()).ToUpperInvariant();            if (i + 1 < args.Length)            {              string value = args[++i];              this[name] = value;            }            else            {              throw new CommandlineParserException("Unexpected Command Line Argument '" + current_arg + "' - expected another argument after as value.");            }          }          else if (current_arg.StartsWith("/") && current_arg.Length == 2)          {            string name = current_arg.TrimStart("/".ToCharArray());            this[name] = "";          }          else          {            // This is just a single parameter            this[current_arg] = "";          }        }
Magic Number,MethodGen,CommandlineParser,C:\repos\mcneel_rhinocommon\methodgen\CommandlineParser.cs,ProcessArguments,The following statement contains a magic number: for (int i=0; i<args.Length; i++)        {          current_arg = args[i];            if (current_arg.Contains("="))          {            // This is a name-value pair            //   color=white            string[] pair = current_arg.Split("=".ToCharArray()' 2' StringSplitOptions.RemoveEmptyEntries);            string name = pair[0].ToUpperInvariant();            this[name] = pair[1];            }          else if (current_arg.StartsWith("/") && current_arg.Length > 2)          {            // This is also a name-value pair            //   /color white            // but not            //   /x  <== these are just a "switch"; see below            string name = current_arg.TrimStart("/".ToCharArray()).ToUpperInvariant();            if (i + 1 < args.Length)            {              string value = args[++i];              this[name] = value;            }            else            {              throw new CommandlineParserException("Unexpected Command Line Argument '" + current_arg + "' - expected another argument after as value.");            }          }          else if (current_arg.StartsWith("/") && current_arg.Length == 2)          {            string name = current_arg.TrimStart("/".ToCharArray());            this[name] = "";          }          else          {            // This is just a single parameter            this[current_arg] = "";          }        }
Magic Number,MethodGen,CommandlineParser,C:\repos\mcneel_rhinocommon\methodgen\CommandlineParser.cs,ProcessArguments,The following statement contains a magic number: for (int i=0; i<args.Length; i++)        {          current_arg = args[i];            if (current_arg.Contains("="))          {            // This is a name-value pair            //   color=white            string[] pair = current_arg.Split("=".ToCharArray()' 2' StringSplitOptions.RemoveEmptyEntries);            string name = pair[0].ToUpperInvariant();            this[name] = pair[1];            }          else if (current_arg.StartsWith("/") && current_arg.Length > 2)          {            // This is also a name-value pair            //   /color white            // but not            //   /x  <== these are just a "switch"; see below            string name = current_arg.TrimStart("/".ToCharArray()).ToUpperInvariant();            if (i + 1 < args.Length)            {              string value = args[++i];              this[name] = value;            }            else            {              throw new CommandlineParserException("Unexpected Command Line Argument '" + current_arg + "' - expected another argument after as value.");            }          }          else if (current_arg.StartsWith("/") && current_arg.Length == 2)          {            string name = current_arg.TrimStart("/".ToCharArray());            this[name] = "";          }          else          {            // This is just a single parameter            this[current_arg] = "";          }        }
Magic Number,MethodGen,DeclarationList,C:\repos\mcneel_rhinocommon\methodgen\NativeMethodDeclares.cs,Construct,The following statement contains a magic number: while (true)        {          int index = source_code.IndexOf(EXPORT_DECLARE' previous_index + 1);          if (-1 == index)            break;          previous_index = index;          // make sure this function is not commented out          // walk backward to the newline and try to find a //          if (index > 2)          {            bool skipThisDeclaration = false;            int testIndex = index - 1;            while (testIndex > 0)            {              if (source_code[testIndex] == '/' && source_code[testIndex - 1] == '/')              {                skipThisDeclaration = true;                break;              }              if (source_code[testIndex] == '#')              {                skipThisDeclaration = true;                break;              }              if (source_code[testIndex] == '\n')                break;              testIndex--;            }            if (skipThisDeclaration)              continue;          }          //if (index > 2 && sourceCode[index - 1] == '/' && sourceCode[index - 2] == '/')          //  continue;          // make sure this function is not defined as a MANUAL definition          if (index > MANUAL.Length)          {            int manStart = index - MANUAL.Length;            if (source_code.Substring(manStart' MANUAL.Length) == MANUAL)              continue;          }          startIndices.Add(index);        }
Magic Number,MethodGen,Declaration,C:\repos\mcneel_rhinocommon\methodgen\NativeMethodDeclares.cs,GetReturnType,The following statement contains a magic number: if (rc.StartsWith("const "))            rc = rc.Substring(6);
Magic Number,MethodGen,Program,C:\repos\mcneel_rhinocommon\methodgen\Program.cs,Main,The following statement contains a magic number: if (args.Length >= 2)        {          dirCPP = args[0];          dirCS = args[1];        }        else        {          // See if there is a configuration file sitting in the same directory          string location = System.Reflection.Assembly.GetExecutingAssembly().Location;          string path = System.IO.Path.GetDirectoryName(location);          path = System.IO.Path.Combine(path' "methodgen.cfg.txt");          if (System.IO.File.Exists(path))          {            string[] lines = System.IO.File.ReadAllLines(path);            dirCPP = System.IO.Path.GetFullPath(lines[0]);            dirCS = System.IO.Path.GetFullPath(lines[1]);            for (int i = 2; i < lines.Length; i++)            {              if (lines[i].StartsWith("using"))              {                m_includeRhinoDeclarations = false;                m_extra_usings.Add(lines[i].Trim());              }              if (lines[i].StartsWith("define"))              {                if (preprocessor_defines == null)                  preprocessor_defines = new List<string>();                string define = lines[i].Substring("define".Length).Trim();                preprocessor_defines.Add(define);              }            }          }          else          {            rhinocommon_build = true;            // find directories for rhcommon_c and RhinoCommon            GetProjectDirectories(out dirCPP' out dirCS' false);          }        }
Magic Number,MethodGen,Program,C:\repos\mcneel_rhinocommon\methodgen\Program.cs,Main,The following statement contains a magic number: if (args.Length >= 2)        {          dirCPP = args[0];          dirCS = args[1];        }        else        {          // See if there is a configuration file sitting in the same directory          string location = System.Reflection.Assembly.GetExecutingAssembly().Location;          string path = System.IO.Path.GetDirectoryName(location);          path = System.IO.Path.Combine(path' "methodgen.cfg.txt");          if (System.IO.File.Exists(path))          {            string[] lines = System.IO.File.ReadAllLines(path);            dirCPP = System.IO.Path.GetFullPath(lines[0]);            dirCS = System.IO.Path.GetFullPath(lines[1]);            for (int i = 2; i < lines.Length; i++)            {              if (lines[i].StartsWith("using"))              {                m_includeRhinoDeclarations = false;                m_extra_usings.Add(lines[i].Trim());              }              if (lines[i].StartsWith("define"))              {                if (preprocessor_defines == null)                  preprocessor_defines = new List<string>();                string define = lines[i].Substring("define".Length).Trim();                preprocessor_defines.Add(define);              }            }          }          else          {            rhinocommon_build = true;            // find directories for rhcommon_c and RhinoCommon            GetProjectDirectories(out dirCPP' out dirCS' false);          }        }
