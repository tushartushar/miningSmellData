Implementation smell,Namespace,Class,File,Method,Description
Long Method,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The method has 340 lines of code.
Long Method,MsgPack,MessagePackCode,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackCode.cs,ToString,The method has 102 lines of code.
Long Method,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ToString,The method has 139 lines of code.
Long Method,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ToStringBinary,The method has 106 lines of code.
Long Method,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,PackToMessage,The method has 122 lines of code.
Long Method,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,PackToMessageAsync,The method has 122 lines of code.
Long Method,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ToObject,The method has 102 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadByteSlow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadByteSlowAsync,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSByteSlow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSByteSlowAsync,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt16Slow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt16SlowAsync,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt16Slow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt16SlowAsync,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt32Slow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt32SlowAsync,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt32Slow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt32SlowAsync,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt64Slow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt64SlowAsync,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt64Slow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt64SlowAsync,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSingleSlow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSingleSlowAsync,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadDoubleSlow,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadDoubleSlowAsync,The method has 112 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The method has 146 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The method has 148 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The method has 146 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The method has 148 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method has 868 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The method has 898 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The method has 134 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLengthAsync,The method has 131 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The method has 134 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLengthAsync,The method has 131 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The method has 138 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The method has 145 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The method has 140 lines of code.
Long Method,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The method has 144 lines of code.
Long Method,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The method has 193 lines of code.
Long Method,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,HandleParseResult,The method has 161 lines of code.
Long Method,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The method has 124 lines of code.
Long Method,System.IO,BufferedStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\BufferedStream.cs,Write,The method has 121 lines of code.
Long Method,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,CreateCore,The method has 113 lines of code.
Long Method,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The method has 156 lines of code.
Long Method,MsgPack.Serialization,SerializationContext,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationContext.cs,GetSerializer,The method has 143 lines of code.
Long Method,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The method has 156 lines of code.
Long Method,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateAbstractCollectionSerializer,The method has 127 lines of code.
Long Method,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromCore,The method has 116 lines of code.
Long Method,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionSerializer,The method has 116 lines of code.
Long Method,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,GetMetadata,The method has 137 lines of code.
Complex Method,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackCore,Cyclomatic complexity of the method is 10
Complex Method,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,Cyclomatic complexity of the method is 10
Complex Method,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,Equals,Cyclomatic complexity of the method is 15
Complex Method,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ToString,Cyclomatic complexity of the method is 16
Complex Method,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,IsTypeOf,Cyclomatic complexity of the method is 9
Complex Method,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ToObject,Cyclomatic complexity of the method is 8
Complex Method,MsgPack,MessagePackObjectDictionary,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.cs,AddCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackCore,Cyclomatic complexity of the method is 10
Complex Method,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,Cyclomatic complexity of the method is 10
Complex Method,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,Cyclomatic complexity of the method is 12
Complex Method,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,Cyclomatic complexity of the method is 20
Complex Method,System.IO,BufferedStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\BufferedStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,System.IO,BufferedStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\BufferedStream.cs,ReadAsync,Cyclomatic complexity of the method is 8
Complex Method,System.IO,BufferedStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\BufferedStream.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,System.IO,BufferedStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\BufferedStream.cs,WriteAsync,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,DefaultConcreteTypeRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultConcreteTypeRepository.cs,Register,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,PackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PackHelpers.cs,PackToMap,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,Cyclomatic complexity of the method is 18
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackArrayTo,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionTo,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionTo,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionTo,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionTo,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMapTo,Cyclomatic complexity of the method is 11
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMapTo,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValue,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValue,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValueAsync,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValueAsync,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValue,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValue,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueAsync,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueAsync,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValue,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValue,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueAsync,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueAsync,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,IsSupported,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,Cyclomatic complexity of the method is 9
Complex Method,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,Cyclomatic complexity of the method is 19
Complex Method,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,Cyclomatic complexity of the method is 19
Complex Method,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromAsyncCore,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackMemberValue,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackMemberValueAsync,Cyclomatic complexity of the method is 8
Complex Method,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,GetMetadata,Cyclomatic complexity of the method is 13
Long Parameter List,MsgPack,CollectionOperation,C:\repos\msgpack_msgpack-cli\src\MsgPack\CollectionOperation.cs,CopyTo,The method has 6 parameters. Parameters: source' sourceCount' index' array' arrayIndex' count
Long Parameter List,MsgPack,CollectionOperation,C:\repos\msgpack_msgpack-cli\src\MsgPack\CollectionOperation.cs,CopyTo,The method has 7 parameters. Parameters: source' sourceCount' index' array' arrayIndex' count' converter
Long Parameter List,MsgPack,CollectionOperation,C:\repos\msgpack_msgpack-cli\src\MsgPack\CollectionOperation.cs,ValidateCopyToArguments,The method has 5 parameters. Parameters: sourceCount' index' array' arrayIndex' count
Long Parameter List,MsgPack,EncodingExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\EncodingExtensions.cs,EncodeString,The method has 9 parameters. Parameters: source' chars' charsOffset' charsLength' buffer' bufferOffset' bufferCount' charsUsed' bytesUsed
Long Parameter List,MsgPack,EncodingExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\EncodingExtensions.cs,DecodeString,The method has 6 parameters. Parameters: source' bytes' bytesOffset' bytesLength' buffer' result
Long Parameter List,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadItems,The method has 5 parameters. Parameters: count' isMap' source' offset' result
Long Parameter List,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,EncodeString,The method has 7 parameters. Parameters: encoder' value' startOffset' count' buffer' charsUsed' bytesUsed
Long Parameter List,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadItems,The method has 5 parameters. Parameters: count' isMap' buffer' offset' result
Long Parameter List,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadItemsAsync,The method has 5 parameters. Parameters: count' isMap' buffer' offset' cancellationToken
Long Parameter List,MsgPack,PackerUnpackerExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\PackerUnpackerExtensions.cs,PackDictionaryAsyncCore,The method has 5 parameters. Parameters: source' dictionary' keySerializer' valueSerializer' cancellationToken
Long Parameter List,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,TryParseExact,The method has 5 parameters. Parameters: input' format' formatProvider' styles' result
Long Parameter List,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,TryParseExact,The method has 5 parameters. Parameters: input' formats' formatProvider' styles' result
Long Parameter List,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,TryParseExactCore,The method has 5 parameters. Parameters: input' format' formatProvider' styles' result
Long Parameter List,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,TryParseExactCore,The method has 5 parameters. Parameters: input' formats' formatProvider' styles' result
Long Parameter List,MsgPack,Value,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.cs,Value,The method has 7 parameters. Parameters: year' month' day' hour' minute' second' nanoseconds
Long Parameter List,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The method has 5 parameters. Parameters: input' format' formatProvider' styles' result
Long Parameter List,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ParseDigitRange,The method has 6 parameters. Parameters: input' minLength' position' min' max' result
Long Parameter List,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ParseDay,The method has 5 parameters. Parameters: input' position' month' isLeapYear' day
Long Parameter List,System.IO,BufferedStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\BufferedStream.cs,FlushAsyncInternal,The method has 6 parameters. Parameters: cancellationToken' _this' stream' writePos' readPos' readLen
Long Parameter List,System.IO,BufferedStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\BufferedStream.cs,ReadFromUnderlyingStreamAsync,The method has 6 parameters. Parameters: array' offset' count' cancellationToken' bytesAlreadySatisfied' semaphoreLockTask
Long Parameter List,System.IO,BufferedStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\BufferedStream.cs,WriteToUnderlyingStreamAsync,The method has 5 parameters. Parameters: array' offset' count' cancellationToken' semaphoreLockTask
Long Parameter List,MsgPack.Serialization,CollectionTraits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\CollectionTraits.cs,CollectionTraits,The method has 5 parameters. Parameters: type' elementType' getEnumeratorMethod' addMethod' countPropertyGetter
Long Parameter List,MsgPack.Serialization,PackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PackHelpers.cs,PackToMapAsyncCore,The method has 6 parameters. Parameters: serializationContext' packer' target' operations' nullCheckers' cancellationToken
Long Parameter List,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,PolymorphismSchema,The method has 5 parameters. Parameters: targetType' polymorphismType' typeVerifier' childrenType' childItemSchemaList
Long Parameter List,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,PolymorphismSchema,The method has 6 parameters. Parameters: targetType' polymorphismType' codeTypeMapping' typeVerifier' childrenType' childItemSchemaList
Long Parameter List,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,PolymorphismSchema,The method has 6 parameters. Parameters: targetType' polymorphismType' codeTypeMapping' typeVerifier' childrenType' childItemSchemaList
Long Parameter List,MsgPack.Serialization,TypeTableEntry,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,SetKnownType,The method has 5 parameters. Parameters: target' memberName' tupleItemNumber' typeCode' bindingType
Long Parameter List,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,TryCreateCollectionTraitsForIEnumerableT,The method has 5 parameters. Parameters: source' genericTypes' options' getMethod' result
Long Parameter List,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,DetermineCollectionInterfaces,The method has 6 parameters. Parameters: type' genericTypes' idictionary' ilist' icollection' ienumerable
Long Parameter List,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,DetermineCanDeserialize,The method has 5 parameters. Parameters: kind' context' targetType' correspondingMemberNames' allowDefault
Long Parameter List,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,GetNullableCompanion,The method has 5 parameters. Parameters: targetType' context' serializer' nullableType' nullableSerializerProvider
Long Parameter List,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,Register,The method has 5 parameters. Parameters: targetType' serializerProvider' nullableType' nullableSerializerProvider' options
Long Parameter List,MsgPack.Serialization,TypeKeyRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\TypeKeyRepository.cs,Register,The method has 5 parameters. Parameters: type' entry' nullableType' nullableValue' options
Long Parameter List,MsgPack.Serialization,TypeKeyRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\TypeKeyRepository.cs,RegisterCore,The method has 5 parameters. Parameters: key' value' nullableType' nullableValue' options
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,Trace,The method has 5 parameters. Parameters: context' label' unpacker' index' itemNames
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,Trace,The method has 5 parameters. Parameters: context' label' unpacker' index' key
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValue,The method has 9 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' directRead' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValueCore,The method has 9 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' directRead' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValueAsync,The method has 10 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' directRead' setter' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValueAsyncCore,The method has 10 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' directRead' setter' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValue,The method has 10 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueCore,The method has 10 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueAsync,The method has 11 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueAsyncCore,The method has 11 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValue,The method has 10 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueCore,The method has 10 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueAsync,The method has 11 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueAsyncCore,The method has 11 parameters. Parameters: unpacker' context' serializer' itemsCount' unpacked' targetObjectType' memberName' nilImplication' directRead' setter' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueFromArray,The method has 7 parameters. Parameters: unpacker' context' itemsCount' unpacked' memberName' nilImplication' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueFromArrayAsync,The method has 8 parameters. Parameters: unpacker' context' itemsCount' unpacked' memberName' nilImplication' setter' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueFromMap,The method has 7 parameters. Parameters: unpacker' context' itemsCount' unpacked' memberName' nilImplication' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueFromMapAsync,The method has 8 parameters. Parameters: unpacker' context' itemsCount' unpacked' memberName' nilImplication' setter' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueCore,The method has 7 parameters. Parameters: unpacker' unpackingContext' itemsCount' unpacked' memberName' nilImplication' setter
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueAsyncCore,The method has 8 parameters. Parameters: unpacker' unpackingContext' itemsCount' unpacked' memberName' nilImplication' setter' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackFromArray,The method has 5 parameters. Parameters: unpacker' context' factory' itemNames' operations
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackFromArrayCore,The method has 5 parameters. Parameters: unpacker' unpackingContext' factory' itemNames' operations
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackFromArrayAsync,The method has 6 parameters. Parameters: unpacker' context' factory' itemNames' operations' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackFromArrayAsyncCore,The method has 6 parameters. Parameters: unpacker' unpackingContext' factory' itemNames' operations' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackFromMapAsync,The method has 5 parameters. Parameters: unpacker' context' factory' operations' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackFromMapAsyncCore,The method has 5 parameters. Parameters: unpacker' unpackingContext' factory' operations' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollection,The method has 5 parameters. Parameters: unpacker' itemsCount' collection' bulkOperation' eachOperation
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionCore,The method has 5 parameters. Parameters: unpacker' itemsCount' collection' bulkOperation' eachOperation
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionAsync,The method has 6 parameters. Parameters: unpacker' itemsCount' collection' bulkOperation' eachOperation' cancellationToken
Long Parameter List,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionAsyncCore,The method has 6 parameters. Parameters: unpacker' itemsCount' collection' bulkOperation' eachOperation' cancellationToken
Long Parameter List,MsgPack.Serialization.DefaultSerializers,AbstractCollectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractCollectionSerializerHelper.cs,GetConcreteSerializer,The method has 7 parameters. Parameters: context' schema' abstractType' targetType' exampleType' factory' serializer
Long Parameter List,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateAbstractCollectionSerializer,The method has 5 parameters. Parameters: context' abstractType' concreteType' schema' traits
Long Parameter List,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,ForEach,The method has 5 parameters. Parameters: array' totalLength' lowerBounds' lengths' action
Long Parameter List,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,ForEachAsync,The method has 5 parameters. Parameters: array' totalLength' lowerBounds' lengths' action
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionCollectionMessagePackSerializer<TCollection;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionCollectionMessagePackSerializer`2.cs,ReflectionCollectionMessagePackSerializer,The method has 5 parameters. Parameters: ownerContext' targetType' collectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionDictionaryMessagePackSerializer<TDictionary;TKey;TValue>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionDictionaryMessagePackSerializer`3.cs,ReflectionDictionaryMessagePackSerializer,The method has 5 parameters. Parameters: ownerContext' targetType' collectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionEnumerableMessagePackSerializer<TCollection;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionEnumerableMessagePackSerializer`2.cs,ReflectionEnumerableMessagePackSerializer,The method has 5 parameters. Parameters: ownerContext' targetType' collectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionNonGenericCollectionMessagePackSerializer<TCollection>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionNonGeenricCollectionMessagePackSerializer`1.cs,ReflectionNonGenericCollectionMessagePackSerializer,The method has 5 parameters. Parameters: ownerContext' targetType' collectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionNonGenericEnumerableMessagePackSerializer<TCollection>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionNonGeenricEnumerableMessagePackSerializer`1.cs,ReflectionNonGenericEnumerableMessagePackSerializer,The method has 5 parameters. Parameters: ownerContext' targetType' collectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionNonGenericDictionaryMessagePackSerializer<TDictionary>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionNonGenericDictionaryMessagePackSerializer`1.cs,ReflectionNonGenericDictionaryMessagePackSerializer,The method has 5 parameters. Parameters: ownerContext' targetType' collectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionNonGenericListMessagePackSerializer<TList>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionNonGenericListMessagePackSerializer`1.cs,ReflectionNonGenericListMessagePackSerializer,The method has 5 parameters. Parameters: ownerContext' targetType' collectionTraits' itemsSchema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackMemberValue,The method has 6 parameters. Parameters: objectGraph' unpacker' itemsCount' unpacked' index' unpackerOffset
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackMemberValueAsync,The method has 7 parameters. Parameters: objectGraph' unpacker' itemsCount' unpacked' index' unpackerOffset' cancellationToken
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,GetMetadata,The method has 8 parameters. Parameters: targetType' members' context' getters' setters' memberInfos' contracts' serializers
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,IVariantReflectionSerializerFactory,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The method has 5 parameters. Parameters: context' targetType' collectionTraits' schema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,NonGenericEnumerableSerializerFactory<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The method has 5 parameters. Parameters: context' targetType' collectionTraits' schema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,NonGenericCollectionSerializerFactory<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The method has 5 parameters. Parameters: context' targetType' collectionTraits' schema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,NonGenericListSerializerFactory<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The method has 5 parameters. Parameters: context' targetType' collectionTraits' schema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,NonGenericDictionarySerializerFactory<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The method has 5 parameters. Parameters: context' targetType' collectionTraits' schema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,EnumerableSerializerFactory<TCollection;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The method has 5 parameters. Parameters: context' targetType' collectionTraits' schema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,CollectionSerializerFactory<TCollection;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The method has 5 parameters. Parameters: context' targetType' collectionTraits' schema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,DictionarySerializerFactory<TDictionary;TKey;TValue>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The method has 5 parameters. Parameters: context' targetType' collectionTraits' schema' targetInfo
Long Parameter List,MsgPack.Serialization.ReflectionSerializers,ReflectionTupleMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionTupleMessagePackSerializer`1.cs,GetGetters,The method has 5 parameters. Parameters: itemTypes' tupleTypes' metadataFactory' accessorFactory' chainedGetterFactory
Long Identifier,MsgPack,PackerUnpackerStreamOptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\PackerUnpackerStreamOptions.cs,,The length of the parameter _knownMemoryOrBufferingStreams is 30.
Long Identifier,MsgPack.Serialization,DateTimeMessagePackSerializerHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DateTimeMessagePackSerializerHelpers.cs,DetermineDateTimeConversionMethod,The length of the parameter dateTimeMemberConversionMethod is 30.
Long Identifier,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,,The length of the parameter _packerCompatibilityOptionsForCompatibility is 43.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForPolymorphicObjectTypeEmbeddingMethod is 39.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForPolymorphicObjectCodeTypeMappingMethod is 41.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForContextSpecifiedCollectionMethod is 35.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForPolymorphicCollectionTypeEmbeddingMethod is 43.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForPolymorphicCollectionCodeTypeMappingMethod is 45.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForContextSpecifiedDictionaryMethod is 35.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForPolymorphicDictionaryTypeEmbeddingMethod is 43.
Long Identifier,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,,The length of the parameter ForPolymorphicDictionaryCodeTypeMappingMethod is 45.
Long Identifier,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The length of the parameter allowNonCollectionEnumerableTypes is 33.
Long Identifier,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,,The length of the parameter ExceptionConstructorWithInnerParameterTypes is 43.
Long Identifier,MsgPack.Serialization,SerializationCompatibilityOptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationCompatibilityOptions.cs,,The length of the parameter _ignorePackabilityForCollection is 31.
Long Identifier,MsgPack.Serialization,SerializationCompatibilityOptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationCompatibilityOptions.cs,,The length of the parameter _allowNonCollectionEnumerableTypes is 34.
Long Identifier,MsgPack.Serialization,SerializationContext,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationContext.cs,,The length of the parameter _dictionarySerializationOptions is 31.
Long Identifier,MsgPack.Serialization,SerializationContext,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationContext.cs,,The length of the parameter _defaultDateTimeConversionMethod is 32.
Long Identifier,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,,The length of the parameter MessagePackMemberAttributeTypeName is 34.
Long Identifier,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,,The length of the parameter MessagePackIgnoreAttributeTypeName is 34.
Long Identifier,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,,The length of the parameter MessagePackDeserializationConstructorAttributeTypeName is 54.
Long Identifier,MsgPack.Serialization,SerializerDebugging,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerDebugging.cs,,The length of the parameter _useLegacyNullMapEntryHandling is 30.
Long Identifier,MsgPack.Serialization,SerializingMember,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializingMember.cs,GetEnumMemberSerializationMethod,The length of the parameter messagePackEnumMemberAttribute is 30.
Long Identifier,MsgPack.Serialization,SerializingMember,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializingMember.cs,GetDateTimeMemberConversionMethod,The length of the parameter messagePackDateTimeMemberAttribute is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractCollectionMessagePackSerializer<TCollection;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractCollectionMessagePackSerializer`2.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractDictionaryMessagePackSerializer<TDictionary;TKey;TValue>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractDictionaryMessagePackSerializer`3.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractEnumerableMessagePackSerializer<TCollection;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractEnumerableMessagePackSerializer`2.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractNonGenericCollectionMessagePackSerializer<TCollection>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractNonGenericCollectionMessagePackSerializer`1.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractNonGenericDictionaryMessagePackSerializer<TDictionary>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractNonGenericDictionaryMessagePackSerializer`1.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractNonGenericEnumerableMessagePackSerializer<TCollection>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractNonGenericEnumerableMessagePackSerializer`1.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractNonGenericListMessagePackSerializer<TCollection>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractNonGenericListMessagePackSerializer`1.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractReadOnlyCollectionMessagePackSerializer<TCollection;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractReadOnlyCollectionMessagePackSerializer`2.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,AbstractReadOnlyDictionaryMessagePackSerializer<TDictionary;TKey;TValue>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\AbstractReadOnlyDictionaryMessagePackSerializer`3.cs,,The length of the parameter _concreteCollectionInstanceFactory is 34.
Long Identifier,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,IsSupported,The length of the parameter preferReflectionBasedSerializer is 31.
Long Statement,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The length of the statement  "					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 " is 141.
Long Statement,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The length of the statement  "					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ]; " is 133.
Long Statement,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt16,The length of the statement  "			Contract.Assert( buffer.Length >= offset + sizeof( ushort )' buffer.Length + ">=" + offset + " + " + sizeof( ushort ) ); " is 120.
Long Statement,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt32,The length of the statement  "				return ( uint )( ( buffer[ offset ] << 24 ) | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ] ); " is 126.
Long Statement,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The length of the statement  "					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32 " is 152.
Long Statement,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The length of the statement  "					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] ); " is 135.
Long Statement,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToBits,The length of the statement  "			// Float32Bits usage is effectively pointer dereference operation rather than shifting operators' so we must consider endianness here. " is 134.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteByteAsync( value ? ( byte )MessagePackCode.TrueValue : ( byte )MessagePackCode.FalseValue' cancellationToken ).ConfigureAwait( false ); " is 151.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt8' unchecked( ( Byte )value )' cancellationToken ).ConfigureAwait( false ); " is 138.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )value )' cancellationToken ).ConfigureAwait( false ); " is 136.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )value )' cancellationToken ).ConfigureAwait( false ); " is 136.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 147.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )value )' cancellationToken ).ConfigureAwait( false ); " is 139.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 147.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )value )' cancellationToken ).ConfigureAwait( false ); " is 139.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 149.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt16' unchecked( ( UInt16 )value )' cancellationToken ).ConfigureAwait( false ); " is 141.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 147.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 152.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt32' unchecked( ( UInt32 )value )' cancellationToken ).ConfigureAwait( false ); " is 139.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 147.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 152.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt32' unchecked( ( UInt32 )value )' cancellationToken ).ConfigureAwait( false ); " is 139.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 149.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 154.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt32' unchecked( ( UInt32 )value )' cancellationToken ).ConfigureAwait( false ); " is 141.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 147.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 152.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt32' unchecked( ( UInt32 )( value & 0xFFFFFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 156.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt64' unchecked( ( UInt64 )value )' cancellationToken ).ConfigureAwait( false ); " is 139.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 147.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 152.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt32' unchecked( ( UInt32 )( value & 0xFFFFFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 156.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt64' unchecked( ( UInt64 )value )' cancellationToken ).ConfigureAwait( false ); " is 139.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 149.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 154.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt32' unchecked( ( UInt32 )( value & 0xFFFFFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 158.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt64' unchecked( ( UInt64 )value )' cancellationToken ).ConfigureAwait( false ); " is 141.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Real32' unchecked( ( Single )value )' cancellationToken ).ConfigureAwait( false ); " is 134.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Real64' unchecked( ( Double )value )' cancellationToken ).ConfigureAwait( false ); " is 134.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackArrayHeaderAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | length ) )' cancellationToken ).ConfigureAwait( false ); " is 140.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackArrayHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Array16' unchecked( ( ushort )( length & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 149.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackArrayHeaderAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Array32' unchecked( ( uint )length )' cancellationToken ).ConfigureAwait( false ); " is 134.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackMapHeaderAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | length ) )' cancellationToken ).ConfigureAwait( false ); " is 138.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackMapHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Map16' unchecked( ( ushort )( length & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 147.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackMapHeaderAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Map32' unchecked( ( uint )length )' cancellationToken ).ConfigureAwait( false ); " is 132.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackStringHeaderAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedRaw | length ) )' cancellationToken ).ConfigureAwait( false ); " is 138.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackStringHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Str8' unchecked( ( byte )( length & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 142.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackStringHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Str16' unchecked( ( ushort )( length & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 147.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackStringHeaderAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Str32' unchecked( ( uint )length )' cancellationToken ).ConfigureAwait( false ); " is 132.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackBinaryHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Bin8' unchecked( ( byte )( length & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 142.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackBinaryHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Bin16' unchecked( ( ushort )( length & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 147.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackBinaryHeaderAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Bin32' unchecked( ( uint )length )' cancellationToken ).ConfigureAwait( false ); " is 132.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackRawAsyncCore,The length of the statement  "			await this.WriteBytesAsync( value' ( this.CompatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) == 0' cancellationToken ).ConfigureAwait( false ); " is 160.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackRawAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedRaw | value.Length ) )' cancellationToken ).ConfigureAwait( false ); " is 144.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackRawAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Str8' unchecked( ( byte )( value.Length ) )' cancellationToken ).ConfigureAwait( false ); " is 141.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackRawAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Str16' unchecked( ( ushort )( value.Length ) )' cancellationToken ).ConfigureAwait( false ); " is 144.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackRawAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Str32' unchecked( ( uint )value.Length )' cancellationToken ).ConfigureAwait( false ); " is 138.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackBinaryAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Bin8' unchecked( ( byte )( value.Length ) )' cancellationToken ).ConfigureAwait( false ); " is 141.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackBinaryAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Bin16' unchecked( ( ushort )( value.Length ) )' cancellationToken ).ConfigureAwait( false ); " is 144.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackBinaryAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Bin32' unchecked( ( uint )value.Length )' cancellationToken ).ConfigureAwait( false ); " is 138.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueAsyncCore,The length of the statement  "							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false ); " is 123.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueAsyncCore,The length of the statement  "							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false ); " is 126.
Long Statement,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueAsyncCore,The length of the statement  "							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false ); " is 124.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadByteAsync,The length of the statement  "			return Task.FromResult( this.ReadByte( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Byte>() ); " is 121.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableByteAsync,The length of the statement  "			return Task.FromResult( this.ReadNullableByte( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Byte?>() ); " is 130.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadSByteAsync,The length of the statement  "			return Task.FromResult( this.ReadSByte( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<SByte>() ); " is 123.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableSByteAsync,The length of the statement  "			return Task.FromResult( this.ReadNullableSByte( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<SByte?>() ); " is 132.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadInt16Async,The length of the statement  "			return Task.FromResult( this.ReadInt16( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Int16>() ); " is 123.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableInt16Async,The length of the statement  "			return Task.FromResult( this.ReadNullableInt16( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Int16?>() ); " is 132.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadUInt16Async,The length of the statement  "			return Task.FromResult( this.ReadUInt16( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<UInt16>() ); " is 125.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableUInt16Async,The length of the statement  "			return Task.FromResult( this.ReadNullableUInt16( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<UInt16?>() ); " is 134.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadInt32Async,The length of the statement  "			return Task.FromResult( this.ReadInt32( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Int32>() ); " is 123.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableInt32Async,The length of the statement  "			return Task.FromResult( this.ReadNullableInt32( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Int32?>() ); " is 132.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadUInt32Async,The length of the statement  "			return Task.FromResult( this.ReadUInt32( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<UInt32>() ); " is 125.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableUInt32Async,The length of the statement  "			return Task.FromResult( this.ReadNullableUInt32( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<UInt32?>() ); " is 134.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadInt64Async,The length of the statement  "			return Task.FromResult( this.ReadInt64( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Int64>() ); " is 123.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableInt64Async,The length of the statement  "			return Task.FromResult( this.ReadNullableInt64( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Int64?>() ); " is 132.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadUInt64Async,The length of the statement  "			return Task.FromResult( this.ReadUInt64( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<UInt64>() ); " is 125.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableUInt64Async,The length of the statement  "			return Task.FromResult( this.ReadNullableUInt64( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<UInt64?>() ); " is 134.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadSingleAsync,The length of the statement  "			return Task.FromResult( this.ReadSingle( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Single>() ); " is 125.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableSingleAsync,The length of the statement  "			return Task.FromResult( this.ReadNullableSingle( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Single?>() ); " is 134.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadDoubleAsync,The length of the statement  "			return Task.FromResult( this.ReadDouble( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Double>() ); " is 125.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableDoubleAsync,The length of the statement  "			return Task.FromResult( this.ReadNullableDouble( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Double?>() ); " is 134.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBooleanAsync,The length of the statement  "			return Task.FromResult( this.ReadBoolean( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Boolean>() ); " is 127.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableBooleanAsync,The length of the statement  "			return Task.FromResult( this.ReadNullableBoolean( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Boolean?>() ); " is 136.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBinaryAsync,The length of the statement  "			return Task.FromResult( this.ReadBinary( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Byte[]>() ); " is 125.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadStringAsync,The length of the statement  "			return Task.FromResult( this.ReadString( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<String>() ); " is 125.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectCore,The length of the statement  "				if ( ( header & ReadValueResult.RawTypeMask ) == ReadValueResult.RawTypeMask && ( header & ReadValueResult.LengthOfLengthMask ) == 0 ) " is 134.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectAsync,The length of the statement  "			return Task.FromResult( this.ReadObject( isDeep' out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<MessagePackObject>() ); " is 144.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadArrayLengthAsync,The length of the statement  "			return Task.FromResult( this.ReadArrayLength( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Int64>() ); " is 129.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMapLengthAsync,The length of the statement  "			return Task.FromResult( this.ReadMapLength( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<Int64>() ); " is 127.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The length of the statement  "			return Task.FromResult( this.ReadMessagePackExtendedTypeObject( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<MessagePackExtendedTypeObject>() ); " is 171.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The length of the statement  "			return Task.FromResult( this.ReadNullableMessagePackExtendedTypeObject( out result ) ? AsyncReadResult.Success( result ) : AsyncReadResult.Fail<MessagePackExtendedTypeObject?>() ); " is 180.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large array (0x{0:X} elements) which has more than Int32.MaxValue elements' at position {1:#'0}" " is 133.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large array (0x{0:X} elements) which has more than Int32.MaxValue elements' at offset {1:#'0}"; " is 132.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large map (0x{0:X} entries) which has more than Int32.MaxValue entries' at position {1:#'0}" " is 129.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large map (0x{0:X} entries) which has more than Int32.MaxValue entries' at offset {1:#'0}"; " is 128.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large ext type (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at position {1:#'0}" " is 130.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large ext type (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at offset {1:#'0}"; " is 129.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large binary or string (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at position {1:#'0}" " is 138.
Long Statement,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large binary or string (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at offset {1:#'0}"; " is 137.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,Equals,The length of the statement  "			Contract.Assert( false' String.Format( "Unknown handle type this:'{0}'(value: '{1}')' other:'{2}'(value: '{3}')"' this._handleOrTypeCode.GetType()' this._handleOrTypeCode' other._handleOrTypeCode.GetType()' other._handleOrTypeCode ) ); " is 235.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,GetHashCode,The length of the statement  "				Contract.Assert( false' String.Format( "(this._handleOrTypeCode is string) but {0}"' this._handleOrTypeCode.GetType() ) ); " is 122.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ToString,The length of the statement  "			Contract.Assert( false' String.Format( "(this._handleOrTypeCode is string) but {0}"' this._handleOrTypeCode.GetType() ) ); " is 122.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,IsTypeOf,The length of the statement  "					return typeCode.IsInteger && ( this._value < 0x80000000 || ( 0xFFFFFFFF80000000 <= this._value && typeCode.IsSigned ) ); " is 120.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,PackToMessage,The length of the statement  "					if ( asString.GetUnderlyingType() == typeof( string ) || ( packer.CompatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) != 0 ) " is 140.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,PackToMessageAsync,The length of the statement  "					if ( asString.GetUnderlyingType() == typeof( string ) || ( packer.CompatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) != 0 ) " is 140.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,PackToMessageAsync,The length of the statement  "					await packer.PackExtendedTypeValueAsync( unchecked( ( byte )this._value )' asExtendedTypeObjectBody' cancellationToken ).ConfigureAwait( false ); " is 145.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsString,The length of the statement  "				throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "Not '{0}' string."' encoding.WebName )' ex ); " is 126.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,VerifyUnderlyingType,The length of the statement  "					throw new ArgumentException( String.Format( CultureInfo.CurrentCulture' "Do not convert nil MessagePackObject to {0}."' typeof( T ) )' parameterName ); " is 151.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,VerifyUnderlyingType,The length of the statement  "					throw new ArgumentException( String.Format( CultureInfo.CurrentCulture' "Do not convert {0} MessagePackObject to {1}."' instance.UnderlyingType' typeof( T ) )' parameterName ); " is 176.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,VerifyUnderlyingRawType,The length of the statement  "				throw new ArgumentException( String.Format( CultureInfo.CurrentCulture' "Do not convert {0} MessagePackObject to {1}."' instance.UnderlyingType' typeof( T ) )' parameterName ); " is 176.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ThrowCannotBeNilAs,The length of the statement  "			throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "Do not convert nil MessagePackObject to {0}."' typeof( T ) ) ); " is 144.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ThrowInvalidTypeAs,The length of the statement  "				throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "Do not convert {0} (binary:0x{2:x}) MessagePackObject to {1}."' instance.UnderlyingType' typeof( T )' instance._value ) ); " is 203.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,ThrowInvalidTypeAs,The length of the statement  "				throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "Do not convert {0} MessagePackObject to {1}."' instance.UnderlyingType' typeof( T ) ) ); " is 169.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,FromObject,The length of the statement  "			throw new MessageTypeException( String.Format( CultureInfo.CurrentCulture' "Type '{0}' is not supported."' boxedValue.GetType() ) ); " is 132.
Long Statement,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,DebugDump,The length of the statement  "				return String.Format( CultureInfo.InvariantCulture' "{0}([{1}])"' this._handleOrTypeCode' this._handleOrTypeCode.GetType() ); " is 125.
Long Statement,MsgPack,MessagePackObjectDictionary,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.cs,ThrowDuplicatedKeyException,The length of the statement  "			throw new ArgumentException( String.Format( CultureInfo.CurrentCulture' "Key '{0}'({1} type) already exists in this dictionary."' key' key.UnderlyingType )' parameterName ); " is 173.
Long Statement,MsgPack,MessagePackObjectDictionary,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.cs,ValidateObjectArgument,The length of the statement  "				throw new ArgumentException( String.Format( CultureInfo.CurrentCulture' "Cannot convert '{1}' to {0}."' typeof( MessagePackObject ).Name' obj.GetType() )' parameterName ); " is 171.
Long Statement,MsgPack,MessagePackObjectDictionary,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.cs,AddCore,The length of the statement  "				this._dictionary = new Dictionary<MessagePackObject' MessagePackObject>( DictionaryInitialCapacity' MessagePackObjectEqualityComparer.Instance ); " is 145.
Long Statement,MsgPack,MessagePackObjectDictionary,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.cs,CopyTo,The length of the statement  "				CollectionOperation.CopyTo( this' this.Count' 0' asDictionaryEntries' index' array.Length' kv => new DictionaryEntry( kv.Key' kv.Value ) ); " is 139.
Long Statement,MsgPack,Enumerator,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.Enumerator.cs,GetCurrentStrict,The length of the statement  "					throw new InvalidOperationException( "The enumerator is positioned before the first element of the collection or after the last element." ); " is 140.
Long Statement,MsgPack,Enumerator,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObjectDictionary.Enumerator.cs,MoveNext,The length of the statement  "				this._current = new KeyValuePair<MessagePackObject' MessagePackObject>( this._underlying._keys[ this._position ]' this._underlying._values[ this._position ] ); " is 159.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteByteAsync( value ? ( byte )MessagePackCode.TrueValue : ( byte )MessagePackCode.FalseValue' cancellationToken ).ConfigureAwait( false ); " is 151.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt8' unchecked( ( Byte )value )' cancellationToken ).ConfigureAwait( false ); " is 138.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )value )' cancellationToken ).ConfigureAwait( false ); " is 136.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )value )' cancellationToken ).ConfigureAwait( false ); " is 136.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 147.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )value )' cancellationToken ).ConfigureAwait( false ); " is 139.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 147.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )value )' cancellationToken ).ConfigureAwait( false ); " is 139.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 149.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt16' unchecked( ( UInt16 )value )' cancellationToken ).ConfigureAwait( false ); " is 141.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 147.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 152.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt32' unchecked( ( UInt32 )value )' cancellationToken ).ConfigureAwait( false ); " is 139.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 147.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 152.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt32' unchecked( ( UInt32 )value )' cancellationToken ).ConfigureAwait( false ); " is 139.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 149.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 154.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt32' unchecked( ( UInt32 )value )' cancellationToken ).ConfigureAwait( false ); " is 141.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 147.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 152.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "					await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt32' unchecked( ( UInt32 )( value & 0xFFFFFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 156.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt64' unchecked( ( UInt64 )value )' cancellationToken ).ConfigureAwait( false ); " is 139.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 147.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 152.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt32' unchecked( ( UInt32 )( value & 0xFFFFFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 156.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.SignedInt64' unchecked( ( UInt64 )value )' cancellationToken ).ConfigureAwait( false ); " is 139.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt8' unchecked( ( Byte )( value & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 149.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt16' unchecked( ( UInt16 )( value & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 154.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt32' unchecked( ( UInt32 )( value & 0xFFFFFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 158.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.UnsignedInt64' unchecked( ( UInt64 )value )' cancellationToken ).ConfigureAwait( false ); " is 141.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Real32' unchecked( ( Single )value )' cancellationToken ).ConfigureAwait( false ); " is 134.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Real64' unchecked( ( Double )value )' cancellationToken ).ConfigureAwait( false ); " is 134.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackArrayHeaderAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | length ) )' cancellationToken ).ConfigureAwait( false ); " is 140.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackArrayHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Array16' unchecked( ( ushort )( length & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 149.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackArrayHeaderAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Array32' unchecked( ( uint )length )' cancellationToken ).ConfigureAwait( false ); " is 134.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackMapHeaderAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | length ) )' cancellationToken ).ConfigureAwait( false ); " is 138.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackMapHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Map16' unchecked( ( ushort )( length & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 147.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackMapHeaderAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Map32' unchecked( ( uint )length )' cancellationToken ).ConfigureAwait( false ); " is 132.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackStringHeaderAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedRaw | length ) )' cancellationToken ).ConfigureAwait( false ); " is 138.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackStringHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Str8' unchecked( ( byte )( length & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 142.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackStringHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Str16' unchecked( ( ushort )( length & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 147.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackStringHeaderAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Str32' unchecked( ( uint )length )' cancellationToken ).ConfigureAwait( false ); " is 132.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackBinaryHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Bin8' unchecked( ( byte )( length & 0xFF ) )' cancellationToken ).ConfigureAwait( false ); " is 142.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackBinaryHeaderAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Bin16' unchecked( ( ushort )( length & 0xFFFF ) )' cancellationToken ).ConfigureAwait( false ); " is 147.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackBinaryHeaderAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Bin32' unchecked( ( uint )length )' cancellationToken ).ConfigureAwait( false ); " is 132.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackRawAsyncCore,The length of the statement  "			await this.WriteBytesAsync( value' ( this.CompatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) == 0' cancellationToken ).ConfigureAwait( false ); " is 160.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackRawAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedRaw | value.Length ) )' cancellationToken ).ConfigureAwait( false ); " is 144.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackRawAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Str8' unchecked( ( byte )( value.Length ) )' cancellationToken ).ConfigureAwait( false ); " is 141.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackRawAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Str16' unchecked( ( ushort )( value.Length ) )' cancellationToken ).ConfigureAwait( false ); " is 144.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackRawAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Str32' unchecked( ( uint )value.Length )' cancellationToken ).ConfigureAwait( false ); " is 138.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackBinaryAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Bin8' unchecked( ( byte )( value.Length ) )' cancellationToken ).ConfigureAwait( false ); " is 141.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackBinaryAsyncCore,The length of the statement  "				await this.WriteBytesAsync( ( byte )MessagePackCode.Bin16' unchecked( ( ushort )( value.Length ) )' cancellationToken ).ConfigureAwait( false ); " is 144.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackBinaryAsyncCore,The length of the statement  "			await this.WriteBytesAsync( ( byte )MessagePackCode.Bin32' unchecked( ( uint )value.Length )' cancellationToken ).ConfigureAwait( false ); " is 138.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueAsyncCore,The length of the statement  "							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false ); " is 123.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueAsyncCore,The length of the statement  "							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false ); " is 126.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueAsyncCore,The length of the statement  "							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false ); " is 124.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteStringHeaderAsync,The length of the statement  "				await this.WriteByteAsync( ( byte )( bytesLength | MessagePackCode.MinimumFixedRaw )' cancellationToken ).ConfigureAwait( false ); " is 130.
Long Statement,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteStringHeaderAsync,The length of the statement  "			await this.WriteBytesAsync( MessagePackCode.Str32' unchecked(( uint )bytesLength)' cancellationToken ).ConfigureAwait( false ); " is 127.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryCoreAsync,The length of the statement  "				var readLength = await this._source.ReadAsync( result' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadByteAsync,The length of the statement  "				var slowAsyncResult = await this.ReadByteSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 120.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadByteSlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableByteAsync,The length of the statement  "				var slowAsyncResult = await this.ReadNullableByteSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 128.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableByteSlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadByteSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 120.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSByteAsync,The length of the statement  "				var slowAsyncResult = await this.ReadSByteSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 121.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSByteSlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableSByteAsync,The length of the statement  "				var slowAsyncResult = await this.ReadNullableSByteSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 129.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableSByteSlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadSByteSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 121.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt16Async,The length of the statement  "				var slowAsyncResult = await this.ReadInt16SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 121.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt16SlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableInt16Async,The length of the statement  "				var slowAsyncResult = await this.ReadNullableInt16SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 129.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableInt16SlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadInt16SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 121.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt16Async,The length of the statement  "				var slowAsyncResult = await this.ReadUInt16SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt16SlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableUInt16Async,The length of the statement  "				var slowAsyncResult = await this.ReadNullableUInt16SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 130.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableUInt16SlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadUInt16SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt32Async,The length of the statement  "				var slowAsyncResult = await this.ReadInt32SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 121.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt32SlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableInt32Async,The length of the statement  "				var slowAsyncResult = await this.ReadNullableInt32SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 129.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableInt32SlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadInt32SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 121.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt32Async,The length of the statement  "				var slowAsyncResult = await this.ReadUInt32SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt32SlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableUInt32Async,The length of the statement  "				var slowAsyncResult = await this.ReadNullableUInt32SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 130.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableUInt32SlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadUInt32SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt64Async,The length of the statement  "				var slowAsyncResult = await this.ReadInt64SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 121.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt64SlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableInt64Async,The length of the statement  "				var slowAsyncResult = await this.ReadNullableInt64SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 129.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableInt64SlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadInt64SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 121.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt64Async,The length of the statement  "				var slowAsyncResult = await this.ReadUInt64SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt64SlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableUInt64Async,The length of the statement  "				var slowAsyncResult = await this.ReadNullableUInt64SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 130.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableUInt64SlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadUInt64SlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSingleAsync,The length of the statement  "				var slowAsyncResult = await this.ReadSingleSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSingleSlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableSingleAsync,The length of the statement  "				var slowAsyncResult = await this.ReadNullableSingleSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 130.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableSingleSlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadSingleSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadDoubleAsync,The length of the statement  "				var slowAsyncResult = await this.ReadDoubleSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadDoubleSlowAsync,The length of the statement  "					var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableDoubleAsync,The length of the statement  "				var slowAsyncResult = await this.ReadNullableDoubleSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 130.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableDoubleSlowAsync,The length of the statement  "			var asyncReadResult = await this.ReadDoubleSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The length of the statement  "			var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); " is 134.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The length of the statement  "			var asyncReadResult = await this.ReadStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); " is 134.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectCore,The length of the statement  "				if ( ( header & ReadValueResult.RawTypeMask ) == ReadValueResult.RawTypeMask && ( header & ReadValueResult.LengthOfLengthMask ) == 0 ) " is 134.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectAsync,The length of the statement  "			var asyncReadResult = await this.ReadObjectCoreAsync( isDeep' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectCoreAsync,The length of the statement  "				if ( ( header & ReadValueResult.RawTypeMask ) == ReadValueResult.RawTypeMask && ( header & ReadValueResult.LengthOfLengthMask ) == 0 ) " is 134.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectCoreAsync,The length of the statement  "					var asyncReadReasult = await this.ReadObjectSlowAsync( header' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 123.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectCoreAsync,The length of the statement  "				var asyncReadReasult = await this.ReadItemsAsync( result.AsInt32()' collectionType == CollectionType.Map' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 166.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); " is 137.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); " is 137.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); " is 137.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); " is 134.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); " is 134.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false ); " is 134.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 165.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 165.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 165.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 165.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadItemsAsync,The length of the statement  "					var itemAsyncReadResult = await this.ReadObjectCoreAsync( true' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 124.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadItemsAsync,The length of the statement  "					var keyAsyncReadResult = await this.ReadObjectCoreAsync( true' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 123.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadItemsAsync,The length of the statement  "					var valueAsyncReadResult = await this.ReadObjectCoreAsync( true' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 125.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLengthAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLengthAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLengthAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLengthAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The length of the statement  "			var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 165.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The length of the statement  "							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The length of the statement  "			var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false ); " is 165.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large array (0x{0:X} elements) which has more than Int32.MaxValue elements' at position {1:#'0}" " is 133.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large array (0x{0:X} elements) which has more than Int32.MaxValue elements' at offset {1:#'0}"; " is 132.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large map (0x{0:X} entries) which has more than Int32.MaxValue entries' at position {1:#'0}" " is 129.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large map (0x{0:X} entries) which has more than Int32.MaxValue entries' at offset {1:#'0}"; " is 128.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large ext type (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at position {1:#'0}" " is 130.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large ext type (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at offset {1:#'0}"; " is 129.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					? "MessagePack for CLI cannot handle large binary or string (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at position {1:#'0}" " is 138.
Long Statement,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ThrowTooLongLengthException,The length of the statement  "					: "MessagePack for CLI cannot handle large binary or string (0x{0:X} bytes) which has more than Int32.MaxValue bytes' at offset {1:#'0}"; " is 137.
Long Statement,MsgPack,MessagePackString,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,GetString,The length of the statement  "				throw new InvalidOperationException( "This bytes is not UTF-8 string."' this._decodingError == IsBinary ? default( Exception ) : this._decodingError ); " is 151.
Long Statement,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackAsyncCore,The length of the statement  "			await this.WriteByteAsync( value ? ( byte )MessagePackCode.TrueValue : ( byte )MessagePackCode.FalseValue' cancellationToken ).ConfigureAwait( false ); " is 151.
Long Statement,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,ThrowCannotBeNegativeException,The length of the statement  "			throw new ArgumentOutOfRangeException( parameterName' String.Format( CultureInfo.CurrentCulture' "'{0}' is negative."' parameterName ) ); " is 137.
Long Statement,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,Create,The length of the statement  "			return new MessagePackStreamPacker( stream' ownsStream ? PackerUnpackerStreamOptions.SingletonOwnsStream : PackerUnpackerStreamOptions.None' compatibilityOptions ); " is 164.
Long Statement,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,Create,The length of the statement  "			return new MessagePackByteArrayPacker( buffer' 0' allowsBufferExpansion ? SingleArrayBufferAllocator.Default : FixedArrayBufferAllocator.Instance' compatibilityOptions ); " is 170.
Long Statement,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,Create,The length of the statement  "			return new MessagePackByteArrayPacker( buffer' startOffset' allowsBufferExpansion ? SingleArrayBufferAllocator.Default : FixedArrayBufferAllocator.Instance' compatibilityOptions ); " is 180.
Long Statement,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,Create,The length of the statement  "			return new MessagePackByteArrayPacker( buffer' startOffset' new SingleArrayBufferAllocator( allocator )' compatibilityOptions ); " is 128.
Long Statement,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The length of the statement  "			// Float32Bits usage is effectively pointer dereference operation rather than shifting operators' so we must consider endianness here. " is 134.
Long Statement,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackAsyncCore,The length of the statement  "			// Float32Bits usage is effectively pointer dereference operation rather than shifting operators' so we must consider endianness here. " is 134.
Long Statement,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | count ) )' cancellationToken ).ConfigureAwait( false ); " is 139.
Long Statement,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackMapHeaderAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | count ) )' cancellationToken ).ConfigureAwait( false ); " is 137.
Long Statement,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackStringHeaderAsyncCore,The length of the statement  "				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedRaw | length ) )' cancellationToken ).ConfigureAwait( false ); " is 138.
Long Statement,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PrivatePackRawBodyAsyncCore,The length of the statement  "				return await this.PrivatePackRawBodyAsyncCore( asCollection' asCollection.IsReadOnly' cancellationToken ).ConfigureAwait( false ); " is 130.
Long Statement,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderAsync,The length of the statement  "			return array == null ? this.PackNullAsync( cancellationToken ) : this.PackArrayHeaderAsync( array.Count' cancellationToken ); " is 125.
Long Statement,MsgPack,PackerUnpackerExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\PackerUnpackerExtensions.cs,PackAsyncCore,The length of the statement  "				await Task.Run( () => asPackable.PackToMessage( source' new PackingOptions() )' cancellationToken ).ConfigureAwait( false ); " is 124.
Long Statement,MsgPack,PackerUnpackerExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\PackerUnpackerExtensions.cs,PackCollectionAsyncCore,The length of the statement  "				await Task.Run( () => asPackable.PackToMessage( source' new PackingOptions() )' cancellationToken ).ConfigureAwait( false ); " is 124.
Long Statement,MsgPack,PackerUnpackerExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\PackerUnpackerExtensions.cs,PackDictionaryAsyncCore,The length of the statement  "			return PackDictionaryAsyncCore( source' dictionary' context.GetSerializer<TKey>()' context.GetSerializer<TValue>()' cancellationToken ); " is 136.
Long Statement,MsgPack,PackerUnpackerExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\PackerUnpackerExtensions.cs,PackDictionaryAsyncCore,The length of the statement  "				await Task.Run( () => asPackable.PackToMessage( source' new PackingOptions() )' cancellationToken ).ConfigureAwait( false ); " is 124.
Long Statement,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The length of the statement  "								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" ); " is 145.
Long Statement,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The length of the statement  "					Contract.Assert( ( source & ReadValueResult.TypeCodeMask ) == ReadValueResult.Real64Type' ( source & ReadValueResult.TypeCodeMask ) + " == ReadValueResult.Real64Type" ); " is 169.
Long Statement,MsgPack,ReflectionAbstractions,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReflectionAbstractions.cs,GetRuntimeConstructor,The length of the statement  "			return source.GetTypeInfo().DeclaredConstructors.SingleOrDefault( c => c.GetParameters().Select( p => p.ParameterType ).SequenceEqual( parameters ) ); " is 150.
Long Statement,MsgPack,ReflectionAbstractions,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReflectionAbstractions.cs,GetRuntimeConstructor,The length of the statement  "			return source.GetConstructor( BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance' null' parameters' null ); " is 125.
Long Statement,MsgPack,ReflectionAbstractions,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReflectionAbstractions.cs,GetConstructor,The length of the statement  "			return source.DeclaredConstructors.SingleOrDefault( c => !c.IsStatic && c.GetParameters().Select( p => p.ParameterType ).SequenceEqual( parameteres ) ); " is 152.
Long Statement,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadAsyncCore,The length of the statement  "			if ( this._itemsCount.Count == 0 || !( await this._root.ReadInternalAsync( cancellationToken ).ConfigureAwait( false ) ) ) " is 122.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ToTicks,The length of the statement  "				throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "This value is too small for '{0}'."' destination ) ); " is 134.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ToTicks,The length of the statement  "				throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "This value is too large for '{0}'."' destination ) ); " is 134.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,FromDateTime,The length of the statement  "			FromDateTimeTicks( ( value.Kind == DateTimeKind.Local ? value.ToUniversalTime() : value ).Ticks' out unixEpocSeconds' out nanoSeconds ); " is 136.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Decode,The length of the statement  "					return new Timestamp( BigEndianBinary.ToInt64( value.Body' sizeof( int ) )' unchecked( ( int )BigEndianBinary.ToUInt32( value.Body' 0 ) ) ); " is 140.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,FromComponents,The length of the statement  "				var days = YearsToDaysOfNewYear( value.Year ) + ToDaysOffsetFromNewYear( value.Month' value.Day' isLeapYear ) - Timestamp.UnixEpochInSeconds / Timestamp.SecondsPerDay; " is 167.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ParseExact,The length of the statement  "			HandleParseResult( TryParseExactCore( input' format' formatProvider' styles' out result )' "Cannot parse specified input with specified format." ); " is 147.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ParseExact,The length of the statement  "			HandleParseResult( TryParseExactCore( input' formats' formatProvider' styles' out result )' "Cannot parse specified input with any specified formats." ); " is 153.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,HandleParseResult,The length of the statement  "					Contract.Assert( kind == TimestampParseResult.KindNoMatchedFormats' kind + " == TimestampParseResult.KindNoMatchedFormats" ); " is 125.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The length of the statement  "			Contract.Assert( this.unixEpochSeconds >= -UnixEpochInSeconds' this.unixEpochSeconds + " > " + ( -UnixEpochInSeconds ) ); " is 121.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The length of the statement  "			// https://github.com/dotnet/coreclr/blob/0825741447c14a6a70c60b7c429e16f95214e74e/src/mscorlib/shared/System/DateTime.cs#L863 " is 126.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The length of the statement  "			year = unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year + 1 ) ); " is 121.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The length of the statement  "			Contract.Assert( this.unixEpochSeconds < -UnixEpochInSeconds' this.unixEpochSeconds + " > " + ( -UnixEpochInSeconds ) ); " is 120.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The length of the statement  "			// https://github.com/dotnet/coreclr/blob/0825741447c14a6a70c60b7c429e16f95214e74e/src/mscorlib/shared/System/DateTime.cs#L863 " is 126.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,TryParseExactCore,The length of the statement  "				if ( TimestampStringConverter.TryParseExact( input' format' formatProvider' styles' out result ) == TimestampParseResult.Success ) " is 130.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ValidateParseStyles,The length of the statement  "			if ( styles != DateTimeStyles.None && ( styles & ~( DateTimeStyles.AllowLeadingWhite | DateTimeStyles.AllowTrailingWhite ) ) != 0 ) " is 131.
Long Statement,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ValidateParseStyles,The length of the statement  "				throw new ArgumentException( "Timestamp currently only support DateTimeStyles.None' DateTimeStyles.AllowLeadingWhite' and DateTimeStyles.AllowTrailingWhite."' "styles" ); " is 170.
Long Statement,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The length of the statement  "			if ( !ParseWhitespace( input' ref position' ( styles & DateTimeStyles.AllowLeadingWhite ) != 0' /* isTrailing */false ) ) " is 121.
Long Statement,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The length of the statement  "			if ( !ParseWhitespace( input' ref position' ( styles & DateTimeStyles.AllowTrailingWhite ) != 0' /* isTrailing */true ) ) " is 121.
Long Statement,MsgPack,Unpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacker.cs,ThrowInvalidModeException,The length of the statement  "			throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "Reader is in '{0}' mode."' this._mode ) ); " is 123.
Long Statement,MsgPack,Unpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacker.cs,ReadNullableMessagePackExtendedTypeObject,The length of the statement  "			result = this.LastReadData.IsNil ? default( MessagePackExtendedTypeObject? ) : this.LastReadData.AsMessagePackExtendedTypeObject(); " is 131.
Long Statement,MsgPack,Unpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The length of the statement  "			return AsyncReadResult.Success( this.LastReadData.IsNil ? default( MessagePackExtendedTypeObject? ) : this.LastReadData.AsMessagePackExtendedTypeObject() ); " is 156.
Long Statement,MsgPack,Unpacking,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.cs,NewTypeMismatchException,The length of the statement  "			return new MessageTypeException( String.Format( CultureInfo.CurrentCulture' "Message type is not compatible to {0}."' requestedType )' innerException ); " is 152.
Long Statement,MsgPack,Unpacking,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.cs,NewInvalidEncodingException,The length of the statement  "			return new MessageTypeException( String.Format( CultureInfo.CurrentCulture' "The stream cannot be decoded as {0} string."' encoding.WebName )' innerException ); " is 160.
Long Statement,System.IO,BufferedStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\BufferedStream.cs,Flush,The length of the statement  "				// However' if we do not forward the Flush to the underlying stream' we may have problems when chaining several streams. " is 120.
Long Statement,System.IO,BufferedStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\BufferedStream.cs,FlushAsyncInternal,The length of the statement  "			// We bring instance fields down as local parameters to this async method becasue BufferedStream is derived from MarshalByRefObject. " is 132.
Long Statement,System.IO,BufferedStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\BufferedStream.cs,FlushAsyncInternal,The length of the statement  "			// Field access would be from the async state machine i.e.' not via the this pointer and would require runtime checking to see " is 126.
Long Statement,System.IO,BufferedStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\BufferedStream.cs,FlushAsyncInternal,The length of the statement  "					// However' if we do not forward the Flush to the underlying stream' we may have problems when chaining several streams. " is 120.
Long Statement,System.IO,BufferedStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\BufferedStream.cs,FlushWrite,The length of the statement  "							"BufferedStream: Write buffer must be allocated and write position must be in the bounds of the buffer in FlushWrite!" ); " is 121.
Long Statement,System.IO,BufferedStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\BufferedStream.cs,FlushWriteAsync,The length of the statement  "							"BufferedStream: Write buffer must be allocated and write position must be in the bounds of the buffer in FlushWrite!" ); " is 121.
Long Statement,System.IO,BufferedStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\BufferedStream.cs,ReadAsync,The length of the statement  "					if ( completeSynchronously )  // if this is FALSE' we will be entering ReadFromUnderlyingStreamAsync and releasing there. " is 121.
Long Statement,System.IO,BufferedStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\BufferedStream.cs,ReadFromUnderlyingStreamAsync,The length of the statement  "					return bytesAlreadySatisfied + await _stream.ReadAsync( array' offset' count' cancellationToken ).ConfigureAwait( false ); " is 122.
Long Statement,System.IO,BufferedStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\BufferedStream.cs,WriteAsync,The length of the statement  "					if ( completeSynchronously )  // if this is FALSE' we will be entering WriteToUnderlyingStreamAsync and releasing there. " is 120.
Long Statement,System.IO,BufferedStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\BufferedStream.cs,WriteByte,The length of the statement  "			// We should not be flushing here' but only writing to the underlying stream' but previous version flushed' so we keep this. " is 124.
Long Statement,System.IO,BufferedStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\BufferedStream.cs,Seek,The length of the statement  "			// If the seek destination is still within the data currently in the buffer' we want to keep the buffer data and continue using it. " is 131.
Long Statement,MsgPack.Serialization,DefaultConcreteTypeRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultConcreteTypeRepository.cs,GetConcreteType,The length of the statement  "			if ( typeOrDefinition == null || !typeOrDefinition.GetIsGenericTypeDefinition() || !abstractCollectionType.GetIsGenericType() ) " is 127.
Long Statement,MsgPack.Serialization,DefaultConcreteTypeRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultConcreteTypeRepository.cs,Register,The length of the statement  "					String.Format( CultureInfo.CurrentCulture' "The defaultCollectionType cannot be abstract class nor interface. The type '{0}' is abstract type."' defaultCollectionType )' " is 169.
Long Statement,MsgPack.Serialization,DefaultConcreteTypeRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultConcreteTypeRepository.cs,Register,The length of the statement  "			this._defaultCollectionTypes.Register( abstractCollectionType' defaultCollectionType' null' null' SerializerRegistrationOptions.AllowOverride ); " is 144.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,Create,The length of the statement  "			// Old Create behavior was effectively Get() because the Builder internally register genreated serializer and returned existent one if it had been already registered.  " is 166.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateInternal,The length of the statement  "				typeof( T ).GetCollectionTraits( CollectionTraitOptions.None' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes ); " is 127.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateInternal,The length of the statement  "				typeof( T ).GetCollectionTraits( CollectionTraitOptions.Full' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes ); " is 127.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateInternal,The length of the statement  "						GenericSerializer.TryCreateAbstractCollectionSerializer( context' typeof( T )' concreteType' schema ) as MessagePackSerializer<T> " is 129.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateInternal,The length of the statement  "			return ( MessagePackSerializer<T> ) builder.BuildSerializerInstance( context' concreteType' schema == null ? null : schema.FilterSelf() ); " is 138.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateInternal,The length of the statement  "				( CreateInternal_2.MakeGenericMethod( targetType ).CreateDelegate( typeof( Func<SerializationContext' PolymorphismSchema' object> ) )  " is 133.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateReflectionInternal,The length of the statement  "				typeof( T ).GetCollectionTraits( CollectionTraitOptions.WithAddMethod' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes ); " is 136.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateReflectionInternal,The length of the statement  "				typeof( T ).GetCollectionTraits( CollectionTraitOptions.WithAddMethod | CollectionTraitOptions.WithCountPropertyGetter' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes ); " is 185.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateReflectionInternal,The length of the statement  "						ReflectionSerializerHelper.CreateCollectionSerializer<T>( context' concreteType' traits' ( schema ?? PolymorphismSchema.Default ) ); " is 132.
Long Statement,MsgPack.Serialization,MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer.cs,CreateReflectionInternal,The length of the statement  "							ReflectionSerializerHelper.CreateCollectionSerializer<T>( context' concreteType' traits' ( schema ?? PolymorphismSchema.Default ) ) " is 131.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InferCapatibity,The length of the statement  "			var traits = typeof( T ).GetCollectionTraits( CollectionTraitOptions.WithAddMethod' allowNonCollectionEnumerableTypes: false ); " is 127.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,PackSingleObjectAsBytes,The length of the statement  "			var packer = Packer.Create( BufferManager.NewByteBuffer( BufferSize )' /* allowExpansion */true' this.PackerCompatibilityOptions ); " is 131.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,PackSingleObjectAsBytesAsync,The length of the statement  "			var packer = Packer.Create( BufferManager.NewByteBuffer( BufferSize )'  /* allowExpansion */true' this.PackerCompatibilityOptions ); " is 132.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalPackTo,The length of the statement  "					ThrowArgumentException( String.Format( CultureInfo.CurrentCulture' "'{0}' is not compatible for '{1}'."' objectTree.GetType()' typeof( T ) )' "objectTree" ); " is 157.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalUnpackTo,The length of the statement  "				ThrowArgumentException( String.Format( CultureInfo.CurrentCulture' "'{0}' is not compatible for '{1}'."' collection.GetType()' typeof( T ) )' "collection" ); " is 157.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalPackSingleObject,The length of the statement  "				ThrowArgumentException( String.Format( CultureInfo.CurrentCulture' "'{0}' is not compatible for '{1}'."' objectTree == null ? "(null)" : objectTree.GetType().FullName' typeof( T ) )' "objectTree" ); " is 198.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalPackToAsync,The length of the statement  "					ThrowArgumentException( String.Format( CultureInfo.CurrentCulture' "'{0}' is not compatible for '{1}'."' objectTree.GetType()' typeof( T ) )' "objectTree" ); " is 157.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalUnpackToAsync,The length of the statement  "				ThrowArgumentException( String.Format( CultureInfo.CurrentCulture' "'{0}' is not compatible for '{1}'."' collection.GetType()' typeof( T ) )' "collection" ); " is 157.
Long Statement,MsgPack.Serialization,MessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalPackSingleObjectAsync,The length of the statement  "				ThrowArgumentException( String.Format( CultureInfo.CurrentCulture' "'{0}' is not compatible for '{1}'."' objectTree == null ? "(null)" : objectTree.GetType().FullName' typeof( T ) )' "objectTree" ); " is 198.
Long Statement,MsgPack.Serialization,PackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PackHelpers.cs,PackToMap,The length of the statement  "				&& parameter.SerializationContext != null && parameter.SerializationContext.DictionarySerlaizationOptions.OmitNullEntry ) " is 121.
Long Statement,MsgPack.Serialization,PackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PackHelpers.cs,PackToMapAsync,The length of the statement  "			return PackToMapAsyncCore( parameter.SerializationContext' parameter.Packer' parameter.Target' parameter.Operations' parameter.NullCheckers' parameter.CancellationToken ); " is 171.
Long Statement,MsgPack.Serialization,PolymorphicTypeVerificationContext,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphicTypeVerificationContext.cs,Equals,The length of the statement  "			return this._loadingTypeFullName == other._loadingTypeFullName && this._loadingAssemblyFullName == other._loadingAssemblyFullName; " is 130.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,ForPolymorphicObject,The length of the statement  "			return new PolymorphismSchema( targetType' PolymorphismType.RuntimeType' DefaultTypeVerfiier' PolymorphismSchemaChildrenType.None ); " is 132.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,ForPolymorphicObject,The length of the statement  "			return new PolymorphismSchema( targetType' PolymorphismType.RuntimeType' typeVerifier' PolymorphismSchemaChildrenType.None ); " is 125.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,VerifyArity,The length of the statement  "				throw new ArgumentException( "An arity of itemSchemaList does not match for an arity of the tuple."' "itemSchemaList" ); " is 120.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,FilterSelf,The length of the statement  "			return new PolymorphismSchema( this.TargetType' PolymorphismType.None' this._codeTypeMapping' this.TypeVerifier' this.ChildrenType' this._children ); " is 149.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,CreateCore,The length of the statement  "			var traits = member.GetMemberValueType().GetCollectionTraits( CollectionTraitOptions.None' allowNonCollectionEnumerableTypes: false ); " is 134.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,CreateCore,The length of the statement  "						SerializerDebugging.TracePolimorphicSchemaEvent( "Returns default because '{0}' does not have own nor items schema: {1}"' member' defaultSchema ); " is 146.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,CreateCore,The length of the statement  "						SerializerDebugging.TracePolimorphicSchemaEvent( "Returns default because '{0}' does not have own' keys' nor items schema: {1}"' member' defaultSchema ); " is 153.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,CreateCore,The length of the statement  "							SerializerDebugging.TracePolimorphicSchemaEvent( "Returns default because '{0}' does not have any tuple items schema: {1}"' member' defaultSchema ); " is 148.
Long Statement,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,CreateCore,The length of the statement  "							SerializerDebugging.TracePolimorphicSchemaEvent( "Returns default because '{0}' does not have own schema: {1}"' member' defaultSchema ); " is 136.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,Interpret,The length of the statement  "					Contract.Assert( attribute.Target == PolymorphismTarget.TupleItem' attribute.Target + " == PolymorphismTarget.TupleItem" ); " is 123.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,Interpret,The length of the statement  "				this.SetRuntimeType( attribute.Target' memberName' tupleItemNumber' GetVerifier( attribute as IPolymorphicRuntimeTypeAttribute ) ); " is 131.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,GetVerifier,The length of the statement  "				var method = attribute.VerifierType.GetRuntimeMethods().SingleOrDefault( m => IsVerificationMethod( m' attribute.VerifierMethodName ) ); " is 136.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,GetVerifier,The length of the statement  "					throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "A public static or instance method named '{0}' with single parameter typed PolymorphicTypeVerificationContext in type '{1}'."' attribute.VerifierMethodName' attribute.VerifierMethodName ) ); " is 268.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,GetVerifier,The length of the statement  "					return method.CreateDelegate( typeof( Func<PolymorphicTypeVerificationContext' bool> ) ) as Func<PolymorphicTypeVerificationContext' bool>; " is 139.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,GetVerifier,The length of the statement  "					return method.CreateDelegate( typeof( Func<PolymorphicTypeVerificationContext' bool> )' Activator.CreateInstance( attribute.VerifierType ) ) as Func<PolymorphicTypeVerificationContext' bool>; " is 191.
Long Statement,MsgPack.Serialization,TypeTableEntry,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,IsVerificationMethod,The length of the statement  "				return parameters.Length == 1 && parameters[ 0 ].ParameterType.IsAssignableFrom( typeof( PolymorphicTypeVerificationContext ) ); " is 128.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The length of the statement  "			 * If the object has single public method TEnumerator GetEnumerator() ( where TEnumerator implements IEnumerator<TItem>)' " is 120.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The length of the statement  "			 * Else' if the object has single public method IEnumerator GetEnumerator()' then the object is considered as the collection of Object. " is 134.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The length of the statement  "			 * First' if the object implements IDictionary<MessagePackObject'MessagePackObject>' then it is considered as MPO dictionary. " is 124.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The length of the statement  "			 * Third' if the object implement SINGLE IDictionary<TKey'TValue> and multiple IEnumerable<T>' then it is considered as dictionary of TKey and TValue. " is 149.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetCollectionTraits,The length of the statement  "			 * Fourth' the object is considered as UNSERIALIZABLE member. This behavior similer to DataContract serialization behavor " is 120.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,TryCreateGenericCollectionTraits,The length of the statement  "						( source == typeof( IDictionary<MessagePackObject' MessagePackObject> ) || source.Implements( typeof( IDictionary<MessagePackObject' MessagePackObject> ) ) ) " is 157.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,TryCreateGenericCollectionTraits,The length of the statement  "						GetGetEnumeratorMethodFromEnumerableType( source' typeof( IEnumerable<KeyValuePair<MessagePackObject' MessagePackObject>> )' options )' " is 135.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,TryCreateGenericCollectionTraits,The length of the statement  "									: ( source == typeof( IReadOnlyList<MessagePackObject> ) || source.Implements( typeof( IReadOnlyList<MessagePackObject> ) ) ) " is 125.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,TryCreateGenericCollectionTraits,The length of the statement  "												: ( source == typeof( IReadOnlyCollection<MessagePackObject> ) || source.Implements( typeof( IReadOnlyCollection<MessagePackObject> ) ) ) " is 137.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetGetEnumeratorMethodFromElementType,The length of the statement  "			return FindInterfaceMethod( targetType' typeof( IEnumerable<> ).MakeGenericType( elementType )' "GetEnumerator"' ReflectionAbstractions.EmptyTypes ); " is 149.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FindInterfaceMethod,The length of the statement  "				return targetType.FindInterfaces( ( type' _ ) => type == interfaceType' null ).Single().GetMethod( name' parameterTypes ); " is 122.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FindInterfaceMethod,The length of the statement  "			int index = Array.FindIndex( map.InterfaceMethods' method => method.Name == name && method.GetParameters().Select( p => p.ParameterType ).SequenceEqual( parameterTypes ) ); " is 172.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FindInterfaceMethod,The length of the statement  "			int index = map.InterfaceMethods.FindIndex( method => method.Name == name && method.GetParameters().Select( p => p.ParameterType ).SequenceEqual( parameterTypes ) ); " is 165.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FindInterfaceMethod,The length of the statement  "				Contract.Assert( false' interfaceType + "::" + name + "(" + String.Join<Type>( "' "' parameterTypes ) + ") is not found in " + targetType ); " is 140.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FindInterfaceMethod,The length of the statement  "				Contract.Assert( false' interfaceType + "::" + name + "(" + String.Join( "' "' parameterTypes.Select( t => t.ToString() ).ToArray() ) + ") is not found in " + targetType ); " is 172.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FilterCollectionType,The length of the statement  "			return type.GetAssembly().Equals( typeof( Array ).GetAssembly() ) && ( type.Namespace == "System.Collections" || type.Namespace == "System.Collections.Generic" ); " is 162.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,FilterCollectionType,The length of the statement  "			return typeInfo.Assembly.Equals( typeof( Array ).GetTypeInfo().Assembly ) && ( type.Namespace == "System.Collections" || type.Namespace == "System.Collections.Generic" ); " is 170.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetMemberValueType,The length of the statement  "			Contract.Assert( typeof( MemberInfo ).IsAssignableFrom( typeof( Type ) )' "Type is assginable to MemberInfo on this platform' so should not step in this line." ); " is 162.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetMemberValueType,The length of the statement  "			Contract.Assert( typeof( Type ).IsAssignableFrom( typeof( TypeInfo ) )' "TypeInfo is assginable to Type on this platform' so should not step in this line." ); " is 158.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,GetMemberValueType,The length of the statement  "				throw new InvalidOperationException( String.Format( CultureInfo.CurrentCulture' "'{0}'({1}) is not field nor property."' source' source.GetType() ) ); " is 150.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,HoistUpInnerException,The length of the statement  "			var ctor = targetInvocationException.InnerException.GetType().GetConstructor( ExceptionConstructorWithInnerParameterTypes ); " is 124.
Long Statement,MsgPack.Serialization,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionExtensions.CollectionTraits.cs,HoistUpInnerException,The length of the statement  "				return ctor.Invoke( new object[] { targetInvocationException.InnerException.Message' targetInvocationException } ) as Exception; " is 128.
Long Statement,MsgPack.Serialization,ReflectionHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionHelpers.cs,GetMethod,The length of the statement  "						.Where( m => !m.IsGenericMethod && !m.IsStatic && m.GetParameters().Select( p => p.ParameterType ).SequenceEqual( parameterTypes ) ) " is 132.
Long Statement,MsgPack.Serialization,SerializationContext,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationContext.cs,GetSerializer,The length of the statement  "						Contract.Assert( typeof( T ).GetIsEnum()' typeof( T ) + " is not enum but generated serializer is ICustomizableEnumSerializer" ); " is 129.
Long Statement,MsgPack.Serialization,SerializationContext,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationContext.cs,GetSerializer,The length of the statement  "						Contract.Assert( !typeof( T ).GetIsEnum()' typeof( T ) + " is enum but generated serializer is not ICustomizableEnumSerializer : " + ( serializer == null ? "null" : serializer.GetType().FullName ) ); " is 199.
Long Statement,MsgPack.Serialization,SerializationContext,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationContext.cs,GetSerializer,The length of the statement  "					// If T is null and schema is not provided or default schema is provided' then exception will be thrown here from the new provider. " is 131.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewValueTypeCannotBeNull,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Member '{0}' of type '{1}' cannot be null because it is value type('{2}')."' name' declaringType' memberType ) ); " is 192.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewValueTypeCannotBeNull,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot be null '{0}' type value."' type ) ); " is 123.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewTypeCannotDeserialize,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot deserialize '{0}' type."' type ) ); " is 121.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewTypeCannotDeserialize,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot deserialize member '{1}' of type '{0}'."' type' memberName )' inner ); " is 156.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewMissingItem,The length of the statement  "			return new InvalidMessagePackStreamException( String.Format( CultureInfo.CurrentCulture' "Items at index '{0}' is missing."' index ) ); " is 135.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewTargetDoesNotHavePublicDefaultConstructor,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Type '{0}' does not have default (parameterless) public constructor."' type ) ); " is 159.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewTargetDoesNotHavePublicDefaultConstructorNorInitialCapacity,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Type '{0}' does not have both of default (parameterless) public constructor and  public constructor with an Int32 parameter."' type ) ); " is 215.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewMissingAddMethod,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Type '{0}' does not have appropriate Add method."' type ) ); " is 139.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewNotSupportedBecauseCannotInstanciateAbstractType,The length of the statement  "			return new NotSupportedException( String.Format( CultureInfo.CurrentCulture' "This operation is not supported because '{0}' cannot be instanciated."' type ) ); " is 159.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewTupleCardinarityIsNotMatch,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "The length of array ({0}) does not match to tuple cardinality ({1})."' actualArrayLength' expectedTupleCardinality ) ); " is 198.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewNullIsProhibited,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "The member '{0}' cannot be nil."' memberName ) ); " is 128.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewReadOnlyMemberItemsMustNotBeNull,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "The member '{0}' cannot be nil because it is read only member."' memberName ) ); " is 159.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewStreamDoesNotContainCollectionForMember,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot deserialize member '{0}' because the underlying stream does not contain collection."' memberName ) ); " is 187.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewUnexpectedArrayLength,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "The MessagePack stream is invalid. Expected array length is {0}' but actual is {1}."' expectedLength' actualLength ) ); " is 198.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewFailedToDeserializeMember,The length of the statement  "			return new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot deserialize member '{0}' of type '{1}'."' memberName' targetType )' inner ); " is 162.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewUnpackFromIsNotSupported,The length of the statement  "			return new NotSupportedException( String.Format( CultureInfo.CurrentCulture' "This operation is not supported for '{0}' because the serializer does not support UnpackFrom method."' targetType ) ); " is 196.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewCreateInstanceIsNotSupported,The length of the statement  "			return new NotSupportedException( String.Format( CultureInfo.CurrentCulture' "This operation is not supported for '{0}' because the serializer does not support CreateInstance method."' targetType ) ); " is 200.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewUnpackToIsNotSupported,The length of the statement  "			return new NotSupportedException( String.Format( CultureInfo.CurrentCulture' "This operation is not supported for '{0}' because it does not have accesible Add(T) method."' type )' inner ); " is 188.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewUnknownTypeEmbedding,The length of the statement  "			return new SerializationException( "Cannot deserialize with type-embedding based serializer. Root object must be 3 element array." ); " is 133.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,NewIncompatibleCollectionSerializer,The length of the statement  "						"Cannot serialize type '{0}' because registered or generated serializer '{1}' does not implement '{2}'' which is implemented by '{3}'' for example."' " is 149.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,ThrowArgumentNullException,The length of the statement  "			throw new ArgumentNullException( parameterName' String.Format( CultureInfo.CurrentCulture' "Field '{0}' of parameter '{1}' cannot be null."' fieldName' parameterName ) ); " is 170.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,ThrowArgumentCannotBeNegativeException,The length of the statement  "			throw new ArgumentOutOfRangeException( parameterName' String.Format( CultureInfo.CurrentCulture' "Field '{0}' of parameter '{1}' cannot be negative number."' fieldName' parameterName ) ); " is 187.
Long Statement,MsgPack.Serialization,SerializationExceptions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationExceptions.cs,ThrowInvalidArrayItemsCount,The length of the statement  "							"Cannot deserialize type '{0}' because stream is not {1} elements array. Current type is {2} and its element count is {3}."' " is 124.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,GetCapabilitiesForObject,The length of the statement  "			return this.CanDeserialize ? ( SerializerCapabilities.PackTo | SerializerCapabilities.UnpackFrom ) : SerializerCapabilities.PackTo; " is 131.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,VerifyCanSerializeTargetType,The length of the statement  "			if ( context.SerializerOptions.DisablePrivilegedAccess && !targetType.GetIsPublic() && !targetType.GetIsNestedPublic() && !ThisAssembly.Equals( targetType.GetAssembly() ) ) " is 172.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,VerifyCanSerializeTargetType,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot serialize type '{0}' because it is not public to the serializer."' targetType ) ); " is 167.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,Prepare,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "Cannot serialize type '{0}' because it does not have any serializable fields nor properties."' targetType ) ); " is 188.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,Prepare,The length of the statement  "						// For backward compatibility' no exceptions are thrown here even if mulitiple deserialization constructor attributes in the type " is 129.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,Prepare,The length of the statement  "						canDeserialize ?? DetermineCanDeserialize( constructorKind' context' targetType' correspondingMemberNames' allowDefault: true ) " is 127.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,DetermineCanDeserialize,The length of the statement  "					Trace( "SerializationTarget::DetermineCanDeserialize({0}' {1}) -> {2}: HasAnyCorrespondingMembers"' targetType' kind' result ); " is 127.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,DetermineCanDeserialize,The length of the statement  "					Contract.Assert( kind == ConstructorKind.None || kind == ConstructorKind.Ambiguous' "kind == ConstructorKind.None || kind == ConstructorKind.Ambiguous : " + kind ); " is 164.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,GetTargetMembers,The length of the statement  "			var filtered = members.Where( item => item.GetCustomAttributesData().Any( a => a.GetAttributeType().FullName == MessagePackMemberAttributeTypeName ) ).ToArray(); " is 161.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,GetAnnotatedMembersWithDuplicationDetection,The length of the statement  "					member => member.GetCustomAttributesData().Any( a => a.GetAttributeType().FullName == MessagePackIgnoreAttributeTypeName ) " is 122.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,GetSystemRuntimeSerializationCompatibleMembers,The length of the statement  "								// Shim for Silverlight returns -1 because GetNamedArguments() extension method cannot recognize whether the argument was actually specified or not. " is 148.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,FindDeserializationConstructor,The length of the statement  "			Trace( "SerializationTarget::FindDeserializationConstructor.MostRich({0}) -> {1}"' targetType' String.Join( ";"' mostRichConstructors.Select( x => x.ToString() ).ToArray() ) ); " is 176.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,FindDeserializationConstructor,The length of the statement  "								"Cannot serialize type '{0}' because it does not have any serializable fields nor properties' and serializer generator failed to determine constructor to deserialize among({1})."' " is 179.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,FindExplicitDeserializationConstructors,The length of the statement  "			return construtors.Where( ctor => ctor.GetCustomAttributesData().Any( a => a.GetAttributeType().FullName == MessagePackDeserializationConstructorAttributeTypeName ) ).ToArray(); " is 177.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,NewTypeCannotBeSerializedException,The length of the statement  "						"Cannot serialize type '{0}' because it does not have any serializable fields nor properties' and it does not have any public constructors with parameters."' " is 157.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,CheckTargetEligibility,The length of the statement  "			var traits = returnType.GetCollectionTraits( CollectionTraitOptions.WithAddMethod' allowNonCollectionEnumerableTypes: false ); " is 126.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,ComplementMembers,The length of the statement  "					"Cannot specify order value 0 on DataMemberAttribute when SerializationContext.CompatibilityOptions.OneBoundDataMemberOrder is set to true." " is 140.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,VerifyKeyUniqueness,The length of the statement  "						duplicated.Add( member.Contract.Name' new List<MemberInfo> { existents[ member.Contract.Name ].Member' member.Member } ); " is 121.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,VerifyKeyUniqueness,The length of the statement  "									String.Join( "'"' kv.Value.Select( m => String.Format( CultureInfo.InvariantCulture' "{0}.{1}({2})"' m.DeclaringType' m.Name' ( m is FieldInfo ) ? "Field" : "Property" ) ).ToArray() ) " is 183.
Long Statement,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,CreateForTuple,The length of the statement  "			return new SerializationTarget( itemTypes.Select( ( _' i ) => new SerializingMember( GetTupleItemNameFromIndex( i ) ) ).ToArray()' null' null' true ); " is 150.
Long Statement,MsgPack.Serialization,MemberConstructorParameterEqualityComparer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,GetHashCode,The length of the statement  "				return ( obj.Key == null ? 0 : StringComparer.OrdinalIgnoreCase.GetHashCode( obj.Key ) ) ^ ( obj.Value == null ? 0 : obj.Value.GetHashCode() ); " is 143.
Long Statement,MsgPack.Serialization,SerializerDebugging,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerDebugging.cs,TracePolimorphicSchemaEvent,The length of the statement  "			Tracer.Emit.TraceEvent( Tracer.EventType.PolimorphicSchema' Tracer.EventId.PolimorphicSchema' format' memberInfo' schema == null ? "(null)" : schema.DebugString ); " is 163.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,Register,The length of the statement  "				GetNullableCompanion( typeof( T )' serializer.OwnerContext' serializer' out nullableType' out nullableSerializerProvider ); " is 123.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,Register,The length of the statement  "			return this.Register( typeof( T )' new PolymorphicSerializerProvider<T>( serializer )' nullableType' nullableSerializerProvider' options ); " is 139.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,Register,The length of the statement  "			return this.Register( typeof( T )' new PolymorphicSerializerProvider<T>(  serializer.OwnerContext' serializer )' nullableType' nullableSerializerProvider' options ); " is 165.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( MessagePackObject ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.MsgPack_MessagePackObjectMessagePackSerializer( ownerContext ) ); " is 166.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( MessagePackObjectDictionary ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.MsgPack_MessagePackObjectDictionaryMessagePackSerializer( ownerContext ) ); " is 186.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( MessagePackExtendedTypeObject ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.MsgPack_MessagePackExtendedTypeObjectMessagePackSerializer( ownerContext ) ); " is 190.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( List<MessagePackObject> ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Collections_Generic_ListOfMessagePackObjectMessagePackSerializer( ownerContext ) ); " is 197.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( Object ).TypeHandle' new MsgPack.Serialization.Polymorphic.PolymorphicSerializerProvider<object>( new MsgPack.Serialization.DefaultSerializers.System_ObjectMessagePackSerializer( ownerContext ) ) ); " is 222.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( Object ).TypeHandle' new MsgPack.Serialization.Polymorphic.PolymorphicSerializerProvider<object>( ownerContext' new MsgPack.Serialization.DefaultSerializers.System_ObjectMessagePackSerializer( ownerContext ) ) ); " is 236.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( String ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_StringMessagePackSerializer( ownerContext ) ); " is 143.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( StringBuilder ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Text_StringBuilderMessagePackSerializer( ownerContext ) ); " is 162.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( Char[] ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_CharArrayMessagePackSerializer( ownerContext ) ); " is 146.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( Byte[] ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_ByteArrayMessagePackSerializer( ownerContext ) ); " is 146.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( DateTime ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.DateTimeMessagePackSerializerProvider( ownerContext' false ) ); " is 155.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( DateTimeOffset ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.DateTimeOffsetMessagePackSerializerProvider( ownerContext' false ) ); " is 167.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( Timestamp ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.TimestampMessagePackSerializerProvider( ownerContext' false ) ); " is 157.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Runtime.InteropServices.ComTypes.FILETIME ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.FileTimeMessagePackSerializerProvider( ownerContext' false ) ); " is 195.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( DateTime? ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.DateTimeMessagePackSerializerProvider( ownerContext' true ) ); " is 155.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( DateTimeOffset? ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.DateTimeOffsetMessagePackSerializerProvider( ownerContext' true ) ); " is 167.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( Timestamp? ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.TimestampMessagePackSerializerProvider( ownerContext' true ) ); " is 157.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Runtime.InteropServices.ComTypes.FILETIME? ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.FileTimeMessagePackSerializerProvider( ownerContext' true ) ); " is 195.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( DBNull ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_DBNullMessagePackSerializer( ownerContext ) ); " is 143.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Boolean ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_BooleanMessagePackSerializer( ownerContext ) ); " is 152.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Byte ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_ByteMessagePackSerializer( ownerContext ) ); " is 146.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Char ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_CharMessagePackSerializer( ownerContext ) ); " is 146.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Decimal ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_DecimalMessagePackSerializer( ownerContext ) ); " is 152.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Double ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_DoubleMessagePackSerializer( ownerContext ) ); " is 150.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Guid ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_GuidMessagePackSerializer( ownerContext ) ); " is 146.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Int16 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Int16MessagePackSerializer( ownerContext ) ); " is 148.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Int32 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Int32MessagePackSerializer( ownerContext ) ); " is 148.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Int64 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Int64MessagePackSerializer( ownerContext ) ); " is 148.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.SByte ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_SByteMessagePackSerializer( ownerContext ) ); " is 148.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Single ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_SingleMessagePackSerializer( ownerContext ) ); " is 150.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.TimeSpan ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_TimeSpanMessagePackSerializer( ownerContext ) ); " is 154.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.UInt16 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_UInt16MessagePackSerializer( ownerContext ) ); " is 150.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.UInt32 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_UInt32MessagePackSerializer( ownerContext ) ); " is 150.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.UInt64 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_UInt64MessagePackSerializer( ownerContext ) ); " is 150.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Security.Cryptography.HashAlgorithmName ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Security_Cryptography_HashAlgorithmNameMessagePackSerializer( ownerContext ) ); " is 216.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Specialized.BitVector32 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Collections_Specialized_BitVector32MessagePackSerializer( ownerContext ) ); " is 208.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.BigInteger ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_BigIntegerMessagePackSerializer( ownerContext ) ); " is 176.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Matrix3x2 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_Matrix3x2MessagePackSerializer( ownerContext ) ); " is 174.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Matrix4x4 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_Matrix4x4MessagePackSerializer( ownerContext ) ); " is 174.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Plane ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_PlaneMessagePackSerializer( ownerContext ) ); " is 166.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Quaternion ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_QuaternionMessagePackSerializer( ownerContext ) ); " is 176.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Vector2 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_Vector2MessagePackSerializer( ownerContext ) ); " is 170.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Vector3 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_Vector3MessagePackSerializer( ownerContext ) ); " is 170.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Vector4 ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_Vector4MessagePackSerializer( ownerContext ) ); " is 170.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Globalization.CultureInfo ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Globalization_CultureInfoMessagePackSerializer( ownerContext ) ); " is 188.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.DictionaryEntry ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Collections_DictionaryEntryMessagePackSerializer( ownerContext ) ); " is 192.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Stack ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Collections_StackMessagePackSerializer( ownerContext ) ); " is 172.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Queue ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Collections_QueueMessagePackSerializer( ownerContext ) ); " is 172.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Generic.KeyValuePair<'> ).TypeHandle' typeof( System_Collections_Generic_KeyValuePair_2MessagePackSerializer<' > ) ); " is 160.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Generic.Stack<> ).TypeHandle' typeof( System_Collections_Generic_Stack_1MessagePackSerializer<> ) ); " is 143.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Generic.Queue<> ).TypeHandle' typeof( System_Collections_Generic_Queue_1MessagePackSerializer<> ) ); " is 143.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Numerics.Complex ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Numerics_ComplexMessagePackSerializer( ownerContext ) ); " is 170.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Uri ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_UriMessagePackSerializer( ownerContext ) ); " is 144.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Version ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_VersionMessagePackSerializer( ownerContext ) ); " is 152.
Long Statement,MsgPack.Serialization,SerializerRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializerRepository.cs,InitializeDefaultTable,The length of the statement  "			dictionary.Add( typeof( System.Collections.Specialized.NameValueCollection ).TypeHandle' new MsgPack.Serialization.DefaultSerializers.System_Collections_Specialized_NameValueCollectionMessagePackSerializer( ownerContext ) ); " is 224.
Long Statement,MsgPack.Serialization,SerializingMember,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializingMember.cs,ToString,The length of the statement  "			return String.Format( CultureInfo.InvariantCulture' "{{\"Name\": \"{0}\"' \"Id\": {1}' \"Member\": \"{2}\"' \"NilImplication\": \"{3}\" }}"' this.MemberName' this.Contract.Id' this.MemberName' this.Contract.NilImplication ); " is 224.
Long Statement,MsgPack.Serialization,TypeKeyRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\TypeKeyRepository.cs,GetEntries,The length of the statement  "				return this._table.Select( kv => new KeyValuePair<Type' object>( Type.GetTypeFromHandle( kv.Key )' kv.Value ) ).ToArray(); " is 122.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The length of the statement  "						if ( currentScore < withCapacityAndComparer && parameters[ 0 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 1 ].ParameterType ) ) " is 151.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The length of the statement  "						else if ( currentScore < withComparerAndCapacity && parameters[ 1 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 0 ].ParameterType ) ) " is 156.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,GetEqualityComparer,The length of the statement  "			// AotHelper is internal because it should not be API -- it is subject to change when the Unity's Mono is updated or IL2CPP becomes stable. " is 139.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValue,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "directRead"' "directRead cannot be null if serializer argument is null." ); " is 124.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValue,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "parameter"' "DirectRead cannot be null if Serializer field is null." ); " is 120.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValueAsync,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "directRead"' "directRead cannot be null if serializer argument is null." ); " is 124.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackValueTypeValueAsync,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "parameter"' "DirectRead cannot be null if Serializer field is null." ); " is 120.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValue,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "directRead"' "directRead cannot be null if serializer argument is null." ); " is 124.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValue,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "parameter"' "DirectRead cannot be null if Serializer field is null." ); " is 120.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueAsync,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "directRead"' "directRead cannot be null if serializer argument is null." ); " is 124.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueAsync,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "parameter"' "DirectRead cannot be null if Serializer field is null." ); " is 120.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValue,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "directRead"' "directRead cannot be null if serializer argument is null." ); " is 124.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValue,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "parameter"' "DirectRead cannot be null if Serializer field is null." ); " is 120.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueAsync,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "directRead"' "directRead cannot be null if serializer argument is null." ); " is 124.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueAsync,The length of the statement  "				SerializationExceptions.ThrowArgumentException( "parameter"' "DirectRead cannot be null if Serializer field is null." ); " is 120.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackFromMapAsyncCore,The length of the statement  "				var key = await UnpackStringValueAsync( unpacker' typeof( TResult )' "MemberName"' cancellationToken ).ConfigureAwait( false ); " is 127.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionCore,The length of the statement  "					SerializationExceptions.ThrowArgumentException( "eachOperation"' "eachOperation cannot not be null when bulkOperation is null." ); " is 130.
Long Statement,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackCollectionAsyncCore,The length of the statement  "					SerializationExceptions.ThrowArgumentException( "eachOperation"' "eachOperation cannot not be null when bulkOperation is null." ); " is 130.
Long Statement,MsgPack.Serialization.DefaultSerializers,ArraySegmentMessageSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\ArraySegmentMessageSerializer.cs,PackCharArraySegmentTo,The length of the statement  "			packer.PackRawBody( MessagePackConvert.EncodeString( new string( objectTree.Array.Skip( objectTree.Offset ).Take( objectTree.Count ).ToArray() ) ) ); " is 149.
Long Statement,MsgPack.Serialization.DefaultSerializers,ArraySegmentMessageSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\ArraySegmentMessageSerializer.cs,PackByteArraySegmentToAsync,The length of the statement  "			await packer.PackRawBodyAsync( objectTree.Array.Skip( objectTree.Offset ).Take( objectTree.Count )' cancellationToken ).ConfigureAwait( false ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,ArraySegmentMessageSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\ArraySegmentMessageSerializer.cs,PackCharArraySegmentToAsync,The length of the statement  "			await packer.PackRawBodyAsync( MessagePackConvert.EncodeString( new string( objectTree.Array.Skip( objectTree.Offset ).Take( objectTree.Count ).ToArray() ) )' cancellationToken ).ConfigureAwait( false ); " is 203.
Long Statement,MsgPack.Serialization.DefaultSerializers,ArraySegmentMessageSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\ArraySegmentMessageSerializer.cs,PackGenericArraySegmentToAsync,The length of the statement  "				await itemSerializer.PackToAsyncCore( packer' objectTree.Array[ i + objectTree.Offset ]' cancellationToken ).ConfigureAwait( false ); " is 133.
Long Statement,MsgPack.Serialization.DefaultSerializers,ArraySerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\ArraySerializer.cs,Create,The length of the statement  "			// Check the T is SZArray -- Type.GetArrayRank() returns 1 for single dimension' non-zero based arrays' so use (SZArrayType).IsAssinableFrom() instead. " is 151.
Long Statement,MsgPack.Serialization.DefaultSerializers,DateTimeOffsetMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeOffsetMessagePackSerializer.cs,PackToAsyncCore,The length of the statement  "				await packer.PackAsync( Timestamp.FromDateTimeOffset( objectTree ).Encode()' cancellationToken ).ConfigureAwait( false ); " is 121.
Long Statement,MsgPack.Serialization.DefaultSerializers,DateTimeOffsetMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeOffsetMessagePackSerializer.cs,PackToAsyncCore,The length of the statement  "					await packer.PackAsync( ( short )( objectTree.Offset.Hours * 60 + objectTree.Offset.Minutes )' cancellationToken ).ConfigureAwait( false ); " is 139.
Long Statement,MsgPack.Serialization.DefaultSerializers,DateTimeOffsetMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeOffsetMessagePackSerializer.cs,PackToAsyncCore,The length of the statement  "				await packer.PackAsync( MessagePackConvert.FromDateTimeOffset( objectTree )' cancellationToken ).ConfigureAwait( false ); " is 121.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_BooleanMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Boolean )' ex.Message ) ); " is 163.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_ByteMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Byte )' ex.Message ) ); " is 160.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_CharMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_CharMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_DecimalMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_DecimalMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_DecimalMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,PackToAsyncCore,The length of the statement  "			await packer.PackStringAsync( value.ToString( "G"' CultureInfo.InvariantCulture )' cancellationToken ).ConfigureAwait( false ); " is 127.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_DoubleMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Double )' ex.Message ) ); " is 162.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_GuidMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_GuidMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Int16MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Int16 )' ex.Message ) ); " is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Int32MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Int32 )' ex.Message ) ); " is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Int64MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Int64 )' ex.Message ) ); " is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_SByteMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.SByte )' ex.Message ) ); " is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_SingleMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Single )' ex.Message ) ); " is 162.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_TimeSpanMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Int64 )' ex.Message ) ); " is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_UInt16MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.UInt16 )' ex.Message ) ); " is 162.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_UInt32MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.UInt32 )' ex.Message ) ); " is 162.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_UInt64MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.UInt64 )' ex.Message ) ); " is 162.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_Specialized_BitVector32MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not '{0}' type. {1}"' typeof( System.Int32 )' ex.Message ) ); " is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Numerics_BigIntegerMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Numerics_BigIntegerMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DefaultSerializers.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,FSharpMapSerializer<T;TKey;TValue>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\FSharpMapSerializer`3.cs,FindFactory,The length of the statement  "			return result.CreateDelegate( typeof( Func<IEnumerable<Tuple<TKey' TValue>>' T> ) ) as Func<IEnumerable<Tuple<TKey' TValue>>' T>; " is 129.
Long Statement,MsgPack.Serialization.DefaultSerializers,FSharpMapSerializer<T;TKey;TValue>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\FSharpMapSerializer`3.cs,FindFactory,The length of the statement  "			return Delegate.CreateDelegate( typeof( Func<IEnumerable<Tuple<TKey' TValue>>' T> )' result ) as Func<IEnumerable<Tuple<TKey' TValue>>' T>; " is 139.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,Create,The length of the statement  "					return CreateListSerializer( context' targetType' targetType.GetCollectionTraits( CollectionTraitOptions.WithAddMethod' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes )' schema ); " is 195.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,Create,The length of the statement  "					return CreateDictionarySerializer( context' targetType' targetType.GetCollectionTraits( CollectionTraitOptions.WithAddMethod' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes )' genericTypeArguments[ 0 ]' genericTypeArguments[ 1 ]' schema ); " is 255.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateImmutableCollectionSerializer,The length of the statement  "							typeof( ImmutableDictionarySerializerFactory<''> ).MakeGenericType( targetType' targetType.GetGenericArguments()[ 0 ]' targetType.GetGenericArguments()[ 1 ] ) " is 158.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateImmutableCollectionSerializer,The length of the statement  "							typeof( FSharpMapSerializerFactory<''> ).MakeGenericType( targetType' targetType.GetGenericArguments()[ 0 ]' targetType.GetGenericArguments()[ 1 ] ) " is 148.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateAbstractCollectionSerializer,The length of the statement  "					abstractType.GetCollectionTraits( CollectionTraitOptions.None' context.CompatibilityOptions.AllowNonCollectionEnumerableTypes ) " is 127.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateAbstractCollectionSerializer,The length of the statement  "					return new AbstractDictionaryMessagePackSerializer( context' abstractType' concreteType' genericArgumentOfKeyValuePair[ 0 ]' genericArgumentOfKeyValuePair[ 1 ]' traits' schema ); " is 178.
Long Statement,MsgPack.Serialization.DefaultSerializers,GenericSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,TryCreateAbstractCollectionSerializer,The length of the statement  "					return new AbstractDictionaryMessagePackSerializer( context' abstractType' concreteType' genericArgumentOfKeyValuePair[ 0 ]' genericArgumentOfKeyValuePair[ 1 ]' traits' schema ); " is 178.
Long Statement,MsgPack.Serialization.DefaultSerializers,DictionaryInstanceFactory<TKey;TValue>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\GenericSerializer.cs,Create,The length of the statement  "				return new System_Collections_Generic_Dictionary_2MessagePackSerializer<TKey' TValue>( context' itemSchema.KeySchema' itemSchema.ItemSchema ); " is 142.
Long Statement,MsgPack.Serialization.DefaultSerializers,ImmutableDictionarySerializer<T;TKey;TValue>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\ImmutableDictionarySerializer`3.cs,FindFactory,The length of the statement  "			return result.CreateDelegate( typeof( Func<KeyValuePair<TKey' TValue>[]' T> ) ) as Func<KeyValuePair<TKey' TValue>[]' T>; " is 121.
Long Statement,MsgPack.Serialization.DefaultSerializers,ImmutableDictionarySerializer<T;TKey;TValue>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\ImmutableDictionarySerializer`3.cs,FindFactory,The length of the statement  "			return Delegate.CreateDelegate( typeof( Func<KeyValuePair<TKey' TValue>[]' T> )' result ) as Func<KeyValuePair<TKey' TValue>[]' T>; " is 131.
Long Statement,MsgPack.Serialization.DefaultSerializers,InternalDateTimeExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\InternalDateTimeExtensions.cs,ToDateTime,The length of the statement  "			// DateTime.FromFileTimeUtc in Mono 2.10.x does not return Utc DateTime (Mono issue #2936)' so do convert manually to ensure returned DateTime is UTC. " is 150.
Long Statement,MsgPack.Serialization.DefaultSerializers,MessagePackObjectExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MessagePackObjectExtensions.cs,DeserializeAsInt64,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,MessagePackObjectExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MessagePackObjectExtensions.cs,DeserializeAsString,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,MessagePackObjectExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MessagePackObjectExtensions.cs,DeserializeAsMessagePackExtendedTypeObject,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,MsgPack_MessagePackExtendedTypeObjectMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MsgPack_MessagePackExtendedTypeObjectMessagePackSerializer.cs,UnpackFromCore,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "The unpacked value is not expected type. {0}"' ex.Message )' ex ); " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,PackArrayCore,The length of the statement  "				packer.PackExtendedTypeValue( this.OwnerContext.ExtTypeCodeMapping[ KnownExtTypeName.MultidimensionalArray ]' buffer.ToArray() ); " is 129.
Long Statement,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromCore,The length of the statement  "						SerializationExceptions.ThrowSerializationException( "Multidimensional metadata array must be encoded as 2 element array." ); " is 125.
Long Statement,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,PackArrayAsyncCore,The length of the statement  "				await packer.PackExtendedTypeValueAsync( this.OwnerContext.ExtTypeCodeMapping[ KnownExtTypeName.MultidimensionalArray ]' buffer.ToArray()' cancellationToken ).ConfigureAwait( false ); " is 183.
Long Statement,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,PackArrayAsyncCore,The length of the statement  "				async indices => await this._itemSerializer.PackToAsync( packer' ( TItem )array.GetValue( indices )' cancellationToken ).ConfigureAwait( false ) " is 144.
Long Statement,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromAsyncCore,The length of the statement  "						SerializationExceptions.ThrowSerializationException( "Multidimensional metadata array must be encoded as 2 element array." ); " is 125.
Long Statement,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromAsyncCore,The length of the statement  "					lengthsAndLowerBounds = await this.ReadArrayMetadataAsync( metadataUnpacker' cancellationToken ).ConfigureAwait( false ); " is 121.
Long Statement,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,ReadArrayMetadataAsync,The length of the statement  "				lengths = await this._int32ArraySerializer.UnpackFromAsync( lengthsUnpacker' cancellationToken ).ConfigureAwait( false ); " is 121.
Long Statement,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,ReadArrayMetadataAsync,The length of the statement  "				lowerBounds = await this._int32ArraySerializer.UnpackFromAsync( lowerBoundsUnpacker' cancellationToken ).ConfigureAwait( false ); " is 129.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The length of the statement  "			return new Matrix4x4( m11.Value' m12.Value' m13.Value' m14.Value' m21.Value' m22.Value' m23.Value' m24.Value' m31.Value' m32.Value' m33.Value' m34.Value' m41.Value' m42.Value' m43.Value' m44.Value ); " is 199.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_DictionaryEntryMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_DictionaryEntryMessagePackSerializer.cs,PackToAsyncCore,The length of the statement  "			await EnsureMessagePackObject( objectTree.Key ).PackToMessageAsync( packer' null' cancellationToken ).ConfigureAwait( false ); " is 126.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_DictionaryEntryMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_DictionaryEntryMessagePackSerializer.cs,PackToAsyncCore,The length of the statement  "			await EnsureMessagePackObject( objectTree.Value ).PackToMessageAsync( packer' null' cancellationToken ).ConfigureAwait( false ); " is 128.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_Dictionary_2MessagePackSerializer<TKey;TValue>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_Dictionary_2MessagePackSerializer`2.cs,PackToAsyncCore,The length of the statement  "			return PackerUnpackerExtensions.PackDictionaryAsyncCore( packer' objectTree' this._keySerializer' this._valueSerializer' cancellationToken ); " is 141.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_Dictionary_2MessagePackSerializer<TKey;TValue>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_Dictionary_2MessagePackSerializer`2.cs,UnpackToAsyncCore,The length of the statement  "						collection.Add( key' await this._valueSerializer.UnpackFromAsync( subTreeUnpacker' cancellationToken ).ConfigureAwait( false ) ); " is 129.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_Dictionary_2MessagePackSerializer<TKey;TValue>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_Dictionary_2MessagePackSerializer`2.cs,UnpackToAsyncCore,The length of the statement  "					collection.Add( key' await this._valueSerializer.UnpackFromAsync( unpacker' cancellationToken ).ConfigureAwait( false ) ); " is 122.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_KeyValuePair_2MessagePackSerializer<TKey;TValue>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_KeyValuePair_2MessagePackSerializer`2.cs,UnpackFromAsyncCore,The length of the statement  "			var key = unpacker.LastReadData.IsNil ? default( TKey ) : await this._keySerializer.UnpackFromAsync( unpacker' cancellationToken ).ConfigureAwait( false ); " is 155.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_KeyValuePair_2MessagePackSerializer<TKey;TValue>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_KeyValuePair_2MessagePackSerializer`2.cs,UnpackFromAsyncCore,The length of the statement  "			var value = unpacker.LastReadData.IsNil ? default( TValue ) : await this._valueSerializer.UnpackFromAsync( unpacker' cancellationToken ).ConfigureAwait( false ); " is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_List_1MessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_List_1MessagePackSerializer`1.cs,UnpackToAsyncCore,The length of the statement  "						collection.Add( await this._itemSerializer.UnpackFromAsync( subTreeUnpacker' cancellationToken ).ConfigureAwait( false ) ); " is 123.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_Stack_1MessagePackSerializer<TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_Stack_1MessagePackSerializer`1.cs,UnpackFromAsyncCore,The length of the statement  "			return new Stack<TItem>( await this.UnpackItemsInReverseOrderAsync( unpacker' UnpackHelpers.GetItemsCount( unpacker )' cancellationToken ).ConfigureAwait( false ) ); " is 165.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_Stack_1MessagePackSerializer<TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_Stack_1MessagePackSerializer`1.cs,UnpackToAsyncCore,The length of the statement  "			foreach ( var item in await this.UnpackItemsInReverseOrderAsync( unpacker' UnpackHelpers.GetItemsCount( unpacker )' cancellationToken ).ConfigureAwait( false ) ) " is 161.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_StackMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_StackMessagePackSerializer.cs,UnpackFromAsyncCore,The length of the statement  "			return new Stack( await UnpackItemsInReverseOrderAsync( unpacker' UnpackHelpers.GetItemsCount( unpacker )' cancellationToken ).ConfigureAwait( false ) ); " is 153.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_Collections_StackMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_StackMessagePackSerializer.cs,UnpackToAsyncCore,The length of the statement  "			foreach ( var item in await UnpackItemsInReverseOrderAsync( unpacker' UnpackHelpers.GetItemsCount( unpacker )' cancellationToken ).ConfigureAwait( false ) ) " is 156.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_ObjectMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_ObjectMessagePackSerializer.cs,PackToCore,The length of the statement  "				// Prevents stack overflow -- System.Object cannot be serialized anyway because it does not have any properties/fields to serialize. " is 132.
Long Statement,MsgPack.Serialization.DefaultSerializers,System_ObjectMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_ObjectMessagePackSerializer.cs,PackToAsyncCore,The length of the statement  "				// Prevents stack overflow -- System.Object cannot be serialized anyway because it does not have any properties/fields to serialize. " is 132.
Long Statement,MsgPack.Serialization.DefaultSerializers,TimestampFileTimeMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\TimestampFileTimeMessagePackSerializer.cs,UnpackFromCore,The length of the statement  "			return Timestamp.Decode( unpacker.LastReadData.DeserializeAsMessagePackExtendedTypeObject() ).ToDateTime().ToWin32FileTimeUtc(); " is 128.
Long Statement,MsgPack.Serialization.DefaultSerializers,TimestampMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\TimestampMessagePackSerializer.cs,PackToAsyncCore,The length of the statement  "				await packer.PackAsync( MessagePackConvert.FromDateTimeOffset( objectTree.ToDateTimeOffset() )' cancellationToken ).ConfigureAwait( false ); " is 140.
Long Statement,MsgPack.Serialization.Polymorphic,KnownTypePolymorphicMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\KnownTypePolymorphicMessagePackSerializer`1.cs,PackToAsyncCore,The length of the statement  "			await this.GetActualTypeSerializer( objectTree.GetType() ).PackToAsync( packer' objectTree' cancellationToken ).ConfigureAwait( false ); " is 136.
Long Statement,MsgPack.Serialization.Polymorphic,RuntimeTypeVerifier,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\RuntimeTypeVerifier.cs,Verify,The length of the statement  "				throw new SerializationException( String.Format( CultureInfo.CurrentCulture' "Type verifier rejects type '{0}'"' typeFullName + "' " + assemblyFullName ) ); " is 156.
Long Statement,MsgPack.Serialization.Polymorphic,TypeEmbedingPolymorphicMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeEmbedingPolymorphicMessagePackSerializer`1.cs,PackToAsyncCore,The length of the statement  "			await this.GetActualTypeSerializer( objectTree.GetType() ).PackToAsync( packer' objectTree' cancellationToken ).ConfigureAwait( false ); " is 136.
Long Statement,MsgPack.Serialization.Polymorphic,TypeEmbedingPolymorphicMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeEmbedingPolymorphicMessagePackSerializer`1.cs,UnpackFromAsyncCore,The length of the statement  "					( u' c ) => TypeInfoEncoder.DecodeRuntimeTypeInfoAsync( u' this._schema.TypeVerifier' c )' // Lamda capture is more efficient. " is 126.
Long Statement,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,ThrowUnknownEncodingType,The length of the statement  "			throw new SerializationException( String.Format( CultureInfo.InvariantCulture' "Unknown encoded type : {0}"' encodeType ) ); " is 124.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionEnumMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionEnumMessagePackSerializer`1.cs,PackUnderlyingValueTo,The length of the statement  "			packer.Pack( UInt64.Parse( ( ( IFormattable ) enumValue ).ToString( "D"' CultureInfo.InvariantCulture )' CultureInfo.InvariantCulture ) ); " is 138.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionEnumMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionEnumMessagePackSerializer`1.cs,PackUnderlyingValueToAsync,The length of the statement  "			return packer.PackAsync( UInt64.Parse( ( ( IFormattable )enumValue ).ToString( "D"' CultureInfo.InvariantCulture )' CultureInfo.InvariantCulture )' cancellationToken ); " is 168.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,PackToAsyncCore,The length of the statement  "						await packer.PackStringAsync( this.OwnerContext.DictionarySerlaizationOptions.SafeKeyTransformer( this._contracts[ i ].Name )' cancellationToken ).ConfigureAwait( false ); " is 171.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,PackToAsyncCore,The length of the statement  "						await packer.PackStringAsync( this.OwnerContext.DictionarySerlaizationOptions.SafeKeyTransformer( this._contracts[ i ].Name )' cancellationToken ).ConfigureAwait( false ); " is 171.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackMemberValue,The length of the statement  "					else if ( index < this._getters.Length && this._getters[ index ] != null ) // null getter supposes undeclared member (should be treated as nil) " is 143.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackAndAddCollectionItem,The length of the statement  "			var traits = destination.GetType().GetCollectionTraits( CollectionTraitOptions.WithAddMethod' this.OwnerContext.CompatibilityOptions.AllowNonCollectionEnumerableTypes ); " is 169.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackFromAsyncCore,The length of the statement  "					result = await this.UnpackMemberValueAsync( result' unpacker' itemsCount' unpacked' i' i' cancellationToken ).ConfigureAwait( false ); " is 134.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackFromAsyncCore,The length of the statement  "					result = await this.UnpackMemberValueAsync( result' unpacker' itemsCount' unpacked' index' i' cancellationToken ).ConfigureAwait( false ); " is 138.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackAndAddCollectionItemAsync,The length of the statement  "			var traits = destination.GetType().GetCollectionTraits( CollectionTraitOptions.WithAddMethod' this.OwnerContext.CompatibilityOptions.AllowNonCollectionEnumerableTypes ); " is 169.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackAndAddCollectionItemAsync,The length of the statement  "			var source = await this._serializers[ index ].UnpackFromAsync( unpacker' cancellationToken ).ConfigureAwait( false ) as IEnumerable; " is 132.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionSerializer,The length of the statement  "			var targetInfo = UnpackHelpers.DetermineCollectionSerializationStrategy( targetType' context.CompatibilityOptions.AllowAsymmetricSerializer ); " is 142.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionSerializer,The length of the statement  "						new ReflectionNonGenericCollectionMessagePackSerializer( context' typeof( T )' targetType' traits' schema' targetInfo ); " is 120.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionSerializer,The length of the statement  "						new ReflectionNonGenericEnumerableMessagePackSerializer( context' typeof( T )' targetType' traits' schema' targetInfo ); " is 120.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionSerializer,The length of the statement  "						new ReflectionNonGenericDictionaryMessagePackSerializer( context' typeof( T )' targetType' traits' schema' targetInfo ); " is 120.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,GetAddItem,The length of the statement  "						"Reflection based serializer only supports collection types which implement interface to add new item such as '{0}' and '{1}'"' " is 127.
Long Statement,MsgPack.Serialization.ReflectionSerializers,NonGenericEnumerableSerializerFactory<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The length of the statement  "				return new ReflectionNonGenericEnumerableMessagePackSerializer<T>( context' targetType' collectionTraits' schema' targetInfo ); " is 127.
Long Statement,MsgPack.Serialization.ReflectionSerializers,NonGenericCollectionSerializerFactory<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The length of the statement  "				return new ReflectionNonGenericCollectionMessagePackSerializer<T>( context' targetType' collectionTraits' schema' targetInfo ); " is 127.
Long Statement,MsgPack.Serialization.ReflectionSerializers,NonGenericListSerializerFactory<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The length of the statement  "				return new ReflectionNonGenericListMessagePackSerializer<T>( context' targetType' collectionTraits' schema' targetInfo ); " is 121.
Long Statement,MsgPack.Serialization.ReflectionSerializers,NonGenericDictionarySerializerFactory<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The length of the statement  "				return new ReflectionNonGenericDictionaryMessagePackSerializer<T>( context' targetType' collectionTraits' schema' targetInfo ); " is 127.
Long Statement,MsgPack.Serialization.ReflectionSerializers,EnumerableSerializerFactory<TCollection;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The length of the statement  "				return new ReflectionEnumerableMessagePackSerializer<TCollection' TItem>( context' targetType' collectionTraits' itemSchema' targetInfo ); " is 138.
Long Statement,MsgPack.Serialization.ReflectionSerializers,CollectionSerializerFactory<TCollection;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The length of the statement  "				return new ReflectionCollectionMessagePackSerializer<TCollection' TItem>( context' targetType' collectionTraits' itemSchema' targetInfo ); " is 138.
Long Statement,MsgPack.Serialization.ReflectionSerializers,DictionarySerializerFactory<TDictionary;TKey;TValue>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,Create,The length of the statement  "				return new ReflectionDictionaryMessagePackSerializer<TDictionary' TKey' TValue>( context' targetType' collectionTraits' schema' targetInfo ); " is 141.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionTupleMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionTupleMessagePackSerializer`1.cs,PackToAsyncCore,The length of the statement  "				await this._itemSerializers[ i ].PackToAsync( packer' this._getters[ i ]( objectTree )' cancellationToken ).ConfigureAwait( false ); " is 132.
Long Statement,MsgPack.Serialization.ReflectionSerializers,ReflectionTupleMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionTupleMessagePackSerializer`1.cs,UnpackFromAsyncCore,The length of the statement  "				unpackedItems.Add( await this._itemSerializers[ i ].UnpackFromAsync( unpacker' cancellationToken ).ConfigureAwait( false ) ); " is 125.
Complex Conditional,MsgPack,MessagePackStringDebuggerProxy,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,MustBeString,The conditional expression  "c < 0x20 && ( c != 0x9 && c != 0xA && c != 0xD )"  is complex.
Complex Conditional,MsgPack.Serialization,DefaultConcreteTypeRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultConcreteTypeRepository.cs,Register,The conditional expression  "!abstractCollectionType.IsAssignableFrom( defaultCollectionType )  				 && abstractCollectionType.GetIsGenericTypeDefinition()  				 && !defaultCollectionType  						 .GetInterfaces()  						 .Select( t => ( t.GetIsGenericType() && !t.GetIsGenericTypeDefinition() ) ? t.GetGenericTypeDefinition() : t )  						 .Contains( abstractCollectionType )  				 && !IsAnscestorType( abstractCollectionType' defaultCollectionType )"  is complex.
Complex Conditional,MsgPack.Serialization,MessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalPackSingleObject,The conditional expression  "( typeof( T ).GetIsValueType() && !isT )  				|| ( ( objectTree != null && !isT ) )"  is complex.
Complex Conditional,MsgPack.Serialization,MessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\MessagePackSerializer`1.cs,InternalPackSingleObjectAsync,The conditional expression  "( typeof( T ).GetIsValueType() && !isT )  				|| ( ( objectTree != null && !isT ) )"  is complex.
Complex Conditional,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,VerifyCanSerializeTargetType,The conditional expression  "context.SerializerOptions.DisablePrivilegedAccess && !targetType.GetIsPublic() && !targetType.GetIsNestedPublic() && !ThisAssembly.Equals( targetType.GetAssembly() )"  is complex.
Complex Conditional,MsgPack.Serialization,SerializationTarget,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\SerializationTarget.cs,Prepare,The conditional expression  "getters.Length == 0  				&& !typeof( IPackable ).IsAssignableFrom( targetType )  				&& !typeof( IUnpackable ).IsAssignableFrom( targetType )  #if FEATURE_TAP  				&& ( context.SerializerOptions.WithAsync  					&& ( !typeof( IAsyncPackable ).IsAssignableFrom( targetType )  						&& !typeof( IAsyncUnpackable ).IsAssignableFrom( targetType )  					)  				)"  is complex.
Empty Catch Block,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,GetAddItem,The method has an empty catch block.
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt16,The following statement contains a magic number: unchecked  			{  				return ( short )( buffer[ offset ] << 8 | buffer[ 1 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt32,The following statement contains a magic number: unchecked  			{  				return buffer[ offset ] << 24 | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt32,The following statement contains a magic number: unchecked  			{  				return buffer[ offset ] << 24 | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt32,The following statement contains a magic number: unchecked  			{  				return buffer[ offset ] << 24 | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt32,The following statement contains a magic number: unchecked  			{  				return buffer[ offset ] << 24 | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt32,The following statement contains a magic number: unchecked  			{  				return buffer[ offset ] << 24 | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToInt64,The following statement contains a magic number: unchecked  			{  				return  					( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ];  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt16,The following statement contains a magic number: unchecked  			{  				return ( ushort )( ( buffer[ offset ] << 8 ) | buffer[ 1 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt32,The following statement contains a magic number: unchecked  			{  				return ( uint )( ( buffer[ offset ] << 24 ) | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt32,The following statement contains a magic number: unchecked  			{  				return ( uint )( ( buffer[ offset ] << 24 ) | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt32,The following statement contains a magic number: unchecked  			{  				return ( uint )( ( buffer[ offset ] << 24 ) | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt32,The following statement contains a magic number: unchecked  			{  				return ( uint )( ( buffer[ offset ] << 24 ) | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt32,The following statement contains a magic number: unchecked  			{  				return ( uint )( ( buffer[ offset ] << 24 ) | buffer[ 1 + offset ] << 16 | buffer[ 2 + offset ] << 8 | buffer[ 3 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,BigEndianBinary,C:\repos\msgpack_msgpack-cli\src\MsgPack\BigEndianBinary.cs,ToUInt64,The following statement contains a magic number: unchecked  			{  				return  					( ulong )( ( long )buffer[ offset ] << 56 | ( long )buffer[ 1 + offset ] << 48 | ( long )buffer[ 2 + offset ] << 40 | ( long )buffer[ 3 + offset ] << 32  					| ( long )buffer[ 4 + offset ] << 24 | ( long )buffer[ 5 + offset ] << 16 | ( long )buffer[ 6 + offset ] << 8 | buffer[ 7 + offset ] );  			}
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToHexString,The following statement contains a magic number: var buffer = new StringBuilder( blob.Length * 2 + (withPrefix ? 2 : 0 ) );
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToHexString,The following statement contains a magic number: var buffer = new StringBuilder( blob.Length * 2 + (withPrefix ? 2 : 0 ) );
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToHexStringCore,The following statement contains a magic number: foreach ( var b in blob )  			{  				buffer.Append( ToHexChar( b >> 4 ) );  				buffer.Append( ToHexChar( b & 0xF ) );  			}
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToHexChar,The following statement contains a magic number: if ( b < 10 )  			{  				return unchecked( ( char )( '0' + b ) );  			}  			else  			{  				return unchecked( ( char )( 'A' + ( b - 10 ) ) );  			}
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToHexChar,The following statement contains a magic number: if ( b < 10 )  			{  				return unchecked( ( char )( '0' + b ) );  			}  			else  			{  				return unchecked( ( char )( 'A' + ( b - 10 ) ) );  			}
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToBits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				result = bits.Byte3 << 24;  				result |= bits.Byte2 << 16;  				result |= bits.Byte1 << 8;  				result |= bits.Byte0;  			}  			else  			{  				result = bits.Byte0 << 24;  				result |= bits.Byte1 << 16;  				result |= bits.Byte2 << 8;  				result |= bits.Byte3;  			}
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToBits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				result = bits.Byte3 << 24;  				result |= bits.Byte2 << 16;  				result |= bits.Byte1 << 8;  				result |= bits.Byte0;  			}  			else  			{  				result = bits.Byte0 << 24;  				result |= bits.Byte1 << 16;  				result |= bits.Byte2 << 8;  				result |= bits.Byte3;  			}
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToBits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				result = bits.Byte3 << 24;  				result |= bits.Byte2 << 16;  				result |= bits.Byte1 << 8;  				result |= bits.Byte0;  			}  			else  			{  				result = bits.Byte0 << 24;  				result |= bits.Byte1 << 16;  				result |= bits.Byte2 << 8;  				result |= bits.Byte3;  			}
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToBits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				result = bits.Byte3 << 24;  				result |= bits.Byte2 << 16;  				result |= bits.Byte1 << 8;  				result |= bits.Byte0;  			}  			else  			{  				result = bits.Byte0 << 24;  				result |= bits.Byte1 << 16;  				result |= bits.Byte2 << 8;  				result |= bits.Byte3;  			}
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToBits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				result = bits.Byte3 << 24;  				result |= bits.Byte2 << 16;  				result |= bits.Byte1 << 8;  				result |= bits.Byte0;  			}  			else  			{  				result = bits.Byte0 << 24;  				result |= bits.Byte1 << 16;  				result |= bits.Byte2 << 8;  				result |= bits.Byte3;  			}
Magic Number,MsgPack,Binary,C:\repos\msgpack_msgpack-cli\src\MsgPack\Binary.cs,ToBits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				result = bits.Byte3 << 24;  				result |= bits.Byte2 << 16;  				result |= bits.Byte1 << 8;  				result |= bits.Byte0;  			}  			else  			{  				result = bits.Byte0 << 24;  				result |= bits.Byte1 << 16;  				result |= bits.Byte2 << 8;  				result |= bits.Byte3;  			}
Magic Number,MsgPack,Float32Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float32Bits.cs,Float32Bits,The following statement contains a magic number: Contract.Assert( bigEndianBytes.Length - offset >= 4' bigEndianBytes.Length + "-" + offset + ">= 4" );
Magic Number,MsgPack,Float32Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float32Bits.cs,Float32Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 3 ];  				this.Byte1 = bigEndianBytes[ offset + 2 ];  				this.Byte2 = bigEndianBytes[ offset + 1 ];  				this.Byte3 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  			}
Magic Number,MsgPack,Float32Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float32Bits.cs,Float32Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 3 ];  				this.Byte1 = bigEndianBytes[ offset + 2 ];  				this.Byte2 = bigEndianBytes[ offset + 1 ];  				this.Byte3 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  			}
Magic Number,MsgPack,Float32Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float32Bits.cs,Float32Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 3 ];  				this.Byte1 = bigEndianBytes[ offset + 2 ];  				this.Byte2 = bigEndianBytes[ offset + 1 ];  				this.Byte3 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  			}
Magic Number,MsgPack,Float32Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float32Bits.cs,Float32Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 3 ];  				this.Byte1 = bigEndianBytes[ offset + 2 ];  				this.Byte2 = bigEndianBytes[ offset + 1 ];  				this.Byte3 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: Contract.Assert( bigEndianBytes.Length - offset >= 8' bigEndianBytes.Length + "-" + offset + ">= 4" );
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,Float64Bits,C:\repos\msgpack_msgpack-cli\src\MsgPack\Float64Bits.cs,Float64Bits,The following statement contains a magic number: if ( BitConverter.IsLittleEndian )  			{  				this.Byte0 = bigEndianBytes[ offset + 7 ];  				this.Byte1 = bigEndianBytes[ offset + 6 ];  				this.Byte2 = bigEndianBytes[ offset + 5 ];  				this.Byte3 = bigEndianBytes[ offset + 4 ];  				this.Byte4 = bigEndianBytes[ offset + 3 ];  				this.Byte5 = bigEndianBytes[ offset + 2 ];  				this.Byte6 = bigEndianBytes[ offset + 1 ];  				this.Byte7 = bigEndianBytes[ offset ];  			}  			else  			{  				this.Byte0 = bigEndianBytes[ offset ];  				this.Byte1 = bigEndianBytes[ offset + 1 ];  				this.Byte2 = bigEndianBytes[ offset + 2 ];  				this.Byte3 = bigEndianBytes[ offset + 3 ];  				this.Byte4 = bigEndianBytes[ offset + 4 ];  				this.Byte5 = bigEndianBytes[ offset + 5 ];  				this.Byte6 = bigEndianBytes[ offset + 6 ];  				this.Byte7 = bigEndianBytes[ offset + 7 ];  			}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt1 );  						break;  					}  					case 2:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt2 );  						break;  					}  					case 4:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt4 );  						break;  					}  					case 8:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt8 );  						break;  					}  					case 16:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt16 );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length );  						}  						else  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt1 );  						break;  					}  					case 2:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt2 );  						break;  					}  					case 4:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt4 );  						break;  					}  					case 8:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt8 );  						break;  					}  					case 16:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt16 );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length );  						}  						else  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt1 );  						break;  					}  					case 2:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt2 );  						break;  					}  					case 4:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt4 );  						break;  					}  					case 8:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt8 );  						break;  					}  					case 16:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt16 );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length );  						}  						else  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt1 );  						break;  					}  					case 2:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt2 );  						break;  					}  					case 4:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt4 );  						break;  					}  					case 8:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt8 );  						break;  					}  					case 16:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt16 );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length );  						}  						else  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 2:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 4:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 8:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 16:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false );  						}  						else if ( body.Length < 0x10000 )  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false );  						}  						else  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 2:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 4:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 8:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 16:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false );  						}  						else if ( body.Length < 0x10000 )  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false );  						}  						else  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 2:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 4:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 8:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 16:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false );  						}  						else if ( body.Length < 0x10000 )  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false );  						}  						else  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 2:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 4:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 8:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 16:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false );  						}  						else if ( body.Length < 0x10000 )  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false );  						}  						else  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset ] = unchecked( ( byte )( value >> ( ( sizeof( byte ) - 1 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset ] = unchecked( ( byte )( value >> ( ( sizeof( ushort ) - 1 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( value >> ( ( sizeof( ushort ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( value >> ( ( sizeof( ushort ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 1 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( value >> ( ( sizeof( uint ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 1 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 4 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 5 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 4 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 5 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 4 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 5 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 5 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 6 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 5 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 6 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 5 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 6 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 6 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 7 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 6 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 7 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 6 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 7 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 7 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 8 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 7 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 8 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 7 ] = unchecked( ( byte )( value >> ( ( sizeof( ulong ) - 8 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 1 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( bits >> ( ( sizeof( float ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 1 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 1 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 2 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 2 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 3 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 3 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 4 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 4 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 5 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 4 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 5 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 4 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 5 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 5 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 6 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 5 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 6 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 5 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 6 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 6 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 7 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 6 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 7 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 6 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 7 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 7 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 8 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 7 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 8 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayPacker.cs,WriteBytes,The following statement contains a magic number: buffer[ offset + 7 ] = unchecked( ( byte )( bits >> ( ( sizeof( double ) - 8 ) * 8 ) & 0xFF ) );
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadByteSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadSByteSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadInt16Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadUInt16Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadInt32Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadUInt32Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadInt64Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadUInt64Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadSingleSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadDoubleSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBinary,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Raw16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Raw16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Raw16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Raw16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadString,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Raw16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Raw16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Raw16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Raw16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = source[ offset ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt16( source' offset );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = BigEndianBinary.ToUInt32( source' offset );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = source[ offset ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' source' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )source[ offset ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = source[ offset ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt16( source' offset );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt32( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToUInt64( source' offset );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToSingle( source' offset );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					if ( source.Length - offset < 8 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = BigEndianBinary.ToDouble( source' offset );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadArrayLength,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Array16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Array16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Array16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Array16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMapLength,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Map16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Map16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Map16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Map16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Ext16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Ext16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Ext16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Ext16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Ext16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Ext16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Ext16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackByteArrayUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackByteArrayUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( source.Length - offset < 1 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToByte( source' offset );    					break;  				}  				case 2: // Ext16  				{  					if ( source.Length - offset < 2 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToUInt16( source' offset );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					if ( source.Length - offset < 4 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToUInt32( source' offset );    					break;  				}  			}
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,ToString,The following statement contains a magic number: var buffer = new StringBuilder( 7 + this._body.Length * 2 );
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,ToString,The following statement contains a magic number: var buffer = new StringBuilder( 7 + this._body.Length * 2 );
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int hashCode = this._typeCode << 24;  				hashCode ^= this._body.Length;  				int hashCodeTargetLength = Math.Min( this._body.Length / 4' 8 );  				for ( int i = 0; i < hashCodeTargetLength; i++ )  				{  					uint temp = this._body[ i ];  					temp |= ( uint )( this._body[ i + 1 ] << 8 );  					temp |= ( uint )( this._body[ i + 2 ] << 16 );  					temp |= ( uint )( this._body[ i + 3 ] << 24 );    					hashCode ^= ( int )temp;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int hashCode = this._typeCode << 24;  				hashCode ^= this._body.Length;  				int hashCodeTargetLength = Math.Min( this._body.Length / 4' 8 );  				for ( int i = 0; i < hashCodeTargetLength; i++ )  				{  					uint temp = this._body[ i ];  					temp |= ( uint )( this._body[ i + 1 ] << 8 );  					temp |= ( uint )( this._body[ i + 2 ] << 16 );  					temp |= ( uint )( this._body[ i + 3 ] << 24 );    					hashCode ^= ( int )temp;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int hashCode = this._typeCode << 24;  				hashCode ^= this._body.Length;  				int hashCodeTargetLength = Math.Min( this._body.Length / 4' 8 );  				for ( int i = 0; i < hashCodeTargetLength; i++ )  				{  					uint temp = this._body[ i ];  					temp |= ( uint )( this._body[ i + 1 ] << 8 );  					temp |= ( uint )( this._body[ i + 2 ] << 16 );  					temp |= ( uint )( this._body[ i + 3 ] << 24 );    					hashCode ^= ( int )temp;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int hashCode = this._typeCode << 24;  				hashCode ^= this._body.Length;  				int hashCodeTargetLength = Math.Min( this._body.Length / 4' 8 );  				for ( int i = 0; i < hashCodeTargetLength; i++ )  				{  					uint temp = this._body[ i ];  					temp |= ( uint )( this._body[ i + 1 ] << 8 );  					temp |= ( uint )( this._body[ i + 2 ] << 16 );  					temp |= ( uint )( this._body[ i + 3 ] << 24 );    					hashCode ^= ( int )temp;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int hashCode = this._typeCode << 24;  				hashCode ^= this._body.Length;  				int hashCodeTargetLength = Math.Min( this._body.Length / 4' 8 );  				for ( int i = 0; i < hashCodeTargetLength; i++ )  				{  					uint temp = this._body[ i ];  					temp |= ( uint )( this._body[ i + 1 ] << 8 );  					temp |= ( uint )( this._body[ i + 2 ] << 16 );  					temp |= ( uint )( this._body[ i + 3 ] << 24 );    					hashCode ^= ( int )temp;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int hashCode = this._typeCode << 24;  				hashCode ^= this._body.Length;  				int hashCodeTargetLength = Math.Min( this._body.Length / 4' 8 );  				for ( int i = 0; i < hashCodeTargetLength; i++ )  				{  					uint temp = this._body[ i ];  					temp |= ( uint )( this._body[ i + 1 ] << 8 );  					temp |= ( uint )( this._body[ i + 2 ] << 16 );  					temp |= ( uint )( this._body[ i + 3 ] << 24 );    					hashCode ^= ( int )temp;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int hashCode = this._typeCode << 24;  				hashCode ^= this._body.Length;  				int hashCodeTargetLength = Math.Min( this._body.Length / 4' 8 );  				for ( int i = 0; i < hashCodeTargetLength; i++ )  				{  					uint temp = this._body[ i ];  					temp |= ( uint )( this._body[ i + 1 ] << 8 );  					temp |= ( uint )( this._body[ i + 2 ] << 16 );  					temp |= ( uint )( this._body[ i + 3 ] << 24 );    					hashCode ^= ( int )temp;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackExtendedTypeObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackExtendedTypeObject.cs,GetHashCode,The following statement contains a magic number: unchecked  			{  				int hashCode = this._typeCode << 24;  				hashCode ^= this._body.Length;  				int hashCodeTargetLength = Math.Min( this._body.Length / 4' 8 );  				for ( int i = 0; i < hashCodeTargetLength; i++ )  				{  					uint temp = this._body[ i ];  					temp |= ( uint )( this._body[ i + 1 ] << 8 );  					temp |= ( uint )( this._body[ i + 2 ] << 16 );  					temp |= ( uint )( this._body[ i + 3 ] << 24 );    					hashCode ^= ( int )temp;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,MessagePackObject,The following statement contains a magic number: unchecked  			{  #pragma warning disable 0675  				if( BitConverter.IsLittleEndian )  				{  					this._value |=  ( ulong )( bytes[ 3 ] << 24 );  					this._value |=  ( ulong )( bytes[ 2 ] << 16 );  					this._value |=  ( ulong )( bytes[ 1 ] << 8 );  					this._value |=  bytes[ 0 ];  				}  				else  				{  					this._value |=  ( ulong )( bytes[ 0 ] << 24 );  					this._value |=  ( ulong )( bytes[ 1 ] << 16 );  					this._value |=  ( ulong )( bytes[ 2 ] << 8 );  					this._value |=  bytes[ 3 ];  				}  #pragma warning restore 0675  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsStringUtf16,The following statement contains a magic number: try  			{  				MessagePackString asMessagePackString = this._handleOrTypeCode as MessagePackString;  #if DEBUG  				Contract.Assert( asMessagePackString != null' "asMessagePackString != null" );  #endif // DEBUG    				if ( asMessagePackString.UnsafeGetString() != null )  				{  					return asMessagePackString.UnsafeGetString();  				}    				byte[] asBytes = asMessagePackString.UnsafeGetBuffer();    				if ( asBytes.Length == 0 )  				{  					return String.Empty;  				}    				if ( asBytes.Length % 2 != 0 )  				{  					throw new InvalidOperationException( "Not UTF-16 string." );  				}    				if ( asBytes[ 0 ] == 0xff && asBytes[ 1 ] == 0xfe )  				{  					return Encoding.Unicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else if ( asBytes[ 0 ] == 0xfe && asBytes[ 1 ] == 0xff )  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 0' asBytes.Length );  				}  			}  			catch ( ArgumentException ex )  			{  				throw new InvalidOperationException( "Not UTF-16 string."' ex );  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsStringUtf16,The following statement contains a magic number: try  			{  				MessagePackString asMessagePackString = this._handleOrTypeCode as MessagePackString;  #if DEBUG  				Contract.Assert( asMessagePackString != null' "asMessagePackString != null" );  #endif // DEBUG    				if ( asMessagePackString.UnsafeGetString() != null )  				{  					return asMessagePackString.UnsafeGetString();  				}    				byte[] asBytes = asMessagePackString.UnsafeGetBuffer();    				if ( asBytes.Length == 0 )  				{  					return String.Empty;  				}    				if ( asBytes.Length % 2 != 0 )  				{  					throw new InvalidOperationException( "Not UTF-16 string." );  				}    				if ( asBytes[ 0 ] == 0xff && asBytes[ 1 ] == 0xfe )  				{  					return Encoding.Unicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else if ( asBytes[ 0 ] == 0xfe && asBytes[ 1 ] == 0xff )  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 0' asBytes.Length );  				}  			}  			catch ( ArgumentException ex )  			{  				throw new InvalidOperationException( "Not UTF-16 string."' ex );  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsStringUtf16,The following statement contains a magic number: try  			{  				MessagePackString asMessagePackString = this._handleOrTypeCode as MessagePackString;  #if DEBUG  				Contract.Assert( asMessagePackString != null' "asMessagePackString != null" );  #endif // DEBUG    				if ( asMessagePackString.UnsafeGetString() != null )  				{  					return asMessagePackString.UnsafeGetString();  				}    				byte[] asBytes = asMessagePackString.UnsafeGetBuffer();    				if ( asBytes.Length == 0 )  				{  					return String.Empty;  				}    				if ( asBytes.Length % 2 != 0 )  				{  					throw new InvalidOperationException( "Not UTF-16 string." );  				}    				if ( asBytes[ 0 ] == 0xff && asBytes[ 1 ] == 0xfe )  				{  					return Encoding.Unicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else if ( asBytes[ 0 ] == 0xfe && asBytes[ 1 ] == 0xff )  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 0' asBytes.Length );  				}  			}  			catch ( ArgumentException ex )  			{  				throw new InvalidOperationException( "Not UTF-16 string."' ex );  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsStringUtf16,The following statement contains a magic number: try  			{  				MessagePackString asMessagePackString = this._handleOrTypeCode as MessagePackString;  #if DEBUG  				Contract.Assert( asMessagePackString != null' "asMessagePackString != null" );  #endif // DEBUG    				if ( asMessagePackString.UnsafeGetString() != null )  				{  					return asMessagePackString.UnsafeGetString();  				}    				byte[] asBytes = asMessagePackString.UnsafeGetBuffer();    				if ( asBytes.Length == 0 )  				{  					return String.Empty;  				}    				if ( asBytes.Length % 2 != 0 )  				{  					throw new InvalidOperationException( "Not UTF-16 string." );  				}    				if ( asBytes[ 0 ] == 0xff && asBytes[ 1 ] == 0xfe )  				{  					return Encoding.Unicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else if ( asBytes[ 0 ] == 0xfe && asBytes[ 1 ] == 0xff )  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 0' asBytes.Length );  				}  			}  			catch ( ArgumentException ex )  			{  				throw new InvalidOperationException( "Not UTF-16 string."' ex );  			}
Magic Number,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,AsStringUtf16,The following statement contains a magic number: try  			{  				MessagePackString asMessagePackString = this._handleOrTypeCode as MessagePackString;  #if DEBUG  				Contract.Assert( asMessagePackString != null' "asMessagePackString != null" );  #endif // DEBUG    				if ( asMessagePackString.UnsafeGetString() != null )  				{  					return asMessagePackString.UnsafeGetString();  				}    				byte[] asBytes = asMessagePackString.UnsafeGetBuffer();    				if ( asBytes.Length == 0 )  				{  					return String.Empty;  				}    				if ( asBytes.Length % 2 != 0 )  				{  					throw new InvalidOperationException( "Not UTF-16 string." );  				}    				if ( asBytes[ 0 ] == 0xff && asBytes[ 1 ] == 0xfe )  				{  					return Encoding.Unicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else if ( asBytes[ 0 ] == 0xfe && asBytes[ 1 ] == 0xff )  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 2' asBytes.Length - 2 );  				}  				else  				{  					return Encoding.BigEndianUnicode.GetString( asBytes' 0' asBytes.Length );  				}  			}  			catch ( ArgumentException ex )  			{  				throw new InvalidOperationException( "Not UTF-16 string."' ex );  			}
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt1 );  						break;  					}  					case 2:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt2 );  						break;  					}  					case 4:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt4 );  						break;  					}  					case 8:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt8 );  						break;  					}  					case 16:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt16 );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length );  						}  						else  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt1 );  						break;  					}  					case 2:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt2 );  						break;  					}  					case 4:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt4 );  						break;  					}  					case 8:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt8 );  						break;  					}  					case 16:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt16 );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length );  						}  						else  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt1 );  						break;  					}  					case 2:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt2 );  						break;  					}  					case 4:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt4 );  						break;  					}  					case 8:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt8 );  						break;  					}  					case 16:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt16 );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length );  						}  						else  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt1 );  						break;  					}  					case 2:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt2 );  						break;  					}  					case 4:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt4 );  						break;  					}  					case 8:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt8 );  						break;  					}  					case 16:  					{  						this.WriteByte( ( byte )MessagePackCode.FixExt16 );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext8' ( byte )body.Length );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext16' ( ushort )body.Length );  						}  						else  						{  							this.WriteBytes( ( byte )MessagePackCode.Ext32' ( uint )body.Length );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 2:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 4:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 8:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 16:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false );  						}  						else if ( body.Length < 0x10000 )  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false );  						}  						else  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 2:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 4:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 8:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 16:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false );  						}  						else if ( body.Length < 0x10000 )  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false );  						}  						else  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 2:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 4:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 8:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 16:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false );  						}  						else if ( body.Length < 0x10000 )  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false );  						}  						else  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: unchecked  			{  				switch ( body.Length )  				{  					case 1:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 2:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 4:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 8:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false );  						break;  					}  					case 16:  					{  						await this.WriteByteAsync( ( byte )MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false );  						break;  					}  					default:  					{  						if ( body.Length < 0x100 )  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext8' ( byte )body.Length' cancellationToken ).ConfigureAwait( false );  						}  						else if ( body.Length < 0x10000 )  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext16' ( ushort )body.Length' cancellationToken ).ConfigureAwait( false );  						}  						else  						{  							await this.WriteBytesAsync( ( byte )MessagePackCode.Ext32' ( uint )body.Length' cancellationToken ).ConfigureAwait( false );  						}    						break;  					}  				} // switch  			}
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( value >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( value & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( value >> 56 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( value >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( value >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( value >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( value >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 8 ] = unchecked( ( byte )( value & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( bits >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( bits & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( bits >> 56 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( bits >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( bits >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( bits >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( bits >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytes,The following statement contains a magic number: this._scalarBuffer[ 8 ] = unchecked( ( byte )( bits & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteStringBody,The following statement contains a magic number: var buffer = BufferManager.NewByteBuffer( value.Length * 4 );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( value >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( value & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( value >> 56 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( value >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( value >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( value >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( value >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( value >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( value >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( value >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( value >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 8 ] = unchecked( ( byte )( value & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( bits >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( bits & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 1 ] = unchecked( ( byte )( bits >> 56 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 2 ] = unchecked( ( byte )( bits >> 48 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 3 ] = unchecked( ( byte )( bits >> 40 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( bits >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 4 ] = unchecked( ( byte )( bits >> 32 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( bits >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 5 ] = unchecked( ( byte )( bits >> 24 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 6 ] = unchecked( ( byte )( bits >> 16 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 7 ] = unchecked( ( byte )( bits >> 8 & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteBytesAsync,The following statement contains a magic number: this._scalarBuffer[ 8 ] = unchecked( ( byte )( bits & 0xFF ) );
Magic Number,MsgPack,MessagePackStreamPacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamPacker.cs,WriteStringBodyAsync,The following statement contains a magic number: var buffer = BufferManager.NewByteBuffer( value.Length * 4 );
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringCore,The following statement contains a magic number: var byteBuffer = BufferManager.NewByteBuffer( length * 4 );
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringCoreAsync,The following statement contains a magic number: var byteBuffer = BufferManager.NewByteBuffer( length * 4 );
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadByteSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadByteSlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSByteSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSByteSlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt16Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt16SlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt16Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt16SlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt32Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt32SlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt32Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt32SlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt64Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadInt64SlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt64Slow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadUInt64SlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSingleSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadSingleSlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadDoubleSlow,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadDoubleSlowAsync,The following statement contains a magic number: var length = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Byte[] );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Byte[] );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Byte[] );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Byte[] );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Byte[] );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Byte[] );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Byte[] );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Byte[] );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Byte[] );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Byte[]>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Byte[]>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Byte[]>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Byte[]>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Byte[]>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Byte[]>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Byte[]>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Byte[]>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Byte[]>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Byte[]>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Byte[]>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Byte[]>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( String );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( String );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( String );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( String );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( String );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( String );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( String );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( String );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( String );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<String>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<String>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<String>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<String>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<String>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<String>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<String>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<String>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<String>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Raw8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<String>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Raw16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<String>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Raw32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<String>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					if( !this.ReadRawStringCore( unchecked( ( int )length )' ref offset' out stringValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					if( !this.ReadBinaryCore( unchecked( ( int )length )' ref offset' out binaryValue ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					if ( !this.ReadMessagePackExtendedTypeObjectCore( unchecked( ( int )length )' buffer' ref offset' out ext ) )  					{  						result = default( MessagePackObject );  						return false;  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackObject );  						return false;  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The following statement contains a magic number: switch ( header & ReadValueResult.TypeCodeMask )  			{  				case ReadValueResult.Array16Type:  				case ReadValueResult.Map16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Array32Type:  				case ReadValueResult.Map32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Str8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Str32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					MessagePackString stringValue;  					var asyncReadResult = await this.ReadRawStringCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						stringValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( stringValue );  					break;  				}  				case ReadValueResult.Bin8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}    					var length = buffer[ 0 ];  					this.CheckLength( length' header );  					offset += 1;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					this.CheckLength( length' header );  					offset += 2;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.Bin32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					this.CheckLength( length' header );  					offset += 4;  					byte[] binaryValue;  					var asyncReadResult = await this.ReadBinaryCoreAsync( unchecked( ( int )length )' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						offset = asyncReadResult.Value.Offset;  						binaryValue = asyncReadResult.Value.Result;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = new MessagePackObject( binaryValue' /* isBinary */true );  					break;  				}  				case ReadValueResult.FixExtType:  				{  					var length = ( header & ReadValueResult.ValueOrLengthMask );  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					var length = buffer[ 0 ];  					offset += 1;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Ext32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					var length = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					MessagePackExtendedTypeObject ext;  					var asyncReadResult = await this.ReadMessagePackExtendedTypeObjectCoreAsync( unchecked( ( int )length )' buffer' offset' cancellationToken ).ConfigureAwait( false );  					if ( asyncReadResult.Success )  					{  						ext = asyncReadResult.Value.Result;  						offset = asyncReadResult.Value.Offset;  					}  					else  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					  					result = ext;  					break;  				}  				case ReadValueResult.Int8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = unchecked( ( sbyte )buffer[ 0 ] );  					offset += 1;  					break;  				}  				case ReadValueResult.Int16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.Int32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Int64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.UInt8Type:  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  					}  					result = buffer[ 0 ];  					offset += 1;  					break;  				}  				case ReadValueResult.UInt16Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt16( buffer' 0 );  					offset += 2;  					break;  				}  				case ReadValueResult.UInt32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt32( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.UInt64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToUInt64( buffer' 0 );  					offset += 8;  					break;  				}  				case ReadValueResult.Real32Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToSingle( buffer' 0 );  					offset += 4;  					break;  				}  				case ReadValueResult.Real64Type:  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 8;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64OffsetValue<MessagePackObject>>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local  					result = BigEndianBinary.ToDouble( buffer' 0 );  					offset += 8;  					break;  				}  				default:  				{  #if DEBUG  					Contract.Assert( header == ReadValueResult.InvalidCode' header.ToString( "X" ) + " == ReadValueResult.InvalidCode" );  #endif // DEBUG  					this.ThrowUnassignedMessageTypeException( 0xC1 );  					// never  					result = default( MessagePackObject );  					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Array16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Array16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Array16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Array16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLengthAsync,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLengthAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Array16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLengthAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Array16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLengthAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Array16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLengthAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Array8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Array16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Array32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Map16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Map16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Map16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( Int64 );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Map16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( Int64 );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLengthAsync,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLengthAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Map16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLengthAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Map16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLengthAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Map16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLengthAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Map8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<Int64>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Map16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Map32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<Int64>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackExtendedTypeObject );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject? );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject? );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject? );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject? );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject? );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject? );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( this._source.Read( buffer' 0' 1 ) < 1 )  					{  						result = default( MessagePackExtendedTypeObject? );  						return false;  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject? );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = this._source.Read( buffer' bufferOffset' reading );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									result = default( MessagePackExtendedTypeObject? );  									return false;  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<MessagePackExtendedTypeObject>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<MessagePackExtendedTypeObject>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<MessagePackExtendedTypeObject>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<MessagePackExtendedTypeObject>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<MessagePackExtendedTypeObject>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<MessagePackExtendedTypeObject>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<MessagePackExtendedTypeObject>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<MessagePackExtendedTypeObject>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<MessagePackExtendedTypeObject>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<MessagePackExtendedTypeObject>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<MessagePackExtendedTypeObject>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<MessagePackExtendedTypeObject>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: var lengthOfLength = ( int )( header & ReadValueResult.LengthOfLengthMask ) >> 8;
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The following statement contains a magic number: switch ( lengthOfLength )  			{  				case 0:  				{  					length = ( byte )( header & ReadValueResult.ValueOrLengthMask );  					break;  				}  				case 1: // Ext8  				{  					if ( await this._source.ReadAsync( buffer' 0' 1' cancellationToken ).ConfigureAwait( false ) < 1 )  					{  						return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>();  					}    					length = BigEndianBinary.ToByte( buffer' 0 );    					break;  				}  				case 2: // Ext16  				{  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 2;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt16( buffer' 0 );    					break;  				}  				default: // Ext32  				{  #if DEBUG  					Contract.Assert( lengthOfLength == 4' lengthOfLength + " == 4" );  #endif // DEBUG  					// scope for local  					{  						var bufferOffset = 0;  						var reading = 4;  						// Retrying for splitted Stream such as NetworkStream  						while( true )  						{  							var readLength = await this._source.ReadAsync( buffer' bufferOffset' reading' cancellationToken ).ConfigureAwait( false );  							if ( readLength < reading )  							{  								if ( readLength > 0 )  								{  									// retry reading  									bufferOffset += readLength;  									reading -= readLength;  									continue;  								}  								else  								{  									if ( this._useStreamPosition )  									{  										// Rollback  										this._source.Position -= ( bufferOffset + readLength );  									}  									else  									{  										// Throw because rollback is not available  										this.ThrowEofException( reading );  									}  					  									return AsyncReadResult.Fail<MessagePackExtendedTypeObject?>();  								}  							} // if readLength < reading  					  							break;  						} // while true  					} // scope for local    					length = BigEndianBinary.ToUInt32( buffer' 0 );    					break;  				}  			}
Magic Number,MsgPack,MessagePackString,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,GetHashCode,The following statement contains a magic number: if ( this._encoded != null )  			{  				int hashCode = 0;  				for ( int i = 0; i < this._encoded.Length; i++ )  				{  					int value = this._encoded[ i ] << ( i % 4 ) * 8;  					hashCode ^= value;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackString,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,GetHashCode,The following statement contains a magic number: if ( this._encoded != null )  			{  				int hashCode = 0;  				for ( int i = 0; i < this._encoded.Length; i++ )  				{  					int value = this._encoded[ i ] << ( i % 4 ) * 8;  					hashCode ^= value;  				}    				return hashCode;  			}
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,MustBeString,The following statement contains a magic number: for ( int i = 0; i < 128 && i < value.Length; i++ )  				{  					var c = value[ i ];  					if ( c < 0x20 && ( c != 0x9 && c != 0xA && c != 0xD ) )  					{  						return false;  					}  					else if ( 0x7E < c && c < 0xA0 )  					{  						return false;  					}  				}
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: var buffer = new StringBuilder( ( bytes.Length <= 128 ? bytes.Length * 3 : 128 * 3 + 3 ) + 4 );
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: var buffer = new StringBuilder( ( bytes.Length <= 128 ? bytes.Length * 3 : 128 * 3 + 3 ) + 4 );
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: var buffer = new StringBuilder( ( bytes.Length <= 128 ? bytes.Length * 3 : 128 * 3 + 3 ) + 4 );
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: var buffer = new StringBuilder( ( bytes.Length <= 128 ? bytes.Length * 3 : 128 * 3 + 3 ) + 4 );
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: var buffer = new StringBuilder( ( bytes.Length <= 128 ? bytes.Length * 3 : 128 * 3 + 3 ) + 4 );
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: var buffer = new StringBuilder( ( bytes.Length <= 128 ? bytes.Length * 3 : 128 * 3 + 3 ) + 4 );
Magic Number,MsgPack,MessagePackStringDebuggerProxy,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackString.cs,CreateByteArrayString,The following statement contains a magic number: foreach ( var b in bytes.Take( 128 ) )  				{  					buffer.Append( ' ' );  					buffer.Append( b.ToString( "X2"' CultureInfo.InvariantCulture ) );  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt16,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt16Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt16,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt16Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt32,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt32,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt32,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt32Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt32Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt32Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt32,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt32,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt32,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt32Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt32Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt32Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackInt64Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64,The following statement contains a magic number: unchecked  			{  				this.WriteByte( ( byte )( ( value >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( value >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( value & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,TryPackUInt64Async,The following statement contains a magic number: unchecked  			{  				await this.WriteByteAsync( ( byte )( ( value >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( value >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( value & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				this.WriteByte( ( byte )( ( bits >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( bits & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				this.WriteByte( ( byte )( ( bits >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( bits & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				this.WriteByte( ( byte )( ( bits >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( bits & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				this.WriteByte( ( byte )( ( bits >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( bits & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				this.WriteByte( ( byte )( ( bits >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( bits & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				this.WriteByte( ( byte )( ( bits >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( bits & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				this.WriteByte( ( byte )( ( bits >> 56 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 48 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 40 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 32 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 24 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 16 ) & 0xFF ) );  				this.WriteByte( ( byte )( ( bits >> 8 ) & 0xFF ) );  				this.WriteByte( ( byte )( bits & 0xFF ) );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackAsyncCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				await this.WriteByteAsync( ( byte )( ( bits >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( bits & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackAsyncCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				await this.WriteByteAsync( ( byte )( ( bits >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( bits & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackAsyncCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				await this.WriteByteAsync( ( byte )( ( bits >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( bits & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackAsyncCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				await this.WriteByteAsync( ( byte )( ( bits >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( bits & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackAsyncCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				await this.WriteByteAsync( ( byte )( ( bits >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( bits & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackAsyncCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				await this.WriteByteAsync( ( byte )( ( bits >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( bits & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackAsyncCore,The following statement contains a magic number: unchecked  			{  				long bits = BitConverter.DoubleToInt64Bits( value );  				await this.WriteByteAsync( ( byte )( ( bits >> 56 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 48 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 40 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 32 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( ( bits >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  				await this.WriteByteAsync( ( byte )( bits & 0xFF )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Array16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Array32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Array16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Array32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Array16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Array32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Array16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Array32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Array16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Array32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderAsyncCore,The following statement contains a magic number: if ( count < 16 )  			{  				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | count ) )' cancellationToken ).ConfigureAwait( false );  			}  			else if ( count <= UInt16.MaxValue )  			{  				await this.WriteByteAsync( MessagePackCode.Array16' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}  			else  			{  				await this.WriteByteAsync( MessagePackCode.Array32' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderAsyncCore,The following statement contains a magic number: if ( count < 16 )  			{  				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | count ) )' cancellationToken ).ConfigureAwait( false );  			}  			else if ( count <= UInt16.MaxValue )  			{  				await this.WriteByteAsync( MessagePackCode.Array16' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}  			else  			{  				await this.WriteByteAsync( MessagePackCode.Array32' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderAsyncCore,The following statement contains a magic number: if ( count < 16 )  			{  				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | count ) )' cancellationToken ).ConfigureAwait( false );  			}  			else if ( count <= UInt16.MaxValue )  			{  				await this.WriteByteAsync( MessagePackCode.Array16' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}  			else  			{  				await this.WriteByteAsync( MessagePackCode.Array32' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderAsyncCore,The following statement contains a magic number: if ( count < 16 )  			{  				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | count ) )' cancellationToken ).ConfigureAwait( false );  			}  			else if ( count <= UInt16.MaxValue )  			{  				await this.WriteByteAsync( MessagePackCode.Array16' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}  			else  			{  				await this.WriteByteAsync( MessagePackCode.Array32' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackArrayHeaderAsyncCore,The following statement contains a magic number: if ( count < 16 )  			{  				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedArray | count ) )' cancellationToken ).ConfigureAwait( false );  			}  			else if ( count <= UInt16.MaxValue )  			{  				await this.WriteByteAsync( MessagePackCode.Array16' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}  			else  			{  				await this.WriteByteAsync( MessagePackCode.Array32' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackMapHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Map16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Map32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackMapHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Map16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Map32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackMapHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Map16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Map32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackMapHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Map16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Map32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackMapHeaderCore,The following statement contains a magic number: if ( count < 16 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | count ) ) );  			}  			else if ( count <= UInt16.MaxValue )  			{  				this.WriteByte( MessagePackCode.Map16 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}  			else  			{  				this.WriteByte( MessagePackCode.Map32 );  				unchecked  				{  					this.WriteByte( ( byte )( ( count >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( count >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( count & 0xFF ) );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackMapHeaderAsyncCore,The following statement contains a magic number: if ( count < 16 )  			{  				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | count ) )' cancellationToken ).ConfigureAwait( false );  			}  			else if ( count <= UInt16.MaxValue )  			{  				await this.WriteByteAsync( MessagePackCode.Map16' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}  			else  			{  				await this.WriteByteAsync( MessagePackCode.Map32' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackMapHeaderAsyncCore,The following statement contains a magic number: if ( count < 16 )  			{  				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | count ) )' cancellationToken ).ConfigureAwait( false );  			}  			else if ( count <= UInt16.MaxValue )  			{  				await this.WriteByteAsync( MessagePackCode.Map16' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}  			else  			{  				await this.WriteByteAsync( MessagePackCode.Map32' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackMapHeaderAsyncCore,The following statement contains a magic number: if ( count < 16 )  			{  				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | count ) )' cancellationToken ).ConfigureAwait( false );  			}  			else if ( count <= UInt16.MaxValue )  			{  				await this.WriteByteAsync( MessagePackCode.Map16' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}  			else  			{  				await this.WriteByteAsync( MessagePackCode.Map32' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackMapHeaderAsyncCore,The following statement contains a magic number: if ( count < 16 )  			{  				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | count ) )' cancellationToken ).ConfigureAwait( false );  			}  			else if ( count <= UInt16.MaxValue )  			{  				await this.WriteByteAsync( MessagePackCode.Map16' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}  			else  			{  				await this.WriteByteAsync( MessagePackCode.Map32' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackMapHeaderAsyncCore,The following statement contains a magic number: if ( count < 16 )  			{  				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedMap | count ) )' cancellationToken ).ConfigureAwait( false );  			}  			else if ( count <= UInt16.MaxValue )  			{  				await this.WriteByteAsync( MessagePackCode.Map16' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}  			else  			{  				await this.WriteByteAsync( MessagePackCode.Map32' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( count >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( count >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( count & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackStringHeaderCore,The following statement contains a magic number: if ( length < 32 )  			{  				this.WriteByte( unchecked( ( byte )( MessagePackCode.MinimumFixedRaw | length ) ) );  				return;  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackStringHeaderCore,The following statement contains a magic number: if ( length <= Byte.MaxValue && ( this._compatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) == 0 )  				{  					this.WriteByte( MessagePackCode.Str8 );  					unchecked  					{  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					this.WriteByte( MessagePackCode.Str16 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else  				{  					this.WriteByte( MessagePackCode.Str32 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 24 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 16 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackStringHeaderCore,The following statement contains a magic number: if ( length <= Byte.MaxValue && ( this._compatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) == 0 )  				{  					this.WriteByte( MessagePackCode.Str8 );  					unchecked  					{  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					this.WriteByte( MessagePackCode.Str16 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else  				{  					this.WriteByte( MessagePackCode.Str32 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 24 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 16 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackStringHeaderCore,The following statement contains a magic number: if ( length <= Byte.MaxValue && ( this._compatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) == 0 )  				{  					this.WriteByte( MessagePackCode.Str8 );  					unchecked  					{  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					this.WriteByte( MessagePackCode.Str16 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else  				{  					this.WriteByte( MessagePackCode.Str32 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 24 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 16 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackStringHeaderCore,The following statement contains a magic number: if ( length <= Byte.MaxValue && ( this._compatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) == 0 )  				{  					this.WriteByte( MessagePackCode.Str8 );  					unchecked  					{  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					this.WriteByte( MessagePackCode.Str16 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else  				{  					this.WriteByte( MessagePackCode.Str32 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 24 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 16 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackStringHeaderAsyncCore,The following statement contains a magic number: if ( length < 32 )  			{  				await this.WriteByteAsync( unchecked( ( byte )( MessagePackCode.MinimumFixedRaw | length ) )' cancellationToken ).ConfigureAwait( false );  				return;  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackStringHeaderAsyncCore,The following statement contains a magic number: if ( length <= Byte.MaxValue && ( this._compatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) == 0 )  				{  					await this.WriteByteAsync( MessagePackCode.Str8' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					await this.WriteByteAsync( MessagePackCode.Str16' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( ( length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}  				else  				{  					await this.WriteByteAsync( MessagePackCode.Str32' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( ( length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( ( length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( ( length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackStringHeaderAsyncCore,The following statement contains a magic number: if ( length <= Byte.MaxValue && ( this._compatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) == 0 )  				{  					await this.WriteByteAsync( MessagePackCode.Str8' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					await this.WriteByteAsync( MessagePackCode.Str16' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( ( length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}  				else  				{  					await this.WriteByteAsync( MessagePackCode.Str32' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( ( length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( ( length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( ( length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackStringHeaderAsyncCore,The following statement contains a magic number: if ( length <= Byte.MaxValue && ( this._compatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) == 0 )  				{  					await this.WriteByteAsync( MessagePackCode.Str8' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					await this.WriteByteAsync( MessagePackCode.Str16' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( ( length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}  				else  				{  					await this.WriteByteAsync( MessagePackCode.Str32' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( ( length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( ( length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( ( length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackStringHeaderAsyncCore,The following statement contains a magic number: if ( length <= Byte.MaxValue && ( this._compatibilityOptions & PackerCompatibilityOptions.PackBinaryAsRaw ) == 0 )  				{  					await this.WriteByteAsync( MessagePackCode.Str8' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					await this.WriteByteAsync( MessagePackCode.Str16' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( ( length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}  				else  				{  					await this.WriteByteAsync( MessagePackCode.Str32' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( ( length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( ( length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( ( length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackBinaryHeaderCore,The following statement contains a magic number: if ( length <= Byte.MaxValue )  				{  					this.WriteByte( MessagePackCode.Bin8 );  					unchecked  					{  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					this.WriteByte( MessagePackCode.Bin16 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else  				{  					this.WriteByte( MessagePackCode.Bin32 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 24 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 16 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackBinaryHeaderCore,The following statement contains a magic number: if ( length <= Byte.MaxValue )  				{  					this.WriteByte( MessagePackCode.Bin8 );  					unchecked  					{  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					this.WriteByte( MessagePackCode.Bin16 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else  				{  					this.WriteByte( MessagePackCode.Bin32 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 24 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 16 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackBinaryHeaderCore,The following statement contains a magic number: if ( length <= Byte.MaxValue )  				{  					this.WriteByte( MessagePackCode.Bin8 );  					unchecked  					{  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					this.WriteByte( MessagePackCode.Bin16 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else  				{  					this.WriteByte( MessagePackCode.Bin32 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 24 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 16 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackBinaryHeaderCore,The following statement contains a magic number: if ( length <= Byte.MaxValue )  				{  					this.WriteByte( MessagePackCode.Bin8 );  					unchecked  					{  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					this.WriteByte( MessagePackCode.Bin16 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}  				else  				{  					this.WriteByte( MessagePackCode.Bin32 );  					unchecked  					{  						this.WriteByte( ( byte )( ( length >> 24 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 16 ) & 0xFF ) );  						this.WriteByte( ( byte )( ( length >> 8 ) & 0xFF ) );  						this.WriteByte( ( byte )( length & 0xFF ) );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackBinaryHeaderAsyncCore,The following statement contains a magic number: if ( length <= Byte.MaxValue )  				{  					await this.WriteByteAsync( MessagePackCode.Bin8' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					await this.WriteByteAsync( MessagePackCode.Bin16' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( ( length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}  				else  				{  					await this.WriteByteAsync( MessagePackCode.Bin32' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( ( length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( ( length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( ( length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackBinaryHeaderAsyncCore,The following statement contains a magic number: if ( length <= Byte.MaxValue )  				{  					await this.WriteByteAsync( MessagePackCode.Bin8' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					await this.WriteByteAsync( MessagePackCode.Bin16' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( ( length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}  				else  				{  					await this.WriteByteAsync( MessagePackCode.Bin32' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( ( length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( ( length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( ( length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackBinaryHeaderAsyncCore,The following statement contains a magic number: if ( length <= Byte.MaxValue )  				{  					await this.WriteByteAsync( MessagePackCode.Bin8' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					await this.WriteByteAsync( MessagePackCode.Bin16' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( ( length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}  				else  				{  					await this.WriteByteAsync( MessagePackCode.Bin32' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( ( length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( ( length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( ( length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackBinaryHeaderAsyncCore,The following statement contains a magic number: if ( length <= Byte.MaxValue )  				{  					await this.WriteByteAsync( MessagePackCode.Bin8' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}  				else if ( length <= UInt16.MaxValue )  				{  					await this.WriteByteAsync( MessagePackCode.Bin16' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( ( length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}  				else  				{  					await this.WriteByteAsync( MessagePackCode.Bin32' cancellationToken ).ConfigureAwait( false );  					unchecked  					{  						await this.WriteByteAsync( ( byte )( ( length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( ( length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( ( length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  						await this.WriteByteAsync( ( byte )( length & 0xFF )' cancellationToken ).ConfigureAwait( false );  					}  				}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					this.WriteByte( MessagePackCode.FixExt1 );  					break;  				}  				case 2:  				{  					this.WriteByte( MessagePackCode.FixExt2 );  					break;  				}  				case 4:  				{  					this.WriteByte( MessagePackCode.FixExt4 );  					break;  				}  				case 8:  				{  					this.WriteByte( MessagePackCode.FixExt8 );  					break;  				}  				case 16:  				{  					this.WriteByte( MessagePackCode.FixExt16 );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							this.WriteByte( MessagePackCode.Ext8 );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteByte( MessagePackCode.Ext16 );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else  						{  							this.WriteByte( MessagePackCode.Ext32 );  							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					this.WriteByte( MessagePackCode.FixExt1 );  					break;  				}  				case 2:  				{  					this.WriteByte( MessagePackCode.FixExt2 );  					break;  				}  				case 4:  				{  					this.WriteByte( MessagePackCode.FixExt4 );  					break;  				}  				case 8:  				{  					this.WriteByte( MessagePackCode.FixExt8 );  					break;  				}  				case 16:  				{  					this.WriteByte( MessagePackCode.FixExt16 );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							this.WriteByte( MessagePackCode.Ext8 );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteByte( MessagePackCode.Ext16 );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else  						{  							this.WriteByte( MessagePackCode.Ext32 );  							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					this.WriteByte( MessagePackCode.FixExt1 );  					break;  				}  				case 2:  				{  					this.WriteByte( MessagePackCode.FixExt2 );  					break;  				}  				case 4:  				{  					this.WriteByte( MessagePackCode.FixExt4 );  					break;  				}  				case 8:  				{  					this.WriteByte( MessagePackCode.FixExt8 );  					break;  				}  				case 16:  				{  					this.WriteByte( MessagePackCode.FixExt16 );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							this.WriteByte( MessagePackCode.Ext8 );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteByte( MessagePackCode.Ext16 );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else  						{  							this.WriteByte( MessagePackCode.Ext32 );  							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					this.WriteByte( MessagePackCode.FixExt1 );  					break;  				}  				case 2:  				{  					this.WriteByte( MessagePackCode.FixExt2 );  					break;  				}  				case 4:  				{  					this.WriteByte( MessagePackCode.FixExt4 );  					break;  				}  				case 8:  				{  					this.WriteByte( MessagePackCode.FixExt8 );  					break;  				}  				case 16:  				{  					this.WriteByte( MessagePackCode.FixExt16 );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							this.WriteByte( MessagePackCode.Ext8 );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteByte( MessagePackCode.Ext16 );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else  						{  							this.WriteByte( MessagePackCode.Ext32 );  							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					this.WriteByte( MessagePackCode.FixExt1 );  					break;  				}  				case 2:  				{  					this.WriteByte( MessagePackCode.FixExt2 );  					break;  				}  				case 4:  				{  					this.WriteByte( MessagePackCode.FixExt4 );  					break;  				}  				case 8:  				{  					this.WriteByte( MessagePackCode.FixExt8 );  					break;  				}  				case 16:  				{  					this.WriteByte( MessagePackCode.FixExt16 );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							this.WriteByte( MessagePackCode.Ext8 );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteByte( MessagePackCode.Ext16 );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else  						{  							this.WriteByte( MessagePackCode.Ext32 );  							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					this.WriteByte( MessagePackCode.FixExt1 );  					break;  				}  				case 2:  				{  					this.WriteByte( MessagePackCode.FixExt2 );  					break;  				}  				case 4:  				{  					this.WriteByte( MessagePackCode.FixExt4 );  					break;  				}  				case 8:  				{  					this.WriteByte( MessagePackCode.FixExt8 );  					break;  				}  				case 16:  				{  					this.WriteByte( MessagePackCode.FixExt16 );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							this.WriteByte( MessagePackCode.Ext8 );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteByte( MessagePackCode.Ext16 );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else  						{  							this.WriteByte( MessagePackCode.Ext32 );  							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					this.WriteByte( MessagePackCode.FixExt1 );  					break;  				}  				case 2:  				{  					this.WriteByte( MessagePackCode.FixExt2 );  					break;  				}  				case 4:  				{  					this.WriteByte( MessagePackCode.FixExt4 );  					break;  				}  				case 8:  				{  					this.WriteByte( MessagePackCode.FixExt8 );  					break;  				}  				case 16:  				{  					this.WriteByte( MessagePackCode.FixExt16 );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							this.WriteByte( MessagePackCode.Ext8 );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteByte( MessagePackCode.Ext16 );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else  						{  							this.WriteByte( MessagePackCode.Ext32 );  							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					this.WriteByte( MessagePackCode.FixExt1 );  					break;  				}  				case 2:  				{  					this.WriteByte( MessagePackCode.FixExt2 );  					break;  				}  				case 4:  				{  					this.WriteByte( MessagePackCode.FixExt4 );  					break;  				}  				case 8:  				{  					this.WriteByte( MessagePackCode.FixExt8 );  					break;  				}  				case 16:  				{  					this.WriteByte( MessagePackCode.FixExt16 );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							this.WriteByte( MessagePackCode.Ext8 );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else if ( body.Length < 0x10000 )  						{  							this.WriteByte( MessagePackCode.Ext16 );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  						else  						{  							this.WriteByte( MessagePackCode.Ext32 );  							this.WriteByte( ( byte )( ( body.Length >> 24 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 16 ) & 0xFF ) );  							this.WriteByte( ( byte )( ( body.Length >> 8 ) & 0xFF ) );  							this.WriteByte( ( byte )( body.Length & 0xFF ) );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 2:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 4:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 8:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 16:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							await this.WriteByteAsync( MessagePackCode.Ext8' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  						else if ( body.Length < 0x10000 )  						{  							await this.WriteByteAsync( MessagePackCode.Ext16' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  						else  						{  							await this.WriteByteAsync( MessagePackCode.Ext32' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 2:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 4:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 8:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 16:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							await this.WriteByteAsync( MessagePackCode.Ext8' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  						else if ( body.Length < 0x10000 )  						{  							await this.WriteByteAsync( MessagePackCode.Ext16' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  						else  						{  							await this.WriteByteAsync( MessagePackCode.Ext32' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 2:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 4:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 8:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 16:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							await this.WriteByteAsync( MessagePackCode.Ext8' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  						else if ( body.Length < 0x10000 )  						{  							await this.WriteByteAsync( MessagePackCode.Ext16' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  						else  						{  							await this.WriteByteAsync( MessagePackCode.Ext32' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 2:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 4:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 8:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 16:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							await this.WriteByteAsync( MessagePackCode.Ext8' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  						else if ( body.Length < 0x10000 )  						{  							await this.WriteByteAsync( MessagePackCode.Ext16' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  						else  						{  							await this.WriteByteAsync( MessagePackCode.Ext32' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 2:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 4:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 8:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 16:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							await this.WriteByteAsync( MessagePackCode.Ext8' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  						else if ( body.Length < 0x10000 )  						{  							await this.WriteByteAsync( MessagePackCode.Ext16' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  						else  						{  							await this.WriteByteAsync( MessagePackCode.Ext32' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 2:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 4:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 8:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 16:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							await this.WriteByteAsync( MessagePackCode.Ext8' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  						else if ( body.Length < 0x10000 )  						{  							await this.WriteByteAsync( MessagePackCode.Ext16' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  						else  						{  							await this.WriteByteAsync( MessagePackCode.Ext32' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 2:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 4:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 8:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 16:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							await this.WriteByteAsync( MessagePackCode.Ext8' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  						else if ( body.Length < 0x10000 )  						{  							await this.WriteByteAsync( MessagePackCode.Ext16' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  						else  						{  							await this.WriteByteAsync( MessagePackCode.Ext32' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,PackExtendedTypeValueAsyncCore,The following statement contains a magic number: switch ( body.Length )  			{  				case 1:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt1' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 2:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt2' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 4:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt4' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 8:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt8' cancellationToken ).ConfigureAwait( false );  					break;  				}  				case 16:  				{  					await this.WriteByteAsync( MessagePackCode.FixExt16' cancellationToken ).ConfigureAwait( false );  					break;  				}  				default:  				{  					unchecked  					{  						if ( body.Length < 0x100 )  						{  							await this.WriteByteAsync( MessagePackCode.Ext8' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  						else if ( body.Length < 0x10000 )  						{  							await this.WriteByteAsync( MessagePackCode.Ext16' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  						else  						{  							await this.WriteByteAsync( MessagePackCode.Ext32' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( ( body.Length >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  							await this.WriteByteAsync( ( byte )( body.Length & 0xFF )' cancellationToken ).ConfigureAwait( false );  						}  					}    					break;  				}  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWrite,The following statement contains a magic number: if ( this.CanSeek )  			{  				// Reserve length  				this.SeekTo( 4L );  				var headerPosition = this.Position;  				// Write body  				writeBody( value' options );  				var bodyLength = this.Position - headerPosition;  				// Back to reserved length  				this.SeekTo( -bodyLength );  				this.SeekTo( -4L );  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}  				// Forward to body tail  				this.SeekTo( bodyLength );  			}  			else  			{  				// Copying is better than forcing stream is seekable...  				var asCollection = value as ICollection<TItem> ?? value.ToArray();    				var bodyLength = asCollection.Count;  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}    				writeBody( asCollection' options );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWrite,The following statement contains a magic number: if ( this.CanSeek )  			{  				// Reserve length  				this.SeekTo( 4L );  				var headerPosition = this.Position;  				// Write body  				writeBody( value' options );  				var bodyLength = this.Position - headerPosition;  				// Back to reserved length  				this.SeekTo( -bodyLength );  				this.SeekTo( -4L );  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}  				// Forward to body tail  				this.SeekTo( bodyLength );  			}  			else  			{  				// Copying is better than forcing stream is seekable...  				var asCollection = value as ICollection<TItem> ?? value.ToArray();    				var bodyLength = asCollection.Count;  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}    				writeBody( asCollection' options );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWrite,The following statement contains a magic number: if ( this.CanSeek )  			{  				// Reserve length  				this.SeekTo( 4L );  				var headerPosition = this.Position;  				// Write body  				writeBody( value' options );  				var bodyLength = this.Position - headerPosition;  				// Back to reserved length  				this.SeekTo( -bodyLength );  				this.SeekTo( -4L );  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}  				// Forward to body tail  				this.SeekTo( bodyLength );  			}  			else  			{  				// Copying is better than forcing stream is seekable...  				var asCollection = value as ICollection<TItem> ?? value.ToArray();    				var bodyLength = asCollection.Count;  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}    				writeBody( asCollection' options );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWrite,The following statement contains a magic number: if ( this.CanSeek )  			{  				// Reserve length  				this.SeekTo( 4L );  				var headerPosition = this.Position;  				// Write body  				writeBody( value' options );  				var bodyLength = this.Position - headerPosition;  				// Back to reserved length  				this.SeekTo( -bodyLength );  				this.SeekTo( -4L );  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}  				// Forward to body tail  				this.SeekTo( bodyLength );  			}  			else  			{  				// Copying is better than forcing stream is seekable...  				var asCollection = value as ICollection<TItem> ?? value.ToArray();    				var bodyLength = asCollection.Count;  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}    				writeBody( asCollection' options );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWrite,The following statement contains a magic number: if ( this.CanSeek )  			{  				// Reserve length  				this.SeekTo( 4L );  				var headerPosition = this.Position;  				// Write body  				writeBody( value' options );  				var bodyLength = this.Position - headerPosition;  				// Back to reserved length  				this.SeekTo( -bodyLength );  				this.SeekTo( -4L );  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}  				// Forward to body tail  				this.SeekTo( bodyLength );  			}  			else  			{  				// Copying is better than forcing stream is seekable...  				var asCollection = value as ICollection<TItem> ?? value.ToArray();    				var bodyLength = asCollection.Count;  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}    				writeBody( asCollection' options );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWrite,The following statement contains a magic number: if ( this.CanSeek )  			{  				// Reserve length  				this.SeekTo( 4L );  				var headerPosition = this.Position;  				// Write body  				writeBody( value' options );  				var bodyLength = this.Position - headerPosition;  				// Back to reserved length  				this.SeekTo( -bodyLength );  				this.SeekTo( -4L );  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}  				// Forward to body tail  				this.SeekTo( bodyLength );  			}  			else  			{  				// Copying is better than forcing stream is seekable...  				var asCollection = value as ICollection<TItem> ?? value.ToArray();    				var bodyLength = asCollection.Count;  				unchecked  				{  					this.WriteByte( ( byte )( ( bodyLength >> 24 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 16 ) & 0xFF ) );  					this.WriteByte( ( byte )( ( bodyLength >> 8 ) & 0xFF ) );  					this.WriteByte( ( byte )( bodyLength & 0xFF ) );  				}    				writeBody( asCollection' options );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWriteAsync,The following statement contains a magic number: if ( this.CanSeek )  			{  				// Reserve length  				this.SeekTo( 4L );  				var headerPosition = this.Position;  				// Write body  				await writeBody( value' options' cancellationToken ).ConfigureAwait( false );  				var bodyLength = this.Position - headerPosition;  				// Back to reserved length  				this.SeekTo( -bodyLength );  				this.SeekTo( -4L );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( bodyLength & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  				// Forward to body tail  				this.SeekTo( bodyLength );  			}  			else  			{  				// Copying is better than forcing stream is seekable...  				var asCollection = value as ICollection<TItem> ?? value.ToArray();    				var bodyLength = asCollection.Count;  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( bodyLength & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}    				await writeBody( asCollection' options' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWriteAsync,The following statement contains a magic number: if ( this.CanSeek )  			{  				// Reserve length  				this.SeekTo( 4L );  				var headerPosition = this.Position;  				// Write body  				await writeBody( value' options' cancellationToken ).ConfigureAwait( false );  				var bodyLength = this.Position - headerPosition;  				// Back to reserved length  				this.SeekTo( -bodyLength );  				this.SeekTo( -4L );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( bodyLength & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  				// Forward to body tail  				this.SeekTo( bodyLength );  			}  			else  			{  				// Copying is better than forcing stream is seekable...  				var asCollection = value as ICollection<TItem> ?? value.ToArray();    				var bodyLength = asCollection.Count;  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( bodyLength & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}    				await writeBody( asCollection' options' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWriteAsync,The following statement contains a magic number: if ( this.CanSeek )  			{  				// Reserve length  				this.SeekTo( 4L );  				var headerPosition = this.Position;  				// Write body  				await writeBody( value' options' cancellationToken ).ConfigureAwait( false );  				var bodyLength = this.Position - headerPosition;  				// Back to reserved length  				this.SeekTo( -bodyLength );  				this.SeekTo( -4L );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( bodyLength & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  				// Forward to body tail  				this.SeekTo( bodyLength );  			}  			else  			{  				// Copying is better than forcing stream is seekable...  				var asCollection = value as ICollection<TItem> ?? value.ToArray();    				var bodyLength = asCollection.Count;  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( bodyLength & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}    				await writeBody( asCollection' options' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWriteAsync,The following statement contains a magic number: if ( this.CanSeek )  			{  				// Reserve length  				this.SeekTo( 4L );  				var headerPosition = this.Position;  				// Write body  				await writeBody( value' options' cancellationToken ).ConfigureAwait( false );  				var bodyLength = this.Position - headerPosition;  				// Back to reserved length  				this.SeekTo( -bodyLength );  				this.SeekTo( -4L );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( bodyLength & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  				// Forward to body tail  				this.SeekTo( bodyLength );  			}  			else  			{  				// Copying is better than forcing stream is seekable...  				var asCollection = value as ICollection<TItem> ?? value.ToArray();    				var bodyLength = asCollection.Count;  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( bodyLength & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}    				await writeBody( asCollection' options' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWriteAsync,The following statement contains a magic number: if ( this.CanSeek )  			{  				// Reserve length  				this.SeekTo( 4L );  				var headerPosition = this.Position;  				// Write body  				await writeBody( value' options' cancellationToken ).ConfigureAwait( false );  				var bodyLength = this.Position - headerPosition;  				// Back to reserved length  				this.SeekTo( -bodyLength );  				this.SeekTo( -4L );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( bodyLength & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  				// Forward to body tail  				this.SeekTo( bodyLength );  			}  			else  			{  				// Copying is better than forcing stream is seekable...  				var asCollection = value as ICollection<TItem> ?? value.ToArray();    				var bodyLength = asCollection.Count;  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( bodyLength & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}    				await writeBody( asCollection' options' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,Packer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Packer.cs,StreamWriteAsync,The following statement contains a magic number: if ( this.CanSeek )  			{  				// Reserve length  				this.SeekTo( 4L );  				var headerPosition = this.Position;  				// Write body  				await writeBody( value' options' cancellationToken ).ConfigureAwait( false );  				var bodyLength = this.Position - headerPosition;  				// Back to reserved length  				this.SeekTo( -bodyLength );  				this.SeekTo( -4L );  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( bodyLength & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}  				// Forward to body tail  				this.SeekTo( bodyLength );  			}  			else  			{  				// Copying is better than forcing stream is seekable...  				var asCollection = value as ICollection<TItem> ?? value.ToArray();    				var bodyLength = asCollection.Count;  				unchecked  				{  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 24 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 16 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( ( bodyLength >> 8 ) & 0xFF )' cancellationToken ).ConfigureAwait( false );  					await this.WriteByteAsync( ( byte )( bodyLength & 0xFF )' cancellationToken ).ConfigureAwait( false );  				}    				await writeBody( asCollection' options' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ArrayTypeMask ) == ReadValueResult.ArrayTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						return ( byte )( MessagePackCode.MinimumFixedArray | ( int )( source & ReadValueResult.ValueOrLengthMask ) );  					}  					case 2:  					{  						return ( byte )MessagePackCode.Array16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Array32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ArrayTypeMask ) == ReadValueResult.ArrayTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						return ( byte )( MessagePackCode.MinimumFixedArray | ( int )( source & ReadValueResult.ValueOrLengthMask ) );  					}  					case 2:  					{  						return ( byte )MessagePackCode.Array16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Array32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ArrayTypeMask ) == ReadValueResult.ArrayTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						return ( byte )( MessagePackCode.MinimumFixedArray | ( int )( source & ReadValueResult.ValueOrLengthMask ) );  					}  					case 2:  					{  						return ( byte )MessagePackCode.Array16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Array32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.MapTypeMask ) == ReadValueResult.MapTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						return ( byte )( MessagePackCode.MinimumFixedMap | ( int )( source & ReadValueResult.ValueOrLengthMask ) );  					}  					case 2:  					{  						return ( byte )MessagePackCode.Map16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Map32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.MapTypeMask ) == ReadValueResult.MapTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						return ( byte )( MessagePackCode.MinimumFixedMap | ( int )( source & ReadValueResult.ValueOrLengthMask ) );  					}  					case 2:  					{  						return ( byte )MessagePackCode.Map16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Map32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.MapTypeMask ) == ReadValueResult.MapTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						return ( byte )( MessagePackCode.MinimumFixedMap | ( int )( source & ReadValueResult.ValueOrLengthMask ) );  					}  					case 2:  					{  						return ( byte )MessagePackCode.Map16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Map32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.RawTypeMask ) == ReadValueResult.RawTypeMask )  			{  				var isBin = ( source & ReadValueResult.BinTypeMask ) == ReadValueResult.BinTypeMask;  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						return ( byte )( MessagePackCode.MinimumFixedRaw | ( int )( source & ReadValueResult.ValueOrLengthMask ) );  					}  					case 1:  					{  						return ( byte )( isBin ? MessagePackCode.Bin8 : MessagePackCode.Str8 );  					}  					case 2:  					{  						return ( byte )( isBin ? MessagePackCode.Bin16 : MessagePackCode.Str16 );  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )( isBin ? MessagePackCode.Bin32 : MessagePackCode.Str32 );  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.RawTypeMask ) == ReadValueResult.RawTypeMask )  			{  				var isBin = ( source & ReadValueResult.BinTypeMask ) == ReadValueResult.BinTypeMask;  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						return ( byte )( MessagePackCode.MinimumFixedRaw | ( int )( source & ReadValueResult.ValueOrLengthMask ) );  					}  					case 1:  					{  						return ( byte )( isBin ? MessagePackCode.Bin8 : MessagePackCode.Str8 );  					}  					case 2:  					{  						return ( byte )( isBin ? MessagePackCode.Bin16 : MessagePackCode.Str16 );  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )( isBin ? MessagePackCode.Bin32 : MessagePackCode.Str32 );  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.RawTypeMask ) == ReadValueResult.RawTypeMask )  			{  				var isBin = ( source & ReadValueResult.BinTypeMask ) == ReadValueResult.BinTypeMask;  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						return ( byte )( MessagePackCode.MinimumFixedRaw | ( int )( source & ReadValueResult.ValueOrLengthMask ) );  					}  					case 1:  					{  						return ( byte )( isBin ? MessagePackCode.Bin8 : MessagePackCode.Str8 );  					}  					case 2:  					{  						return ( byte )( isBin ? MessagePackCode.Bin16 : MessagePackCode.Str16 );  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )( isBin ? MessagePackCode.Bin32 : MessagePackCode.Str32 );  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ExtTypeMask ) == ReadValueResult.ExtTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) )  						{  							case 1:  							{  								return ( byte )MessagePackCode.FixExt1;  							}  							case 2:  							{  								return ( byte )MessagePackCode.FixExt2;  							}  							case 4:  							{  								return ( byte )MessagePackCode.FixExt4;  							}  							case 8:  							{  								return ( byte )MessagePackCode.FixExt8;  							}  							default:  							{  #if DEBUG  								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" );  #endif // DEBUG  								return ( byte )MessagePackCode.FixExt16;  							}  						}  					}  					case 1:  					{  						return ( byte )MessagePackCode.Ext8;  					}  					case 2:  					{  						return ( byte )MessagePackCode.Ext16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Ext32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ExtTypeMask ) == ReadValueResult.ExtTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) )  						{  							case 1:  							{  								return ( byte )MessagePackCode.FixExt1;  							}  							case 2:  							{  								return ( byte )MessagePackCode.FixExt2;  							}  							case 4:  							{  								return ( byte )MessagePackCode.FixExt4;  							}  							case 8:  							{  								return ( byte )MessagePackCode.FixExt8;  							}  							default:  							{  #if DEBUG  								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" );  #endif // DEBUG  								return ( byte )MessagePackCode.FixExt16;  							}  						}  					}  					case 1:  					{  						return ( byte )MessagePackCode.Ext8;  					}  					case 2:  					{  						return ( byte )MessagePackCode.Ext16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Ext32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ExtTypeMask ) == ReadValueResult.ExtTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) )  						{  							case 1:  							{  								return ( byte )MessagePackCode.FixExt1;  							}  							case 2:  							{  								return ( byte )MessagePackCode.FixExt2;  							}  							case 4:  							{  								return ( byte )MessagePackCode.FixExt4;  							}  							case 8:  							{  								return ( byte )MessagePackCode.FixExt8;  							}  							default:  							{  #if DEBUG  								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" );  #endif // DEBUG  								return ( byte )MessagePackCode.FixExt16;  							}  						}  					}  					case 1:  					{  						return ( byte )MessagePackCode.Ext8;  					}  					case 2:  					{  						return ( byte )MessagePackCode.Ext16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Ext32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ExtTypeMask ) == ReadValueResult.ExtTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) )  						{  							case 1:  							{  								return ( byte )MessagePackCode.FixExt1;  							}  							case 2:  							{  								return ( byte )MessagePackCode.FixExt2;  							}  							case 4:  							{  								return ( byte )MessagePackCode.FixExt4;  							}  							case 8:  							{  								return ( byte )MessagePackCode.FixExt8;  							}  							default:  							{  #if DEBUG  								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" );  #endif // DEBUG  								return ( byte )MessagePackCode.FixExt16;  							}  						}  					}  					case 1:  					{  						return ( byte )MessagePackCode.Ext8;  					}  					case 2:  					{  						return ( byte )MessagePackCode.Ext16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Ext32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ExtTypeMask ) == ReadValueResult.ExtTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) )  						{  							case 1:  							{  								return ( byte )MessagePackCode.FixExt1;  							}  							case 2:  							{  								return ( byte )MessagePackCode.FixExt2;  							}  							case 4:  							{  								return ( byte )MessagePackCode.FixExt4;  							}  							case 8:  							{  								return ( byte )MessagePackCode.FixExt8;  							}  							default:  							{  #if DEBUG  								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" );  #endif // DEBUG  								return ( byte )MessagePackCode.FixExt16;  							}  						}  					}  					case 1:  					{  						return ( byte )MessagePackCode.Ext8;  					}  					case 2:  					{  						return ( byte )MessagePackCode.Ext16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Ext32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ExtTypeMask ) == ReadValueResult.ExtTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) )  						{  							case 1:  							{  								return ( byte )MessagePackCode.FixExt1;  							}  							case 2:  							{  								return ( byte )MessagePackCode.FixExt2;  							}  							case 4:  							{  								return ( byte )MessagePackCode.FixExt4;  							}  							case 8:  							{  								return ( byte )MessagePackCode.FixExt8;  							}  							default:  							{  #if DEBUG  								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" );  #endif // DEBUG  								return ( byte )MessagePackCode.FixExt16;  							}  						}  					}  					case 1:  					{  						return ( byte )MessagePackCode.Ext8;  					}  					case 2:  					{  						return ( byte )MessagePackCode.Ext16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Ext32;  					}  				}  			}
Magic Number,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following statement contains a magic number: if ( ( source & ReadValueResult.ExtTypeMask ) == ReadValueResult.ExtTypeMask )  			{  				var length = ( int )( source & ReadValueResult.LengthOfLengthMask ) >> 8;  				switch ( length )  				{  					case 0:  					{  						switch ( ( int )( source & ReadValueResult.ValueOrLengthMask ) )  						{  							case 1:  							{  								return ( byte )MessagePackCode.FixExt1;  							}  							case 2:  							{  								return ( byte )MessagePackCode.FixExt2;  							}  							case 4:  							{  								return ( byte )MessagePackCode.FixExt4;  							}  							case 8:  							{  								return ( byte )MessagePackCode.FixExt8;  							}  							default:  							{  #if DEBUG  								Contract.Assert( ( int )( source & ReadValueResult.ValueOrLengthMask ) == 16' ( int )( source & ReadValueResult.ValueOrLengthMask ) + " == 16" );  #endif // DEBUG  								return ( byte )MessagePackCode.FixExt16;  							}  						}  					}  					case 1:  					{  						return ( byte )MessagePackCode.Ext8;  					}  					case 2:  					{  						return ( byte )MessagePackCode.Ext16;  					}  					default:  					{  #if DEBUG  						Contract.Assert( length == 4' length + " == 4" );  #endif // DEBUG  						return ( byte )MessagePackCode.Ext32;  					}  				}  			}
Magic Number,MsgPack,SingleArrayBufferAllocator,C:\repos\msgpack_msgpack-cli\src\MsgPack\SingleArrayBufferAllocator.cs,Allocate,The following statement contains a magic number: if ( old.Length < 256 )  			{  				return new byte[ 256 ];  			}
Magic Number,MsgPack,SingleArrayBufferAllocator,C:\repos\msgpack_msgpack-cli\src\MsgPack\SingleArrayBufferAllocator.cs,Allocate,The following statement contains a magic number: if ( old.Length < 256 )  			{  				return new byte[ 256 ];  			}
Magic Number,MsgPack,SingleArrayBufferAllocator,C:\repos\msgpack_msgpack-cli\src\MsgPack\SingleArrayBufferAllocator.cs,Allocate,The following statement contains a magic number: var newSize = Math.Max( ( long )( old.Length * 1.1618 )' requestSize + ( long )old.Length );
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,SubtreeUnpacker,The following statement contains a magic number: this._unpacked = new Int64Stack( 2 );
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,SubtreeUnpacker,The following statement contains a magic number: this._itemsCount = new Int64Stack( 2 );
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,SubtreeUnpacker,The following statement contains a magic number: this._isMap = new BooleanStack( 2 );
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadCore,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadAsyncCore,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadBoolean,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableBoolean,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadByte,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableByte,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadSByte,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableSByte,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadInt16,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableInt16,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadUInt16,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableUInt16,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadInt32,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableInt32,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadUInt32,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableUInt32,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadInt64,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableInt64,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadUInt64,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableUInt64,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadSingle,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableSingle,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadDouble,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadNullableDouble,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadArrayLength,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadMapLength,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadBinary,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadString,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadMessagePackExtendedTypeObject,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,SubtreeUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\SubtreeUnpacker.cs,ReadObject,The following statement contains a magic number: switch ( this._internalRoot.CollectionType )  			{  				case CollectionType.Array:  				{  					this._itemsCount.Push( this._root.ItemsCount );  					this._unpacked.Push( 0 );  					this._isMap.Push( false );  					break;  				}  				case CollectionType.Map:  				{  					this._itemsCount.Push( this._root.ItemsCount * 2 );  					this._unpacked.Push( 0 );  					this._isMap.Push( true );  					break;  				}  				default:  				{  					this._unpacked.Push( this._unpacked.Pop() + 1 );  					break;  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Encode,The following statement contains a magic number: if ( ( this.unixEpochSeconds >> 34 ) != 0 )  			{  				// timestamp 96  				var value = this;  				var body = new byte[ 12 ];  				body[ 0 ] = unchecked( ( byte )( ( this.nanoseconds >> 24 ) & 0xFF ) );  				body[ 1 ] = unchecked( ( byte )( ( this.nanoseconds >> 16 ) & 0xFF ) );  				body[ 2 ] = unchecked( ( byte )( ( this.nanoseconds >> 8 ) & 0xFF ) );  				body[ 3 ] = unchecked( ( byte )( ( this.nanoseconds ) & 0xFF ) );  				body[ 4 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 56 ) & 0xFF ) );  				body[ 5 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 48 ) & 0xFF ) );  				body[ 6 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 40 ) & 0xFF ) );  				body[ 7 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 32 ) & 0xFF ) );  				body[ 8 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 24 ) & 0xFF ) );  				body[ 9 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 16 ) & 0xFF ) );  				body[ 10 ] = unchecked( ( byte )( ( this.unixEpochSeconds >> 8 ) & 0xFF ) );  				body[ 11 ] = unchecked( ( byte )( this.unixEpochSeconds & 0xFF ) );    				return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  			}  			else  			{  				var encoded = ( ( ( ulong )this.nanoseconds ) << 34 ) | unchecked( ( ulong )this.unixEpochSeconds );  				if ( ( encoded & 0xFFFFFFFF00000000L ) == 0 )  				{  					// timestamp 32  					var value = unchecked( ( uint )encoded );  					var body = new byte[ 4 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  				else  				{  					// timestamp 64  					var body = new byte[ 8 ];  					body[ 0 ] = unchecked( ( byte )( ( encoded >> 56 ) & 0xFF ) );  					body[ 1 ] = unchecked( ( byte )( ( encoded >> 48 ) & 0xFF ) );  					body[ 2 ] = unchecked( ( byte )( ( encoded >> 40 ) & 0xFF ) );  					body[ 3 ] = unchecked( ( byte )( ( encoded >> 32 ) & 0xFF ) );  					body[ 4 ] = unchecked( ( byte )( ( encoded >> 24 ) & 0xFF ) );  					body[ 5 ] = unchecked( ( byte )( ( encoded >> 16 ) & 0xFF ) );  					body[ 6 ] = unchecked( ( byte )( ( encoded >> 8 ) & 0xFF ) );  					body[ 7 ] = unchecked( ( byte )( encoded & 0xFF ) );    					return MessagePackExtendedTypeObject.Unpack( TypeCode' body );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,FromOffsetTicks,The following statement contains a magic number: nanoSeconds = unchecked( ( int )remaining ) * 100;
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Decode,The following statement contains a magic number: switch( value.Body.Length )  			{  				case 4:  				{  					// timespan32 format  					return new Timestamp( BigEndianBinary.ToUInt32( value.Body' 0 )' 0 );  				}  				case 8:  				{  					// timespan64 format  					var payload = BigEndianBinary.ToUInt64( value.Body' 0 );  					return new Timestamp( unchecked( ( long )( payload & 0x00000003ffffffffL ) )' unchecked( ( int )( payload >> 34 ) ) );  				}  				case 12:  				{  					// timespan96 format  					return new Timestamp( BigEndianBinary.ToInt64( value.Body' sizeof( int ) )' unchecked( ( int )BigEndianBinary.ToUInt32( value.Body' 0 ) ) );  				}  				default:  				{  					throw new ArgumentException( "The value's length is not valid."' "value" );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Decode,The following statement contains a magic number: switch( value.Body.Length )  			{  				case 4:  				{  					// timespan32 format  					return new Timestamp( BigEndianBinary.ToUInt32( value.Body' 0 )' 0 );  				}  				case 8:  				{  					// timespan64 format  					var payload = BigEndianBinary.ToUInt64( value.Body' 0 );  					return new Timestamp( unchecked( ( long )( payload & 0x00000003ffffffffL ) )' unchecked( ( int )( payload >> 34 ) ) );  				}  				case 12:  				{  					// timespan96 format  					return new Timestamp( BigEndianBinary.ToInt64( value.Body' sizeof( int ) )' unchecked( ( int )BigEndianBinary.ToUInt32( value.Body' 0 ) ) );  				}  				default:  				{  					throw new ArgumentException( "The value's length is not valid."' "value" );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Decode,The following statement contains a magic number: switch( value.Body.Length )  			{  				case 4:  				{  					// timespan32 format  					return new Timestamp( BigEndianBinary.ToUInt32( value.Body' 0 )' 0 );  				}  				case 8:  				{  					// timespan64 format  					var payload = BigEndianBinary.ToUInt64( value.Body' 0 );  					return new Timestamp( unchecked( ( long )( payload & 0x00000003ffffffffL ) )' unchecked( ( int )( payload >> 34 ) ) );  				}  				case 12:  				{  					// timespan96 format  					return new Timestamp( BigEndianBinary.ToInt64( value.Body' sizeof( int ) )' unchecked( ( int )BigEndianBinary.ToUInt32( value.Body' 0 ) ) );  				}  				default:  				{  					throw new ArgumentException( "The value's length is not valid."' "value" );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,Decode,The following statement contains a magic number: switch( value.Body.Length )  			{  				case 4:  				{  					// timespan32 format  					return new Timestamp( BigEndianBinary.ToUInt32( value.Body' 0 )' 0 );  				}  				case 8:  				{  					// timespan64 format  					var payload = BigEndianBinary.ToUInt64( value.Body' 0 );  					return new Timestamp( unchecked( ( long )( payload & 0x00000003ffffffffL ) )' unchecked( ( int )( payload >> 34 ) ) );  				}  				case 12:  				{  					// timespan96 format  					return new Timestamp( BigEndianBinary.ToInt64( value.Body' sizeof( int ) )' unchecked( ( int )BigEndianBinary.ToUInt32( value.Body' 0 ) ) );  				}  				default:  				{  					throw new ArgumentException( "The value's length is not valid."' "value" );  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,FromComponents,The following statement contains a magic number: checked  			{  				var days = YearsToDaysOfNewYear( value.Year ) + ToDaysOffsetFromNewYear( value.Month' value.Day' isLeapYear ) - Timestamp.UnixEpochInSeconds / Timestamp.SecondsPerDay;  				// First set time offset to avoid overflow.  				epoc = value.Hour * 60 * 60;  				epoc += value.Minute * 60;  				epoc += value.Second;  				if ( days < 0 )  				{  					// Avoid right side overflow.  					epoc += ( days + 1 ) * Timestamp.SecondsPerDay;  					epoc -= Timestamp.SecondsPerDay;  				}  				else  				{  					epoc += days * Timestamp.SecondsPerDay;  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,FromComponents,The following statement contains a magic number: checked  			{  				var days = YearsToDaysOfNewYear( value.Year ) + ToDaysOffsetFromNewYear( value.Month' value.Day' isLeapYear ) - Timestamp.UnixEpochInSeconds / Timestamp.SecondsPerDay;  				// First set time offset to avoid overflow.  				epoc = value.Hour * 60 * 60;  				epoc += value.Minute * 60;  				epoc += value.Second;  				if ( days < 0 )  				{  					// Avoid right side overflow.  					epoc += ( days + 1 ) * Timestamp.SecondsPerDay;  					epoc -= Timestamp.SecondsPerDay;  				}  				else  				{  					epoc += days * Timestamp.SecondsPerDay;  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,FromComponents,The following statement contains a magic number: checked  			{  				var days = YearsToDaysOfNewYear( value.Year ) + ToDaysOffsetFromNewYear( value.Month' value.Day' isLeapYear ) - Timestamp.UnixEpochInSeconds / Timestamp.SecondsPerDay;  				// First set time offset to avoid overflow.  				epoc = value.Hour * 60 * 60;  				epoc += value.Minute * 60;  				epoc += value.Second;  				if ( days < 0 )  				{  					// Avoid right side overflow.  					epoc += ( days + 1 ) * Timestamp.SecondsPerDay;  					epoc -= Timestamp.SecondsPerDay;  				}  				else  				{  					epoc += days * Timestamp.SecondsPerDay;  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,YearsToDaysOfNewYear,The following statement contains a magic number: var numberOf400Years = DivRem( years > 0 ? ( years - 1 ) : years' 400' out remainOf400Years );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,YearsToDaysOfNewYear,The following statement contains a magic number: var numberOf100Years = DivRem( remainOf400Years' 100' out remainOf100Years );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,YearsToDaysOfNewYear,The following statement contains a magic number: var numberOf4Years = DivRem( remainOf100Years' 4' out remainOf4Years );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ToDaysOffsetFromNewYear,The following statement contains a magic number: for ( var i = 1; i < month; i++ )  			{  				result += LastDays[ i ];  				if ( i == 2 )  				{  					result += isLeapYear ? 29 : 28;  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ToDaysOffsetFromNewYear,The following statement contains a magic number: for ( var i = 1; i < month; i++ )  			{  				result += LastDays[ i ];  				if ( i == 2 )  				{  					result += isLeapYear ? 29 : 28;  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,ToDaysOffsetFromNewYear,The following statement contains a magic number: for ( var i = 1; i < month; i++ )  			{  				result += LastDays[ i ];  				if ( i == 2 )  				{  					result += isLeapYear ? 29 : 28;  				}  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,IsLeapYearInternal,The following statement contains a magic number: return !( year % 4 != 0 || ( year % 100 == 0 && year % 400 != 0 ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,IsLeapYearInternal,The following statement contains a magic number: return !( year % 4 != 0 || ( year % 100 == 0 && year % 400 != 0 ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,IsLeapYearInternal,The following statement contains a magic number: return !( year % 4 != 0 || ( year % 100 == 0 && year % 400 != 0 ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetLastDay,The following statement contains a magic number: if ( month == 2 )  			{  				lastDay = isLeapYear ? 29 : 28;  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetLastDay,The following statement contains a magic number: if ( month == 2 )  			{  				lastDay = isLeapYear ? 29 : 28;  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetLastDay,The following statement contains a magic number: if ( month == 2 )  			{  				lastDay = isLeapYear ? 29 : 28;  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: if ( numberOf100Years == 4 )  			{  				numberOf100Years = 3;  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: if ( numberOf100Years == 4 )  			{  				numberOf100Years = 3;  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: if ( numberOf1Year == 4 )  			{  				numberOf1Year = 3;  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: if ( numberOf1Year == 4 )  			{  				numberOf1Year = 3;  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: year = unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year + 1 ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: year = unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year + 1 ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: year = unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year + 1 ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: var isLeapYear = numberOf1Year == 3 && ( numberOf4years != 24 || numberOf100Years == 3 );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: var isLeapYear = numberOf1Year == 3 && ( numberOf4years != 24 || numberOf100Years == 3 );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: var isLeapYear = numberOf1Year == 3 && ( numberOf4years != 24 || numberOf100Years == 3 );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: var numberOfMonth = ( daysInYear >> 5 ) + 1;
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: Contract.Assert( numberOfMonth <= 12' numberOfMonth + "<= 12' daysInYear = " + daysInYear );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartAD,The following statement contains a magic number: while ( daysInYear >= days[ numberOfMonth ] )  			{  				numberOfMonth++;  #if DEBUG  				Contract.Assert( numberOfMonth <= 12' numberOfMonth + "<= 12' daysInYear = " + daysInYear );  #endif // DEBUG  			}
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: var numberOf100Years =  				daysIn400Years <= ( DaysPer100Years  + 1 ) // 1st year is leap year (power of 400)  					? 0  					: ( ( daysIn400Years - 2 ) / DaysPer100Years );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: var numberOf1Year =  				daysIn4Years <= ( DaysPerYear + ( numberOf4years != 0 ? 1 : 0 ) ) // is leap year in 4 years range?  					? 0  					: ( ( daysIn4Years - 2 ) / DaysPerYear );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: year = -unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: year = -unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: year = -unchecked( ( long )( numberOf400Years * 400 + numberOf100Years * 100 + numberOf4years * 4 + numberOf1Year ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: var daysInYear =  				isLeapYear  				? ( 366 - daysIn4Years )  				: ( 365 - ( daysIn4Years - 1 - numberOf1Year * DaysPerYear ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: var daysInYear =  				isLeapYear  				? ( 366 - daysIn4Years )  				: ( 365 - ( daysIn4Years - 1 - numberOf1Year * DaysPerYear ) );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: var numberOfMonth = ( daysInYear >> 5 ) + 1;
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: Contract.Assert( numberOfMonth <= 12' numberOfMonth + "<= 12' daysInYear = " + daysInYear );
Magic Number,MsgPack,Timestamp,C:\repos\msgpack_msgpack-cli\src\MsgPack\Timestamp.Calculation.cs,GetDatePartBC,The following statement contains a magic number: while ( daysInYear >= days[ numberOfMonth ] )  			{  				numberOfMonth++;  #if DEBUG  				Contract.Assert( numberOfMonth <= 12' numberOfMonth + "<= 12' daysInYear = " + daysInYear );  #endif // DEBUG  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( !ParseDigitRange( input' 2' ref position' 1' 12' out month ) )  			{  				result = default( Timestamp );  				return TimestampParseResult.InvalidMonth;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( !ParseDigitRange( input' 2' ref position' 1' 12' out month ) )  			{  				result = default( Timestamp );  				return TimestampParseResult.InvalidMonth;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( !ParseDigitRange( input' 2' ref position' 0' 23' out hour ) )  			{  				result = default( Timestamp );  				return TimestampParseResult.InvalidHour;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( !ParseDigitRange( input' 2' ref position' 0' 23' out hour ) )  			{  				result = default( Timestamp );  				return TimestampParseResult.InvalidHour;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( !ParseDigitRange( input' 2' ref position' 0' 59' out minute ) )  			{  				result = default( Timestamp );  				return TimestampParseResult.InvalidMinute;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( !ParseDigitRange( input' 2' ref position' 0' 59' out minute ) )  			{  				result = default( Timestamp );  				return TimestampParseResult.InvalidMinute;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( !ParseDigitRange( input' 2' ref position' 0' 59' out second ) )  			{  				result = default( Timestamp );  				return TimestampParseResult.InvalidSecond;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( !ParseDigitRange( input' 2' ref position' 0' 59' out second ) )  			{  				result = default( Timestamp );  				return TimestampParseResult.InvalidSecond;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( format != "s" )  			{  				// "o" or "O"  				if ( !ParseDelimiter( input' ref position' SubsecondDelimiter ) )  				{  					result = default( Timestamp );  					return TimestampParseResult.InvalidSubsecondDelimiter;  				}    				if ( !ParseDigitRange( input' 9' ref position' 0' 999999999' out nanosecond ) )  				{  					result = default( Timestamp );  					return TimestampParseResult.InvalidNanoSecond;  				}  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,TryParseExact,The following statement contains a magic number: if ( format != "s" )  			{  				// "o" or "O"  				if ( !ParseDelimiter( input' ref position' SubsecondDelimiter ) )  				{  					result = default( Timestamp );  					return TimestampParseResult.InvalidSubsecondDelimiter;  				}    				if ( !ParseDigitRange( input' 9' ref position' 0' 999999999' out nanosecond ) )  				{  					result = default( Timestamp );  					return TimestampParseResult.InvalidNanoSecond;  				}  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ParseDigit,The following statement contains a magic number: while ( position < input.Length )  			{  				var c = input[ position ];  				if ( !IsDigit( c ) )  				{  					break;  				}    				bits = bits * 10 + ( c - '0' );  				position++;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ParseYear,The following statement contains a magic number: if ( !ParseDigit( input' 4' ref position' out digit ) )  			{  				year = default( long );  				return false;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ParseDay,The following statement contains a magic number: if ( !ParseDigit( input' 2' ref position' out digit ) )  			{  				day = default( int );  				return false;  			}
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ToIso8601String,The following statement contains a magic number: var buffer = new StringBuilder( 49 + ( containsNanosecons ? 11 : 1 ) );
Magic Number,MsgPack,TimestampStringConverter,C:\repos\msgpack_msgpack-cli\src\MsgPack\TimestampStringConverter.cs,ToIso8601String,The following statement contains a magic number: var buffer = new StringBuilder( 49 + ( containsNanosecons ? 11 : 1 ) );
Magic Number,MsgPack,TupleItems,C:\repos\msgpack_msgpack-cli\src\MsgPack\TupleItems.cs,CreateTupleTypeList,The following statement contains a magic number: while ( true )  			{  				result.Add( tupleType );  				if ( !tupleType.GetIsGenericType() )  				{  					// arity 0  					break;  				}    				var itemTypes = tupleType.GetGenericArguments();  				if ( itemTypes.Length < 8 )  				{  					// leaf tuple  					break;  				}    				tupleType = itemTypes.Last();  			}
Magic Number,MsgPack,TupleItems,C:\repos\msgpack_msgpack-cli\src\MsgPack\TupleItems.cs,GetTupleItemTypes,The following statement contains a magic number: var count = itemTypes.Count == 8 ? 7 : itemTypes.Count;
Magic Number,MsgPack,TupleItems,C:\repos\msgpack_msgpack-cli\src\MsgPack\TupleItems.cs,GetTupleItemTypes,The following statement contains a magic number: var count = itemTypes.Count == 8 ? 7 : itemTypes.Count;
Magic Number,MsgPack,TupleItems,C:\repos\msgpack_msgpack-cli\src\MsgPack\TupleItems.cs,GetTupleItemTypes,The following statement contains a magic number: if ( itemTypes.Count == 8 )  			{  				var trest = itemTypes[ 7 ];  #if DEBUG  				Contract.Assert( IsTuple( trest )' "IsTuple( " + trest.AssemblyQualifiedName + " )" );  #endif // DEBUG  				// Put nested tuple's item types recursively.  				GetTupleItemTypes( trest.GetGenericArguments()' result );  			}
Magic Number,MsgPack,TupleItems,C:\repos\msgpack_msgpack-cli\src\MsgPack\TupleItems.cs,GetTupleItemTypes,The following statement contains a magic number: if ( itemTypes.Count == 8 )  			{  				var trest = itemTypes[ 7 ];  #if DEBUG  				Contract.Assert( IsTuple( trest )' "IsTuple( " + trest.AssemblyQualifiedName + " )" );  #endif // DEBUG  				// Put nested tuple's item types recursively.  				GetTupleItemTypes( trest.GetGenericArguments()' result );  			}
Magic Number,MsgPack,Unpacking,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.cs,UnpackRawLengthCore,The following statement contains a magic number: if ( header == MessagePackCode.NilValue )  			{  				// Nil should be as empty stream because returning byte stream should not be null.  				return 0;  			}  			else if ( MessagePackCode.MinimumFixedRaw <= header && header <= MessagePackCode.MaximumFixedRaw )  			{  				return unchecked( ( uint )( header - MessagePackCode.MinimumFixedRaw ) );  			}  			else if ( header == MessagePackCode.Str8 || header == MessagePackCode.Bin8 )  			{  				var bytes = ReadBytes( source' sizeof( byte ) );  				unchecked  				{  					return bytes[ 0 ];  				}  			}  			else if ( header == MessagePackCode.Raw16 || header == MessagePackCode.Bin16 )  			{  				var bytes = ReadBytes( source' sizeof( short ) );  				unchecked  				{  					ushort buffer = bytes[ 1 ];  					buffer |= ( ushort )( bytes[ 0 ] << 8 );  					return buffer;  				}  			}  			else if ( header == MessagePackCode.Raw32 || header == MessagePackCode.Bin32 )  			{  				var bytes = ReadBytes( source' sizeof( int ) );  				unchecked  				{  					uint buffer = bytes[ 3 ];  					buffer |= ( uint )( bytes[ 2 ] << 8 );  					buffer |= ( uint )( bytes[ 1 ] << 16 );  					buffer |= ( uint )( bytes[ 0 ] << 24 );  					return buffer;  				}  			}  			else  			{  				throw new MessageTypeException( "The underlying stream is not raw type." );  			}
Magic Number,MsgPack,Unpacking,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.cs,UnpackRawLengthCore,The following statement contains a magic number: if ( header == MessagePackCode.NilValue )  			{  				// Nil should be as empty stream because returning byte stream should not be null.  				return 0;  			}  			else if ( MessagePackCode.MinimumFixedRaw <= header && header <= MessagePackCode.MaximumFixedRaw )  			{  				return unchecked( ( uint )( header - MessagePackCode.MinimumFixedRaw ) );  			}  			else if ( header == MessagePackCode.Str8 || header == MessagePackCode.Bin8 )  			{  				var bytes = ReadBytes( source' sizeof( byte ) );  				unchecked  				{  					return bytes[ 0 ];  				}  			}  			else if ( header == MessagePackCode.Raw16 || header == MessagePackCode.Bin16 )  			{  				var bytes = ReadBytes( source' sizeof( short ) );  				unchecked  				{  					ushort buffer = bytes[ 1 ];  					buffer |= ( ushort )( bytes[ 0 ] << 8 );  					return buffer;  				}  			}  			else if ( header == MessagePackCode.Raw32 || header == MessagePackCode.Bin32 )  			{  				var bytes = ReadBytes( source' sizeof( int ) );  				unchecked  				{  					uint buffer = bytes[ 3 ];  					buffer |= ( uint )( bytes[ 2 ] << 8 );  					buffer |= ( uint )( bytes[ 1 ] << 16 );  					buffer |= ( uint )( bytes[ 0 ] << 24 );  					return buffer;  				}  			}  			else  			{  				throw new MessageTypeException( "The underlying stream is not raw type." );  			}
Magic Number,MsgPack,Unpacking,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.cs,UnpackRawLengthCore,The following statement contains a magic number: if ( header == MessagePackCode.NilValue )  			{  				// Nil should be as empty stream because returning byte stream should not be null.  				return 0;  			}  			else if ( MessagePackCode.MinimumFixedRaw <= header && header <= MessagePackCode.MaximumFixedRaw )  			{  				return unchecked( ( uint )( header - MessagePackCode.MinimumFixedRaw ) );  			}  			else if ( header == MessagePackCode.Str8 || header == MessagePackCode.Bin8 )  			{  				var bytes = ReadBytes( source' sizeof( byte ) );  				unchecked  				{  					return bytes[ 0 ];  				}  			}  			else if ( header == MessagePackCode.Raw16 || header == MessagePackCode.Bin16 )  			{  				var bytes = ReadBytes( source' sizeof( short ) );  				unchecked  				{  					ushort buffer = bytes[ 1 ];  					buffer |= ( ushort )( bytes[ 0 ] << 8 );  					return buffer;  				}  			}  			else if ( header == MessagePackCode.Raw32 || header == MessagePackCode.Bin32 )  			{  				var bytes = ReadBytes( source' sizeof( int ) );  				unchecked  				{  					uint buffer = bytes[ 3 ];  					buffer |= ( uint )( bytes[ 2 ] << 8 );  					buffer |= ( uint )( bytes[ 1 ] << 16 );  					buffer |= ( uint )( bytes[ 0 ] << 24 );  					return buffer;  				}  			}  			else  			{  				throw new MessageTypeException( "The underlying stream is not raw type." );  			}
Magic Number,MsgPack,Unpacking,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.cs,UnpackRawLengthCore,The following statement contains a magic number: if ( header == MessagePackCode.NilValue )  			{  				// Nil should be as empty stream because returning byte stream should not be null.  				return 0;  			}  			else if ( MessagePackCode.MinimumFixedRaw <= header && header <= MessagePackCode.MaximumFixedRaw )  			{  				return unchecked( ( uint )( header - MessagePackCode.MinimumFixedRaw ) );  			}  			else if ( header == MessagePackCode.Str8 || header == MessagePackCode.Bin8 )  			{  				var bytes = ReadBytes( source' sizeof( byte ) );  				unchecked  				{  					return bytes[ 0 ];  				}  			}  			else if ( header == MessagePackCode.Raw16 || header == MessagePackCode.Bin16 )  			{  				var bytes = ReadBytes( source' sizeof( short ) );  				unchecked  				{  					ushort buffer = bytes[ 1 ];  					buffer |= ( ushort )( bytes[ 0 ] << 8 );  					return buffer;  				}  			}  			else if ( header == MessagePackCode.Raw32 || header == MessagePackCode.Bin32 )  			{  				var bytes = ReadBytes( source' sizeof( int ) );  				unchecked  				{  					uint buffer = bytes[ 3 ];  					buffer |= ( uint )( bytes[ 2 ] << 8 );  					buffer |= ( uint )( bytes[ 1 ] << 16 );  					buffer |= ( uint )( bytes[ 0 ] << 24 );  					return buffer;  				}  			}  			else  			{  				throw new MessageTypeException( "The underlying stream is not raw type." );  			}
Magic Number,MsgPack,Unpacking,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.cs,UnpackRawLengthCore,The following statement contains a magic number: if ( header == MessagePackCode.NilValue )  			{  				// Nil should be as empty stream because returning byte stream should not be null.  				return 0;  			}  			else if ( MessagePackCode.MinimumFixedRaw <= header && header <= MessagePackCode.MaximumFixedRaw )  			{  				return unchecked( ( uint )( header - MessagePackCode.MinimumFixedRaw ) );  			}  			else if ( header == MessagePackCode.Str8 || header == MessagePackCode.Bin8 )  			{  				var bytes = ReadBytes( source' sizeof( byte ) );  				unchecked  				{  					return bytes[ 0 ];  				}  			}  			else if ( header == MessagePackCode.Raw16 || header == MessagePackCode.Bin16 )  			{  				var bytes = ReadBytes( source' sizeof( short ) );  				unchecked  				{  					ushort buffer = bytes[ 1 ];  					buffer |= ( ushort )( bytes[ 0 ] << 8 );  					return buffer;  				}  			}  			else if ( header == MessagePackCode.Raw32 || header == MessagePackCode.Bin32 )  			{  				var bytes = ReadBytes( source' sizeof( int ) );  				unchecked  				{  					uint buffer = bytes[ 3 ];  					buffer |= ( uint )( bytes[ 2 ] << 8 );  					buffer |= ( uint )( bytes[ 1 ] << 16 );  					buffer |= ( uint )( bytes[ 0 ] << 24 );  					return buffer;  				}  			}  			else  			{  				throw new MessageTypeException( "The underlying stream is not raw type." );  			}
Magic Number,MsgPack,Unpacking,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.cs,UnpackRawLengthCore,The following statement contains a magic number: if ( header == MessagePackCode.NilValue )  			{  				// Nil should be as empty stream because returning byte stream should not be null.  				return 0;  			}  			else if ( MessagePackCode.MinimumFixedRaw <= header && header <= MessagePackCode.MaximumFixedRaw )  			{  				return unchecked( ( uint )( header - MessagePackCode.MinimumFixedRaw ) );  			}  			else if ( header == MessagePackCode.Str8 || header == MessagePackCode.Bin8 )  			{  				var bytes = ReadBytes( source' sizeof( byte ) );  				unchecked  				{  					return bytes[ 0 ];  				}  			}  			else if ( header == MessagePackCode.Raw16 || header == MessagePackCode.Bin16 )  			{  				var bytes = ReadBytes( source' sizeof( short ) );  				unchecked  				{  					ushort buffer = bytes[ 1 ];  					buffer |= ( ushort )( bytes[ 0 ] << 8 );  					return buffer;  				}  			}  			else if ( header == MessagePackCode.Raw32 || header == MessagePackCode.Bin32 )  			{  				var bytes = ReadBytes( source' sizeof( int ) );  				unchecked  				{  					uint buffer = bytes[ 3 ];  					buffer |= ( uint )( bytes[ 2 ] << 8 );  					buffer |= ( uint )( bytes[ 1 ] << 16 );  					buffer |= ( uint )( bytes[ 0 ] << 24 );  					return buffer;  				}  			}  			else  			{  				throw new MessageTypeException( "The underlying stream is not raw type." );  			}
Magic Number,MsgPack.Serialization,DefaultConcreteTypeRepository,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultConcreteTypeRepository.cs,DefaultConcreteTypeRepository,The following statement contains a magic number: this._defaultCollectionTypes = new TypeKeyRepository(  				new Dictionary<RuntimeTypeHandle' object>(  #if NET35 || ( SILVERLIGHT && !WINDOWS_PHONE )  					8  #elif NET40  					9  #else  					12  #endif  				)  				{  					{ typeof( IEnumerable<> ).TypeHandle' typeof( List<> ) }'  					{ typeof( ICollection<> ).TypeHandle' typeof( List<> ) }'  					{ typeof( IList<> ).TypeHandle' typeof( List<> ) }'  					{ typeof( IDictionary<'> ).TypeHandle' typeof( Dictionary<'> ) }'  					{ typeof( IEnumerable ).TypeHandle' typeof( List<MessagePackObject> ) }'  					{ typeof( ICollection ).TypeHandle' typeof( List<MessagePackObject> ) }'  					{ typeof( IList ).TypeHandle' typeof( List<MessagePackObject> ) }'  					{ typeof( IDictionary ).TypeHandle' typeof( MessagePackObjectDictionary ) }'  #if !NET35 && !UNITY  					{ typeof( ISet<> ).TypeHandle' typeof( HashSet<> ) }'  #if !NET40 && !( SILVERLIGHT && !WINDOWS_PHONE )  					{ typeof( IReadOnlyCollection<> ).TypeHandle' typeof( List<> ) }'  					{ typeof( IReadOnlyList<> ).TypeHandle' typeof( List<> ) }'  					{ typeof( IReadOnlyDictionary<'> ).TypeHandle' typeof( Dictionary<'> ) }'  #endif // !NET40 && !( SILVERLIGHT && !WINDOWS_PHONE )  #endif // !NET35 && !UNITY  				}  			);
Magic Number,MsgPack.Serialization,ExtTypeCodeMapping,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ExtTypeCodeMapping.cs,ExtTypeCodeMapping,The following statement contains a magic number: this._index = new Dictionary<string' byte>( 2 );
Magic Number,MsgPack.Serialization,ExtTypeCodeMapping,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ExtTypeCodeMapping.cs,ExtTypeCodeMapping,The following statement contains a magic number: this._types = new Dictionary<byte' string>( 2 );
Magic Number,MsgPack.Serialization,KeyNameTransformers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\KeyNameTransformers.cs,ToUpperSnake,The following statement contains a magic number: var buffer = new StringBuilder( mayBeUpperCamel.Length * 2 );
Magic Number,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: const int withCapacity = 10;
Magic Number,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: const int withComparer = 11;
Magic Number,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: const int withComparerAndCapacity = 20;
Magic Number,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: const int withCapacityAndComparer = 21;
Magic Number,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following statement contains a magic number: foreach ( var candidate in instanceType.GetConstructors() )  			{  				var parameters = candidate.GetParameters();  				switch ( parameters.Length )  				{  					case 0:  					{  						if ( currentScore < noParameters )  						{  							constructor = candidate;  							currentScore = noParameters;  						}    						break;  					}  					case 1:  					{  						if ( currentScore < withCapacity && parameters[ 0 ].ParameterType == typeof( int ) )  						{  							constructor = candidate;  							currentScore = noParameters;  						}  						else if ( currentScore < withComparer && IsIEqualityComparer( parameters[ 0 ].ParameterType ) )  						{  							constructor = candidate;  							currentScore = noParameters;  						}  						break;  					}  					case 2:  					{  						if ( currentScore < withCapacityAndComparer && parameters[ 0 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 1 ].ParameterType ) )  						{  							constructor = candidate;  							currentScore = withCapacityAndComparer;  						}  						else if ( currentScore < withComparerAndCapacity && parameters[ 1 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 0 ].ParameterType ) )  						{  							constructor = candidate;  							currentScore = withComparerAndCapacity;  						}    						break;  					}  				}  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,ArraySerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\ArraySerializer.cs,InitializeArraySerializerFactories,The following statement contains a magic number: return  				new Dictionary<Type' Func<SerializationContext'object>>( 25 )  				{  					{ typeof( SByte[] )' context => new SByteArraySerializer( context ) }'  					{ typeof( SByte?[] )'context => new NullableSByteArraySerializer( context ) }'  					{ typeof( Int16[] )' context => new Int16ArraySerializer( context ) }'  					{ typeof( Int16?[] )'context => new NullableInt16ArraySerializer( context ) }'  					{ typeof( Int32[] )' context => new Int32ArraySerializer( context ) }'  					{ typeof( Int32?[] )'context => new NullableInt32ArraySerializer( context ) }'  					{ typeof( Int64[] )' context => new Int64ArraySerializer( context ) }'  					{ typeof( Int64?[] )'context => new NullableInt64ArraySerializer( context ) }'  					{ typeof( Byte[] )' context => new ByteArraySerializer( context ) }'  					{ typeof( Byte?[] )'context => new NullableByteArraySerializer( context ) }'  					{ typeof( UInt16[] )' context => new UInt16ArraySerializer( context ) }'  					{ typeof( UInt16?[] )'context => new NullableUInt16ArraySerializer( context ) }'  					{ typeof( UInt32[] )' context => new UInt32ArraySerializer( context ) }'  					{ typeof( UInt32?[] )'context => new NullableUInt32ArraySerializer( context ) }'  					{ typeof( UInt64[] )' context => new UInt64ArraySerializer( context ) }'  					{ typeof( UInt64?[] )'context => new NullableUInt64ArraySerializer( context ) }'  					{ typeof( Single[] )' context => new SingleArraySerializer( context ) }'  					{ typeof( Single?[] )'context => new NullableSingleArraySerializer( context ) }'  					{ typeof( Double[] )' context => new DoubleArraySerializer( context ) }'  					{ typeof( Double?[] )'context => new NullableDoubleArraySerializer( context ) }'  					{ typeof( Boolean[] )' context => new BooleanArraySerializer( context ) }'  					{ typeof( Boolean?[] )'context => new NullableBooleanArraySerializer( context ) }'  					{ typeof( string[] )' context => new StringArraySerializer( context ) }'  					{ typeof( byte[][] )' context => new BinaryArraySerializer( context ) }'  					{ typeof( MessagePackObject[] )' context => new MessagePackObjectArraySerializer( context ) }'  				};
Magic Number,MsgPack.Serialization.DefaultSerializers,DateTimeOffsetMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeOffsetMessagePackSerializer.cs,PackToCore,The following statement contains a magic number: if ( this._conversion == DateTimeConversionMethod.Timestamp )  			{  				packer.Pack( Timestamp.FromDateTimeOffset( objectTree ).Encode() );  			}  			else if ( this._conversion == DateTimeConversionMethod.Native )  			{  				packer.PackArrayHeader( 2 );  				packer.Pack( objectTree.DateTime.ToBinary() );  				unchecked  				{  					packer.Pack( ( short )( objectTree.Offset.Hours * 60 + objectTree.Offset.Minutes ) );  				}  			}  			else  			{  #if DEBUG  				Contract.Assert( this._conversion == DateTimeConversionMethod.UnixEpoc );  #endif // DEBUG  				packer.Pack( MessagePackConvert.FromDateTimeOffset( objectTree ) );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,DateTimeOffsetMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeOffsetMessagePackSerializer.cs,PackToCore,The following statement contains a magic number: if ( this._conversion == DateTimeConversionMethod.Timestamp )  			{  				packer.Pack( Timestamp.FromDateTimeOffset( objectTree ).Encode() );  			}  			else if ( this._conversion == DateTimeConversionMethod.Native )  			{  				packer.PackArrayHeader( 2 );  				packer.Pack( objectTree.DateTime.ToBinary() );  				unchecked  				{  					packer.Pack( ( short )( objectTree.Offset.Hours * 60 + objectTree.Offset.Minutes ) );  				}  			}  			else  			{  #if DEBUG  				Contract.Assert( this._conversion == DateTimeConversionMethod.UnixEpoc );  #endif // DEBUG  				packer.Pack( MessagePackConvert.FromDateTimeOffset( objectTree ) );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,DateTimeOffsetMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeOffsetMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: if ( unpacker.LastReadData.IsTypeOf<MessagePackExtendedTypeObject>().GetValueOrDefault() )  			{  				return Timestamp.Decode( unpacker.LastReadData.DeserializeAsMessagePackExtendedTypeObject() ).ToDateTimeOffset();  			}  			else if ( unpacker.IsArrayHeader )  			{  				if ( UnpackHelpers.GetItemsCount( unpacker ) != 2 )  				{  					SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( DateTimeOffset )' 2 );  				}    				long ticks;  				if ( !unpacker.ReadInt64( out ticks ) )  				{  					SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  				}    				short offsetMinutes;  				if ( !unpacker.ReadInt16( out offsetMinutes ) )  				{  					SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  				}    				return new DateTimeOffset( DateTime.FromBinary( ticks )' TimeSpan.FromMinutes( offsetMinutes ) );  			}  			else  			{  				return MessagePackConvert.ToDateTimeOffset( unpacker.LastReadData.DeserializeAsInt64() );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,DateTimeOffsetMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeOffsetMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: if ( unpacker.LastReadData.IsTypeOf<MessagePackExtendedTypeObject>().GetValueOrDefault() )  			{  				return Timestamp.Decode( unpacker.LastReadData.DeserializeAsMessagePackExtendedTypeObject() ).ToDateTimeOffset();  			}  			else if ( unpacker.IsArrayHeader )  			{  				if ( UnpackHelpers.GetItemsCount( unpacker ) != 2 )  				{  					SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( DateTimeOffset )' 2 );  				}    				long ticks;  				if ( !unpacker.ReadInt64( out ticks ) )  				{  					SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  				}    				short offsetMinutes;  				if ( !unpacker.ReadInt16( out offsetMinutes ) )  				{  					SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  				}    				return new DateTimeOffset( DateTime.FromBinary( ticks )' TimeSpan.FromMinutes( offsetMinutes ) );  			}  			else  			{  				return MessagePackConvert.ToDateTimeOffset( unpacker.LastReadData.DeserializeAsInt64() );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,DateTimeOffsetMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeOffsetMessagePackSerializer.cs,PackToAsyncCore,The following statement contains a magic number: if ( this._conversion == DateTimeConversionMethod.Timestamp )  			{  				await packer.PackAsync( Timestamp.FromDateTimeOffset( objectTree ).Encode()' cancellationToken ).ConfigureAwait( false );  			}  			else if ( this._conversion == DateTimeConversionMethod.Native )  			{  				await packer.PackArrayHeaderAsync( 2' cancellationToken ).ConfigureAwait( false );  				await packer.PackAsync( objectTree.DateTime.ToBinary()' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await packer.PackAsync( ( short )( objectTree.Offset.Hours * 60 + objectTree.Offset.Minutes )' cancellationToken ).ConfigureAwait( false );  				}  			}  			else  			{  #if DEBUG  				Contract.Assert( this._conversion == DateTimeConversionMethod.UnixEpoc );  #endif // DEBUG  				await packer.PackAsync( MessagePackConvert.FromDateTimeOffset( objectTree )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,DateTimeOffsetMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeOffsetMessagePackSerializer.cs,PackToAsyncCore,The following statement contains a magic number: if ( this._conversion == DateTimeConversionMethod.Timestamp )  			{  				await packer.PackAsync( Timestamp.FromDateTimeOffset( objectTree ).Encode()' cancellationToken ).ConfigureAwait( false );  			}  			else if ( this._conversion == DateTimeConversionMethod.Native )  			{  				await packer.PackArrayHeaderAsync( 2' cancellationToken ).ConfigureAwait( false );  				await packer.PackAsync( objectTree.DateTime.ToBinary()' cancellationToken ).ConfigureAwait( false );  				unchecked  				{  					await packer.PackAsync( ( short )( objectTree.Offset.Hours * 60 + objectTree.Offset.Minutes )' cancellationToken ).ConfigureAwait( false );  				}  			}  			else  			{  #if DEBUG  				Contract.Assert( this._conversion == DateTimeConversionMethod.UnixEpoc );  #endif // DEBUG  				await packer.PackAsync( MessagePackConvert.FromDateTimeOffset( objectTree )' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,InternalDateTimeExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\InternalDateTimeExtensions.cs,ToDateTime,The following statement contains a magic number: return  				_fileTimeEpocUtc.AddTicks(  					unchecked( ( ( long )source.dwHighDateTime << 32 ) | ( source.dwLowDateTime & 0xffffffff ) )  				);
Magic Number,MsgPack.Serialization.DefaultSerializers,InternalDateTimeExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\InternalDateTimeExtensions.cs,ToWin32FileTimeUtc,The following statement contains a magic number: return  				new FILETIME  				{  					dwHighDateTime = unchecked( ( int ) ( value >> 32 ) )'  					dwLowDateTime = unchecked( ( int ) ( value & 0xffffffff ) )  				};
Magic Number,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,PackArrayCore,The following statement contains a magic number: packer.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,PackArrayCore,The following statement contains a magic number: using ( var buffer = new MemoryStream() )  			using ( var bodyPacker = Packer.Create( buffer' false ) )  			{  				bodyPacker.PackArrayHeader( 2 );  				this._int32ArraySerializer.PackTo( bodyPacker' lengths );  				this._int32ArraySerializer.PackTo( bodyPacker' lowerBounds );  				packer.PackExtendedTypeValue( this.OwnerContext.ExtTypeCodeMapping[ KnownExtTypeName.MultidimensionalArray ]' buffer.ToArray() );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromCore,The following statement contains a magic number: if ( UnpackHelpers.GetItemsCount( unpacker ) != 2 )  			{  				SerializationExceptions.ThrowSerializationException( "Multidimensional array must be encoded as 2 element array." );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromCore,The following statement contains a magic number: using ( var wholeUnpacker = unpacker.ReadSubtree() )  			{  				if ( !wholeUnpacker.Read() )  				{  					SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  				}    				MessagePackExtendedTypeObject metadata;  				try  				{  					metadata = wholeUnpacker.LastReadData.AsMessagePackExtendedTypeObject();  				}  				catch ( InvalidOperationException ex )  				{  					SerializationExceptions.ThrowSerializationException( "Multidimensional array must be encoded as ext type."' ex );  					metadata = default ( MessagePackExtendedTypeObject ); // never reaches  				}    				if ( metadata.TypeCode != this.OwnerContext.ExtTypeCodeMapping[ KnownExtTypeName.MultidimensionalArray ] )  				{  					SerializationExceptions.ThrowSerializationException(  						String.Format(  							CultureInfo.CurrentCulture'  							"Multidimensional array must be encoded as ext type 0x{0:X2}."'  							this.OwnerContext.ExtTypeCodeMapping[ KnownExtTypeName.MultidimensionalArray ]  							)  						);  				}    				int[] lengths' lowerBounds;    				using ( var arrayMetadata = new MemoryStream( metadata.Body ) )  				using ( var metadataUnpacker = Unpacker.Create( arrayMetadata' false ) )  				{  					if ( !metadataUnpacker.Read() )  					{  						SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  					}    					if ( !metadataUnpacker.IsArrayHeader )  					{  						SerializationExceptions.ThrowIsNotArrayHeader( unpacker );  					}    					if ( UnpackHelpers.GetItemsCount( metadataUnpacker ) != 2 )  					{  						SerializationExceptions.ThrowSerializationException( "Multidimensional metadata array must be encoded as 2 element array." );  					}    					this.ReadArrayMetadata( metadataUnpacker' out lengths' out lowerBounds );  				}    #if SILVERLIGHT  				// Simulate lowerbounds because Array.Initialize() in Silverlight does not support lowerbounds.  				var inflatedLengths = new int[ lengths.Length ];  				for ( var i = 0; i < lowerBounds.Length; i++ )  				{  					inflatedLengths[ i ] = lengths[ i ] + lowerBounds[ i ];  				}    #endif // SILVERLIGHT  				if ( !wholeUnpacker.Read() )  				{  					SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  				}    				if ( !wholeUnpacker.IsArrayHeader )  				{  					SerializationExceptions.ThrowIsNotArrayHeader( unpacker );  				}    				using ( var arrayUnpacker = wholeUnpacker.ReadSubtree() )  				{  					var result =  						Array.CreateInstance(  #if !UNITY  							typeof( TItem )'  #else  							this._itemType'  #endif // !UNITY  #if !SILVERLIGHT  							lengths'  							lowerBounds  #else  							inflatedLengths  #endif // !SILVERLIGHT  						);    					var totalLength = UnpackHelpers.GetItemsCount( arrayUnpacker );  					if ( totalLength > 0 )  					{  						ForEach(  							result'  							totalLength'  							lowerBounds'  							lengths'  							indices =>  							{  								// ReSharper disable AccessToDisposedClosure  								if ( !arrayUnpacker.Read() )  								{  									SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  								}    								result.SetValue(  									this._itemSerializer.UnpackFrom( arrayUnpacker )'  									indices  								);  								// ReSharper restore AccessToDisposedClosure  							}  						);  					}    #if !UNITY  					return ( TArray ) ( object ) result;  #else  					return result;  #endif // !UNITY  				}  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,PackArrayAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 2' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,PackArrayAsyncCore,The following statement contains a magic number: using ( var buffer = new MemoryStream() )  			using ( var bodyPacker = Packer.Create( buffer' false ) )  			{  				await bodyPacker.PackArrayHeaderAsync( 2' cancellationToken ).ConfigureAwait( false );  				await this._int32ArraySerializer.PackToAsync( bodyPacker' lengths' cancellationToken ).ConfigureAwait( false );  				await this._int32ArraySerializer.PackToAsync( bodyPacker' lowerBounds' cancellationToken ).ConfigureAwait( false );  				await packer.PackExtendedTypeValueAsync( this.OwnerContext.ExtTypeCodeMapping[ KnownExtTypeName.MultidimensionalArray ]' buffer.ToArray()' cancellationToken ).ConfigureAwait( false );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( UnpackHelpers.GetItemsCount( unpacker ) != 2 )  			{  				SerializationExceptions.ThrowSerializationException( "Multidimensional array must be encoded as 2 element array." );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,MultidimensionalArraySerializer<TArray;TItem>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\MultidimensionalArraySerializer`1.cs,UnpackFromAsyncCore,The following statement contains a magic number: using ( var wholeUnpacker = unpacker.ReadSubtree() )  			{  				if ( !await wholeUnpacker.ReadAsync( cancellationToken ).ConfigureAwait( false ) )  				{  					SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  				}    				MessagePackExtendedTypeObject metadata;  				try  				{  					metadata = wholeUnpacker.LastReadData.AsMessagePackExtendedTypeObject();  				}  				catch ( InvalidOperationException ex )  				{  					SerializationExceptions.ThrowSerializationException( "Multidimensional array must be encoded as ext type."' ex );  					metadata = default( MessagePackExtendedTypeObject ); // never reaches  				}    				if ( metadata.TypeCode != this.OwnerContext.ExtTypeCodeMapping[ KnownExtTypeName.MultidimensionalArray ] )  				{  					SerializationExceptions.ThrowSerializationException(  						String.Format(  							CultureInfo.CurrentCulture'  							"Multidimensional array must be encoded as ext type 0x{0:X2}."'  							this.OwnerContext.ExtTypeCodeMapping[ KnownExtTypeName.MultidimensionalArray ]  							)  						);  				}    				Tuple<int[]' int[]> lengthsAndLowerBounds;    				using ( var arrayMetadata = new MemoryStream( metadata.Body ) )  				using ( var metadataUnpacker = Unpacker.Create( arrayMetadata' false ) )  				{  					if ( !metadataUnpacker.Read() )  					{  						SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  					}    					if ( !metadataUnpacker.IsArrayHeader )  					{  						SerializationExceptions.ThrowIsNotArrayHeader( unpacker );  					}    					if ( UnpackHelpers.GetItemsCount( metadataUnpacker ) != 2 )  					{  						SerializationExceptions.ThrowSerializationException( "Multidimensional metadata array must be encoded as 2 element array." );  					}    					lengthsAndLowerBounds = await this.ReadArrayMetadataAsync( metadataUnpacker' cancellationToken ).ConfigureAwait( false );  				}    				if ( !await wholeUnpacker.ReadAsync( cancellationToken ).ConfigureAwait( false ) )  				{  					SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  				}    				if ( !wholeUnpacker.IsArrayHeader )  				{  					SerializationExceptions.ThrowIsNotArrayHeader( unpacker );  				}    				using ( var arrayUnpacker = wholeUnpacker.ReadSubtree() )  				{  					var result =  						Array.CreateInstance( typeof( TItem )' lengthsAndLowerBounds.Item1' lengthsAndLowerBounds.Item2 );    					var totalLength = UnpackHelpers.GetItemsCount( arrayUnpacker );  					if ( totalLength > 0 )  					{  						await ForEachAsync(  							result'  							totalLength'  							lengthsAndLowerBounds.Item2'  							lengthsAndLowerBounds.Item1'  							async indices =>  							{  								// ReSharper disable AccessToDisposedClosure  								if ( !await arrayUnpacker.ReadAsync( cancellationToken ).ConfigureAwait( false ) )  								{  									SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  								}    								result.SetValue(  									await this._itemSerializer.UnpackFromAsync( arrayUnpacker' cancellationToken ).ConfigureAwait( false )'  									indices  								);  								// ReSharper restore AccessToDisposedClosure  							}  						).ConfigureAwait( false );  					}    					return ( TArray )( object )result;  				}  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.IsArrayHeader )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector2 )' 2 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 2 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector2 )' 2 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 2 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector2 )' 2 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 2' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !unpacker.IsArrayHeader )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector2 )' 2 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( length != 2 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector2 )' 2 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( length != 2 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector2 )' 2 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 3 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.IsArrayHeader )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector3 )' 3 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 3 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector3 )' 3 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 3 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector3 )' 3 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out z ) )  			{  				SerializationExceptions.ThrowMissingItem( 2' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 3' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !unpacker.IsArrayHeader )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector3 )' 3 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( length != 3 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector3 )' 3 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( length != 3 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector3 )' 3 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector3MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !z.Success )  			{  				SerializationExceptions.ThrowMissingItem( 2' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.IsArrayHeader )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector4 )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 4 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector4 )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 4 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector4 )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out z ) )  			{  				SerializationExceptions.ThrowMissingItem( 2' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out w ) )  			{  				SerializationExceptions.ThrowMissingItem( 3' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 4' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !unpacker.IsArrayHeader )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector4 )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( length != 4 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector4 )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( length != 4 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Vector4 )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !z.Success )  			{  				SerializationExceptions.ThrowMissingItem( 2' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Vector4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !w.Success )  			{  				SerializationExceptions.ThrowMissingItem( 3' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.IsArrayHeader )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Plane )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 4 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Plane )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 4 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Plane )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out normal_Z ) )  			{  				SerializationExceptions.ThrowMissingItem( 2' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out d ) )  			{  				SerializationExceptions.ThrowMissingItem( 3' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 4' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !unpacker.IsArrayHeader )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Plane )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( length != 4 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Plane )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( length != 4 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Plane )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !normal_Z.Success )  			{  				SerializationExceptions.ThrowMissingItem( 2' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_PlaneMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !d.Success )  			{  				SerializationExceptions.ThrowMissingItem( 3' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.IsArrayHeader )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Quaternion )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 4 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Quaternion )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 4 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Quaternion )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out z ) )  			{  				SerializationExceptions.ThrowMissingItem( 2' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out w ) )  			{  				SerializationExceptions.ThrowMissingItem( 3' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 4' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !unpacker.IsArrayHeader )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Quaternion )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( length != 4 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Quaternion )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( length != 4 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Quaternion )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !z.Success )  			{  				SerializationExceptions.ThrowMissingItem( 2' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_QuaternionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !w.Success )  			{  				SerializationExceptions.ThrowMissingItem( 3' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 6 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.IsArrayHeader )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix3x2 )' 6 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 6 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix3x2 )' 6 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 6 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix3x2 )' 6 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out m21 ) )  			{  				SerializationExceptions.ThrowMissingItem( 2' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out m22 ) )  			{  				SerializationExceptions.ThrowMissingItem( 3' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out m31 ) )  			{  				SerializationExceptions.ThrowMissingItem( 4' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out m32 ) )  			{  				SerializationExceptions.ThrowMissingItem( 5' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 6' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !unpacker.IsArrayHeader )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix3x2 )' 6 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( length != 6 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix3x2 )' 6 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( length != 6 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix3x2 )' 6 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !m21.Success )  			{  				SerializationExceptions.ThrowMissingItem( 2' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !m22.Success )  			{  				SerializationExceptions.ThrowMissingItem( 3' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !m31.Success )  			{  				SerializationExceptions.ThrowMissingItem( 4' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix3x2MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !m32.Success )  			{  				SerializationExceptions.ThrowMissingItem( 5' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 16 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.IsArrayHeader )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix4x4 )' 16 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 16 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix4x4 )' 16 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 16 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix4x4 )' 16 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out m13 ) )  			{  				SerializationExceptions.ThrowMissingItem( 2' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out m14 ) )  			{  				SerializationExceptions.ThrowMissingItem( 3' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out m21 ) )  			{  				SerializationExceptions.ThrowMissingItem( 4' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out m22 ) )  			{  				SerializationExceptions.ThrowMissingItem( 5' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out m23 ) )  			{  				SerializationExceptions.ThrowMissingItem( 6' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out m24 ) )  			{  				SerializationExceptions.ThrowMissingItem( 7' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out m31 ) )  			{  				SerializationExceptions.ThrowMissingItem( 8' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out m32 ) )  			{  				SerializationExceptions.ThrowMissingItem( 9' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out m33 ) )  			{  				SerializationExceptions.ThrowMissingItem( 10' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out m34 ) )  			{  				SerializationExceptions.ThrowMissingItem( 11' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out m41 ) )  			{  				SerializationExceptions.ThrowMissingItem( 12' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out m42 ) )  			{  				SerializationExceptions.ThrowMissingItem( 13' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out m43 ) )  			{  				SerializationExceptions.ThrowMissingItem( 14' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadSingle( out m44 ) )  			{  				SerializationExceptions.ThrowMissingItem( 15' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 16' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !unpacker.IsArrayHeader )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix4x4 )' 16 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( length != 16 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix4x4 )' 16 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( length != 16 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Matrix4x4 )' 16 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !m13.Success )  			{  				SerializationExceptions.ThrowMissingItem( 2' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !m14.Success )  			{  				SerializationExceptions.ThrowMissingItem( 3' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !m21.Success )  			{  				SerializationExceptions.ThrowMissingItem( 4' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !m22.Success )  			{  				SerializationExceptions.ThrowMissingItem( 5' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !m23.Success )  			{  				SerializationExceptions.ThrowMissingItem( 6' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !m24.Success )  			{  				SerializationExceptions.ThrowMissingItem( 7' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !m31.Success )  			{  				SerializationExceptions.ThrowMissingItem( 8' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !m32.Success )  			{  				SerializationExceptions.ThrowMissingItem( 9' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !m33.Success )  			{  				SerializationExceptions.ThrowMissingItem( 10' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !m34.Success )  			{  				SerializationExceptions.ThrowMissingItem( 11' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !m41.Success )  			{  				SerializationExceptions.ThrowMissingItem( 12' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !m42.Success )  			{  				SerializationExceptions.ThrowMissingItem( 13' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !m43.Success )  			{  				SerializationExceptions.ThrowMissingItem( 14' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_Matrix4x4MessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\SimdTypeSerializers.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !m44.Success )  			{  				SerializationExceptions.ThrowMissingItem( 15' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Collections_DictionaryEntryMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_DictionaryEntryMessagePackSerializer.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Collections_DictionaryEntryMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_DictionaryEntryMessagePackSerializer.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 2' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_KeyValuePair_2MessagePackSerializer<TKey;TValue>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_KeyValuePair_2MessagePackSerializer`2.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Collections_Generic_KeyValuePair_2MessagePackSerializer<TKey;TValue>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_Generic_KeyValuePair_2MessagePackSerializer`2.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 2' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_ComplexMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Numerics_ComplexMessagePackSerializer.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_ComplexMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Numerics_ComplexMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.IsArrayHeader )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Complex )' 2 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_ComplexMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Numerics_ComplexMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 2 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Complex )' 2 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_ComplexMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Numerics_ComplexMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 2 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Complex )' 2 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_Numerics_ComplexMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Numerics_ComplexMessagePackSerializer.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 2' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,PackToCore,The following statement contains a magic number: packer.PackArrayHeader( 4 );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.IsArrayHeader )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Version )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 4 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Version )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: if ( length != 4 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Version )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadInt32( out build ) )  			{  				SerializationExceptions.ThrowMissingItem( 2' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromCore,The following statement contains a magic number: if ( !unpacker.ReadInt32( out revision ) )  			{  				SerializationExceptions.ThrowMissingItem( 3' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,PackToAsyncCore,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 4' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !unpacker.IsArrayHeader )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Version )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( length != 4 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Version )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( length != 4 )  			{  				SerializationExceptions.ThrowInvalidArrayItemsCount( unpacker' typeof( Version )' 4 );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !build.Success )  			{  				SerializationExceptions.ThrowMissingItem( 2' unpacker );  			}
Magic Number,MsgPack.Serialization.DefaultSerializers,System_VersionMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_VersionMessagePackSerializer.cs,UnpackFromAsyncCore,The following statement contains a magic number: if ( !revision.Success )  			{  				SerializationExceptions.ThrowMissingItem( 3' unpacker );  			}
Magic Number,MsgPack.Serialization.Polymorphic,RuntimeTypeVerifier,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\RuntimeTypeVerifier.cs,VerifyCore,The following statement contains a magic number: try  			{  				int count = _resultCache.Count;  				_resultCache[ key ] = result;  				if ( count < _resultCache.Count && CacheSize < _resultCache.Count )  				{  					// Added. Start eviction.  					var removalKey = _histories.Dequeue();  					var removed = _resultCache.Remove( removalKey );  #if ASSERT  					Contract.Assert( removed );  #endif // ASSERT  				}    #if ASSERT  				Contract.Assert( _histories.Count < 1000 );  #endif // ASSERT  				_histories.Enqueue( key );  			}  			finally  			{  				_resultCacheLock.ExitWriteLock();  			}
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: packer.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 2' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: packer.PackArrayHeader( 2 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: packer.PackArrayHeader( 6 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: var version = new byte[ 16 ];
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Major )' 0' version' 0' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Minor )' 0' version' 4' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Minor )' 0' version' 4' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Build )' 0' version' 8' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Build )' 0' version' 8' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Revision )' 0' version' 12' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Encode,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Revision )' 0' version' 12' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 2' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: await packer.PackArrayHeaderAsync( 6' cancellationToken ).ConfigureAwait( false );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: var version = new byte[ 16 ];
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Major )' 0' version' 0' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Minor )' 0' version' 4' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Minor )' 0' version' 4' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Build )' 0' version' 8' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Build )' 0' version' 8' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Revision )' 0' version' 12' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,EncodeAsync,The following statement contains a magic number: Buffer.BlockCopy( BitConverter.GetBytes( assemblyName.Version.Revision )' 0' version' 12' 4 );
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Decode,The following statement contains a magic number: if ( !unpacker.IsArrayHeader || UnpackHelpers.GetItemsCount( unpacker ) != 2 )  			{  				throw SerializationExceptions.NewUnknownTypeEmbedding();  			}
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,Decode,The following statement contains a magic number: if ( !unpacker.IsArrayHeader || UnpackHelpers.GetItemsCount( unpacker ) != 2 )  			{  				throw SerializationExceptions.NewUnknownTypeEmbedding();  			}
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,DecodeAsync,The following statement contains a magic number: if ( !unpacker.IsArrayHeader || UnpackHelpers.GetItemsCount( unpacker ) != 2 )  			{  				throw SerializationExceptions.NewUnknownTypeEmbedding();  			}
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,DecodeAsync,The following statement contains a magic number: if ( !unpacker.IsArrayHeader || UnpackHelpers.GetItemsCount( unpacker ) != 2 )  			{  				throw SerializationExceptions.NewUnknownTypeEmbedding();  			}
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,CheckUnpackerForRuntimeTypeInfoDecoding,The following statement contains a magic number: if ( unpacker.ItemsCount != 6 )  			{  				ThrowEncodedTypeDoesNotHaveValidArrayItems();  			}
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,BuildAssemblyName,The following statement contains a magic number: return  				new AssemblyName(   					String.Format(   						CultureInfo.InvariantCulture'   						"{0}'Version={1}'Culture={2}'PublicKeyToken={3}"'  						assemblySimpleName'  						new Version(  							BitConverter.ToInt32( version' 0 )'  							BitConverter.ToInt32( version' 4 )'  							BitConverter.ToInt32( version' 8 )'  							BitConverter.ToInt32( version' 12 )  						)'  						String.IsNullOrEmpty( culture ) ? "neutral" : culture'  						( publicKeyToken == null || publicKeyToken.Length == 0 ) ? "null" : Binary.ToHexString( publicKeyToken' false )  					)  				);
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,BuildAssemblyName,The following statement contains a magic number: return  				new AssemblyName(   					String.Format(   						CultureInfo.InvariantCulture'   						"{0}'Version={1}'Culture={2}'PublicKeyToken={3}"'  						assemblySimpleName'  						new Version(  							BitConverter.ToInt32( version' 0 )'  							BitConverter.ToInt32( version' 4 )'  							BitConverter.ToInt32( version' 8 )'  							BitConverter.ToInt32( version' 12 )  						)'  						String.IsNullOrEmpty( culture ) ? "neutral" : culture'  						( publicKeyToken == null || publicKeyToken.Length == 0 ) ? "null" : Binary.ToHexString( publicKeyToken' false )  					)  				);
Magic Number,MsgPack.Serialization.Polymorphic,TypeInfoEncoder,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Polymorphic\TypeInfoEncoder.cs,BuildAssemblyName,The following statement contains a magic number: return  				new AssemblyName(   					String.Format(   						CultureInfo.InvariantCulture'   						"{0}'Version={1}'Culture={2}'PublicKeyToken={3}"'  						assemblySimpleName'  						new Version(  							BitConverter.ToInt32( version' 0 )'  							BitConverter.ToInt32( version' 4 )'  							BitConverter.ToInt32( version' 8 )'  							BitConverter.ToInt32( version' 12 )  						)'  						String.IsNullOrEmpty( culture ) ? "neutral" : culture'  						( publicKeyToken == null || publicKeyToken.Length == 0 ) ? "null" : Binary.ToHexString( publicKeyToken' false )  					)  				);
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackAndAddCollectionItem,The following statement contains a magic number: if ( source != null )  			{  				switch ( traits.DetailedCollectionType )  				{  					case CollectionDetailedKind.GenericDictionary:  					{  						// item should be KeyValuePair<TKey' TValue>  						var arguments = new object[ 2 ];  						var key = default( PropertyInfo );  						var value = default( PropertyInfo );  						foreach ( var item in source )  						{  							if ( key == null )  							{  								key = item.GetType().GetProperty( "Key" );  								value = item.GetType().GetProperty( "Value" );  							}    							arguments[ 0 ] = key.GetValue( item' null );  							arguments[ 1 ] = value.GetValue( item' null );  							traits.AddMethod.InvokePreservingExceptionType( destination' arguments );  						}  						break;  					}  					case CollectionDetailedKind.NonGenericDictionary:  					{  						// item should be DictionaryEntry  						var arguments = new object[ 2 ];  						foreach ( var item in source )  						{  							arguments[ 0 ] = ReflectionSerializerHelper.DictionaryEntryKeyProperty.GetValue( item' null );  							arguments[ 1 ] = ReflectionSerializerHelper.DictionaryEntryValueProperty.GetValue( item' null );  							traits.AddMethod.InvokePreservingExceptionType( destination' arguments );  						}  						break;  					}  					default:  					{  						var arguments = new object[ 1 ];  						foreach ( var item in source )  						{  							arguments[ 0 ] = item;  							traits.AddMethod.InvokePreservingExceptionType( destination' arguments );  						}  						break;  					}  				}  			}
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackAndAddCollectionItem,The following statement contains a magic number: if ( source != null )  			{  				switch ( traits.DetailedCollectionType )  				{  					case CollectionDetailedKind.GenericDictionary:  					{  						// item should be KeyValuePair<TKey' TValue>  						var arguments = new object[ 2 ];  						var key = default( PropertyInfo );  						var value = default( PropertyInfo );  						foreach ( var item in source )  						{  							if ( key == null )  							{  								key = item.GetType().GetProperty( "Key" );  								value = item.GetType().GetProperty( "Value" );  							}    							arguments[ 0 ] = key.GetValue( item' null );  							arguments[ 1 ] = value.GetValue( item' null );  							traits.AddMethod.InvokePreservingExceptionType( destination' arguments );  						}  						break;  					}  					case CollectionDetailedKind.NonGenericDictionary:  					{  						// item should be DictionaryEntry  						var arguments = new object[ 2 ];  						foreach ( var item in source )  						{  							arguments[ 0 ] = ReflectionSerializerHelper.DictionaryEntryKeyProperty.GetValue( item' null );  							arguments[ 1 ] = ReflectionSerializerHelper.DictionaryEntryValueProperty.GetValue( item' null );  							traits.AddMethod.InvokePreservingExceptionType( destination' arguments );  						}  						break;  					}  					default:  					{  						var arguments = new object[ 1 ];  						foreach ( var item in source )  						{  							arguments[ 0 ] = item;  							traits.AddMethod.InvokePreservingExceptionType( destination' arguments );  						}  						break;  					}  				}  			}
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackAndAddCollectionItemAsync,The following statement contains a magic number: if ( source != null )  			{  				switch ( traits.DetailedCollectionType )  				{  					case CollectionDetailedKind.GenericDictionary:  					{  						// item should be KeyValuePair<TKey' TValue>  						var arguments = new object[ 2 ];  						var key = default( PropertyInfo );  						var value = default( PropertyInfo );  						foreach ( var item in source )  						{  							if ( key == null )  							{  								key = item.GetType().GetProperty( "Key" );  								value = item.GetType().GetProperty( "Value" );  							}    							arguments[ 0 ] = key.GetValue( item' null );  							arguments[ 1 ] = value.GetValue( item' null );  							traits.AddMethod.InvokePreservingExceptionType( destination' arguments );  						}  						break;  					}  					case CollectionDetailedKind.NonGenericDictionary:  					{  						// item should be DictionaryEntry  						var arguments = new object[ 2 ];  						foreach ( var item in source )  						{  							arguments[ 0 ] = ReflectionSerializerHelper.DictionaryEntryKeyProperty.GetValue( item' null );  							arguments[ 1 ] = ReflectionSerializerHelper.DictionaryEntryValueProperty.GetValue( item' null );  							traits.AddMethod.InvokePreservingExceptionType( destination' arguments );  						}  						break;  					}  					default:  					{  						var arguments = new object[ 1 ];  						foreach ( var item in source )  						{  							arguments[ 0 ] = item;  							traits.AddMethod.InvokePreservingExceptionType( destination' arguments );  						}  						break;  					}  				}  			}
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionObjectMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionObjectMessagePackSerializer`1.cs,UnpackAndAddCollectionItemAsync,The following statement contains a magic number: if ( source != null )  			{  				switch ( traits.DetailedCollectionType )  				{  					case CollectionDetailedKind.GenericDictionary:  					{  						// item should be KeyValuePair<TKey' TValue>  						var arguments = new object[ 2 ];  						var key = default( PropertyInfo );  						var value = default( PropertyInfo );  						foreach ( var item in source )  						{  							if ( key == null )  							{  								key = item.GetType().GetProperty( "Key" );  								value = item.GetType().GetProperty( "Value" );  							}    							arguments[ 0 ] = key.GetValue( item' null );  							arguments[ 1 ] = value.GetValue( item' null );  							traits.AddMethod.InvokePreservingExceptionType( destination' arguments );  						}  						break;  					}  					case CollectionDetailedKind.NonGenericDictionary:  					{  						// item should be DictionaryEntry  						var arguments = new object[ 2 ];  						foreach ( var item in source )  						{  							arguments[ 0 ] = ReflectionSerializerHelper.DictionaryEntryKeyProperty.GetValue( item' null );  							arguments[ 1 ] = ReflectionSerializerHelper.DictionaryEntryValueProperty.GetValue( item' null );  							traits.AddMethod.InvokePreservingExceptionType( destination' arguments );  						}  						break;  					}  					default:  					{  						var arguments = new object[ 1 ];  						foreach ( var item in source )  						{  							arguments[ 0 ] = item;  							traits.AddMethod.InvokePreservingExceptionType( destination' arguments );  						}  						break;  					}  				}  			}
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionInstanceFactory,The following statement contains a magic number: switch ( parameters.Length )  			{  				case 0:  				{  					return _ =>  #if !UNITY  						( T )  #endif // !UNITY  						constructor.InvokePreservingExceptionType();  				}  				case 1:  				{  					if ( parameters[ 0 ].ParameterType == typeof( int ) )  					{  						return capacity =>  #if !UNITY  							( T )  #endif // !UNITY  							constructor.InvokePreservingExceptionType( capacity );  					}  					else if ( UnpackHelpers.IsIEqualityComparer( parameters[ 0 ].ParameterType ) )  					{  						var comparer =   #if !UNITY  							EqualityComparer<TKey>.Default;  #else  							UnpackHelpers.GetEqualityComparer( comparisonType );  #endif // !UNITY  						return _ =>  #if !UNITY  							( T )  #endif // !UNITY  							constructor.InvokePreservingExceptionType( comparer );  					}    					break;  				}  				case 2:  				{  					var comparer =  #if !UNITY  						EqualityComparer<TKey>.Default;  #else  						UnpackHelpers.GetEqualityComparer( comparisonType );  #endif // !UNITY  					if ( parameters[ 0 ].ParameterType == typeof( int )  						&& UnpackHelpers.IsIEqualityComparer( parameters[ 1 ].ParameterType ) )  					{  						return capacity =>  #if !UNITY  							( T )  #endif // !UNITY  							constructor.InvokePreservingExceptionType( capacity' comparer );  					}  					else if ( UnpackHelpers.IsIEqualityComparer( parameters[ 0 ].ParameterType ) &&  							parameters[ 0 ].ParameterType == typeof( int ) )  					{  						return capacity =>  #if !UNITY  							( T )  #endif // !UNITY  							constructor.InvokePreservingExceptionType( comparer' capacity );  					}    					break;  				}  			}
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionTupleMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionTupleMessagePackSerializer`1.cs,GetGetters,The following statement contains a magic number: var memberInvocationChain = new List<TInfo>( itemTypes.Count % 7 + 1 );
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionTupleMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionTupleMessagePackSerializer`1.cs,GetGetters,The following statement contains a magic number: for ( var i = 0; i < itemTypes.Count; i++ )  			{  				if ( i % 7 == 0 )  				{  					depth++;  				}    				for ( var j = 0; j < depth; j++ )  				{  					// .TRest.TRest ...  					var restMember = metadataFactory( tupleTypes[ j ]' "Rest" );  #if DEBUG  					Contract.Assert( restMember != null' "restMember != null" );  #endif // DEBUG  					memberInvocationChain.Add( restMember );  				}    				var itemNMember = metadataFactory( tupleTypes[ depth ]' "Item" + ( ( i % 7 ) + 1 ) );  				memberInvocationChain.Add( itemNMember );  #if DEBUG  				Contract.Assert(  					itemNMember != null'  					tupleTypes[ depth ].GetFullName() + "::Item" + ( ( i % 7 ) + 1 ) + " [ " + depth + " ] @ " + i );  #endif // DEBUG  				var getters = memberInvocationChain.Select( accessorFactory ).ToArray();  				yield return chainedGetterFactory( getters );    				memberInvocationChain.Clear();  			}
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionTupleMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionTupleMessagePackSerializer`1.cs,GetGetters,The following statement contains a magic number: for ( var i = 0; i < itemTypes.Count; i++ )  			{  				if ( i % 7 == 0 )  				{  					depth++;  				}    				for ( var j = 0; j < depth; j++ )  				{  					// .TRest.TRest ...  					var restMember = metadataFactory( tupleTypes[ j ]' "Rest" );  #if DEBUG  					Contract.Assert( restMember != null' "restMember != null" );  #endif // DEBUG  					memberInvocationChain.Add( restMember );  				}    				var itemNMember = metadataFactory( tupleTypes[ depth ]' "Item" + ( ( i % 7 ) + 1 ) );  				memberInvocationChain.Add( itemNMember );  #if DEBUG  				Contract.Assert(  					itemNMember != null'  					tupleTypes[ depth ].GetFullName() + "::Item" + ( ( i % 7 ) + 1 ) + " [ " + depth + " ] @ " + i );  #endif // DEBUG  				var getters = memberInvocationChain.Select( accessorFactory ).ToArray();  				yield return chainedGetterFactory( getters );    				memberInvocationChain.Clear();  			}
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionTupleMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionTupleMessagePackSerializer`1.cs,GetGetters,The following statement contains a magic number: for ( var i = 0; i < itemTypes.Count; i++ )  			{  				if ( i % 7 == 0 )  				{  					depth++;  				}    				for ( var j = 0; j < depth; j++ )  				{  					// .TRest.TRest ...  					var restMember = metadataFactory( tupleTypes[ j ]' "Rest" );  #if DEBUG  					Contract.Assert( restMember != null' "restMember != null" );  #endif // DEBUG  					memberInvocationChain.Add( restMember );  				}    				var itemNMember = metadataFactory( tupleTypes[ depth ]' "Item" + ( ( i % 7 ) + 1 ) );  				memberInvocationChain.Add( itemNMember );  #if DEBUG  				Contract.Assert(  					itemNMember != null'  					tupleTypes[ depth ].GetFullName() + "::Item" + ( ( i % 7 ) + 1 ) + " [ " + depth + " ] @ " + i );  #endif // DEBUG  				var getters = memberInvocationChain.Select( accessorFactory ).ToArray();  				yield return chainedGetterFactory( getters );    				memberInvocationChain.Clear();  			}
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionTupleMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionTupleMessagePackSerializer`1.cs,CreateTuple,The following statement contains a magic number: for ( var nest = this._tupleTypes.Count - 1; nest >= 0; nest-- )  			{  				var items = unpackedItems.Skip( nest * 7 ).Take( Math.Min( unpackedItems.Count' 7 ) ).ToList();  				if ( currentTuple != null )  				{  					items.Add( currentTuple );  				}    				currentTuple =  					this._tupleConstructors[ nest ] == null  						? ReflectionExtensions.CreateInstancePreservingExceptionType( this._tupleTypes[ nest ] )  						: this._tupleConstructors[ nest ].InvokePreservingExceptionType( items.ToArray() );  			}
Magic Number,MsgPack.Serialization.ReflectionSerializers,ReflectionTupleMessagePackSerializer<T>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionTupleMessagePackSerializer`1.cs,CreateTuple,The following statement contains a magic number: for ( var nest = this._tupleTypes.Count - 1; nest >= 0; nest-- )  			{  				var items = unpackedItems.Skip( nest * 7 ).Take( Math.Min( unpackedItems.Count' 7 ) ).ToList();  				if ( currentTuple != null )  				{  					items.Add( currentTuple );  				}    				currentTuple =  					this._tupleConstructors[ nest ] == null  						? ReflectionExtensions.CreateInstancePreservingExceptionType( this._tupleTypes[ nest ] )  						: this._tupleConstructors[ nest ].InvokePreservingExceptionType( items.ToArray() );  			}
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinary,The method contains a code clone-set at the following line numbers (starting from the method definition): ((57' 91)' (105' 139))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadBinaryAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((56' 89)' (103' 136))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadString,The method contains a code clone-set at the following line numbers (starting from the method definition): ((57' 91)' (105' 139))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadStringAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((56' 89)' (103' 136))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((6' 44)' (116' 154)' (245' 283)' (385' 423)' (500' 538)' (643' 681))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((6' 48)' (643' 685)' (116' 158)' (245' 287))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((11' 30)' (56' 75)' (121' 140)' (175' 194)' (250' 269)' (304' 323)' (390' 409)' (442' 461)' (505' 524)' (549' 568)' (593' 612)' (648' 667)' (692' 711)' (736' 755)' (780' 799)' (824' 843))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((11' 44)' (56' 89)' (175' 208)' (304' 337)' (442' 475)' (549' 582)' (593' 626)' (692' 725)' (736' 769)' (780' 813)' (824' 857)' (121' 154)' (250' 283)' (390' 423)' (505' 538)' (648' 681))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((56' 93)' (692' 729)' (175' 212)' (304' 341))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((121' 155)' (175' 209)' (304' 338)' (250' 284))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((51' 74)' (170' 193)' (299' 322)' (437' 460)' (544' 567)' (687' 710)' (775' 798))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlow,The method contains a code clone-set at the following line numbers (starting from the method definition): ((588' 611)' (731' 754)' (819' 842))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((7' 44)' (119' 156)' (260' 297)' (417' 454)' (539' 576)' (678' 715))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((7' 48)' (678' 719)' (119' 160)' (260' 301))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((12' 31)' (56' 75)' (124' 143)' (182' 201)' (265' 284)' (323' 342)' (422' 441)' (478' 497)' (544' 563)' (587' 606)' (630' 649)' (683' 702)' (726' 745)' (769' 788)' (812' 831)' (855' 874))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((12' 44)' (56' 88)' (182' 214)' (323' 355)' (478' 510)' (587' 619)' (630' 662)' (726' 758)' (769' 801)' (812' 844)' (855' 887)' (124' 156)' (265' 297)' (422' 454)' (544' 576)' (683' 715))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((56' 92)' (726' 762)' (182' 218)' (323' 359))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((124' 157)' (182' 215)' (323' 356)' (265' 298))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((51' 74)' (177' 200)' (318' 341)' (473' 496)' (582' 605)' (721' 744)' (807' 830))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadObjectSlowAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((625' 648)' (764' 787)' (850' 873))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLength,The method contains a code clone-set at the following line numbers (starting from the method definition): ((48' 82)' (96' 130))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadArrayLengthAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((47' 80)' (94' 127))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLength,The method contains a code clone-set at the following line numbers (starting from the method definition): ((48' 82)' (96' 130))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMapLengthAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((47' 80)' (94' 127))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObject,The method contains a code clone-set at the following line numbers (starting from the method definition): ((48' 82)' (96' 130))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObject,The method contains a code clone-set at the following line numbers (starting from the method definition): ((53' 87)' (101' 135))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadMessagePackExtendedTypeObjectAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((47' 80)' (94' 127))
Duplicate Code,MsgPack,MessagePackStreamUnpacker,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackStreamUnpacker.cs,ReadNullableMessagePackExtendedTypeObjectAsync,The method contains a code clone-set at the following line numbers (starting from the method definition): ((51' 84)' (98' 131))
Missing Default,MsgPack,MessagePackCode,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackCode.cs,ToString,The following switch statement is missing a default case: switch( code )  			{  				case 0xC0:  				{  					return "Nil";  				}  				case 0xC3:  				{  					return "True";  				}  				case 0xD0:  				{  					return "SingnedInt8";  				}  				case 0xCC:  				{  					return "UnsignedInt8";  				}  				case 0xD1:  				{  					return "SignedInt16";  				}  				case 0xCD:  				{  					return "UnsignedInt16";  				}  				case 0xD2:  				{  					return "SignedInt32";  				}  				case 0xCE:  				{  					return "UnsignedInt32";  				}  				case 0xD3:  				{  					return "SignedInt64";  				}  				case 0xCF:  				{  					return "UnsignedInt64";  				}  				case 0xCA:  				{  					return "Real32";  				}  				case 0xCB:  				{  					return "Real64";  				}  				case 0xDC:  				{  					return "Array16";  				}  				case 0xDD:  				{  					return "Array32";  				}  				case 0xDE:  				{  					return "Map16";  				}  				case 0xDF:  				{  					return "Map32";  				}  				case 0xDA:  				{  					return "Raw16";  				}  				case 0xDB:  				{  					return "Raw32";  				}  			}
Missing Default,MsgPack,MessagePackCode,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackCode.cs,ToString,The following switch statement is missing a default case: switch( ( code & 0xF0))  			{  				case 0x80:  				{  					return "FixedMap";  				}  				case 0x90:  				{  					return "FixedArray";  				}  				case 0xA0:  				case 0xB0:  				{  					return "FixedRaw";  				}  			}
Missing Default,MsgPack,MessagePackObject,C:\repos\msgpack_msgpack-cli\src\MsgPack\MessagePackObject.cs,IsTypeOf,The following switch statement is missing a default case: switch ( NetStandardCompatibility.GetTypeCode( type ) )  #else  			switch ( Type.GetTypeCode( type ) )  #endif // NETSTANDARD1_1 || NETSTANDARD1_3  			{  				case TypeCode.SByte:  				{  					return typeCode.IsInteger && ( this._value < 0x80 || ( 0xFFFFFFFFFFFFFF80 <= this._value && typeCode.IsSigned ) );  				}  				case TypeCode.Byte:  				{  					return typeCode.IsInteger && this._value < 0x100;  				}  				case TypeCode.Int16:  				{  					return typeCode.IsInteger && ( this._value < 0x8000 || ( 0xFFFFFFFFFFFF8000 <= this._value && typeCode.IsSigned ) );  				}  				case TypeCode.UInt16:  				{  					return typeCode.IsInteger && this._value < 0x10000;  				}  				case TypeCode.Int32:  				{  					return typeCode.IsInteger && ( this._value < 0x80000000 || ( 0xFFFFFFFF80000000 <= this._value && typeCode.IsSigned ) );  				}  				case TypeCode.UInt32:  				{  					return typeCode.IsInteger && this._value < 0x100000000L;  				}  				case TypeCode.Int64:  				{  					return typeCode.IsInteger && ( this._value < 0x8000000000000000L || typeCode.IsSigned );  				}  				case TypeCode.UInt64:  				{  					return typeCode.IsInteger && ( this._value < 0x8000000000000000L || !typeCode.IsSigned );  				}  				case TypeCode.Double:  				{  					return  						typeCode.Type == typeof( float )  						|| typeCode.Type == typeof( double );  				}  			}
Missing Default,MsgPack,ReadValueResults,C:\repos\msgpack_msgpack-cli\src\MsgPack\ReadValueResults.cs,ToByte,The following switch statement is missing a default case: switch ( source )  			{  				case ReadValueResult.Nil:  				{  					return ( byte )MessagePackCode.NilValue;  				}  				case ReadValueResult.True:  				{  					return ( byte )MessagePackCode.TrueValue;  				}  				case ReadValueResult.False:  				{  					return ( byte )MessagePackCode.FalseValue;  				}  				case ReadValueResult.InvalidCode:  				{  					return 0xC1;  				}  			}
Missing Default,MsgPack,StringEscape,C:\repos\msgpack_msgpack-cli\src\MsgPack\StringEscape.cs,ForDisplay,The following switch statement is missing a default case: switch ( c )  				{  					case '\0':  					{  						buffer.Append( "\\0" );  						continue;  					}  					case '\t':  					{  						buffer.Append( "\\t" );  						continue;  					}  					case '\r':  					{  						buffer.Append( "\\r" );  						continue;  					}  					case '\n':  					{  						buffer.Append( "\\n" );  						continue;  					}  					case '\a':  					{  						buffer.Append( "\\a" );  						continue;  					}  					case '\b':  					{  						buffer.Append( "\\b" );  						continue;  					}  					case '\f':  					{  						buffer.Append( "\\f" );  						continue;  					}  					case '\v':  					{  						buffer.Append( "\\v" );  						continue;  					}  				}
Missing Default,MsgPack,SeekableUnpackingStream,C:\repos\msgpack_msgpack-cli\src\MsgPack\Unpacking.Streaming.cs,Seek,The following switch statement is missing a default case: switch ( origin )  				{  					case SeekOrigin.Begin:  					{  						this.SeekTo( offset );  						break;  					}  					case SeekOrigin.End:  					{  						this.SeekTo( this.RawLength + offset );  						break;  					}  					case SeekOrigin.Current:  					{  						this.SeekTo( this.Position + offset );  						break;  					}  				}
Missing Default,MsgPack.Serialization,EnumMessagePackSerializerProvider,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\EnumMessagePackSerializerProvider.cs,Get,The following switch statement is missing a default case: switch ( ( EnumSerializationMethod )providerParameter )  				{  					case EnumSerializationMethod.ByName:  					{  						return this._serializerForName;  					}  					case EnumSerializationMethod.ByUnderlyingValue:  					{  						return this._serializerForIntegral;  					}  				}
Missing Default,MsgPack.Serialization,NilImplicationHandler<TAction;TCondition;TPackingParameter;TUnpackedParameter>,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\NilImplicationHandler`4.cs,OnPacking,The following switch statement is missing a default case: switch ( nilImplication )  			{  				case NilImplication.Prohibit:  				{  					TCondition condition = null;  					if ( parameter.ItemType == typeof( MessagePackObject ) )  					{  						condition = this.OnPackingMessagePackObject( parameter );  					}  					else if ( !parameter.ItemType.GetIsValueType() )  					{  						condition = this.OnPackingReferenceTypeObject( parameter );  					}  					else if ( Nullable.GetUnderlyingType( parameter.ItemType ) != null )  					{  						condition = this.OnPackingNullableValueTypeObject( parameter );  					}    					if ( condition != null )  					{  						return this.OnPackingCore( parameter' condition );  					}    					break;  				}  			}
Missing Default,MsgPack.Serialization,PolymorphismSchema,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Constructors.cs,ToDebugString,The following switch statement is missing a default case: switch ( this.ChildrenType )  			{  				case PolymorphismSchemaChildrenType.CollectionItems:  				{  					buffer.Append( "' CollectionItemsSchema:" );  					if ( this.ItemSchema == null )  					{  						buffer.Append( "null" );  					}  					else  					{  						this.ItemSchema.ToDebugString( buffer );  					}    					break;  				}  				case PolymorphismSchemaChildrenType.DictionaryKeyValues:  				{  					buffer.Append( "' DictinoaryKeysSchema:" );  					if ( this.KeySchema == null )  					{  						buffer.Append( "null" );  					}  					else  					{  						this.KeySchema.ToDebugString( buffer );  					}    					buffer.Append( "' DictinoaryValuesSchema:" );  					if ( this.ItemSchema == null )  					{  						buffer.Append( "null" );  					}  					else  					{  						this.ItemSchema.ToDebugString( buffer );  					}    					break;  				}  #if !NET35 && !UNITY  				case PolymorphismSchemaChildrenType.TupleItems:  				{  					buffer.Append( "' TupleItemsSchema:[" );  					var isFirst = true;  					foreach ( var child in this._children )  					{  						if ( isFirst )  						{  							isFirst = false;  						}  						else  						{  							buffer.Append( "' " );  						}    						if ( child == null )  						{  							buffer.Append( "null" );  						}  						else  						{  							child.ToDebugString( buffer );  						}  					}    					break;  				}  #endif // !NET35 && !UNITY  			}
Missing Default,MsgPack.Serialization,TypeTableEntry,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\PolymorphismSchema.Internals.cs,SetDefault,The following switch statement is missing a default case: switch ( defaultSchema.PolymorphismType )  				{  					case PolymorphismType.KnownTypes:  					{  						foreach ( var typeMapping in defaultSchema.CodeTypeMapping )  						{  							this.SetKnownType( target' memberName' tupleItemNumber' typeMapping.Key' typeMapping.Value );  						}    						break;  					}  					case PolymorphismType.RuntimeType:  					{  						this.SetRuntimeType( target' memberName' tupleItemNumber' defaultSchema.TypeVerifier );  						break;  					}  				}
Missing Default,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,TryGetCollectionConstructor,The following switch statement is missing a default case: switch ( parameters.Length )  				{  					case 0:  					{  						if ( currentScore < noParameters )  						{  							constructor = candidate;  							currentScore = noParameters;  						}    						break;  					}  					case 1:  					{  						if ( currentScore < withCapacity && parameters[ 0 ].ParameterType == typeof( int ) )  						{  							constructor = candidate;  							currentScore = noParameters;  						}  						else if ( currentScore < withComparer && IsIEqualityComparer( parameters[ 0 ].ParameterType ) )  						{  							constructor = candidate;  							currentScore = noParameters;  						}  						break;  					}  					case 2:  					{  						if ( currentScore < withCapacityAndComparer && parameters[ 0 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 1 ].ParameterType ) )  						{  							constructor = candidate;  							currentScore = withCapacityAndComparer;  						}  						else if ( currentScore < withComparerAndCapacity && parameters[ 1 ].ParameterType == typeof( int ) && IsIEqualityComparer( parameters[ 0 ].ParameterType ) )  						{  							constructor = candidate;  							currentScore = withComparerAndCapacity;  						}    						break;  					}  				}
Missing Default,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueCore,The following switch statement is missing a default case: switch ( nilImplication )  				{  					case NilImplication.Prohibit:  					{  						SerializationExceptions.ThrowNullIsProhibited( memberName );  						break;  					}  					case NilImplication.MemberDefault:  					{  						return;  					}  				}
Missing Default,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackReferenceTypeValueAsyncCore,The following switch statement is missing a default case: switch ( nilImplication )  				{  					case NilImplication.Prohibit:  					{  						SerializationExceptions.ThrowNullIsProhibited( memberName );  						break;  					}  					case NilImplication.MemberDefault:  					{  						return;  					}  				}
Missing Default,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueCore,The following switch statement is missing a default case: switch ( nilImplication )  				{  					case NilImplication.Prohibit:  					{  						SerializationExceptions.ThrowNullIsProhibited( memberName );  						break;  					}  					case NilImplication.MemberDefault:  					{  						return;  					}  				}
Missing Default,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackNullableTypeValueAsyncCore,The following switch statement is missing a default case: switch ( nilImplication )  				{  					case NilImplication.Prohibit:  					{  						SerializationExceptions.ThrowNullIsProhibited( memberName );  						break;  					}  					case NilImplication.MemberDefault:  					{  						return;  					}  				}
Missing Default,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueCore,The following switch statement is missing a default case: switch ( nilImplication )  				{  					case NilImplication.Prohibit:  					{  						SerializationExceptions.ThrowNullIsProhibited( memberName );  						break;  					}  					case NilImplication.MemberDefault:  					{  						return;  					}  				}
Missing Default,MsgPack.Serialization,UnpackHelpers,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\UnpackHelpers.cs,UnpackMessagePackObjectValueAsyncCore,The following switch statement is missing a default case: switch ( nilImplication )  				{  					case NilImplication.Prohibit:  					{  						SerializationExceptions.ThrowNullIsProhibited( memberName );  						break;  					}  					case NilImplication.MemberDefault:  					{  						return;  					}  				}
Missing Default,MsgPack.Serialization.DefaultSerializers,DateTimeMessagePackSerializerProvider,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeMessagePackSerializerProvider.cs,Get,The following switch statement is missing a default case: switch ( ( DateTimeConversionMethod )providerParameter )  				{  					case DateTimeConversionMethod.Native:  					{  						return this._native;  					}  					case DateTimeConversionMethod.UnixEpoc:  					{  						return this._unixEpoc;  					}  					case DateTimeConversionMethod.Timestamp:  					{  						return this._timestamp;  					}  				}
Missing Default,MsgPack.Serialization.DefaultSerializers,DateTimeOffsetMessagePackSerializerProvider,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\DateTimeOffsetMessagePackSerializerProvider.cs,Get,The following switch statement is missing a default case: switch ( ( DateTimeConversionMethod )providerParameter )  				{  					case DateTimeConversionMethod.Native:  					{  						return this._native;  					}  					case DateTimeConversionMethod.UnixEpoc:  					{  						return this._unixEpoc;  					}  					case DateTimeConversionMethod.Timestamp:  					{  						return this._timestamp;  					}  				}
Missing Default,MsgPack.Serialization.DefaultSerializers,FileTimeMessagePackSerializerProvider,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\FileTimeMessagePackSerializerProvider.cs,Get,The following switch statement is missing a default case: switch ( ( DateTimeConversionMethod )providerParameter )  				{  					case DateTimeConversionMethod.Native:  					{  						return this._native;  					}  					case DateTimeConversionMethod.UnixEpoc:  					{  						return this._unixEpoc;  					}  					case DateTimeConversionMethod.Timestamp:  					{  						return this._timestamp;  					}  				}
Missing Default,MsgPack.Serialization.DefaultSerializers,System_Collections_DictionaryEntryMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_DictionaryEntryMessagePackSerializer.cs,UnpackFromCore,The following switch statement is missing a default case: switch ( propertyName )  					{  						case "Key":  						{  							if ( !unpacker.ReadObject( out key ) )  							{  								SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  							}    							isKeyFound = true;  							break;  						}  						case "Value":  						{  							if ( !unpacker.ReadObject( out value ) )  							{  								SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  							}    							isValueFound = true;  							break;  						}  					}
Missing Default,MsgPack.Serialization.DefaultSerializers,System_Collections_DictionaryEntryMessagePackSerializer,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\System_Collections_DictionaryEntryMessagePackSerializer.cs,UnpackFromAsyncCore,The following switch statement is missing a default case: switch ( propertyName.Value )  					{  						case "Key":  						{  							key = await unpacker.ReadObjectAsync( cancellationToken ).ConfigureAwait( false );  							if ( !key.Success )  							{  								SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  							}    							break;  						}  						case "Value":  						{  							value = await unpacker.ReadObjectAsync( cancellationToken ).ConfigureAwait( false );  							if ( !value.Success )  							{  								SerializationExceptions.ThrowUnexpectedEndOfStream( unpacker );  							}    							break;  						}  					}
Missing Default,MsgPack.Serialization.DefaultSerializers,TimestampMessagePackSerializerProvider,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\DefaultSerializers\TimestampMessagePackSerializerProvider.cs,Get,The following switch statement is missing a default case: switch ( ( DateTimeConversionMethod )providerParameter )  				{  					case DateTimeConversionMethod.Native:  					{  						return this._native;  					}  					case DateTimeConversionMethod.UnixEpoc:  					{  						return this._unixEpoc;  					}  					case DateTimeConversionMethod.Timestamp:  					{  						return this._timestamp;  					}  				}
Missing Default,MsgPack.Serialization.Reflection,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\ReflectionExtensions.cs,ToILString,The following switch statement is missing a default case: switch ( memberAccess )  			{  				case MethodAttributes.PrivateScope:  				{  					result.Append( "privatescope" );  					break;  				}  				case MethodAttributes.Private:  				{  					result.Append( "private" );  					break;  				}  				case MethodAttributes.FamANDAssem:  				{  					result.Append( "famandassem" );  					break;  				}  				case MethodAttributes.Assembly:  				{  					result.Append( "assembly" );  					break;  				}  				case MethodAttributes.Family:  				{  					result.Append( "family" );  					break;  				}  				case MethodAttributes.FamORAssem:  				{  					result.Append( "famorassem" );  					break;  				}  				case MethodAttributes.Public:  				{  					result.Append( "public" );  					break;  				}  			}
Missing Default,MsgPack.Serialization.Reflection,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\ReflectionExtensions.cs,ToILString,The following switch statement is missing a default case: switch ( (source & CallingConventions.Any) )  			{  				case CallingConventions.Standard:  				{  					if ( result.Length > 0 )  					{  						result.Append( ' ' );  					}    					result.Append( "standard" );  					break;  				}  				case CallingConventions.VarArgs:  				{  					if ( result.Length > 0 )  					{  						result.Append( ' ' );  					}    					result.Append( "vararg" );  					break;  				}  				case CallingConventions.Any:  				{  					if ( result.Length > 0 )  					{  						result.Append( ' ' );  					}    					result.Append( "any" );  					break;  				}  			}
Missing Default,MsgPack.Serialization.Reflection,ReflectionExtensions,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\Reflection\ReflectionExtensions.cs,ToILString,The following switch statement is missing a default case: switch ( codeType )  			{  				case MethodImplAttributes.IL:  				{  					result.Append( "cil" );  					break;  				}  				case MethodImplAttributes.Native:  				{  					result.Append( "native" );  					break;  				}  				case MethodImplAttributes.OPTIL:  				{  					result.Append( "optil" );  					break;  				}  				case MethodImplAttributes.Runtime:  				{  					result.Append( "runtime" );  					break;  				}  			}
Missing Default,MsgPack.Serialization.ReflectionSerializers,ReflectionSerializerHelper,C:\repos\msgpack_msgpack-cli\src\MsgPack\Serialization\ReflectionSerializers\ReflectionSerializerHelper.cs,CreateCollectionInstanceFactory,The following switch statement is missing a default case: switch ( parameters.Length )  			{  				case 0:  				{  					return _ =>  #if !UNITY  						( T )  #endif // !UNITY  						constructor.InvokePreservingExceptionType();  				}  				case 1:  				{  					if ( parameters[ 0 ].ParameterType == typeof( int ) )  					{  						return capacity =>  #if !UNITY  							( T )  #endif // !UNITY  							constructor.InvokePreservingExceptionType( capacity );  					}  					else if ( UnpackHelpers.IsIEqualityComparer( parameters[ 0 ].ParameterType ) )  					{  						var comparer =   #if !UNITY  							EqualityComparer<TKey>.Default;  #else  							UnpackHelpers.GetEqualityComparer( comparisonType );  #endif // !UNITY  						return _ =>  #if !UNITY  							( T )  #endif // !UNITY  							constructor.InvokePreservingExceptionType( comparer );  					}    					break;  				}  				case 2:  				{  					var comparer =  #if !UNITY  						EqualityComparer<TKey>.Default;  #else  						UnpackHelpers.GetEqualityComparer( comparisonType );  #endif // !UNITY  					if ( parameters[ 0 ].ParameterType == typeof( int )  						&& UnpackHelpers.IsIEqualityComparer( parameters[ 1 ].ParameterType ) )  					{  						return capacity =>  #if !UNITY  							( T )  #endif // !UNITY  							constructor.InvokePreservingExceptionType( capacity' comparer );  					}  					else if ( UnpackHelpers.IsIEqualityComparer( parameters[ 0 ].ParameterType ) &&  							parameters[ 0 ].ParameterType == typeof( int ) )  					{  						return capacity =>  #if !UNITY  							( T )  #endif // !UNITY  							constructor.InvokePreservingExceptionType( comparer' capacity );  					}    					break;  				}  			}
